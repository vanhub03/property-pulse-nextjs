module.exports = {

"[project]/node_modules/next/dist/compiled/babel/bundle.js [app-rsc] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require } = __turbopack_context__;
{
(()=>{
    var e1 = {
        5179: (e1)=>{
            function webpackEmptyAsyncContext(e1) {
                return Promise.resolve().then(()=>{
                    var t = new Error("Cannot find module '" + e1 + "'");
                    t.code = "MODULE_NOT_FOUND";
                    throw t;
                });
            }
            webpackEmptyAsyncContext.keys = ()=>[];
            webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
            webpackEmptyAsyncContext.id = 5179;
            e1.exports = webpackEmptyAsyncContext;
        },
        3914: function(e1, t, r) {
            (function(t, n) {
                ("TURBOPACK compile-time truthy", 1) ? e1.exports = n(r(4614), r(5328)) : ("TURBOPACK unreachable", undefined);
            })(this, function(e1, t) {
                "use strict";
                const r = SegmentObject("", -1, -1, "", null);
                const n = [];
                function SegmentObject(e1, t, r, n, s) {
                    return {
                        source: e1,
                        line: t,
                        column: r,
                        name: n,
                        content: s
                    };
                }
                function Source(e1, t, r, n) {
                    return {
                        map: e1,
                        sources: t,
                        source: r,
                        content: n
                    };
                }
                function MapSource(e1, t) {
                    return Source(e1, t, "", null);
                }
                function OriginalSource(e1, t) {
                    return Source(null, n, e1, t);
                }
                function traceMappings(n) {
                    const s = new t.GenMapping({
                        file: n.map.file
                    });
                    const { sources: i, map: a } = n;
                    const o = a.names;
                    const l = e1.decodedMappings(a);
                    for(let e1 = 0; e1 < l.length; e1++){
                        const n = l[e1];
                        for(let a = 0; a < n.length; a++){
                            const l = n[a];
                            const c = l[0];
                            let u = r;
                            if (l.length !== 1) {
                                const e1 = i[l[1]];
                                u = originalPositionFor(e1, l[2], l[3], l.length === 5 ? o[l[4]] : "");
                                if (u == null) continue;
                            }
                            const { column: p, line: f, name: d, content: h, source: m } = u;
                            t.maybeAddSegment(s, e1, c, m, f, p, d);
                            if (m && h != null) t.setSourceContent(s, m, h);
                        }
                    }
                    return s;
                }
                function originalPositionFor(t, n, s, i) {
                    if (!t.map) {
                        return SegmentObject(t.source, n, s, i, t.content);
                    }
                    const a = e1.traceSegment(t.map, n, s);
                    if (a == null) return null;
                    if (a.length === 1) return r;
                    return originalPositionFor(t.sources[a[1]], a[2], a[3], a.length === 5 ? t.map.names[a[4]] : i);
                }
                function asArray(e1) {
                    if (Array.isArray(e1)) return e1;
                    return [
                        e1
                    ];
                }
                function buildSourceMapTree(t, r) {
                    const n = asArray(t).map((t)=>new e1.TraceMap(t, ""));
                    const s = n.pop();
                    for(let e1 = 0; e1 < n.length; e1++){
                        if (n[e1].sources.length > 1) {
                            throw new Error(`Transformation map ${e1} must have exactly one source file.\n` + "Did you specify these with the most recent transformation maps first?");
                        }
                    }
                    let i = build(s, r, "", 0);
                    for(let e1 = n.length - 1; e1 >= 0; e1--){
                        i = MapSource(n[e1], [
                            i
                        ]);
                    }
                    return i;
                }
                function build(t, r, n, s) {
                    const { resolvedSources: i, sourcesContent: a } = t;
                    const o = s + 1;
                    const l = i.map((t, s)=>{
                        const i = {
                            importer: n,
                            depth: o,
                            source: t || "",
                            content: undefined
                        };
                        const l = r(i.source, i);
                        const { source: c, content: u } = i;
                        if (l) return build(new e1.TraceMap(l, c), r, c, o);
                        const p = u !== undefined ? u : a ? a[s] : null;
                        return OriginalSource(c, p);
                    });
                    return MapSource(t, l);
                }
                class SourceMap {
                    constructor(e1, r){
                        const n = r.decodedMappings ? t.toDecodedMap(e1) : t.toEncodedMap(e1);
                        this.version = n.version;
                        this.file = n.file;
                        this.mappings = n.mappings;
                        this.names = n.names;
                        this.sourceRoot = n.sourceRoot;
                        this.sources = n.sources;
                        if (!r.excludeContent) {
                            this.sourcesContent = n.sourcesContent;
                        }
                    }
                    toString() {
                        return JSON.stringify(this);
                    }
                }
                function remapping(e1, t, r) {
                    const n = typeof r === "object" ? r : {
                        excludeContent: !!r,
                        decodedMappings: false
                    };
                    const s = buildSourceMapTree(e1, t);
                    return new SourceMap(traceMappings(s), n);
                }
                return remapping;
            });
        },
        5328: function(e1, t, r) {
            (function(e1, n) {
                ("TURBOPACK compile-time truthy", 1) ? n(t, r(7168), r(1575), r(4614)) : ("TURBOPACK unreachable", undefined);
            })(this, function(e1, t, r, n) {
                "use strict";
                const s = 0;
                const i = 1;
                const a = 2;
                const o = 3;
                const l = 4;
                const c = -1;
                e1.addSegment = void 0;
                e1.addMapping = void 0;
                e1.maybeAddSegment = void 0;
                e1.maybeAddMapping = void 0;
                e1.setSourceContent = void 0;
                e1.toDecodedMap = void 0;
                e1.toEncodedMap = void 0;
                e1.fromMap = void 0;
                e1.allMappings = void 0;
                let u;
                class GenMapping {
                    constructor({ file: e1, sourceRoot: r } = {}){
                        this._names = new t.SetArray;
                        this._sources = new t.SetArray;
                        this._sourcesContent = [];
                        this._mappings = [];
                        this.file = e1;
                        this.sourceRoot = r;
                    }
                }
                (()=>{
                    e1.addSegment = (e1, t, r, n, s, i, a, o)=>u(false, e1, t, r, n, s, i, a, o);
                    e1.maybeAddSegment = (e1, t, r, n, s, i, a, o)=>u(true, e1, t, r, n, s, i, a, o);
                    e1.addMapping = (e1, t)=>addMappingInternal(false, e1, t);
                    e1.maybeAddMapping = (e1, t)=>addMappingInternal(true, e1, t);
                    e1.setSourceContent = (e1, r, n)=>{
                        const { _sources: s, _sourcesContent: i } = e1;
                        i[t.put(s, r)] = n;
                    };
                    e1.toDecodedMap = (e1)=>{
                        const { file: t, sourceRoot: r, _mappings: n, _sources: s, _sourcesContent: i, _names: a } = e1;
                        removeEmptyFinalLines(n);
                        return {
                            version: 3,
                            file: t || undefined,
                            names: a.array,
                            sourceRoot: r || undefined,
                            sources: s.array,
                            sourcesContent: i,
                            mappings: n
                        };
                    };
                    e1.toEncodedMap = (t)=>{
                        const n = e1.toDecodedMap(t);
                        return Object.assign(Object.assign({}, n), {
                            mappings: r.encode(n.mappings)
                        });
                    };
                    e1.allMappings = (e1)=>{
                        const t = [];
                        const { _mappings: r, _sources: n, _names: c } = e1;
                        for(let e1 = 0; e1 < r.length; e1++){
                            const u = r[e1];
                            for(let r = 0; r < u.length; r++){
                                const p = u[r];
                                const f = {
                                    line: e1 + 1,
                                    column: p[s]
                                };
                                let d = undefined;
                                let h = undefined;
                                let m = undefined;
                                if (p.length !== 1) {
                                    d = n.array[p[i]];
                                    h = {
                                        line: p[a] + 1,
                                        column: p[o]
                                    };
                                    if (p.length === 5) m = c.array[p[l]];
                                }
                                t.push({
                                    generated: f,
                                    source: d,
                                    original: h,
                                    name: m
                                });
                            }
                        }
                        return t;
                    };
                    e1.fromMap = (e1)=>{
                        const t = new n.TraceMap(e1);
                        const r = new GenMapping({
                            file: t.file,
                            sourceRoot: t.sourceRoot
                        });
                        putAll(r._names, t.names);
                        putAll(r._sources, t.sources);
                        r._sourcesContent = t.sourcesContent || t.sources.map(()=>null);
                        r._mappings = n.decodedMappings(t);
                        return r;
                    };
                    u = (e1, r, n, s, i, a, o, l, u)=>{
                        const { _mappings: p, _sources: f, _sourcesContent: d, _names: h } = r;
                        const m = getLine(p, n);
                        const y = getColumnIndex(m, s);
                        if (!i) {
                            if (e1 && skipSourceless(m, y)) return;
                            return insert(m, y, [
                                s
                            ]);
                        }
                        const g = t.put(f, i);
                        const b = l ? t.put(h, l) : c;
                        if (g === d.length) d[g] = u !== null && u !== void 0 ? u : null;
                        if (e1 && skipSource(m, y, g, a, o, b)) {
                            return;
                        }
                        return insert(m, y, l ? [
                            s,
                            g,
                            a,
                            o,
                            b
                        ] : [
                            s,
                            g,
                            a,
                            o
                        ]);
                    };
                })();
                function getLine(e1, t) {
                    for(let r = e1.length; r <= t; r++){
                        e1[r] = [];
                    }
                    return e1[t];
                }
                function getColumnIndex(e1, t) {
                    let r = e1.length;
                    for(let n = r - 1; n >= 0; r = n--){
                        const r = e1[n];
                        if (t >= r[s]) break;
                    }
                    return r;
                }
                function insert(e1, t, r) {
                    for(let r = e1.length; r > t; r--){
                        e1[r] = e1[r - 1];
                    }
                    e1[t] = r;
                }
                function removeEmptyFinalLines(e1) {
                    const { length: t } = e1;
                    let r = t;
                    for(let t = r - 1; t >= 0; r = t, t--){
                        if (e1[t].length > 0) break;
                    }
                    if (r < t) e1.length = r;
                }
                function putAll(e1, r) {
                    for(let n = 0; n < r.length; n++)t.put(e1, r[n]);
                }
                function skipSourceless(e1, t) {
                    if (t === 0) return true;
                    const r = e1[t - 1];
                    return r.length === 1;
                }
                function skipSource(e1, t, r, n, s, u) {
                    if (t === 0) return false;
                    const p = e1[t - 1];
                    if (p.length === 1) return false;
                    return r === p[i] && n === p[a] && s === p[o] && u === (p.length === 5 ? p[l] : c);
                }
                function addMappingInternal(e1, t, r) {
                    const { generated: n, source: s, original: i, name: a, content: o } = r;
                    if (!s) {
                        return u(e1, t, n.line - 1, n.column, null, null, null, null, null);
                    }
                    const l = s;
                    return u(e1, t, n.line - 1, n.column, l, i.line - 1, i.column, a, o);
                }
                e1.GenMapping = GenMapping;
                Object.defineProperty(e1, "__esModule", {
                    value: true
                });
            });
        },
        2987: function(e1, t, r) {
            (function(e1, n) {
                ("TURBOPACK compile-time truthy", 1) ? n(t, r(7168), r(1575), r(519)) : ("TURBOPACK unreachable", undefined);
            })(this, function(e1, t, r, n) {
                "use strict";
                const s = 0;
                const i = 1;
                const a = 2;
                const o = 3;
                const l = 4;
                const c = -1;
                e1.addSegment = void 0;
                e1.addMapping = void 0;
                e1.maybeAddSegment = void 0;
                e1.maybeAddMapping = void 0;
                e1.setSourceContent = void 0;
                e1.toDecodedMap = void 0;
                e1.toEncodedMap = void 0;
                e1.fromMap = void 0;
                e1.allMappings = void 0;
                let u;
                class GenMapping {
                    constructor({ file: e1, sourceRoot: r } = {}){
                        this._names = new t.SetArray;
                        this._sources = new t.SetArray;
                        this._sourcesContent = [];
                        this._mappings = [];
                        this.file = e1;
                        this.sourceRoot = r;
                    }
                }
                (()=>{
                    e1.addSegment = (e1, t, r, n, s, i, a, o)=>u(false, e1, t, r, n, s, i, a, o);
                    e1.maybeAddSegment = (e1, t, r, n, s, i, a, o)=>u(true, e1, t, r, n, s, i, a, o);
                    e1.addMapping = (e1, t)=>addMappingInternal(false, e1, t);
                    e1.maybeAddMapping = (e1, t)=>addMappingInternal(true, e1, t);
                    e1.setSourceContent = (e1, r, n)=>{
                        const { _sources: s, _sourcesContent: i } = e1;
                        i[t.put(s, r)] = n;
                    };
                    e1.toDecodedMap = (e1)=>{
                        const { file: t, sourceRoot: r, _mappings: n, _sources: s, _sourcesContent: i, _names: a } = e1;
                        removeEmptyFinalLines(n);
                        return {
                            version: 3,
                            file: t || undefined,
                            names: a.array,
                            sourceRoot: r || undefined,
                            sources: s.array,
                            sourcesContent: i,
                            mappings: n
                        };
                    };
                    e1.toEncodedMap = (t)=>{
                        const n = e1.toDecodedMap(t);
                        return Object.assign(Object.assign({}, n), {
                            mappings: r.encode(n.mappings)
                        });
                    };
                    e1.allMappings = (e1)=>{
                        const t = [];
                        const { _mappings: r, _sources: n, _names: c } = e1;
                        for(let e1 = 0; e1 < r.length; e1++){
                            const u = r[e1];
                            for(let r = 0; r < u.length; r++){
                                const p = u[r];
                                const f = {
                                    line: e1 + 1,
                                    column: p[s]
                                };
                                let d = undefined;
                                let h = undefined;
                                let m = undefined;
                                if (p.length !== 1) {
                                    d = n.array[p[i]];
                                    h = {
                                        line: p[a] + 1,
                                        column: p[o]
                                    };
                                    if (p.length === 5) m = c.array[p[l]];
                                }
                                t.push({
                                    generated: f,
                                    source: d,
                                    original: h,
                                    name: m
                                });
                            }
                        }
                        return t;
                    };
                    e1.fromMap = (e1)=>{
                        const t = new n.TraceMap(e1);
                        const r = new GenMapping({
                            file: t.file,
                            sourceRoot: t.sourceRoot
                        });
                        putAll(r._names, t.names);
                        putAll(r._sources, t.sources);
                        r._sourcesContent = t.sourcesContent || t.sources.map(()=>null);
                        r._mappings = n.decodedMappings(t);
                        return r;
                    };
                    u = (e1, r, n, s, i, a, o, l, u)=>{
                        const { _mappings: p, _sources: f, _sourcesContent: d, _names: h } = r;
                        const m = getLine(p, n);
                        const y = getColumnIndex(m, s);
                        if (!i) {
                            if (e1 && skipSourceless(m, y)) return;
                            return insert(m, y, [
                                s
                            ]);
                        }
                        const g = t.put(f, i);
                        const b = l ? t.put(h, l) : c;
                        if (g === d.length) d[g] = u !== null && u !== void 0 ? u : null;
                        if (e1 && skipSource(m, y, g, a, o, b)) {
                            return;
                        }
                        return insert(m, y, l ? [
                            s,
                            g,
                            a,
                            o,
                            b
                        ] : [
                            s,
                            g,
                            a,
                            o
                        ]);
                    };
                })();
                function getLine(e1, t) {
                    for(let r = e1.length; r <= t; r++){
                        e1[r] = [];
                    }
                    return e1[t];
                }
                function getColumnIndex(e1, t) {
                    let r = e1.length;
                    for(let n = r - 1; n >= 0; r = n--){
                        const r = e1[n];
                        if (t >= r[s]) break;
                    }
                    return r;
                }
                function insert(e1, t, r) {
                    for(let r = e1.length; r > t; r--){
                        e1[r] = e1[r - 1];
                    }
                    e1[t] = r;
                }
                function removeEmptyFinalLines(e1) {
                    const { length: t } = e1;
                    let r = t;
                    for(let t = r - 1; t >= 0; r = t, t--){
                        if (e1[t].length > 0) break;
                    }
                    if (r < t) e1.length = r;
                }
                function putAll(e1, r) {
                    for(let n = 0; n < r.length; n++)t.put(e1, r[n]);
                }
                function skipSourceless(e1, t) {
                    if (t === 0) return true;
                    const r = e1[t - 1];
                    return r.length === 1;
                }
                function skipSource(e1, t, r, n, s, u) {
                    if (t === 0) return false;
                    const p = e1[t - 1];
                    if (p.length === 1) return false;
                    return r === p[i] && n === p[a] && s === p[o] && u === (p.length === 5 ? p[l] : c);
                }
                function addMappingInternal(e1, t, r) {
                    const { generated: n, source: s, original: i, name: a, content: o } = r;
                    if (!s) {
                        return u(e1, t, n.line - 1, n.column, null, null, null, null, null);
                    }
                    const l = s;
                    return u(e1, t, n.line - 1, n.column, l, i.line - 1, i.column, a, o);
                }
                e1.GenMapping = GenMapping;
                Object.defineProperty(e1, "__esModule", {
                    value: true
                });
            });
        },
        6982: function(e1) {
            (function(t, r) {
                ("TURBOPACK compile-time truthy", 1) ? e1.exports = r() : ("TURBOPACK unreachable", undefined);
            })(this, function() {
                "use strict";
                const e1 = /^[\w+.-]+:\/\//;
                const t = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
                const r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
                var n;
                (function(e1) {
                    e1[e1["Empty"] = 1] = "Empty";
                    e1[e1["Hash"] = 2] = "Hash";
                    e1[e1["Query"] = 3] = "Query";
                    e1[e1["RelativePath"] = 4] = "RelativePath";
                    e1[e1["AbsolutePath"] = 5] = "AbsolutePath";
                    e1[e1["SchemeRelative"] = 6] = "SchemeRelative";
                    e1[e1["Absolute"] = 7] = "Absolute";
                })(n || (n = {}));
                function isAbsoluteUrl(t) {
                    return e1.test(t);
                }
                function isSchemeRelativeUrl(e1) {
                    return e1.startsWith("//");
                }
                function isAbsolutePath(e1) {
                    return e1.startsWith("/");
                }
                function isFileUrl(e1) {
                    return e1.startsWith("file:");
                }
                function isRelative(e1) {
                    return /^[.?#]/.test(e1);
                }
                function parseAbsoluteUrl(e1) {
                    const r = t.exec(e1);
                    return makeUrl(r[1], r[2] || "", r[3], r[4] || "", r[5] || "/", r[6] || "", r[7] || "");
                }
                function parseFileUrl(e1) {
                    const t = r.exec(e1);
                    const n = t[2];
                    return makeUrl("file:", "", t[1] || "", "", isAbsolutePath(n) ? n : "/" + n, t[3] || "", t[4] || "");
                }
                function makeUrl(e1, t, r, s, i, a, o) {
                    return {
                        scheme: e1,
                        user: t,
                        host: r,
                        port: s,
                        path: i,
                        query: a,
                        hash: o,
                        type: n.Absolute
                    };
                }
                function parseUrl(e1) {
                    if (isSchemeRelativeUrl(e1)) {
                        const t = parseAbsoluteUrl("http:" + e1);
                        t.scheme = "";
                        t.type = n.SchemeRelative;
                        return t;
                    }
                    if (isAbsolutePath(e1)) {
                        const t = parseAbsoluteUrl("http://foo.com" + e1);
                        t.scheme = "";
                        t.host = "";
                        t.type = n.AbsolutePath;
                        return t;
                    }
                    if (isFileUrl(e1)) return parseFileUrl(e1);
                    if (isAbsoluteUrl(e1)) return parseAbsoluteUrl(e1);
                    const t = parseAbsoluteUrl("http://foo.com/" + e1);
                    t.scheme = "";
                    t.host = "";
                    t.type = e1 ? e1.startsWith("?") ? n.Query : e1.startsWith("#") ? n.Hash : n.RelativePath : n.Empty;
                    return t;
                }
                function stripPathFilename(e1) {
                    if (e1.endsWith("/..")) return e1;
                    const t = e1.lastIndexOf("/");
                    return e1.slice(0, t + 1);
                }
                function mergePaths(e1, t) {
                    normalizePath(t, t.type);
                    if (e1.path === "/") {
                        e1.path = t.path;
                    } else {
                        e1.path = stripPathFilename(t.path) + e1.path;
                    }
                }
                function normalizePath(e1, t) {
                    const r = t <= n.RelativePath;
                    const s = e1.path.split("/");
                    let i = 1;
                    let a = 0;
                    let o = false;
                    for(let e1 = 1; e1 < s.length; e1++){
                        const t = s[e1];
                        if (!t) {
                            o = true;
                            continue;
                        }
                        o = false;
                        if (t === ".") continue;
                        if (t === "..") {
                            if (a) {
                                o = true;
                                a--;
                                i--;
                            } else if (r) {
                                s[i++] = t;
                            }
                            continue;
                        }
                        s[i++] = t;
                        a++;
                    }
                    let l = "";
                    for(let e1 = 1; e1 < i; e1++){
                        l += "/" + s[e1];
                    }
                    if (!l || o && !l.endsWith("/..")) {
                        l += "/";
                    }
                    e1.path = l;
                }
                function resolve(e1, t) {
                    if (!e1 && !t) return "";
                    const r = parseUrl(e1);
                    let s = r.type;
                    if (t && s !== n.Absolute) {
                        const e1 = parseUrl(t);
                        const i = e1.type;
                        switch(s){
                            case n.Empty:
                                r.hash = e1.hash;
                            case n.Hash:
                                r.query = e1.query;
                            case n.Query:
                            case n.RelativePath:
                                mergePaths(r, e1);
                            case n.AbsolutePath:
                                r.user = e1.user;
                                r.host = e1.host;
                                r.port = e1.port;
                            case n.SchemeRelative:
                                r.scheme = e1.scheme;
                        }
                        if (i > s) s = i;
                    }
                    normalizePath(r, s);
                    const i = r.query + r.hash;
                    switch(s){
                        case n.Hash:
                        case n.Query:
                            return i;
                        case n.RelativePath:
                            {
                                const n = r.path.slice(1);
                                if (!n) return i || ".";
                                if (isRelative(t || e1) && !isRelative(n)) {
                                    return "./" + n + i;
                                }
                                return n + i;
                            }
                        case n.AbsolutePath:
                            return r.path + i;
                        default:
                            return r.scheme + "//" + r.user + r.host + r.port + r.path + i;
                    }
                }
                return resolve;
            });
        },
        7168: function(e1, t) {
            (function(e1, r) {
                ("TURBOPACK compile-time truthy", 1) ? r(t) : ("TURBOPACK unreachable", undefined);
            })(this, function(e1) {
                "use strict";
                e1.get = void 0;
                e1.put = void 0;
                e1.pop = void 0;
                class SetArray {
                    constructor(){
                        this._indexes = {
                            __proto__: null
                        };
                        this.array = [];
                    }
                }
                (()=>{
                    e1.get = (e1, t)=>e1._indexes[t];
                    e1.put = (t, r)=>{
                        const n = e1.get(t, r);
                        if (n !== undefined) return n;
                        const { array: s, _indexes: i } = t;
                        return i[r] = s.push(r) - 1;
                    };
                    e1.pop = (e1)=>{
                        const { array: t, _indexes: r } = e1;
                        if (t.length === 0) return;
                        const n = t.pop();
                        r[n] = undefined;
                    };
                })();
                e1.SetArray = SetArray;
                Object.defineProperty(e1, "__esModule", {
                    value: true
                });
            });
        },
        1575: function(e1, t) {
            (function(e1, r) {
                ("TURBOPACK compile-time truthy", 1) ? r(t) : ("TURBOPACK unreachable", undefined);
            })(this, function(e1) {
                "use strict";
                const t = ",".charCodeAt(0);
                const r = ";".charCodeAt(0);
                const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                const s = new Uint8Array(64);
                const i = new Uint8Array(128);
                for(let e1 = 0; e1 < n.length; e1++){
                    const t = n.charCodeAt(e1);
                    s[e1] = t;
                    i[t] = e1;
                }
                const a = typeof TextDecoder !== "undefined" ? new TextDecoder : typeof Buffer !== "undefined" ? {
                    decode (e1) {
                        const t = Buffer.from(e1.buffer, e1.byteOffset, e1.byteLength);
                        return t.toString();
                    }
                } : {
                    decode (e1) {
                        let t = "";
                        for(let r = 0; r < e1.length; r++){
                            t += String.fromCharCode(e1[r]);
                        }
                        return t;
                    }
                };
                function decode(e1) {
                    const t = new Int32Array(5);
                    const r = [];
                    let n = 0;
                    do {
                        const s = indexOf(e1, n);
                        const i = [];
                        let a = true;
                        let o = 0;
                        t[0] = 0;
                        for(let r = n; r < s; r++){
                            let n;
                            r = decodeInteger(e1, r, t, 0);
                            const l = t[0];
                            if (l < o) a = false;
                            o = l;
                            if (hasMoreVlq(e1, r, s)) {
                                r = decodeInteger(e1, r, t, 1);
                                r = decodeInteger(e1, r, t, 2);
                                r = decodeInteger(e1, r, t, 3);
                                if (hasMoreVlq(e1, r, s)) {
                                    r = decodeInteger(e1, r, t, 4);
                                    n = [
                                        l,
                                        t[1],
                                        t[2],
                                        t[3],
                                        t[4]
                                    ];
                                } else {
                                    n = [
                                        l,
                                        t[1],
                                        t[2],
                                        t[3]
                                    ];
                                }
                            } else {
                                n = [
                                    l
                                ];
                            }
                            i.push(n);
                        }
                        if (!a) sort(i);
                        r.push(i);
                        n = s + 1;
                    }while (n <= e1.length)
                    return r;
                }
                function indexOf(e1, t) {
                    const r = e1.indexOf(";", t);
                    return r === -1 ? e1.length : r;
                }
                function decodeInteger(e1, t, r, n) {
                    let s = 0;
                    let a = 0;
                    let o = 0;
                    do {
                        const r = e1.charCodeAt(t++);
                        o = i[r];
                        s |= (o & 31) << a;
                        a += 5;
                    }while (o & 32)
                    const l = s & 1;
                    s >>>= 1;
                    if (l) {
                        s = -2147483648 | -s;
                    }
                    r[n] += s;
                    return t;
                }
                function hasMoreVlq(e1, r, n) {
                    if (r >= n) return false;
                    return e1.charCodeAt(r) !== t;
                }
                function sort(e1) {
                    e1.sort(sortComparator);
                }
                function sortComparator(e1, t) {
                    return e1[0] - t[0];
                }
                function encode(e1) {
                    const n = new Int32Array(5);
                    const s = 1024 * 16;
                    const i = s - 36;
                    const o = new Uint8Array(s);
                    const l = o.subarray(0, i);
                    let c = 0;
                    let u = "";
                    for(let p = 0; p < e1.length; p++){
                        const f = e1[p];
                        if (p > 0) {
                            if (c === s) {
                                u += a.decode(o);
                                c = 0;
                            }
                            o[c++] = r;
                        }
                        if (f.length === 0) continue;
                        n[0] = 0;
                        for(let e1 = 0; e1 < f.length; e1++){
                            const r = f[e1];
                            if (c > i) {
                                u += a.decode(l);
                                o.copyWithin(0, i, c);
                                c -= i;
                            }
                            if (e1 > 0) o[c++] = t;
                            c = encodeInteger(o, c, n, r, 0);
                            if (r.length === 1) continue;
                            c = encodeInteger(o, c, n, r, 1);
                            c = encodeInteger(o, c, n, r, 2);
                            c = encodeInteger(o, c, n, r, 3);
                            if (r.length === 4) continue;
                            c = encodeInteger(o, c, n, r, 4);
                        }
                    }
                    return u + a.decode(o.subarray(0, c));
                }
                function encodeInteger(e1, t, r, n, i) {
                    const a = n[i];
                    let o = a - r[i];
                    r[i] = a;
                    o = o < 0 ? -o << 1 | 1 : o << 1;
                    do {
                        let r = o & 31;
                        o >>>= 5;
                        if (o > 0) r |= 32;
                        e1[t++] = s[r];
                    }while (o > 0)
                    return t;
                }
                e1.decode = decode;
                e1.encode = encode;
                Object.defineProperty(e1, "__esModule", {
                    value: true
                });
            });
        },
        4614: function(e1, t, r) {
            (function(e1, n) {
                ("TURBOPACK compile-time truthy", 1) ? n(t, r(1575), r(6982)) : ("TURBOPACK unreachable", undefined);
            })(this, function(e1, t, r) {
                "use strict";
                function _interopDefaultLegacy(e1) {
                    return e1 && typeof e1 === "object" && "default" in e1 ? e1 : {
                        default: e1
                    };
                }
                var n = _interopDefaultLegacy(r);
                function resolve(e1, t) {
                    if (t && !t.endsWith("/")) t += "/";
                    return n["default"](e1, t);
                }
                function stripFilename(e1) {
                    if (!e1) return "";
                    const t = e1.lastIndexOf("/");
                    return e1.slice(0, t + 1);
                }
                const s = 0;
                const i = 1;
                const a = 2;
                const o = 3;
                const l = 4;
                const c = 1;
                const u = 2;
                function maybeSort(e1, t) {
                    const r = nextUnsortedSegmentLine(e1, 0);
                    if (r === e1.length) return e1;
                    if (!t) e1 = e1.slice();
                    for(let n = r; n < e1.length; n = nextUnsortedSegmentLine(e1, n + 1)){
                        e1[n] = sortSegments(e1[n], t);
                    }
                    return e1;
                }
                function nextUnsortedSegmentLine(e1, t) {
                    for(let r = t; r < e1.length; r++){
                        if (!isSorted(e1[r])) return r;
                    }
                    return e1.length;
                }
                function isSorted(e1) {
                    for(let t = 1; t < e1.length; t++){
                        if (e1[t][s] < e1[t - 1][s]) {
                            return false;
                        }
                    }
                    return true;
                }
                function sortSegments(e1, t) {
                    if (!t) e1 = e1.slice();
                    return e1.sort(sortComparator);
                }
                function sortComparator(e1, t) {
                    return e1[s] - t[s];
                }
                let p = false;
                function binarySearch(e1, t, r, n) {
                    while(r <= n){
                        const i = r + (n - r >> 1);
                        const a = e1[i][s] - t;
                        if (a === 0) {
                            p = true;
                            return i;
                        }
                        if (a < 0) {
                            r = i + 1;
                        } else {
                            n = i - 1;
                        }
                    }
                    p = false;
                    return r - 1;
                }
                function upperBound(e1, t, r) {
                    for(let n = r + 1; n < e1.length; r = n++){
                        if (e1[n][s] !== t) break;
                    }
                    return r;
                }
                function lowerBound(e1, t, r) {
                    for(let n = r - 1; n >= 0; r = n--){
                        if (e1[n][s] !== t) break;
                    }
                    return r;
                }
                function memoizedState() {
                    return {
                        lastKey: -1,
                        lastNeedle: -1,
                        lastIndex: -1
                    };
                }
                function memoizedBinarySearch(e1, t, r, n) {
                    const { lastKey: i, lastNeedle: a, lastIndex: o } = r;
                    let l = 0;
                    let c = e1.length - 1;
                    if (n === i) {
                        if (t === a) {
                            p = o !== -1 && e1[o][s] === t;
                            return o;
                        }
                        if (t >= a) {
                            l = o === -1 ? 0 : o;
                        } else {
                            c = o;
                        }
                    }
                    r.lastKey = n;
                    r.lastNeedle = t;
                    return r.lastIndex = binarySearch(e1, t, l, c);
                }
                function buildBySources(e1, t) {
                    const r = t.map(buildNullArray);
                    for(let n = 0; n < e1.length; n++){
                        const l = e1[n];
                        for(let e1 = 0; e1 < l.length; e1++){
                            const c = l[e1];
                            if (c.length === 1) continue;
                            const u = c[i];
                            const p = c[a];
                            const f = c[o];
                            const d = r[u];
                            const h = d[p] || (d[p] = []);
                            const m = t[u];
                            const y = upperBound(h, f, memoizedBinarySearch(h, f, m, p));
                            insert(h, m.lastIndex = y + 1, [
                                f,
                                n,
                                c[s]
                            ]);
                        }
                    }
                    return r;
                }
                function insert(e1, t, r) {
                    for(let r = e1.length; r > t; r--){
                        e1[r] = e1[r - 1];
                    }
                    e1[t] = r;
                }
                function buildNullArray() {
                    return {
                        __proto__: null
                    };
                }
                const AnyMap = function(t, r) {
                    const n = typeof t === "string" ? JSON.parse(t) : t;
                    if (!("sections" in n)) return new TraceMap(n, r);
                    const s = [];
                    const i = [];
                    const a = [];
                    const o = [];
                    recurse(n, r, s, i, a, o, 0, 0, Infinity, Infinity);
                    const l = {
                        version: 3,
                        file: n.file,
                        names: o,
                        sources: i,
                        sourcesContent: a,
                        mappings: s
                    };
                    return e1.presortedDecodedMap(l);
                };
                function recurse(e1, t, r, n, s, i, a, o, l, c) {
                    const { sections: u } = e1;
                    for(let e1 = 0; e1 < u.length; e1++){
                        const { map: p, offset: f } = u[e1];
                        let d = l;
                        let h = c;
                        if (e1 + 1 < u.length) {
                            const t = u[e1 + 1].offset;
                            d = Math.min(l, a + t.line);
                            if (d === l) {
                                h = Math.min(c, o + t.column);
                            } else if (d < l) {
                                h = o + t.column;
                            }
                        }
                        addSection(p, t, r, n, s, i, a + f.line, o + f.column, d, h);
                    }
                }
                function addSection(t, r, n, c, u, p, f, d, h, m) {
                    if ("sections" in t) return recurse(...arguments);
                    const y = new TraceMap(t, r);
                    const g = c.length;
                    const b = p.length;
                    const T = e1.decodedMappings(y);
                    const { resolvedSources: S, sourcesContent: E } = y;
                    append(c, S);
                    append(p, y.names);
                    if (E) append(u, E);
                    else for(let e1 = 0; e1 < S.length; e1++)u.push(null);
                    for(let e1 = 0; e1 < T.length; e1++){
                        const t = f + e1;
                        if (t > h) return;
                        const r = getLine(n, t);
                        const c = e1 === 0 ? d : 0;
                        const u = T[e1];
                        for(let e1 = 0; e1 < u.length; e1++){
                            const n = u[e1];
                            const p = c + n[s];
                            if (t === h && p >= m) return;
                            if (n.length === 1) {
                                r.push([
                                    p
                                ]);
                                continue;
                            }
                            const f = g + n[i];
                            const d = n[a];
                            const y = n[o];
                            r.push(n.length === 4 ? [
                                p,
                                f,
                                d,
                                y
                            ] : [
                                p,
                                f,
                                d,
                                y,
                                b + n[l]
                            ]);
                        }
                    }
                }
                function append(e1, t) {
                    for(let r = 0; r < t.length; r++)e1.push(t[r]);
                }
                function getLine(e1, t) {
                    for(let r = e1.length; r <= t; r++)e1[r] = [];
                    return e1[t];
                }
                const f = "`line` must be greater than 0 (lines start at line 1)";
                const d = "`column` must be greater than or equal to 0 (columns start at column 0)";
                const h = -1;
                const m = 1;
                e1.encodedMappings = void 0;
                e1.decodedMappings = void 0;
                e1.traceSegment = void 0;
                e1.originalPositionFor = void 0;
                e1.generatedPositionFor = void 0;
                e1.allGeneratedPositionsFor = void 0;
                e1.eachMapping = void 0;
                e1.sourceContentFor = void 0;
                e1.presortedDecodedMap = void 0;
                e1.decodedMap = void 0;
                e1.encodedMap = void 0;
                class TraceMap {
                    constructor(e1, t){
                        const r = typeof e1 === "string";
                        if (!r && e1._decodedMemo) return e1;
                        const n = r ? JSON.parse(e1) : e1;
                        const { version: s, file: i, names: a, sourceRoot: o, sources: l, sourcesContent: c } = n;
                        this.version = s;
                        this.file = i;
                        this.names = a;
                        this.sourceRoot = o;
                        this.sources = l;
                        this.sourcesContent = c;
                        const u = resolve(o || "", stripFilename(t));
                        this.resolvedSources = l.map((e1)=>resolve(e1 || "", u));
                        const { mappings: p } = n;
                        if (typeof p === "string") {
                            this._encoded = p;
                            this._decoded = undefined;
                        } else {
                            this._encoded = undefined;
                            this._decoded = maybeSort(p, r);
                        }
                        this._decodedMemo = memoizedState();
                        this._bySources = undefined;
                        this._bySourceMemos = undefined;
                    }
                }
                (()=>{
                    e1.encodedMappings = (e1)=>{
                        var r;
                        return (r = e1._encoded) !== null && r !== void 0 ? r : e1._encoded = t.encode(e1._decoded);
                    };
                    e1.decodedMappings = (e1)=>e1._decoded || (e1._decoded = t.decode(e1._encoded));
                    e1.traceSegment = (t, r, n)=>{
                        const s = e1.decodedMappings(t);
                        if (r >= s.length) return null;
                        const i = s[r];
                        const a = traceSegmentInternal(i, t._decodedMemo, r, n, m);
                        return a === -1 ? null : i[a];
                    };
                    e1.originalPositionFor = (t, { line: r, column: n, bias: s })=>{
                        r--;
                        if (r < 0) throw new Error(f);
                        if (n < 0) throw new Error(d);
                        const c = e1.decodedMappings(t);
                        if (r >= c.length) return OMapping(null, null, null, null);
                        const u = c[r];
                        const p = traceSegmentInternal(u, t._decodedMemo, r, n, s || m);
                        if (p === -1) return OMapping(null, null, null, null);
                        const h = u[p];
                        if (h.length === 1) return OMapping(null, null, null, null);
                        const { names: y, resolvedSources: g } = t;
                        return OMapping(g[h[i]], h[a] + 1, h[o], h.length === 5 ? y[h[l]] : null);
                    };
                    e1.allGeneratedPositionsFor = (e1, { source: t, line: r, column: n, bias: s })=>generatedPosition(e1, t, r, n, s || h, true);
                    e1.generatedPositionFor = (e1, { source: t, line: r, column: n, bias: s })=>generatedPosition(e1, t, r, n, s || m, false);
                    e1.eachMapping = (t, r)=>{
                        const n = e1.decodedMappings(t);
                        const { names: s, resolvedSources: i } = t;
                        for(let e1 = 0; e1 < n.length; e1++){
                            const t = n[e1];
                            for(let n = 0; n < t.length; n++){
                                const a = t[n];
                                const o = e1 + 1;
                                const l = a[0];
                                let c = null;
                                let u = null;
                                let p = null;
                                let f = null;
                                if (a.length !== 1) {
                                    c = i[a[1]];
                                    u = a[2] + 1;
                                    p = a[3];
                                }
                                if (a.length === 5) f = s[a[4]];
                                r({
                                    generatedLine: o,
                                    generatedColumn: l,
                                    source: c,
                                    originalLine: u,
                                    originalColumn: p,
                                    name: f
                                });
                            }
                        }
                    };
                    e1.sourceContentFor = (e1, t)=>{
                        const { sources: r, resolvedSources: n, sourcesContent: s } = e1;
                        if (s == null) return null;
                        let i = r.indexOf(t);
                        if (i === -1) i = n.indexOf(t);
                        return i === -1 ? null : s[i];
                    };
                    e1.presortedDecodedMap = (e1, t)=>{
                        const r = new TraceMap(clone(e1, []), t);
                        r._decoded = e1.mappings;
                        return r;
                    };
                    e1.decodedMap = (t)=>clone(t, e1.decodedMappings(t));
                    e1.encodedMap = (t)=>clone(t, e1.encodedMappings(t));
                    function generatedPosition(t, r, n, s, i, a) {
                        n--;
                        if (n < 0) throw new Error(f);
                        if (s < 0) throw new Error(d);
                        const { sources: o, resolvedSources: l } = t;
                        let p = o.indexOf(r);
                        if (p === -1) p = l.indexOf(r);
                        if (p === -1) return a ? [] : GMapping(null, null);
                        const h = t._bySources || (t._bySources = buildBySources(e1.decodedMappings(t), t._bySourceMemos = o.map(memoizedState)));
                        const m = h[p][n];
                        if (m == null) return a ? [] : GMapping(null, null);
                        const y = t._bySourceMemos[p];
                        if (a) return sliceGeneratedPositions(m, y, n, s, i);
                        const g = traceSegmentInternal(m, y, n, s, i);
                        if (g === -1) return GMapping(null, null);
                        const b = m[g];
                        return GMapping(b[c] + 1, b[u]);
                    }
                })();
                function clone(e1, t) {
                    return {
                        version: e1.version,
                        file: e1.file,
                        names: e1.names,
                        sourceRoot: e1.sourceRoot,
                        sources: e1.sources,
                        sourcesContent: e1.sourcesContent,
                        mappings: t
                    };
                }
                function OMapping(e1, t, r, n) {
                    return {
                        source: e1,
                        line: t,
                        column: r,
                        name: n
                    };
                }
                function GMapping(e1, t) {
                    return {
                        line: e1,
                        column: t
                    };
                }
                function traceSegmentInternal(e1, t, r, n, s) {
                    let i = memoizedBinarySearch(e1, n, t, r);
                    if (p) {
                        i = (s === h ? upperBound : lowerBound)(e1, n, i);
                    } else if (s === h) i++;
                    if (i === -1 || i === e1.length) return -1;
                    return i;
                }
                function sliceGeneratedPositions(e1, t, r, n, i) {
                    let a = traceSegmentInternal(e1, t, r, n, m);
                    if (!p && i === h) a++;
                    if (a === -1 || a === e1.length) return [];
                    const o = p ? n : e1[a][s];
                    if (!p) a = lowerBound(e1, o, a);
                    const l = upperBound(e1, o, a);
                    const f = [];
                    for(; a <= l; a++){
                        const t = e1[a];
                        f.push(GMapping(t[c] + 1, t[u]));
                    }
                    return f;
                }
                e1.AnyMap = AnyMap;
                e1.GREATEST_LOWER_BOUND = m;
                e1.LEAST_UPPER_BOUND = h;
                e1.TraceMap = TraceMap;
                Object.defineProperty(e1, "__esModule", {
                    value: true
                });
            });
        },
        519: function(e1, t, r) {
            (function(e1, n) {
                ("TURBOPACK compile-time truthy", 1) ? n(t, r(1575), r(6982)) : ("TURBOPACK unreachable", undefined);
            })(this, function(e1, t, r) {
                "use strict";
                function _interopDefaultLegacy(e1) {
                    return e1 && typeof e1 === "object" && "default" in e1 ? e1 : {
                        default: e1
                    };
                }
                var n = _interopDefaultLegacy(r);
                function resolve(e1, t) {
                    if (t && !t.endsWith("/")) t += "/";
                    return n["default"](e1, t);
                }
                function stripFilename(e1) {
                    if (!e1) return "";
                    const t = e1.lastIndexOf("/");
                    return e1.slice(0, t + 1);
                }
                const s = 0;
                const i = 1;
                const a = 2;
                const o = 3;
                const l = 4;
                const c = 1;
                const u = 2;
                function maybeSort(e1, t) {
                    const r = nextUnsortedSegmentLine(e1, 0);
                    if (r === e1.length) return e1;
                    if (!t) e1 = e1.slice();
                    for(let n = r; n < e1.length; n = nextUnsortedSegmentLine(e1, n + 1)){
                        e1[n] = sortSegments(e1[n], t);
                    }
                    return e1;
                }
                function nextUnsortedSegmentLine(e1, t) {
                    for(let r = t; r < e1.length; r++){
                        if (!isSorted(e1[r])) return r;
                    }
                    return e1.length;
                }
                function isSorted(e1) {
                    for(let t = 1; t < e1.length; t++){
                        if (e1[t][s] < e1[t - 1][s]) {
                            return false;
                        }
                    }
                    return true;
                }
                function sortSegments(e1, t) {
                    if (!t) e1 = e1.slice();
                    return e1.sort(sortComparator);
                }
                function sortComparator(e1, t) {
                    return e1[s] - t[s];
                }
                let p = false;
                function binarySearch(e1, t, r, n) {
                    while(r <= n){
                        const i = r + (n - r >> 1);
                        const a = e1[i][s] - t;
                        if (a === 0) {
                            p = true;
                            return i;
                        }
                        if (a < 0) {
                            r = i + 1;
                        } else {
                            n = i - 1;
                        }
                    }
                    p = false;
                    return r - 1;
                }
                function upperBound(e1, t, r) {
                    for(let n = r + 1; n < e1.length; r = n++){
                        if (e1[n][s] !== t) break;
                    }
                    return r;
                }
                function lowerBound(e1, t, r) {
                    for(let n = r - 1; n >= 0; r = n--){
                        if (e1[n][s] !== t) break;
                    }
                    return r;
                }
                function memoizedState() {
                    return {
                        lastKey: -1,
                        lastNeedle: -1,
                        lastIndex: -1
                    };
                }
                function memoizedBinarySearch(e1, t, r, n) {
                    const { lastKey: i, lastNeedle: a, lastIndex: o } = r;
                    let l = 0;
                    let c = e1.length - 1;
                    if (n === i) {
                        if (t === a) {
                            p = o !== -1 && e1[o][s] === t;
                            return o;
                        }
                        if (t >= a) {
                            l = o === -1 ? 0 : o;
                        } else {
                            c = o;
                        }
                    }
                    r.lastKey = n;
                    r.lastNeedle = t;
                    return r.lastIndex = binarySearch(e1, t, l, c);
                }
                function buildBySources(e1, t) {
                    const r = t.map(buildNullArray);
                    for(let n = 0; n < e1.length; n++){
                        const l = e1[n];
                        for(let e1 = 0; e1 < l.length; e1++){
                            const c = l[e1];
                            if (c.length === 1) continue;
                            const u = c[i];
                            const p = c[a];
                            const f = c[o];
                            const d = r[u];
                            const h = d[p] || (d[p] = []);
                            const m = t[u];
                            const y = upperBound(h, f, memoizedBinarySearch(h, f, m, p));
                            insert(h, m.lastIndex = y + 1, [
                                f,
                                n,
                                c[s]
                            ]);
                        }
                    }
                    return r;
                }
                function insert(e1, t, r) {
                    for(let r = e1.length; r > t; r--){
                        e1[r] = e1[r - 1];
                    }
                    e1[t] = r;
                }
                function buildNullArray() {
                    return {
                        __proto__: null
                    };
                }
                const AnyMap = function(t, r) {
                    const n = typeof t === "string" ? JSON.parse(t) : t;
                    if (!("sections" in n)) return new TraceMap(n, r);
                    const s = [];
                    const i = [];
                    const a = [];
                    const o = [];
                    recurse(n, r, s, i, a, o, 0, 0, Infinity, Infinity);
                    const l = {
                        version: 3,
                        file: n.file,
                        names: o,
                        sources: i,
                        sourcesContent: a,
                        mappings: s
                    };
                    return e1.presortedDecodedMap(l);
                };
                function recurse(e1, t, r, n, s, i, a, o, l, c) {
                    const { sections: u } = e1;
                    for(let e1 = 0; e1 < u.length; e1++){
                        const { map: p, offset: f } = u[e1];
                        let d = l;
                        let h = c;
                        if (e1 + 1 < u.length) {
                            const t = u[e1 + 1].offset;
                            d = Math.min(l, a + t.line);
                            if (d === l) {
                                h = Math.min(c, o + t.column);
                            } else if (d < l) {
                                h = o + t.column;
                            }
                        }
                        addSection(p, t, r, n, s, i, a + f.line, o + f.column, d, h);
                    }
                }
                function addSection(t, r, n, c, u, p, f, d, h, m) {
                    if ("sections" in t) return recurse(...arguments);
                    const y = new TraceMap(t, r);
                    const g = c.length;
                    const b = p.length;
                    const T = e1.decodedMappings(y);
                    const { resolvedSources: S, sourcesContent: E } = y;
                    append(c, S);
                    append(p, y.names);
                    if (E) append(u, E);
                    else for(let e1 = 0; e1 < S.length; e1++)u.push(null);
                    for(let e1 = 0; e1 < T.length; e1++){
                        const t = f + e1;
                        if (t > h) return;
                        const r = getLine(n, t);
                        const c = e1 === 0 ? d : 0;
                        const u = T[e1];
                        for(let e1 = 0; e1 < u.length; e1++){
                            const n = u[e1];
                            const p = c + n[s];
                            if (t === h && p >= m) return;
                            if (n.length === 1) {
                                r.push([
                                    p
                                ]);
                                continue;
                            }
                            const f = g + n[i];
                            const d = n[a];
                            const y = n[o];
                            r.push(n.length === 4 ? [
                                p,
                                f,
                                d,
                                y
                            ] : [
                                p,
                                f,
                                d,
                                y,
                                b + n[l]
                            ]);
                        }
                    }
                }
                function append(e1, t) {
                    for(let r = 0; r < t.length; r++)e1.push(t[r]);
                }
                function getLine(e1, t) {
                    for(let r = e1.length; r <= t; r++)e1[r] = [];
                    return e1[t];
                }
                const f = "`line` must be greater than 0 (lines start at line 1)";
                const d = "`column` must be greater than or equal to 0 (columns start at column 0)";
                const h = -1;
                const m = 1;
                e1.encodedMappings = void 0;
                e1.decodedMappings = void 0;
                e1.traceSegment = void 0;
                e1.originalPositionFor = void 0;
                e1.generatedPositionFor = void 0;
                e1.allGeneratedPositionsFor = void 0;
                e1.eachMapping = void 0;
                e1.sourceContentFor = void 0;
                e1.presortedDecodedMap = void 0;
                e1.decodedMap = void 0;
                e1.encodedMap = void 0;
                class TraceMap {
                    constructor(e1, t){
                        const r = typeof e1 === "string";
                        if (!r && e1._decodedMemo) return e1;
                        const n = r ? JSON.parse(e1) : e1;
                        const { version: s, file: i, names: a, sourceRoot: o, sources: l, sourcesContent: c } = n;
                        this.version = s;
                        this.file = i;
                        this.names = a;
                        this.sourceRoot = o;
                        this.sources = l;
                        this.sourcesContent = c;
                        const u = resolve(o || "", stripFilename(t));
                        this.resolvedSources = l.map((e1)=>resolve(e1 || "", u));
                        const { mappings: p } = n;
                        if (typeof p === "string") {
                            this._encoded = p;
                            this._decoded = undefined;
                        } else {
                            this._encoded = undefined;
                            this._decoded = maybeSort(p, r);
                        }
                        this._decodedMemo = memoizedState();
                        this._bySources = undefined;
                        this._bySourceMemos = undefined;
                    }
                }
                (()=>{
                    e1.encodedMappings = (e1)=>{
                        var r;
                        return (r = e1._encoded) !== null && r !== void 0 ? r : e1._encoded = t.encode(e1._decoded);
                    };
                    e1.decodedMappings = (e1)=>e1._decoded || (e1._decoded = t.decode(e1._encoded));
                    e1.traceSegment = (t, r, n)=>{
                        const s = e1.decodedMappings(t);
                        if (r >= s.length) return null;
                        const i = s[r];
                        const a = traceSegmentInternal(i, t._decodedMemo, r, n, m);
                        return a === -1 ? null : i[a];
                    };
                    e1.originalPositionFor = (t, { line: r, column: n, bias: s })=>{
                        r--;
                        if (r < 0) throw new Error(f);
                        if (n < 0) throw new Error(d);
                        const c = e1.decodedMappings(t);
                        if (r >= c.length) return OMapping(null, null, null, null);
                        const u = c[r];
                        const p = traceSegmentInternal(u, t._decodedMemo, r, n, s || m);
                        if (p === -1) return OMapping(null, null, null, null);
                        const h = u[p];
                        if (h.length === 1) return OMapping(null, null, null, null);
                        const { names: y, resolvedSources: g } = t;
                        return OMapping(g[h[i]], h[a] + 1, h[o], h.length === 5 ? y[h[l]] : null);
                    };
                    e1.allGeneratedPositionsFor = (e1, { source: t, line: r, column: n, bias: s })=>generatedPosition(e1, t, r, n, s || h, true);
                    e1.generatedPositionFor = (e1, { source: t, line: r, column: n, bias: s })=>generatedPosition(e1, t, r, n, s || m, false);
                    e1.eachMapping = (t, r)=>{
                        const n = e1.decodedMappings(t);
                        const { names: s, resolvedSources: i } = t;
                        for(let e1 = 0; e1 < n.length; e1++){
                            const t = n[e1];
                            for(let n = 0; n < t.length; n++){
                                const a = t[n];
                                const o = e1 + 1;
                                const l = a[0];
                                let c = null;
                                let u = null;
                                let p = null;
                                let f = null;
                                if (a.length !== 1) {
                                    c = i[a[1]];
                                    u = a[2] + 1;
                                    p = a[3];
                                }
                                if (a.length === 5) f = s[a[4]];
                                r({
                                    generatedLine: o,
                                    generatedColumn: l,
                                    source: c,
                                    originalLine: u,
                                    originalColumn: p,
                                    name: f
                                });
                            }
                        }
                    };
                    e1.sourceContentFor = (e1, t)=>{
                        const { sources: r, resolvedSources: n, sourcesContent: s } = e1;
                        if (s == null) return null;
                        let i = r.indexOf(t);
                        if (i === -1) i = n.indexOf(t);
                        return i === -1 ? null : s[i];
                    };
                    e1.presortedDecodedMap = (e1, t)=>{
                        const r = new TraceMap(clone(e1, []), t);
                        r._decoded = e1.mappings;
                        return r;
                    };
                    e1.decodedMap = (t)=>clone(t, e1.decodedMappings(t));
                    e1.encodedMap = (t)=>clone(t, e1.encodedMappings(t));
                    function generatedPosition(t, r, n, s, i, a) {
                        n--;
                        if (n < 0) throw new Error(f);
                        if (s < 0) throw new Error(d);
                        const { sources: o, resolvedSources: l } = t;
                        let p = o.indexOf(r);
                        if (p === -1) p = l.indexOf(r);
                        if (p === -1) return a ? [] : GMapping(null, null);
                        const h = t._bySources || (t._bySources = buildBySources(e1.decodedMappings(t), t._bySourceMemos = o.map(memoizedState)));
                        const m = h[p][n];
                        if (m == null) return a ? [] : GMapping(null, null);
                        const y = t._bySourceMemos[p];
                        if (a) return sliceGeneratedPositions(m, y, n, s, i);
                        const g = traceSegmentInternal(m, y, n, s, i);
                        if (g === -1) return GMapping(null, null);
                        const b = m[g];
                        return GMapping(b[c] + 1, b[u]);
                    }
                })();
                function clone(e1, t) {
                    return {
                        version: e1.version,
                        file: e1.file,
                        names: e1.names,
                        sourceRoot: e1.sourceRoot,
                        sources: e1.sources,
                        sourcesContent: e1.sourcesContent,
                        mappings: t
                    };
                }
                function OMapping(e1, t, r, n) {
                    return {
                        source: e1,
                        line: t,
                        column: r,
                        name: n
                    };
                }
                function GMapping(e1, t) {
                    return {
                        line: e1,
                        column: t
                    };
                }
                function traceSegmentInternal(e1, t, r, n, s) {
                    let i = memoizedBinarySearch(e1, n, t, r);
                    if (p) {
                        i = (s === h ? upperBound : lowerBound)(e1, n, i);
                    } else if (s === h) i++;
                    if (i === -1 || i === e1.length) return -1;
                    return i;
                }
                function sliceGeneratedPositions(e1, t, r, n, i) {
                    let a = traceSegmentInternal(e1, t, r, n, m);
                    if (!p && i === h) a++;
                    if (a === -1 || a === e1.length) return [];
                    const o = p ? n : e1[a][s];
                    if (!p) a = lowerBound(e1, o, a);
                    const l = upperBound(e1, o, a);
                    const f = [];
                    for(; a <= l; a++){
                        const t = e1[a];
                        f.push(GMapping(t[c] + 1, t[u]));
                    }
                    return f;
                }
                e1.AnyMap = AnyMap;
                e1.GREATEST_LOWER_BOUND = m;
                e1.LEAST_UPPER_BOUND = h;
                e1.TraceMap = TraceMap;
                Object.defineProperty(e1, "__esModule", {
                    value: true
                });
            });
        },
        8535: (e1, t, r)=>{
            "use strict";
            e1 = r.nmd(e1);
            const n = r(9054);
            const wrapAnsi16 = (e1, t)=>function() {
                    const r = e1.apply(n, arguments);
                    return `[${r + t}m`;
                };
            const wrapAnsi256 = (e1, t)=>function() {
                    const r = e1.apply(n, arguments);
                    return `[${38 + t};5;${r}m`;
                };
            const wrapAnsi16m = (e1, t)=>function() {
                    const r = e1.apply(n, arguments);
                    return `[${38 + t};2;${r[0]};${r[1]};${r[2]}m`;
                };
            function assembleStyles() {
                const e1 = new Map;
                const t = {
                    modifier: {
                        reset: [
                            0,
                            0
                        ],
                        bold: [
                            1,
                            22
                        ],
                        dim: [
                            2,
                            22
                        ],
                        italic: [
                            3,
                            23
                        ],
                        underline: [
                            4,
                            24
                        ],
                        inverse: [
                            7,
                            27
                        ],
                        hidden: [
                            8,
                            28
                        ],
                        strikethrough: [
                            9,
                            29
                        ]
                    },
                    color: {
                        black: [
                            30,
                            39
                        ],
                        red: [
                            31,
                            39
                        ],
                        green: [
                            32,
                            39
                        ],
                        yellow: [
                            33,
                            39
                        ],
                        blue: [
                            34,
                            39
                        ],
                        magenta: [
                            35,
                            39
                        ],
                        cyan: [
                            36,
                            39
                        ],
                        white: [
                            37,
                            39
                        ],
                        gray: [
                            90,
                            39
                        ],
                        redBright: [
                            91,
                            39
                        ],
                        greenBright: [
                            92,
                            39
                        ],
                        yellowBright: [
                            93,
                            39
                        ],
                        blueBright: [
                            94,
                            39
                        ],
                        magentaBright: [
                            95,
                            39
                        ],
                        cyanBright: [
                            96,
                            39
                        ],
                        whiteBright: [
                            97,
                            39
                        ]
                    },
                    bgColor: {
                        bgBlack: [
                            40,
                            49
                        ],
                        bgRed: [
                            41,
                            49
                        ],
                        bgGreen: [
                            42,
                            49
                        ],
                        bgYellow: [
                            43,
                            49
                        ],
                        bgBlue: [
                            44,
                            49
                        ],
                        bgMagenta: [
                            45,
                            49
                        ],
                        bgCyan: [
                            46,
                            49
                        ],
                        bgWhite: [
                            47,
                            49
                        ],
                        bgBlackBright: [
                            100,
                            49
                        ],
                        bgRedBright: [
                            101,
                            49
                        ],
                        bgGreenBright: [
                            102,
                            49
                        ],
                        bgYellowBright: [
                            103,
                            49
                        ],
                        bgBlueBright: [
                            104,
                            49
                        ],
                        bgMagentaBright: [
                            105,
                            49
                        ],
                        bgCyanBright: [
                            106,
                            49
                        ],
                        bgWhiteBright: [
                            107,
                            49
                        ]
                    }
                };
                t.color.grey = t.color.gray;
                for (const r of Object.keys(t)){
                    const n = t[r];
                    for (const r of Object.keys(n)){
                        const s = n[r];
                        t[r] = {
                            open: `[${s[0]}m`,
                            close: `[${s[1]}m`
                        };
                        n[r] = t[r];
                        e1.set(s[0], s[1]);
                    }
                    Object.defineProperty(t, r, {
                        value: n,
                        enumerable: false
                    });
                    Object.defineProperty(t, "codes", {
                        value: e1,
                        enumerable: false
                    });
                }
                const ansi2ansi = (e1)=>e1;
                const rgb2rgb = (e1, t, r)=>[
                        e1,
                        t,
                        r
                    ];
                t.color.close = "[39m";
                t.bgColor.close = "[49m";
                t.color.ansi = {
                    ansi: wrapAnsi16(ansi2ansi, 0)
                };
                t.color.ansi256 = {
                    ansi256: wrapAnsi256(ansi2ansi, 0)
                };
                t.color.ansi16m = {
                    rgb: wrapAnsi16m(rgb2rgb, 0)
                };
                t.bgColor.ansi = {
                    ansi: wrapAnsi16(ansi2ansi, 10)
                };
                t.bgColor.ansi256 = {
                    ansi256: wrapAnsi256(ansi2ansi, 10)
                };
                t.bgColor.ansi16m = {
                    rgb: wrapAnsi16m(rgb2rgb, 10)
                };
                for (let e1 of Object.keys(n)){
                    if (typeof n[e1] !== "object") {
                        continue;
                    }
                    const r = n[e1];
                    if (e1 === "ansi16") {
                        e1 = "ansi";
                    }
                    if ("ansi16" in r) {
                        t.color.ansi[e1] = wrapAnsi16(r.ansi16, 0);
                        t.bgColor.ansi[e1] = wrapAnsi16(r.ansi16, 10);
                    }
                    if ("ansi256" in r) {
                        t.color.ansi256[e1] = wrapAnsi256(r.ansi256, 0);
                        t.bgColor.ansi256[e1] = wrapAnsi256(r.ansi256, 10);
                    }
                    if ("rgb" in r) {
                        t.color.ansi16m[e1] = wrapAnsi16m(r.rgb, 0);
                        t.bgColor.ansi16m[e1] = wrapAnsi16m(r.rgb, 10);
                    }
                }
                return t;
            }
            Object.defineProperty(e1, "exports", {
                enumerable: true,
                get: assembleStyles
            });
        },
        6148: (e1, t, r)=>{
            "use strict";
            const n = r(7379);
            const s = r(8535);
            const i = r(7220).stdout;
            const a = r(5299);
            const o = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
            const l = [
                "ansi",
                "ansi",
                "ansi256",
                "ansi16m"
            ];
            const c = new Set([
                "gray"
            ]);
            const u = Object.create(null);
            function applyOptions(e1, t) {
                t = t || {};
                const r = i ? i.level : 0;
                e1.level = t.level === undefined ? r : t.level;
                e1.enabled = "enabled" in t ? t.enabled : e1.level > 0;
            }
            function Chalk(e1) {
                if (!this || !(this instanceof Chalk) || this.template) {
                    const t = {};
                    applyOptions(t, e1);
                    t.template = function() {
                        const e1 = [].slice.call(arguments);
                        return chalkTag.apply(null, [
                            t.template
                        ].concat(e1));
                    };
                    Object.setPrototypeOf(t, Chalk.prototype);
                    Object.setPrototypeOf(t.template, t);
                    t.template.constructor = Chalk;
                    return t.template;
                }
                applyOptions(this, e1);
            }
            if (o) {
                s.blue.open = "[94m";
            }
            for (const e1 of Object.keys(s)){
                s[e1].closeRe = new RegExp(n(s[e1].close), "g");
                u[e1] = {
                    get () {
                        const t = s[e1];
                        return build.call(this, this._styles ? this._styles.concat(t) : [
                            t
                        ], this._empty, e1);
                    }
                };
            }
            u.visible = {
                get () {
                    return build.call(this, this._styles || [], true, "visible");
                }
            };
            s.color.closeRe = new RegExp(n(s.color.close), "g");
            for (const e1 of Object.keys(s.color.ansi)){
                if (c.has(e1)) {
                    continue;
                }
                u[e1] = {
                    get () {
                        const t = this.level;
                        return function() {
                            const r = s.color[l[t]][e1].apply(null, arguments);
                            const n = {
                                open: r,
                                close: s.color.close,
                                closeRe: s.color.closeRe
                            };
                            return build.call(this, this._styles ? this._styles.concat(n) : [
                                n
                            ], this._empty, e1);
                        };
                    }
                };
            }
            s.bgColor.closeRe = new RegExp(n(s.bgColor.close), "g");
            for (const e1 of Object.keys(s.bgColor.ansi)){
                if (c.has(e1)) {
                    continue;
                }
                const t = "bg" + e1[0].toUpperCase() + e1.slice(1);
                u[t] = {
                    get () {
                        const t = this.level;
                        return function() {
                            const r = s.bgColor[l[t]][e1].apply(null, arguments);
                            const n = {
                                open: r,
                                close: s.bgColor.close,
                                closeRe: s.bgColor.closeRe
                            };
                            return build.call(this, this._styles ? this._styles.concat(n) : [
                                n
                            ], this._empty, e1);
                        };
                    }
                };
            }
            const p = Object.defineProperties(()=>{}, u);
            function build(e1, t, r) {
                const builder = function() {
                    return applyStyle.apply(builder, arguments);
                };
                builder._styles = e1;
                builder._empty = t;
                const n = this;
                Object.defineProperty(builder, "level", {
                    enumerable: true,
                    get () {
                        return n.level;
                    },
                    set (e1) {
                        n.level = e1;
                    }
                });
                Object.defineProperty(builder, "enabled", {
                    enumerable: true,
                    get () {
                        return n.enabled;
                    },
                    set (e1) {
                        n.enabled = e1;
                    }
                });
                builder.hasGrey = this.hasGrey || r === "gray" || r === "grey";
                builder.__proto__ = p;
                return builder;
            }
            function applyStyle() {
                const e1 = arguments;
                const t = e1.length;
                let r = String(arguments[0]);
                if (t === 0) {
                    return "";
                }
                if (t > 1) {
                    for(let n = 1; n < t; n++){
                        r += " " + e1[n];
                    }
                }
                if (!this.enabled || this.level <= 0 || !r) {
                    return this._empty ? "" : r;
                }
                const n = s.dim.open;
                if (o && this.hasGrey) {
                    s.dim.open = "";
                }
                for (const e1 of this._styles.slice().reverse()){
                    r = e1.open + r.replace(e1.closeRe, e1.open) + e1.close;
                    r = r.replace(/\r?\n/g, `${e1.close}$&${e1.open}`);
                }
                s.dim.open = n;
                return r;
            }
            function chalkTag(e1, t) {
                if (!Array.isArray(t)) {
                    return [].slice.call(arguments, 1).join(" ");
                }
                const r = [].slice.call(arguments, 2);
                const n = [
                    t.raw[0]
                ];
                for(let e1 = 1; e1 < t.length; e1++){
                    n.push(String(r[e1 - 1]).replace(/[{}\\]/g, "\\$&"));
                    n.push(String(t.raw[e1]));
                }
                return a(e1, n.join(""));
            }
            Object.defineProperties(Chalk.prototype, u);
            e1.exports = Chalk();
            e1.exports.supportsColor = i;
            e1.exports["default"] = e1.exports;
        },
        5299: (e1)=>{
            "use strict";
            const t = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
            const r = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
            const n = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
            const s = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
            const i = new Map([
                [
                    "n",
                    "\n"
                ],
                [
                    "r",
                    "\r"
                ],
                [
                    "t",
                    "\t"
                ],
                [
                    "b",
                    "\b"
                ],
                [
                    "f",
                    "\f"
                ],
                [
                    "v",
                    "\v"
                ],
                [
                    "0",
                    "\0"
                ],
                [
                    "\\",
                    "\\"
                ],
                [
                    "e",
                    ""
                ],
                [
                    "a",
                    ""
                ]
            ]);
            function unescape1(e1) {
                if (e1[0] === "u" && e1.length === 5 || e1[0] === "x" && e1.length === 3) {
                    return String.fromCharCode(parseInt(e1.slice(1), 16));
                }
                return i.get(e1) || e1;
            }
            function parseArguments(e1, t) {
                const r = [];
                const i = t.trim().split(/\s*,\s*/g);
                let a;
                for (const t of i){
                    if (!isNaN(t)) {
                        r.push(Number(t));
                    } else if (a = t.match(n)) {
                        r.push(a[2].replace(s, (e1, t, r)=>t ? unescape1(t) : r));
                    } else {
                        throw new Error(`Invalid Chalk template style argument: ${t} (in style '${e1}')`);
                    }
                }
                return r;
            }
            function parseStyle(e1) {
                r.lastIndex = 0;
                const t = [];
                let n;
                while((n = r.exec(e1)) !== null){
                    const e1 = n[1];
                    if (n[2]) {
                        const r = parseArguments(e1, n[2]);
                        t.push([
                            e1
                        ].concat(r));
                    } else {
                        t.push([
                            e1
                        ]);
                    }
                }
                return t;
            }
            function buildStyle(e1, t) {
                const r = {};
                for (const e1 of t){
                    for (const t of e1.styles){
                        r[t[0]] = e1.inverse ? null : t.slice(1);
                    }
                }
                let n = e1;
                for (const e1 of Object.keys(r)){
                    if (Array.isArray(r[e1])) {
                        if (!(e1 in n)) {
                            throw new Error(`Unknown Chalk style: ${e1}`);
                        }
                        if (r[e1].length > 0) {
                            n = n[e1].apply(n, r[e1]);
                        } else {
                            n = n[e1];
                        }
                    }
                }
                return n;
            }
            e1.exports = (e1, r)=>{
                const n = [];
                const s = [];
                let i = [];
                r.replace(t, (t, r, a, o, l, c)=>{
                    if (r) {
                        i.push(unescape1(r));
                    } else if (o) {
                        const t = i.join("");
                        i = [];
                        s.push(n.length === 0 ? t : buildStyle(e1, n)(t));
                        n.push({
                            inverse: a,
                            styles: parseStyle(o)
                        });
                    } else if (l) {
                        if (n.length === 0) {
                            throw new Error("Found extraneous } in Chalk template literal");
                        }
                        s.push(buildStyle(e1, n)(i.join("")));
                        i = [];
                        n.pop();
                    } else {
                        i.push(c);
                    }
                });
                s.push(i.join(""));
                if (n.length > 0) {
                    const e1 = `Chalk template literal is missing ${n.length} closing bracket${n.length === 1 ? "" : "s"} (\`}\`)`;
                    throw new Error(e1);
                }
                return s.join("");
            };
        },
        4117: (e1, t, r)=>{
            var n = r(2251);
            var s = {};
            for(var i in n){
                if (n.hasOwnProperty(i)) {
                    s[n[i]] = i;
                }
            }
            var a = e1.exports = {
                rgb: {
                    channels: 3,
                    labels: "rgb"
                },
                hsl: {
                    channels: 3,
                    labels: "hsl"
                },
                hsv: {
                    channels: 3,
                    labels: "hsv"
                },
                hwb: {
                    channels: 3,
                    labels: "hwb"
                },
                cmyk: {
                    channels: 4,
                    labels: "cmyk"
                },
                xyz: {
                    channels: 3,
                    labels: "xyz"
                },
                lab: {
                    channels: 3,
                    labels: "lab"
                },
                lch: {
                    channels: 3,
                    labels: "lch"
                },
                hex: {
                    channels: 1,
                    labels: [
                        "hex"
                    ]
                },
                keyword: {
                    channels: 1,
                    labels: [
                        "keyword"
                    ]
                },
                ansi16: {
                    channels: 1,
                    labels: [
                        "ansi16"
                    ]
                },
                ansi256: {
                    channels: 1,
                    labels: [
                        "ansi256"
                    ]
                },
                hcg: {
                    channels: 3,
                    labels: [
                        "h",
                        "c",
                        "g"
                    ]
                },
                apple: {
                    channels: 3,
                    labels: [
                        "r16",
                        "g16",
                        "b16"
                    ]
                },
                gray: {
                    channels: 1,
                    labels: [
                        "gray"
                    ]
                }
            };
            for(var o in a){
                if (a.hasOwnProperty(o)) {
                    if (!("channels" in a[o])) {
                        throw new Error("missing channels property: " + o);
                    }
                    if (!("labels" in a[o])) {
                        throw new Error("missing channel labels property: " + o);
                    }
                    if (a[o].labels.length !== a[o].channels) {
                        throw new Error("channel and label counts mismatch: " + o);
                    }
                    var l = a[o].channels;
                    var c = a[o].labels;
                    delete a[o].channels;
                    delete a[o].labels;
                    Object.defineProperty(a[o], "channels", {
                        value: l
                    });
                    Object.defineProperty(a[o], "labels", {
                        value: c
                    });
                }
            }
            a.rgb.hsl = function(e1) {
                var t = e1[0] / 255;
                var r = e1[1] / 255;
                var n = e1[2] / 255;
                var s = Math.min(t, r, n);
                var i = Math.max(t, r, n);
                var a = i - s;
                var o;
                var l;
                var c;
                if (i === s) {
                    o = 0;
                } else if (t === i) {
                    o = (r - n) / a;
                } else if (r === i) {
                    o = 2 + (n - t) / a;
                } else if (n === i) {
                    o = 4 + (t - r) / a;
                }
                o = Math.min(o * 60, 360);
                if (o < 0) {
                    o += 360;
                }
                c = (s + i) / 2;
                if (i === s) {
                    l = 0;
                } else if (c <= .5) {
                    l = a / (i + s);
                } else {
                    l = a / (2 - i - s);
                }
                return [
                    o,
                    l * 100,
                    c * 100
                ];
            };
            a.rgb.hsv = function(e1) {
                var t;
                var r;
                var n;
                var s;
                var i;
                var a = e1[0] / 255;
                var o = e1[1] / 255;
                var l = e1[2] / 255;
                var c = Math.max(a, o, l);
                var u = c - Math.min(a, o, l);
                var diffc = function(e1) {
                    return (c - e1) / 6 / u + 1 / 2;
                };
                if (u === 0) {
                    s = i = 0;
                } else {
                    i = u / c;
                    t = diffc(a);
                    r = diffc(o);
                    n = diffc(l);
                    if (a === c) {
                        s = n - r;
                    } else if (o === c) {
                        s = 1 / 3 + t - n;
                    } else if (l === c) {
                        s = 2 / 3 + r - t;
                    }
                    if (s < 0) {
                        s += 1;
                    } else if (s > 1) {
                        s -= 1;
                    }
                }
                return [
                    s * 360,
                    i * 100,
                    c * 100
                ];
            };
            a.rgb.hwb = function(e1) {
                var t = e1[0];
                var r = e1[1];
                var n = e1[2];
                var s = a.rgb.hsl(e1)[0];
                var i = 1 / 255 * Math.min(t, Math.min(r, n));
                n = 1 - 1 / 255 * Math.max(t, Math.max(r, n));
                return [
                    s,
                    i * 100,
                    n * 100
                ];
            };
            a.rgb.cmyk = function(e1) {
                var t = e1[0] / 255;
                var r = e1[1] / 255;
                var n = e1[2] / 255;
                var s;
                var i;
                var a;
                var o;
                o = Math.min(1 - t, 1 - r, 1 - n);
                s = (1 - t - o) / (1 - o) || 0;
                i = (1 - r - o) / (1 - o) || 0;
                a = (1 - n - o) / (1 - o) || 0;
                return [
                    s * 100,
                    i * 100,
                    a * 100,
                    o * 100
                ];
            };
            function comparativeDistance(e1, t) {
                return Math.pow(e1[0] - t[0], 2) + Math.pow(e1[1] - t[1], 2) + Math.pow(e1[2] - t[2], 2);
            }
            a.rgb.keyword = function(e1) {
                var t = s[e1];
                if (t) {
                    return t;
                }
                var r = Infinity;
                var i;
                for(var a in n){
                    if (n.hasOwnProperty(a)) {
                        var o = n[a];
                        var l = comparativeDistance(e1, o);
                        if (l < r) {
                            r = l;
                            i = a;
                        }
                    }
                }
                return i;
            };
            a.keyword.rgb = function(e1) {
                return n[e1];
            };
            a.rgb.xyz = function(e1) {
                var t = e1[0] / 255;
                var r = e1[1] / 255;
                var n = e1[2] / 255;
                t = t > .04045 ? Math.pow((t + .055) / 1.055, 2.4) : t / 12.92;
                r = r > .04045 ? Math.pow((r + .055) / 1.055, 2.4) : r / 12.92;
                n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92;
                var s = t * .4124 + r * .3576 + n * .1805;
                var i = t * .2126 + r * .7152 + n * .0722;
                var a = t * .0193 + r * .1192 + n * .9505;
                return [
                    s * 100,
                    i * 100,
                    a * 100
                ];
            };
            a.rgb.lab = function(e1) {
                var t = a.rgb.xyz(e1);
                var r = t[0];
                var n = t[1];
                var s = t[2];
                var i;
                var o;
                var l;
                r /= 95.047;
                n /= 100;
                s /= 108.883;
                r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116;
                n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116;
                s = s > .008856 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116;
                i = 116 * n - 16;
                o = 500 * (r - n);
                l = 200 * (n - s);
                return [
                    i,
                    o,
                    l
                ];
            };
            a.hsl.rgb = function(e1) {
                var t = e1[0] / 360;
                var r = e1[1] / 100;
                var n = e1[2] / 100;
                var s;
                var i;
                var a;
                var o;
                var l;
                if (r === 0) {
                    l = n * 255;
                    return [
                        l,
                        l,
                        l
                    ];
                }
                if (n < .5) {
                    i = n * (1 + r);
                } else {
                    i = n + r - n * r;
                }
                s = 2 * n - i;
                o = [
                    0,
                    0,
                    0
                ];
                for(var c = 0; c < 3; c++){
                    a = t + 1 / 3 * -(c - 1);
                    if (a < 0) {
                        a++;
                    }
                    if (a > 1) {
                        a--;
                    }
                    if (6 * a < 1) {
                        l = s + (i - s) * 6 * a;
                    } else if (2 * a < 1) {
                        l = i;
                    } else if (3 * a < 2) {
                        l = s + (i - s) * (2 / 3 - a) * 6;
                    } else {
                        l = s;
                    }
                    o[c] = l * 255;
                }
                return o;
            };
            a.hsl.hsv = function(e1) {
                var t = e1[0];
                var r = e1[1] / 100;
                var n = e1[2] / 100;
                var s = r;
                var i = Math.max(n, .01);
                var a;
                var o;
                n *= 2;
                r *= n <= 1 ? n : 2 - n;
                s *= i <= 1 ? i : 2 - i;
                o = (n + r) / 2;
                a = n === 0 ? 2 * s / (i + s) : 2 * r / (n + r);
                return [
                    t,
                    a * 100,
                    o * 100
                ];
            };
            a.hsv.rgb = function(e1) {
                var t = e1[0] / 60;
                var r = e1[1] / 100;
                var n = e1[2] / 100;
                var s = Math.floor(t) % 6;
                var i = t - Math.floor(t);
                var a = 255 * n * (1 - r);
                var o = 255 * n * (1 - r * i);
                var l = 255 * n * (1 - r * (1 - i));
                n *= 255;
                switch(s){
                    case 0:
                        return [
                            n,
                            l,
                            a
                        ];
                    case 1:
                        return [
                            o,
                            n,
                            a
                        ];
                    case 2:
                        return [
                            a,
                            n,
                            l
                        ];
                    case 3:
                        return [
                            a,
                            o,
                            n
                        ];
                    case 4:
                        return [
                            l,
                            a,
                            n
                        ];
                    case 5:
                        return [
                            n,
                            a,
                            o
                        ];
                }
            };
            a.hsv.hsl = function(e1) {
                var t = e1[0];
                var r = e1[1] / 100;
                var n = e1[2] / 100;
                var s = Math.max(n, .01);
                var i;
                var a;
                var o;
                o = (2 - r) * n;
                i = (2 - r) * s;
                a = r * s;
                a /= i <= 1 ? i : 2 - i;
                a = a || 0;
                o /= 2;
                return [
                    t,
                    a * 100,
                    o * 100
                ];
            };
            a.hwb.rgb = function(e1) {
                var t = e1[0] / 360;
                var r = e1[1] / 100;
                var n = e1[2] / 100;
                var s = r + n;
                var i;
                var a;
                var o;
                var l;
                if (s > 1) {
                    r /= s;
                    n /= s;
                }
                i = Math.floor(6 * t);
                a = 1 - n;
                o = 6 * t - i;
                if ((i & 1) !== 0) {
                    o = 1 - o;
                }
                l = r + o * (a - r);
                var c;
                var u;
                var p;
                switch(i){
                    default:
                    case 6:
                    case 0:
                        c = a;
                        u = l;
                        p = r;
                        break;
                    case 1:
                        c = l;
                        u = a;
                        p = r;
                        break;
                    case 2:
                        c = r;
                        u = a;
                        p = l;
                        break;
                    case 3:
                        c = r;
                        u = l;
                        p = a;
                        break;
                    case 4:
                        c = l;
                        u = r;
                        p = a;
                        break;
                    case 5:
                        c = a;
                        u = r;
                        p = l;
                        break;
                }
                return [
                    c * 255,
                    u * 255,
                    p * 255
                ];
            };
            a.cmyk.rgb = function(e1) {
                var t = e1[0] / 100;
                var r = e1[1] / 100;
                var n = e1[2] / 100;
                var s = e1[3] / 100;
                var i;
                var a;
                var o;
                i = 1 - Math.min(1, t * (1 - s) + s);
                a = 1 - Math.min(1, r * (1 - s) + s);
                o = 1 - Math.min(1, n * (1 - s) + s);
                return [
                    i * 255,
                    a * 255,
                    o * 255
                ];
            };
            a.xyz.rgb = function(e1) {
                var t = e1[0] / 100;
                var r = e1[1] / 100;
                var n = e1[2] / 100;
                var s;
                var i;
                var a;
                s = t * 3.2406 + r * -1.5372 + n * -.4986;
                i = t * -.9689 + r * 1.8758 + n * .0415;
                a = t * .0557 + r * -.204 + n * 1.057;
                s = s > .0031308 ? 1.055 * Math.pow(s, 1 / 2.4) - .055 : s * 12.92;
                i = i > .0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - .055 : i * 12.92;
                a = a > .0031308 ? 1.055 * Math.pow(a, 1 / 2.4) - .055 : a * 12.92;
                s = Math.min(Math.max(0, s), 1);
                i = Math.min(Math.max(0, i), 1);
                a = Math.min(Math.max(0, a), 1);
                return [
                    s * 255,
                    i * 255,
                    a * 255
                ];
            };
            a.xyz.lab = function(e1) {
                var t = e1[0];
                var r = e1[1];
                var n = e1[2];
                var s;
                var i;
                var a;
                t /= 95.047;
                r /= 100;
                n /= 108.883;
                t = t > .008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116;
                r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116;
                n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116;
                s = 116 * r - 16;
                i = 500 * (t - r);
                a = 200 * (r - n);
                return [
                    s,
                    i,
                    a
                ];
            };
            a.lab.xyz = function(e1) {
                var t = e1[0];
                var r = e1[1];
                var n = e1[2];
                var s;
                var i;
                var a;
                i = (t + 16) / 116;
                s = r / 500 + i;
                a = i - n / 200;
                var o = Math.pow(i, 3);
                var l = Math.pow(s, 3);
                var c = Math.pow(a, 3);
                i = o > .008856 ? o : (i - 16 / 116) / 7.787;
                s = l > .008856 ? l : (s - 16 / 116) / 7.787;
                a = c > .008856 ? c : (a - 16 / 116) / 7.787;
                s *= 95.047;
                i *= 100;
                a *= 108.883;
                return [
                    s,
                    i,
                    a
                ];
            };
            a.lab.lch = function(e1) {
                var t = e1[0];
                var r = e1[1];
                var n = e1[2];
                var s;
                var i;
                var a;
                s = Math.atan2(n, r);
                i = s * 360 / 2 / Math.PI;
                if (i < 0) {
                    i += 360;
                }
                a = Math.sqrt(r * r + n * n);
                return [
                    t,
                    a,
                    i
                ];
            };
            a.lch.lab = function(e1) {
                var t = e1[0];
                var r = e1[1];
                var n = e1[2];
                var s;
                var i;
                var a;
                a = n / 360 * 2 * Math.PI;
                s = r * Math.cos(a);
                i = r * Math.sin(a);
                return [
                    t,
                    s,
                    i
                ];
            };
            a.rgb.ansi16 = function(e1) {
                var t = e1[0];
                var r = e1[1];
                var n = e1[2];
                var s = 1 in arguments ? arguments[1] : a.rgb.hsv(e1)[2];
                s = Math.round(s / 50);
                if (s === 0) {
                    return 30;
                }
                var i = 30 + (Math.round(n / 255) << 2 | Math.round(r / 255) << 1 | Math.round(t / 255));
                if (s === 2) {
                    i += 60;
                }
                return i;
            };
            a.hsv.ansi16 = function(e1) {
                return a.rgb.ansi16(a.hsv.rgb(e1), e1[2]);
            };
            a.rgb.ansi256 = function(e1) {
                var t = e1[0];
                var r = e1[1];
                var n = e1[2];
                if (t === r && r === n) {
                    if (t < 8) {
                        return 16;
                    }
                    if (t > 248) {
                        return 231;
                    }
                    return Math.round((t - 8) / 247 * 24) + 232;
                }
                var s = 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(n / 255 * 5);
                return s;
            };
            a.ansi16.rgb = function(e1) {
                var t = e1 % 10;
                if (t === 0 || t === 7) {
                    if (e1 > 50) {
                        t += 3.5;
                    }
                    t = t / 10.5 * 255;
                    return [
                        t,
                        t,
                        t
                    ];
                }
                var r = (~~(e1 > 50) + 1) * .5;
                var n = (t & 1) * r * 255;
                var s = (t >> 1 & 1) * r * 255;
                var i = (t >> 2 & 1) * r * 255;
                return [
                    n,
                    s,
                    i
                ];
            };
            a.ansi256.rgb = function(e1) {
                if (e1 >= 232) {
                    var t = (e1 - 232) * 10 + 8;
                    return [
                        t,
                        t,
                        t
                    ];
                }
                e1 -= 16;
                var r;
                var n = Math.floor(e1 / 36) / 5 * 255;
                var s = Math.floor((r = e1 % 36) / 6) / 5 * 255;
                var i = r % 6 / 5 * 255;
                return [
                    n,
                    s,
                    i
                ];
            };
            a.rgb.hex = function(e1) {
                var t = ((Math.round(e1[0]) & 255) << 16) + ((Math.round(e1[1]) & 255) << 8) + (Math.round(e1[2]) & 255);
                var r = t.toString(16).toUpperCase();
                return "000000".substring(r.length) + r;
            };
            a.hex.rgb = function(e1) {
                var t = e1.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
                if (!t) {
                    return [
                        0,
                        0,
                        0
                    ];
                }
                var r = t[0];
                if (t[0].length === 3) {
                    r = r.split("").map(function(e1) {
                        return e1 + e1;
                    }).join("");
                }
                var n = parseInt(r, 16);
                var s = n >> 16 & 255;
                var i = n >> 8 & 255;
                var a = n & 255;
                return [
                    s,
                    i,
                    a
                ];
            };
            a.rgb.hcg = function(e1) {
                var t = e1[0] / 255;
                var r = e1[1] / 255;
                var n = e1[2] / 255;
                var s = Math.max(Math.max(t, r), n);
                var i = Math.min(Math.min(t, r), n);
                var a = s - i;
                var o;
                var l;
                if (a < 1) {
                    o = i / (1 - a);
                } else {
                    o = 0;
                }
                if (a <= 0) {
                    l = 0;
                } else if (s === t) {
                    l = (r - n) / a % 6;
                } else if (s === r) {
                    l = 2 + (n - t) / a;
                } else {
                    l = 4 + (t - r) / a + 4;
                }
                l /= 6;
                l %= 1;
                return [
                    l * 360,
                    a * 100,
                    o * 100
                ];
            };
            a.hsl.hcg = function(e1) {
                var t = e1[1] / 100;
                var r = e1[2] / 100;
                var n = 1;
                var s = 0;
                if (r < .5) {
                    n = 2 * t * r;
                } else {
                    n = 2 * t * (1 - r);
                }
                if (n < 1) {
                    s = (r - .5 * n) / (1 - n);
                }
                return [
                    e1[0],
                    n * 100,
                    s * 100
                ];
            };
            a.hsv.hcg = function(e1) {
                var t = e1[1] / 100;
                var r = e1[2] / 100;
                var n = t * r;
                var s = 0;
                if (n < 1) {
                    s = (r - n) / (1 - n);
                }
                return [
                    e1[0],
                    n * 100,
                    s * 100
                ];
            };
            a.hcg.rgb = function(e1) {
                var t = e1[0] / 360;
                var r = e1[1] / 100;
                var n = e1[2] / 100;
                if (r === 0) {
                    return [
                        n * 255,
                        n * 255,
                        n * 255
                    ];
                }
                var s = [
                    0,
                    0,
                    0
                ];
                var i = t % 1 * 6;
                var a = i % 1;
                var o = 1 - a;
                var l = 0;
                switch(Math.floor(i)){
                    case 0:
                        s[0] = 1;
                        s[1] = a;
                        s[2] = 0;
                        break;
                    case 1:
                        s[0] = o;
                        s[1] = 1;
                        s[2] = 0;
                        break;
                    case 2:
                        s[0] = 0;
                        s[1] = 1;
                        s[2] = a;
                        break;
                    case 3:
                        s[0] = 0;
                        s[1] = o;
                        s[2] = 1;
                        break;
                    case 4:
                        s[0] = a;
                        s[1] = 0;
                        s[2] = 1;
                        break;
                    default:
                        s[0] = 1;
                        s[1] = 0;
                        s[2] = o;
                }
                l = (1 - r) * n;
                return [
                    (r * s[0] + l) * 255,
                    (r * s[1] + l) * 255,
                    (r * s[2] + l) * 255
                ];
            };
            a.hcg.hsv = function(e1) {
                var t = e1[1] / 100;
                var r = e1[2] / 100;
                var n = t + r * (1 - t);
                var s = 0;
                if (n > 0) {
                    s = t / n;
                }
                return [
                    e1[0],
                    s * 100,
                    n * 100
                ];
            };
            a.hcg.hsl = function(e1) {
                var t = e1[1] / 100;
                var r = e1[2] / 100;
                var n = r * (1 - t) + .5 * t;
                var s = 0;
                if (n > 0 && n < .5) {
                    s = t / (2 * n);
                } else if (n >= .5 && n < 1) {
                    s = t / (2 * (1 - n));
                }
                return [
                    e1[0],
                    s * 100,
                    n * 100
                ];
            };
            a.hcg.hwb = function(e1) {
                var t = e1[1] / 100;
                var r = e1[2] / 100;
                var n = t + r * (1 - t);
                return [
                    e1[0],
                    (n - t) * 100,
                    (1 - n) * 100
                ];
            };
            a.hwb.hcg = function(e1) {
                var t = e1[1] / 100;
                var r = e1[2] / 100;
                var n = 1 - r;
                var s = n - t;
                var i = 0;
                if (s < 1) {
                    i = (n - s) / (1 - s);
                }
                return [
                    e1[0],
                    s * 100,
                    i * 100
                ];
            };
            a.apple.rgb = function(e1) {
                return [
                    e1[0] / 65535 * 255,
                    e1[1] / 65535 * 255,
                    e1[2] / 65535 * 255
                ];
            };
            a.rgb.apple = function(e1) {
                return [
                    e1[0] / 255 * 65535,
                    e1[1] / 255 * 65535,
                    e1[2] / 255 * 65535
                ];
            };
            a.gray.rgb = function(e1) {
                return [
                    e1[0] / 100 * 255,
                    e1[0] / 100 * 255,
                    e1[0] / 100 * 255
                ];
            };
            a.gray.hsl = a.gray.hsv = function(e1) {
                return [
                    0,
                    0,
                    e1[0]
                ];
            };
            a.gray.hwb = function(e1) {
                return [
                    0,
                    100,
                    e1[0]
                ];
            };
            a.gray.cmyk = function(e1) {
                return [
                    0,
                    0,
                    0,
                    e1[0]
                ];
            };
            a.gray.lab = function(e1) {
                return [
                    e1[0],
                    0,
                    0
                ];
            };
            a.gray.hex = function(e1) {
                var t = Math.round(e1[0] / 100 * 255) & 255;
                var r = (t << 16) + (t << 8) + t;
                var n = r.toString(16).toUpperCase();
                return "000000".substring(n.length) + n;
            };
            a.rgb.gray = function(e1) {
                var t = (e1[0] + e1[1] + e1[2]) / 3;
                return [
                    t / 255 * 100
                ];
            };
        },
        9054: (e1, t, r)=>{
            var n = r(4117);
            var s = r(6528);
            var i = {};
            var a = Object.keys(n);
            function wrapRaw(e1) {
                var wrappedFn = function(t) {
                    if (t === undefined || t === null) {
                        return t;
                    }
                    if (arguments.length > 1) {
                        t = Array.prototype.slice.call(arguments);
                    }
                    return e1(t);
                };
                if ("conversion" in e1) {
                    wrappedFn.conversion = e1.conversion;
                }
                return wrappedFn;
            }
            function wrapRounded(e1) {
                var wrappedFn = function(t) {
                    if (t === undefined || t === null) {
                        return t;
                    }
                    if (arguments.length > 1) {
                        t = Array.prototype.slice.call(arguments);
                    }
                    var r = e1(t);
                    if (typeof r === "object") {
                        for(var n = r.length, s = 0; s < n; s++){
                            r[s] = Math.round(r[s]);
                        }
                    }
                    return r;
                };
                if ("conversion" in e1) {
                    wrappedFn.conversion = e1.conversion;
                }
                return wrappedFn;
            }
            a.forEach(function(e1) {
                i[e1] = {};
                Object.defineProperty(i[e1], "channels", {
                    value: n[e1].channels
                });
                Object.defineProperty(i[e1], "labels", {
                    value: n[e1].labels
                });
                var t = s(e1);
                var r = Object.keys(t);
                r.forEach(function(r) {
                    var n = t[r];
                    i[e1][r] = wrapRounded(n);
                    i[e1][r].raw = wrapRaw(n);
                });
            });
            e1.exports = i;
        },
        6528: (e1, t, r)=>{
            var n = r(4117);
            function buildGraph() {
                var e1 = {};
                var t = Object.keys(n);
                for(var r = t.length, s = 0; s < r; s++){
                    e1[t[s]] = {
                        distance: -1,
                        parent: null
                    };
                }
                return e1;
            }
            function deriveBFS(e1) {
                var t = buildGraph();
                var r = [
                    e1
                ];
                t[e1].distance = 0;
                while(r.length){
                    var s = r.pop();
                    var i = Object.keys(n[s]);
                    for(var a = i.length, o = 0; o < a; o++){
                        var l = i[o];
                        var c = t[l];
                        if (c.distance === -1) {
                            c.distance = t[s].distance + 1;
                            c.parent = s;
                            r.unshift(l);
                        }
                    }
                }
                return t;
            }
            function link(e1, t) {
                return function(r) {
                    return t(e1(r));
                };
            }
            function wrapConversion(e1, t) {
                var r = [
                    t[e1].parent,
                    e1
                ];
                var s = n[t[e1].parent][e1];
                var i = t[e1].parent;
                while(t[i].parent){
                    r.unshift(t[i].parent);
                    s = link(n[t[i].parent][i], s);
                    i = t[i].parent;
                }
                s.conversion = r;
                return s;
            }
            e1.exports = function(e1) {
                var t = deriveBFS(e1);
                var r = {};
                var n = Object.keys(t);
                for(var s = n.length, i = 0; i < s; i++){
                    var a = n[i];
                    var o = t[a];
                    if (o.parent === null) {
                        continue;
                    }
                    r[a] = wrapConversion(a, t);
                }
                return r;
            };
        },
        2251: (e1)=>{
            "use strict";
            e1.exports = {
                aliceblue: [
                    240,
                    248,
                    255
                ],
                antiquewhite: [
                    250,
                    235,
                    215
                ],
                aqua: [
                    0,
                    255,
                    255
                ],
                aquamarine: [
                    127,
                    255,
                    212
                ],
                azure: [
                    240,
                    255,
                    255
                ],
                beige: [
                    245,
                    245,
                    220
                ],
                bisque: [
                    255,
                    228,
                    196
                ],
                black: [
                    0,
                    0,
                    0
                ],
                blanchedalmond: [
                    255,
                    235,
                    205
                ],
                blue: [
                    0,
                    0,
                    255
                ],
                blueviolet: [
                    138,
                    43,
                    226
                ],
                brown: [
                    165,
                    42,
                    42
                ],
                burlywood: [
                    222,
                    184,
                    135
                ],
                cadetblue: [
                    95,
                    158,
                    160
                ],
                chartreuse: [
                    127,
                    255,
                    0
                ],
                chocolate: [
                    210,
                    105,
                    30
                ],
                coral: [
                    255,
                    127,
                    80
                ],
                cornflowerblue: [
                    100,
                    149,
                    237
                ],
                cornsilk: [
                    255,
                    248,
                    220
                ],
                crimson: [
                    220,
                    20,
                    60
                ],
                cyan: [
                    0,
                    255,
                    255
                ],
                darkblue: [
                    0,
                    0,
                    139
                ],
                darkcyan: [
                    0,
                    139,
                    139
                ],
                darkgoldenrod: [
                    184,
                    134,
                    11
                ],
                darkgray: [
                    169,
                    169,
                    169
                ],
                darkgreen: [
                    0,
                    100,
                    0
                ],
                darkgrey: [
                    169,
                    169,
                    169
                ],
                darkkhaki: [
                    189,
                    183,
                    107
                ],
                darkmagenta: [
                    139,
                    0,
                    139
                ],
                darkolivegreen: [
                    85,
                    107,
                    47
                ],
                darkorange: [
                    255,
                    140,
                    0
                ],
                darkorchid: [
                    153,
                    50,
                    204
                ],
                darkred: [
                    139,
                    0,
                    0
                ],
                darksalmon: [
                    233,
                    150,
                    122
                ],
                darkseagreen: [
                    143,
                    188,
                    143
                ],
                darkslateblue: [
                    72,
                    61,
                    139
                ],
                darkslategray: [
                    47,
                    79,
                    79
                ],
                darkslategrey: [
                    47,
                    79,
                    79
                ],
                darkturquoise: [
                    0,
                    206,
                    209
                ],
                darkviolet: [
                    148,
                    0,
                    211
                ],
                deeppink: [
                    255,
                    20,
                    147
                ],
                deepskyblue: [
                    0,
                    191,
                    255
                ],
                dimgray: [
                    105,
                    105,
                    105
                ],
                dimgrey: [
                    105,
                    105,
                    105
                ],
                dodgerblue: [
                    30,
                    144,
                    255
                ],
                firebrick: [
                    178,
                    34,
                    34
                ],
                floralwhite: [
                    255,
                    250,
                    240
                ],
                forestgreen: [
                    34,
                    139,
                    34
                ],
                fuchsia: [
                    255,
                    0,
                    255
                ],
                gainsboro: [
                    220,
                    220,
                    220
                ],
                ghostwhite: [
                    248,
                    248,
                    255
                ],
                gold: [
                    255,
                    215,
                    0
                ],
                goldenrod: [
                    218,
                    165,
                    32
                ],
                gray: [
                    128,
                    128,
                    128
                ],
                green: [
                    0,
                    128,
                    0
                ],
                greenyellow: [
                    173,
                    255,
                    47
                ],
                grey: [
                    128,
                    128,
                    128
                ],
                honeydew: [
                    240,
                    255,
                    240
                ],
                hotpink: [
                    255,
                    105,
                    180
                ],
                indianred: [
                    205,
                    92,
                    92
                ],
                indigo: [
                    75,
                    0,
                    130
                ],
                ivory: [
                    255,
                    255,
                    240
                ],
                khaki: [
                    240,
                    230,
                    140
                ],
                lavender: [
                    230,
                    230,
                    250
                ],
                lavenderblush: [
                    255,
                    240,
                    245
                ],
                lawngreen: [
                    124,
                    252,
                    0
                ],
                lemonchiffon: [
                    255,
                    250,
                    205
                ],
                lightblue: [
                    173,
                    216,
                    230
                ],
                lightcoral: [
                    240,
                    128,
                    128
                ],
                lightcyan: [
                    224,
                    255,
                    255
                ],
                lightgoldenrodyellow: [
                    250,
                    250,
                    210
                ],
                lightgray: [
                    211,
                    211,
                    211
                ],
                lightgreen: [
                    144,
                    238,
                    144
                ],
                lightgrey: [
                    211,
                    211,
                    211
                ],
                lightpink: [
                    255,
                    182,
                    193
                ],
                lightsalmon: [
                    255,
                    160,
                    122
                ],
                lightseagreen: [
                    32,
                    178,
                    170
                ],
                lightskyblue: [
                    135,
                    206,
                    250
                ],
                lightslategray: [
                    119,
                    136,
                    153
                ],
                lightslategrey: [
                    119,
                    136,
                    153
                ],
                lightsteelblue: [
                    176,
                    196,
                    222
                ],
                lightyellow: [
                    255,
                    255,
                    224
                ],
                lime: [
                    0,
                    255,
                    0
                ],
                limegreen: [
                    50,
                    205,
                    50
                ],
                linen: [
                    250,
                    240,
                    230
                ],
                magenta: [
                    255,
                    0,
                    255
                ],
                maroon: [
                    128,
                    0,
                    0
                ],
                mediumaquamarine: [
                    102,
                    205,
                    170
                ],
                mediumblue: [
                    0,
                    0,
                    205
                ],
                mediumorchid: [
                    186,
                    85,
                    211
                ],
                mediumpurple: [
                    147,
                    112,
                    219
                ],
                mediumseagreen: [
                    60,
                    179,
                    113
                ],
                mediumslateblue: [
                    123,
                    104,
                    238
                ],
                mediumspringgreen: [
                    0,
                    250,
                    154
                ],
                mediumturquoise: [
                    72,
                    209,
                    204
                ],
                mediumvioletred: [
                    199,
                    21,
                    133
                ],
                midnightblue: [
                    25,
                    25,
                    112
                ],
                mintcream: [
                    245,
                    255,
                    250
                ],
                mistyrose: [
                    255,
                    228,
                    225
                ],
                moccasin: [
                    255,
                    228,
                    181
                ],
                navajowhite: [
                    255,
                    222,
                    173
                ],
                navy: [
                    0,
                    0,
                    128
                ],
                oldlace: [
                    253,
                    245,
                    230
                ],
                olive: [
                    128,
                    128,
                    0
                ],
                olivedrab: [
                    107,
                    142,
                    35
                ],
                orange: [
                    255,
                    165,
                    0
                ],
                orangered: [
                    255,
                    69,
                    0
                ],
                orchid: [
                    218,
                    112,
                    214
                ],
                palegoldenrod: [
                    238,
                    232,
                    170
                ],
                palegreen: [
                    152,
                    251,
                    152
                ],
                paleturquoise: [
                    175,
                    238,
                    238
                ],
                palevioletred: [
                    219,
                    112,
                    147
                ],
                papayawhip: [
                    255,
                    239,
                    213
                ],
                peachpuff: [
                    255,
                    218,
                    185
                ],
                peru: [
                    205,
                    133,
                    63
                ],
                pink: [
                    255,
                    192,
                    203
                ],
                plum: [
                    221,
                    160,
                    221
                ],
                powderblue: [
                    176,
                    224,
                    230
                ],
                purple: [
                    128,
                    0,
                    128
                ],
                rebeccapurple: [
                    102,
                    51,
                    153
                ],
                red: [
                    255,
                    0,
                    0
                ],
                rosybrown: [
                    188,
                    143,
                    143
                ],
                royalblue: [
                    65,
                    105,
                    225
                ],
                saddlebrown: [
                    139,
                    69,
                    19
                ],
                salmon: [
                    250,
                    128,
                    114
                ],
                sandybrown: [
                    244,
                    164,
                    96
                ],
                seagreen: [
                    46,
                    139,
                    87
                ],
                seashell: [
                    255,
                    245,
                    238
                ],
                sienna: [
                    160,
                    82,
                    45
                ],
                silver: [
                    192,
                    192,
                    192
                ],
                skyblue: [
                    135,
                    206,
                    235
                ],
                slateblue: [
                    106,
                    90,
                    205
                ],
                slategray: [
                    112,
                    128,
                    144
                ],
                slategrey: [
                    112,
                    128,
                    144
                ],
                snow: [
                    255,
                    250,
                    250
                ],
                springgreen: [
                    0,
                    255,
                    127
                ],
                steelblue: [
                    70,
                    130,
                    180
                ],
                tan: [
                    210,
                    180,
                    140
                ],
                teal: [
                    0,
                    128,
                    128
                ],
                thistle: [
                    216,
                    191,
                    216
                ],
                tomato: [
                    255,
                    99,
                    71
                ],
                turquoise: [
                    64,
                    224,
                    208
                ],
                violet: [
                    238,
                    130,
                    238
                ],
                wheat: [
                    245,
                    222,
                    179
                ],
                white: [
                    255,
                    255,
                    255
                ],
                whitesmoke: [
                    245,
                    245,
                    245
                ],
                yellow: [
                    255,
                    255,
                    0
                ],
                yellowgreen: [
                    154,
                    205,
                    50
                ]
            };
        },
        9714: (e1, t, r)=>{
            "use strict";
            var n = r(7147);
            var s = r(1017);
            Object.defineProperty(t, "commentRegex", {
                get: function getCommentRegex() {
                    return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/gm;
                }
            });
            Object.defineProperty(t, "mapFileCommentRegex", {
                get: function getMapFileCommentRegex() {
                    return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/gm;
                }
            });
            var i;
            if (typeof Buffer !== "undefined") {
                if (typeof Buffer.from === "function") {
                    i = decodeBase64WithBufferFrom;
                } else {
                    i = decodeBase64WithNewBuffer;
                }
            } else {
                i = decodeBase64WithAtob;
            }
            function decodeBase64WithBufferFrom(e1) {
                return Buffer.from(e1, "base64").toString();
            }
            function decodeBase64WithNewBuffer(e1) {
                if (typeof value === "number") {
                    throw new TypeError("The value to decode must not be of type number.");
                }
                return new Buffer(e1, "base64").toString();
            }
            function decodeBase64WithAtob(e1) {
                return decodeURIComponent(escape(atob(e1)));
            }
            function stripComment(e1) {
                return e1.split(",").pop();
            }
            function readFromFileMap(e1, r) {
                var i = t.mapFileCommentRegex.exec(e1);
                var a = i[1] || i[2];
                var o = s.resolve(r, a);
                try {
                    return n.readFileSync(o, "utf8");
                } catch (e1) {
                    throw new Error("An error occurred while trying to read the map file at " + o + "\n" + e1);
                }
            }
            function Converter(e1, t) {
                t = t || {};
                if (t.isFileComment) e1 = readFromFileMap(e1, t.commentFileDir);
                if (t.hasComment) e1 = stripComment(e1);
                if (t.isEncoded) e1 = i(e1);
                if (t.isJSON || t.isEncoded) e1 = JSON.parse(e1);
                this.sourcemap = e1;
            }
            Converter.prototype.toJSON = function(e1) {
                return JSON.stringify(this.sourcemap, null, e1);
            };
            if (typeof Buffer !== "undefined") {
                if (typeof Buffer.from === "function") {
                    Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
                } else {
                    Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
                }
            } else {
                Converter.prototype.toBase64 = encodeBase64WithBtoa;
            }
            function encodeBase64WithBufferFrom() {
                var e1 = this.toJSON();
                return Buffer.from(e1, "utf8").toString("base64");
            }
            function encodeBase64WithNewBuffer() {
                var e1 = this.toJSON();
                if (typeof e1 === "number") {
                    throw new TypeError("The json to encode must not be of type number.");
                }
                return new Buffer(e1, "utf8").toString("base64");
            }
            function encodeBase64WithBtoa() {
                var e1 = this.toJSON();
                return btoa(unescape(encodeURIComponent(e1)));
            }
            Converter.prototype.toComment = function(e1) {
                var t = this.toBase64();
                var r = "sourceMappingURL=data:application/json;charset=utf-8;base64," + t;
                return e1 && e1.multiline ? "/*# " + r + " */" : "//# " + r;
            };
            Converter.prototype.toObject = function() {
                return JSON.parse(this.toJSON());
            };
            Converter.prototype.addProperty = function(e1, t) {
                if (this.sourcemap.hasOwnProperty(e1)) throw new Error('property "' + e1 + '" already exists on the sourcemap, use set property instead');
                return this.setProperty(e1, t);
            };
            Converter.prototype.setProperty = function(e1, t) {
                this.sourcemap[e1] = t;
                return this;
            };
            Converter.prototype.getProperty = function(e1) {
                return this.sourcemap[e1];
            };
            t.fromObject = function(e1) {
                return new Converter(e1);
            };
            t.fromJSON = function(e1) {
                return new Converter(e1, {
                    isJSON: true
                });
            };
            t.fromBase64 = function(e1) {
                return new Converter(e1, {
                    isEncoded: true
                });
            };
            t.fromComment = function(e1) {
                e1 = e1.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
                return new Converter(e1, {
                    isEncoded: true,
                    hasComment: true
                });
            };
            t.fromMapFileComment = function(e1, t) {
                return new Converter(e1, {
                    commentFileDir: t,
                    isFileComment: true,
                    isJSON: true
                });
            };
            t.fromSource = function(e1) {
                var r = e1.match(t.commentRegex);
                return r ? t.fromComment(r.pop()) : null;
            };
            t.fromMapFileSource = function(e1, r) {
                var n = e1.match(t.mapFileCommentRegex);
                return n ? t.fromMapFileComment(n.pop(), r) : null;
            };
            t.removeComments = function(e1) {
                return e1.replace(t.commentRegex, "");
            };
            t.removeMapFileComments = function(e1) {
                return e1.replace(t.mapFileCommentRegex, "");
            };
            t.generateMapFileComment = function(e1, t) {
                var r = "sourceMappingURL=" + e1;
                return t && t.multiline ? "/*# " + r + " */" : "//# " + r;
            };
        },
        7379: (e1)=>{
            "use strict";
            var t = /[|\\{}()[\]^$+*?.]/g;
            e1.exports = function(e1) {
                if (typeof e1 !== "string") {
                    throw new TypeError("Expected a string");
                }
                return e1.replace(t, "\\$&");
            };
        },
        6433: (e1)=>{
            "use strict";
            const t = Symbol.for("gensync:v1:start");
            const r = Symbol.for("gensync:v1:suspend");
            const n = "GENSYNC_EXPECTED_START";
            const s = "GENSYNC_EXPECTED_SUSPEND";
            const i = "GENSYNC_OPTIONS_ERROR";
            const a = "GENSYNC_RACE_NONEMPTY";
            const o = "GENSYNC_ERRBACK_NO_CALLBACK";
            e1.exports = Object.assign(function gensync(e1) {
                let t = e1;
                if (typeof e1 !== "function") {
                    t = newGenerator(e1);
                } else {
                    t = wrapGenerator(e1);
                }
                return Object.assign(t, makeFunctionAPI(t));
            }, {
                all: buildOperation({
                    name: "all",
                    arity: 1,
                    sync: function(e1) {
                        const t = Array.from(e1[0]);
                        return t.map((e1)=>evaluateSync(e1));
                    },
                    async: function(e1, t, r) {
                        const n = Array.from(e1[0]);
                        if (n.length === 0) {
                            Promise.resolve().then(()=>t([]));
                            return;
                        }
                        let s = 0;
                        const i = n.map(()=>undefined);
                        n.forEach((e1, n)=>{
                            evaluateAsync(e1, (e1)=>{
                                i[n] = e1;
                                s += 1;
                                if (s === i.length) t(i);
                            }, r);
                        });
                    }
                }),
                race: buildOperation({
                    name: "race",
                    arity: 1,
                    sync: function(e1) {
                        const t = Array.from(e1[0]);
                        if (t.length === 0) {
                            throw makeError("Must race at least 1 item", a);
                        }
                        return evaluateSync(t[0]);
                    },
                    async: function(e1, t, r) {
                        const n = Array.from(e1[0]);
                        if (n.length === 0) {
                            throw makeError("Must race at least 1 item", a);
                        }
                        for (const e1 of n){
                            evaluateAsync(e1, t, r);
                        }
                    }
                })
            });
            function makeFunctionAPI(e1) {
                const t = {
                    sync: function(...t) {
                        return evaluateSync(e1.apply(this, t));
                    },
                    async: function(...t) {
                        return new Promise((r, n)=>{
                            evaluateAsync(e1.apply(this, t), r, n);
                        });
                    },
                    errback: function(...t) {
                        const r = t.pop();
                        if (typeof r !== "function") {
                            throw makeError("Asynchronous function called without callback", o);
                        }
                        let n;
                        try {
                            n = e1.apply(this, t);
                        } catch (e1) {
                            r(e1);
                            return;
                        }
                        evaluateAsync(n, (e1)=>r(undefined, e1), (e1)=>r(e1));
                    }
                };
                return t;
            }
            function assertTypeof(e1, t, r, n) {
                if (typeof r === e1 || n && typeof r === "undefined") {
                    return;
                }
                let s;
                if (n) {
                    s = `Expected opts.${t} to be either a ${e1}, or undefined.`;
                } else {
                    s = `Expected opts.${t} to be a ${e1}.`;
                }
                throw makeError(s, i);
            }
            function makeError(e1, t) {
                return Object.assign(new Error(e1), {
                    code: t
                });
            }
            function newGenerator({ name: e1, arity: t, sync: r, async: n, errback: s }) {
                assertTypeof("string", "name", e1, true);
                assertTypeof("number", "arity", t, true);
                assertTypeof("function", "sync", r);
                assertTypeof("function", "async", n, true);
                assertTypeof("function", "errback", s, true);
                if (n && s) {
                    throw makeError("Expected one of either opts.async or opts.errback, but got _both_.", i);
                }
                if (typeof e1 !== "string") {
                    let t;
                    if (s && s.name && s.name !== "errback") {
                        t = s.name;
                    }
                    if (n && n.name && n.name !== "async") {
                        t = n.name.replace(/Async$/, "");
                    }
                    if (r && r.name && r.name !== "sync") {
                        t = r.name.replace(/Sync$/, "");
                    }
                    if (typeof t === "string") {
                        e1 = t;
                    }
                }
                if (typeof t !== "number") {
                    t = r.length;
                }
                return buildOperation({
                    name: e1,
                    arity: t,
                    sync: function(e1) {
                        return r.apply(this, e1);
                    },
                    async: function(e1, t, i) {
                        if (n) {
                            n.apply(this, e1).then(t, i);
                        } else if (s) {
                            s.call(this, ...e1, (e1, r)=>{
                                if (e1 == null) t(r);
                                else i(e1);
                            });
                        } else {
                            t(r.apply(this, e1));
                        }
                    }
                });
            }
            function wrapGenerator(e1) {
                return setFunctionMetadata(e1.name, e1.length, function(...t) {
                    return e1.apply(this, t);
                });
            }
            function buildOperation({ name: e1, arity: n, sync: s, async: i }) {
                return setFunctionMetadata(e1, n, function*(...e1) {
                    const n = yield t;
                    if (!n) {
                        const t = s.call(this, e1);
                        return t;
                    }
                    let a;
                    try {
                        i.call(this, e1, (e1)=>{
                            if (a) return;
                            a = {
                                value: e1
                            };
                            n();
                        }, (e1)=>{
                            if (a) return;
                            a = {
                                err: e1
                            };
                            n();
                        });
                    } catch (e1) {
                        a = {
                            err: e1
                        };
                        n();
                    }
                    yield r;
                    if (a.hasOwnProperty("err")) {
                        throw a.err;
                    }
                    return a.value;
                });
            }
            function evaluateSync(e1) {
                let t;
                while(!({ value: t } = e1.next()).done){
                    assertStart(t, e1);
                }
                return t;
            }
            function evaluateAsync(e1, t, r) {
                (function step() {
                    try {
                        let r;
                        while(!({ value: r } = e1.next()).done){
                            assertStart(r, e1);
                            let t = true;
                            let n = false;
                            const s = e1.next(()=>{
                                if (t) {
                                    n = true;
                                } else {
                                    step();
                                }
                            });
                            t = false;
                            assertSuspend(s, e1);
                            if (!n) {
                                return;
                            }
                        }
                        return t(r);
                    } catch (e1) {
                        return r(e1);
                    }
                })();
            }
            function assertStart(e1, r) {
                if (e1 === t) return;
                throwError(r, makeError(`Got unexpected yielded value in gensync generator: ${JSON.stringify(e1)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`, n));
            }
            function assertSuspend({ value: e1, done: t }, n) {
                if (!t && e1 === r) return;
                throwError(n, makeError(t ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(e1)}. If you get this, it is probably a gensync bug.`, s));
            }
            function throwError(e1, t) {
                if (e1.throw) e1.throw(t);
                throw t;
            }
            function isIterable(e1) {
                return !!e1 && (typeof e1 === "object" || typeof e1 === "function") && !e1[Symbol.iterator];
            }
            function setFunctionMetadata(e1, t, r) {
                if (typeof e1 === "string") {
                    const t = Object.getOwnPropertyDescriptor(r, "name");
                    if (!t || t.configurable) {
                        Object.defineProperty(r, "name", Object.assign(t || {}, {
                            configurable: true,
                            value: e1
                        }));
                    }
                }
                if (typeof t === "number") {
                    const e1 = Object.getOwnPropertyDescriptor(r, "length");
                    if (!e1 || e1.configurable) {
                        Object.defineProperty(r, "length", Object.assign(e1 || {}, {
                            configurable: true,
                            value: t
                        }));
                    }
                }
                return r;
            }
        },
        6929: (e1, t, r)=>{
            "use strict";
            e1.exports = r(3676);
        },
        5343: (e1)=>{
            "use strict";
            e1.exports = (e1, t)=>{
                t = t || process.argv;
                const r = e1.startsWith("-") ? "" : e1.length === 1 ? "-" : "--";
                const n = t.indexOf(r + e1);
                const s = t.indexOf("--");
                return n !== -1 && (s === -1 ? true : n < s);
            };
        },
        8874: (e1, t)=>{
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
            t.matchToToken = function(e1) {
                var t = {
                    type: "invalid",
                    value: e1[0],
                    closed: undefined
                };
                if (e1[1]) t.type = "string", t.closed = !!(e1[3] || e1[4]);
                else if (e1[5]) t.type = "comment";
                else if (e1[6]) t.type = "comment", t.closed = !!e1[7];
                else if (e1[8]) t.type = "regex";
                else if (e1[9]) t.type = "number";
                else if (e1[10]) t.type = "name";
                else if (e1[11]) t.type = "punctuator";
                else if (e1[12]) t.type = "whitespace";
                return t;
            };
        },
        4011: (e1)=>{
            "use strict";
            const t = {};
            const r = t.hasOwnProperty;
            const forOwn = (e1, t)=>{
                for(const n in e1){
                    if (r.call(e1, n)) {
                        t(n, e1[n]);
                    }
                }
            };
            const extend = (e1, t)=>{
                if (!t) {
                    return e1;
                }
                forOwn(t, (t, r)=>{
                    e1[t] = r;
                });
                return e1;
            };
            const forEach = (e1, t)=>{
                const r = e1.length;
                let n = -1;
                while(++n < r){
                    t(e1[n]);
                }
            };
            const n = t.toString;
            const s = Array.isArray;
            const i = Buffer.isBuffer;
            const isObject = (e1)=>n.call(e1) == "[object Object]";
            const isString = (e1)=>typeof e1 == "string" || n.call(e1) == "[object String]";
            const isNumber = (e1)=>typeof e1 == "number" || n.call(e1) == "[object Number]";
            const isFunction = (e1)=>typeof e1 == "function";
            const isMap = (e1)=>n.call(e1) == "[object Map]";
            const isSet = (e1)=>n.call(e1) == "[object Set]";
            const a = {
                '"': '\\"',
                "'": "\\'",
                "\\": "\\\\",
                "\b": "\\b",
                "\f": "\\f",
                "\n": "\\n",
                "\r": "\\r",
                "\t": "\\t"
            };
            const o = /["'\\\b\f\n\r\t]/;
            const l = /[0-9]/;
            const c = /[ !#-&\(-\[\]-_a-~]/;
            const jsesc = (e1, t)=>{
                const increaseIndentation = ()=>{
                    h = d;
                    ++t.indentLevel;
                    d = t.indent.repeat(t.indentLevel);
                };
                const r = {
                    escapeEverything: false,
                    minimal: false,
                    isScriptContext: false,
                    quotes: "single",
                    wrap: false,
                    es6: false,
                    json: false,
                    compact: true,
                    lowercaseHex: false,
                    numbers: "decimal",
                    indent: "\t",
                    indentLevel: 0,
                    __inline1__: false,
                    __inline2__: false
                };
                const n = t && t.json;
                if (n) {
                    r.quotes = "double";
                    r.wrap = true;
                }
                t = extend(r, t);
                if (t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick") {
                    t.quotes = "single";
                }
                const u = t.quotes == "double" ? '"' : t.quotes == "backtick" ? "`" : "'";
                const p = t.compact;
                const f = t.lowercaseHex;
                let d = t.indent.repeat(t.indentLevel);
                let h = "";
                const m = t.__inline1__;
                const y = t.__inline2__;
                const g = p ? "" : "\n";
                let b;
                let T = true;
                const S = t.numbers == "binary";
                const E = t.numbers == "octal";
                const v = t.numbers == "decimal";
                const x = t.numbers == "hexadecimal";
                if (n && e1 && isFunction(e1.toJSON)) {
                    e1 = e1.toJSON();
                }
                if (!isString(e1)) {
                    if (isMap(e1)) {
                        if (e1.size == 0) {
                            return "new Map()";
                        }
                        if (!p) {
                            t.__inline1__ = true;
                            t.__inline2__ = false;
                        }
                        return "new Map(" + jsesc(Array.from(e1), t) + ")";
                    }
                    if (isSet(e1)) {
                        if (e1.size == 0) {
                            return "new Set()";
                        }
                        return "new Set(" + jsesc(Array.from(e1), t) + ")";
                    }
                    if (i(e1)) {
                        if (e1.length == 0) {
                            return "Buffer.from([])";
                        }
                        return "Buffer.from(" + jsesc(Array.from(e1), t) + ")";
                    }
                    if (s(e1)) {
                        b = [];
                        t.wrap = true;
                        if (m) {
                            t.__inline1__ = false;
                            t.__inline2__ = true;
                        }
                        if (!y) {
                            increaseIndentation();
                        }
                        forEach(e1, (e1)=>{
                            T = false;
                            if (y) {
                                t.__inline2__ = false;
                            }
                            b.push((p || y ? "" : d) + jsesc(e1, t));
                        });
                        if (T) {
                            return "[]";
                        }
                        if (y) {
                            return "[" + b.join(", ") + "]";
                        }
                        return "[" + g + b.join("," + g) + g + (p ? "" : h) + "]";
                    } else if (isNumber(e1)) {
                        if (n) {
                            return JSON.stringify(e1);
                        }
                        if (v) {
                            return String(e1);
                        }
                        if (x) {
                            let t = e1.toString(16);
                            if (!f) {
                                t = t.toUpperCase();
                            }
                            return "0x" + t;
                        }
                        if (S) {
                            return "0b" + e1.toString(2);
                        }
                        if (E) {
                            return "0o" + e1.toString(8);
                        }
                    } else if (!isObject(e1)) {
                        if (n) {
                            return JSON.stringify(e1) || "null";
                        }
                        return String(e1);
                    } else {
                        b = [];
                        t.wrap = true;
                        increaseIndentation();
                        forOwn(e1, (e1, r)=>{
                            T = false;
                            b.push((p ? "" : d) + jsesc(e1, t) + ":" + (p ? "" : " ") + jsesc(r, t));
                        });
                        if (T) {
                            return "{}";
                        }
                        return "{" + g + b.join("," + g) + g + (p ? "" : h) + "}";
                    }
                }
                const P = e1;
                let w = -1;
                const A = P.length;
                b = "";
                while(++w < A){
                    const e1 = P.charAt(w);
                    if (t.es6) {
                        const e1 = P.charCodeAt(w);
                        if (e1 >= 55296 && e1 <= 56319 && A > w + 1) {
                            const t = P.charCodeAt(w + 1);
                            if (t >= 56320 && t <= 57343) {
                                const r = (e1 - 55296) * 1024 + t - 56320 + 65536;
                                let n = r.toString(16);
                                if (!f) {
                                    n = n.toUpperCase();
                                }
                                b += "\\u{" + n + "}";
                                ++w;
                                continue;
                            }
                        }
                    }
                    if (!t.escapeEverything) {
                        if (c.test(e1)) {
                            b += e1;
                            continue;
                        }
                        if (e1 == '"') {
                            b += u == e1 ? '\\"' : e1;
                            continue;
                        }
                        if (e1 == "`") {
                            b += u == e1 ? "\\`" : e1;
                            continue;
                        }
                        if (e1 == "'") {
                            b += u == e1 ? "\\'" : e1;
                            continue;
                        }
                    }
                    if (e1 == "\0" && !n && !l.test(P.charAt(w + 1))) {
                        b += "\\0";
                        continue;
                    }
                    if (o.test(e1)) {
                        b += a[e1];
                        continue;
                    }
                    const r = e1.charCodeAt(0);
                    if (t.minimal && r != 8232 && r != 8233) {
                        b += e1;
                        continue;
                    }
                    let s = r.toString(16);
                    if (!f) {
                        s = s.toUpperCase();
                    }
                    const i = s.length > 2 || n;
                    const p = "\\" + (i ? "u" : "x") + ("0000" + s).slice(i ? -4 : -2);
                    b += p;
                    continue;
                }
                if (t.wrap) {
                    b = u + b + u;
                }
                if (u == "`") {
                    b = b.replace(/\$\{/g, "\\${");
                }
                if (t.isScriptContext) {
                    return b.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, n ? "\\u003C!--" : "\\x3C!--");
                }
                return b;
            };
            jsesc.version = "2.5.2";
            e1.exports = jsesc;
        },
        1437: (e1, t, r)=>{
            let n = process.argv || [], s = process.env;
            let i = !("NO_COLOR" in s || n.includes("--no-color")) && ("FORCE_COLOR" in s || n.includes("--color") || process.platform === "win32" || require != null && r(6224).isatty(1) && s.TERM !== "dumb" || "CI" in s);
            let formatter = (e1, t, r = e1)=>(n)=>{
                    let s = "" + n;
                    let i = s.indexOf(t, e1.length);
                    return ~i ? e1 + replaceClose(s, t, r, i) + t : e1 + s + t;
                };
            let replaceClose = (e1, t, r, n)=>{
                let s = "";
                let i = 0;
                do {
                    s += e1.substring(i, n) + r;
                    i = n + t.length;
                    n = e1.indexOf(t, i);
                }while (~n)
                return s + e1.substring(i);
            };
            let createColors = (e1 = i)=>{
                let t = e1 ? formatter : ()=>String;
                return {
                    isColorSupported: e1,
                    reset: t("[0m", "[0m"),
                    bold: t("[1m", "[22m", "[22m[1m"),
                    dim: t("[2m", "[22m", "[22m[2m"),
                    italic: t("[3m", "[23m"),
                    underline: t("[4m", "[24m"),
                    inverse: t("[7m", "[27m"),
                    hidden: t("[8m", "[28m"),
                    strikethrough: t("[9m", "[29m"),
                    black: t("[30m", "[39m"),
                    red: t("[31m", "[39m"),
                    green: t("[32m", "[39m"),
                    yellow: t("[33m", "[39m"),
                    blue: t("[34m", "[39m"),
                    magenta: t("[35m", "[39m"),
                    cyan: t("[36m", "[39m"),
                    white: t("[37m", "[39m"),
                    gray: t("[90m", "[39m"),
                    bgBlack: t("[40m", "[49m"),
                    bgRed: t("[41m", "[49m"),
                    bgGreen: t("[42m", "[49m"),
                    bgYellow: t("[43m", "[49m"),
                    bgBlue: t("[44m", "[49m"),
                    bgMagenta: t("[45m", "[49m"),
                    bgCyan: t("[46m", "[49m"),
                    bgWhite: t("[47m", "[49m")
                };
            };
            e1.exports = createColors();
            e1.exports.createColors = createColors;
        },
        7220: (e1, t, r)=>{
            "use strict";
            const n = r(2037);
            const s = r(5343);
            const i = process.env;
            let a;
            if (s("no-color") || s("no-colors") || s("color=false")) {
                a = false;
            } else if (s("color") || s("colors") || s("color=true") || s("color=always")) {
                a = true;
            }
            if ("FORCE_COLOR" in i) {
                a = i.FORCE_COLOR.length === 0 || parseInt(i.FORCE_COLOR, 10) !== 0;
            }
            function translateLevel(e1) {
                if (e1 === 0) {
                    return false;
                }
                return {
                    level: e1,
                    hasBasic: true,
                    has256: e1 >= 2,
                    has16m: e1 >= 3
                };
            }
            function supportsColor(e1) {
                if (a === false) {
                    return 0;
                }
                if (s("color=16m") || s("color=full") || s("color=truecolor")) {
                    return 3;
                }
                if (s("color=256")) {
                    return 2;
                }
                if (e1 && !e1.isTTY && a !== true) {
                    return 0;
                }
                const t = a ? 1 : 0;
                if ("TURBOPACK compile-time truthy", 1) {
                    const e1 = n.release().split(".");
                    if (Number(process.versions.node.split(".")[0]) >= 8 && Number(e1[0]) >= 10 && Number(e1[2]) >= 10586) {
                        return Number(e1[2]) >= 14931 ? 3 : 2;
                    }
                    return 1;
                }
                "TURBOPACK unreachable";
            }
            function getSupportLevel(e1) {
                const t = supportsColor(e1);
                return translateLevel(t);
            }
            e1.exports = {
                supportsColor: getSupportLevel,
                stdout: getSupportLevel(process.stdout),
                stderr: getSupportLevel(process.stderr)
            };
        },
        3797: (e1)=>{
            "use strict";
            let t = null;
            function FastObject(e1) {
                if (t !== null && typeof t.property) {
                    const e1 = t;
                    t = FastObject.prototype = null;
                    return e1;
                }
                t = FastObject.prototype = e1 == null ? Object.create(null) : e1;
                return new FastObject;
            }
            FastObject();
            e1.exports = function toFastproperties(e1) {
                return FastObject(e1);
            };
        },
        3050: (e1, t, r)=>{
            function types() {
                return r(776);
            }
            function codeFrame() {
                return r(2430);
            }
            function core() {
                return r(3688);
            }
            function coreLibConfig() {
                return r(4455);
            }
            function coreLibNormalizeFile() {
                return r(4082);
            }
            function coreLibNormalizeOpts() {
                return r(3907);
            }
            function coreLibBlockHoistPlugin() {
                return r(2167);
            }
            function coreLibPluginPass() {
                return r(1732);
            }
            function traverse() {
                return r(2297);
            }
            function generator() {
                return r(3956);
            }
            function parser() {
                return r(7383);
            }
            function eslintParser() {
                return r(3305).eslintParser();
            }
            function pluginProposalClassProperties() {
                return r(3305).pluginProposalClassProperties();
            }
            function pluginProposalExportNamespaceFrom() {
                return r(3305).pluginProposalExportNamespaceFrom();
            }
            function pluginProposalNumericSeparator() {
                return r(3305).pluginProposalNumericSeparator();
            }
            function pluginProposalObjectRestSpread() {
                return r(3305).pluginProposalObjectRestSpread();
            }
            function pluginSyntaxBigint() {
                return r(3305).pluginSyntaxBigint();
            }
            function pluginSyntaxDynamicImport() {
                return r(3305).pluginSyntaxDynamicImport();
            }
            function pluginSyntaxImportAttributes() {
                return r(3305).pluginSyntaxImportAttributes();
            }
            function pluginSyntaxJsx() {
                return r(3305).pluginSyntaxJsx();
            }
            function pluginTransformDefine() {
                return r(3305).pluginTransformDefine();
            }
            function pluginTransformModulesCommonjs() {
                return r(3305).pluginTransformModulesCommonjs();
            }
            function pluginTransformReactRemovePropTypes() {
                return r(3305).pluginTransformReactRemovePropTypes();
            }
            function pluginTransformRuntime() {
                return r(3305).pluginTransformRuntime();
            }
            function presetEnv() {
                return r(3305).presetEnv();
            }
            function presetReact() {
                return r(3305).presetReact();
            }
            function presetTypescript() {
                return r(3305).presetTypescript();
            }
            e1.exports = {
                types: types,
                codeFrame: codeFrame,
                core: core,
                coreLibConfig: coreLibConfig,
                coreLibNormalizeFile: coreLibNormalizeFile,
                coreLibNormalizeOpts: coreLibNormalizeOpts,
                coreLibBlockHoistPlugin: coreLibBlockHoistPlugin,
                coreLibPluginPass: coreLibPluginPass,
                generator: generator,
                traverse: traverse,
                eslintParser: eslintParser,
                parser: parser,
                pluginProposalClassProperties: pluginProposalClassProperties,
                pluginProposalExportNamespaceFrom: pluginProposalExportNamespaceFrom,
                pluginProposalNumericSeparator: pluginProposalNumericSeparator,
                pluginProposalObjectRestSpread: pluginProposalObjectRestSpread,
                pluginSyntaxBigint: pluginSyntaxBigint,
                pluginSyntaxDynamicImport: pluginSyntaxDynamicImport,
                pluginSyntaxImportAttributes: pluginSyntaxImportAttributes,
                pluginSyntaxJsx: pluginSyntaxJsx,
                pluginTransformDefine: pluginTransformDefine,
                pluginTransformModulesCommonjs: pluginTransformModulesCommonjs,
                pluginTransformReactRemovePropTypes: pluginTransformReactRemovePropTypes,
                pluginTransformRuntime: pluginTransformRuntime,
                presetEnv: presetEnv,
                presetReact: presetReact,
                presetTypescript: presetTypescript
            };
        },
        9491: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[externals]/ [external] (assert, cjs)");
        },
        7147: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[externals]/ [external] (fs, cjs)");
        },
        8188: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[externals]/ [external] (module, cjs)");
        },
        3305: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/babel-packages/packages-bundle.js [app-rsc] (ecmascript)");
        },
        4907: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/browserslist/index.js [app-rsc] (ecmascript)");
        },
        6937: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/debug/index.js [app-rsc] (ecmascript)");
        },
        8310: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/json5/index.js [app-rsc] (ecmascript)");
        },
        7330: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/lru-cache/index.js [app-rsc] (ecmascript)");
        },
        7849: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[project]/node_modules/next/dist/compiled/semver/index.js [app-rsc] (ecmascript)");
        },
        2037: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[externals]/ [external] (os, cjs)");
        },
        1017: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[externals]/ [external] (path, cjs)");
        },
        7282: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[externals]/ [external] (process, cjs)");
        },
        6224: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[externals]/ [external] (tty, cjs)");
        },
        7310: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[externals]/ [external] (url, cjs)");
        },
        3849: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[externals]/ [external] (util, cjs)");
        },
        4655: (e1)=>{
            "use strict";
            e1.exports = __turbopack_require__("[externals]/ [external] (v8, cjs)");
        },
        3327: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.codeFrameColumns = codeFrameColumns;
            t["default"] = _default;
            var n = r(5771);
            var s = _interopRequireWildcard(r(6148), true);
            function _getRequireWildcardCache(e1) {
                if (typeof WeakMap !== "function") return null;
                var t = new WeakMap;
                var r = new WeakMap;
                return (_getRequireWildcardCache = function(e1) {
                    return e1 ? r : t;
                })(e1);
            }
            function _interopRequireWildcard(e1, t) {
                if (!t && e1 && e1.__esModule) {
                    return e1;
                }
                if (e1 === null || typeof e1 !== "object" && typeof e1 !== "function") {
                    return {
                        default: e1
                    };
                }
                var r = _getRequireWildcardCache(t);
                if (r && r.has(e1)) {
                    return r.get(e1);
                }
                var n = {};
                var s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var i in e1){
                    if (i !== "default" && Object.prototype.hasOwnProperty.call(e1, i)) {
                        var a = s ? Object.getOwnPropertyDescriptor(e1, i) : null;
                        if (a && (a.get || a.set)) {
                            Object.defineProperty(n, i, a);
                        } else {
                            n[i] = e1[i];
                        }
                    }
                }
                n.default = e1;
                if (r) {
                    r.set(e1, n);
                }
                return n;
            }
            let i = undefined;
            function getChalk(e1) {
                if (e1) {
                    var t;
                    (t = i) != null ? t : i = new s.default.constructor({
                        enabled: true,
                        level: 1
                    });
                    return i;
                }
                return s.default;
            }
            let a = false;
            function getDefs(e1) {
                return {
                    gutter: e1.grey,
                    marker: e1.red.bold,
                    message: e1.red.bold
                };
            }
            const o = /\r\n|[\n\r\u2028\u2029]/;
            function getMarkerLines(e1, t, r) {
                const n = Object.assign({
                    column: 0,
                    line: -1
                }, e1.start);
                const s = Object.assign({}, n, e1.end);
                const { linesAbove: i = 2, linesBelow: a = 3 } = r || {};
                const o = n.line;
                const l = n.column;
                const c = s.line;
                const u = s.column;
                let p = Math.max(o - (i + 1), 0);
                let f = Math.min(t.length, c + a);
                if (o === -1) {
                    p = 0;
                }
                if (c === -1) {
                    f = t.length;
                }
                const d = c - o;
                const h = {};
                if (d) {
                    for(let e1 = 0; e1 <= d; e1++){
                        const r = e1 + o;
                        if (!l) {
                            h[r] = true;
                        } else if (e1 === 0) {
                            const e1 = t[r - 1].length;
                            h[r] = [
                                l,
                                e1 - l + 1
                            ];
                        } else if (e1 === d) {
                            h[r] = [
                                0,
                                u
                            ];
                        } else {
                            const n = t[r - e1].length;
                            h[r] = [
                                0,
                                n
                            ];
                        }
                    }
                } else {
                    if (l === u) {
                        if (l) {
                            h[o] = [
                                l,
                                0
                            ];
                        } else {
                            h[o] = true;
                        }
                    } else {
                        h[o] = [
                            l,
                            u - l
                        ];
                    }
                }
                return {
                    start: p,
                    end: f,
                    markerLines: h
                };
            }
            function codeFrameColumns(e1, t, r = {}) {
                const s = (r.highlightCode || r.forceColor) && (0, n.shouldHighlight)(r);
                const i = getChalk(r.forceColor);
                const a = getDefs(i);
                const maybeHighlight = (e1, t)=>s ? e1(t) : t;
                const l = e1.split(o);
                const { start: c, end: u, markerLines: p } = getMarkerLines(t, l, r);
                const f = t.start && typeof t.start.column === "number";
                const d = String(u).length;
                const h = s ? (0, n.default)(e1, r) : e1;
                let m = h.split(o, u).slice(c, u).map((e1, t)=>{
                    const n = c + 1 + t;
                    const s = ` ${n}`.slice(-d);
                    const i = ` ${s} |`;
                    const o = p[n];
                    const l = !p[n + 1];
                    if (o) {
                        let t = "";
                        if (Array.isArray(o)) {
                            const n = e1.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " ");
                            const s = o[1] || 1;
                            t = [
                                "\n ",
                                maybeHighlight(a.gutter, i.replace(/\d/g, " ")),
                                " ",
                                n,
                                maybeHighlight(a.marker, "^").repeat(s)
                            ].join("");
                            if (l && r.message) {
                                t += " " + maybeHighlight(a.message, r.message);
                            }
                        }
                        return [
                            maybeHighlight(a.marker, ">"),
                            maybeHighlight(a.gutter, i),
                            e1.length > 0 ? ` ${e1}` : "",
                            t
                        ].join("");
                    } else {
                        return ` ${maybeHighlight(a.gutter, i)}${e1.length > 0 ? ` ${e1}` : ""}`;
                    }
                }).join("\n");
                if (r.message && !f) {
                    m = `${" ".repeat(d + 1)}${r.message}\n${m}`;
                }
                if (s) {
                    return i.reset(m);
                } else {
                    return m;
                }
            }
            function _default(e1, t, r, n = {}) {
                if (!a) {
                    a = true;
                    const e1 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                    if (process.emitWarning) {
                        process.emitWarning(e1, "DeprecationWarning");
                    } else {
                        const t = new Error(e1);
                        t.name = "DeprecationWarning";
                        console.warn(new Error(e1));
                    }
                }
                r = Math.max(r, 0);
                const s = {
                    start: {
                        column: r,
                        line: t
                    }
                };
                return codeFrameColumns(e1, s, n);
            }
        },
        2430: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.codeFrameColumns = codeFrameColumns;
            t["default"] = _default;
            var n = r(6448);
            let s = false;
            function getDefs(e1) {
                return {
                    gutter: e1.grey,
                    marker: e1.red.bold,
                    message: e1.red.bold
                };
            }
            const i = /\r\n|[\n\r\u2028\u2029]/;
            function getMarkerLines(e1, t, r) {
                const n = Object.assign({
                    column: 0,
                    line: -1
                }, e1.start);
                const s = Object.assign({}, n, e1.end);
                const { linesAbove: i = 2, linesBelow: a = 3 } = r || {};
                const o = n.line;
                const l = n.column;
                const c = s.line;
                const u = s.column;
                let p = Math.max(o - (i + 1), 0);
                let f = Math.min(t.length, c + a);
                if (o === -1) {
                    p = 0;
                }
                if (c === -1) {
                    f = t.length;
                }
                const d = c - o;
                const h = {};
                if (d) {
                    for(let e1 = 0; e1 <= d; e1++){
                        const r = e1 + o;
                        if (!l) {
                            h[r] = true;
                        } else if (e1 === 0) {
                            const e1 = t[r - 1].length;
                            h[r] = [
                                l,
                                e1 - l + 1
                            ];
                        } else if (e1 === d) {
                            h[r] = [
                                0,
                                u
                            ];
                        } else {
                            const n = t[r - e1].length;
                            h[r] = [
                                0,
                                n
                            ];
                        }
                    }
                } else {
                    if (l === u) {
                        if (l) {
                            h[o] = [
                                l,
                                0
                            ];
                        } else {
                            h[o] = true;
                        }
                    } else {
                        h[o] = [
                            l,
                            u - l
                        ];
                    }
                }
                return {
                    start: p,
                    end: f,
                    markerLines: h
                };
            }
            function codeFrameColumns(e1, t, r = {}) {
                const s = (r.highlightCode || r.forceColor) && (0, n.shouldHighlight)(r);
                const a = (0, n.getChalk)(r);
                const o = getDefs(a);
                const maybeHighlight = (e1, t)=>s ? e1(t) : t;
                const l = e1.split(i);
                const { start: c, end: u, markerLines: p } = getMarkerLines(t, l, r);
                const f = t.start && typeof t.start.column === "number";
                const d = String(u).length;
                const h = s ? (0, n.default)(e1, r) : e1;
                let m = h.split(i, u).slice(c, u).map((e1, t)=>{
                    const n = c + 1 + t;
                    const s = ` ${n}`.slice(-d);
                    const i = ` ${s} |`;
                    const a = p[n];
                    const l = !p[n + 1];
                    if (a) {
                        let t = "";
                        if (Array.isArray(a)) {
                            const n = e1.slice(0, Math.max(a[0] - 1, 0)).replace(/[^\t]/g, " ");
                            const s = a[1] || 1;
                            t = [
                                "\n ",
                                maybeHighlight(o.gutter, i.replace(/\d/g, " ")),
                                " ",
                                n,
                                maybeHighlight(o.marker, "^").repeat(s)
                            ].join("");
                            if (l && r.message) {
                                t += " " + maybeHighlight(o.message, r.message);
                            }
                        }
                        return [
                            maybeHighlight(o.marker, ">"),
                            maybeHighlight(o.gutter, i),
                            e1.length > 0 ? ` ${e1}` : "",
                            t
                        ].join("");
                    } else {
                        return ` ${maybeHighlight(o.gutter, i)}${e1.length > 0 ? ` ${e1}` : ""}`;
                    }
                }).join("\n");
                if (r.message && !f) {
                    m = `${" ".repeat(d + 1)}${r.message}\n${m}`;
                }
                if (s) {
                    return a.reset(m);
                } else {
                    return m;
                }
            }
            function _default(e1, t, r, n = {}) {
                if (!s) {
                    s = true;
                    const e1 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                    if (process.emitWarning) {
                        process.emitWarning(e1, "DeprecationWarning");
                    } else {
                        const t = new Error(e1);
                        t.name = "DeprecationWarning";
                        console.warn(new Error(e1));
                    }
                }
                r = Math.max(r, 0);
                const i = {
                    start: {
                        column: r,
                        line: t
                    }
                };
                return codeFrameColumns(e1, i, n);
            }
        },
        3950: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.codeFrameColumns = codeFrameColumns;
            t["default"] = _default;
            var n = r(5771);
            var s = _interopRequireWildcard(r(1437), true);
            function _getRequireWildcardCache(e1) {
                if ("function" != typeof WeakMap) return null;
                var t = new WeakMap, r = new WeakMap;
                return (_getRequireWildcardCache = function(e1) {
                    return e1 ? r : t;
                })(e1);
            }
            function _interopRequireWildcard(e1, t) {
                if (!t && e1 && e1.__esModule) return e1;
                if (null === e1 || "object" != typeof e1 && "function" != typeof e1) return {
                    default: e1
                };
                var r = _getRequireWildcardCache(t);
                if (r && r.has(e1)) return r.get(e1);
                var n = {
                    __proto__: null
                }, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var i in e1)if ("default" !== i && ({}).hasOwnProperty.call(e1, i)) {
                    var a = s ? Object.getOwnPropertyDescriptor(e1, i) : null;
                    a && (a.get || a.set) ? Object.defineProperty(n, i, a) : n[i] = e1[i];
                }
                return n.default = e1, r && r.set(e1, n), n;
            }
            const i = typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, s.createColors)(false) : s.default;
            const compose = (e1, t)=>(r)=>e1(t(r));
            let a = undefined;
            function getColors(e1) {
                if (e1) {
                    var t;
                    (t = a) != null ? t : a = (0, s.createColors)(true);
                    return a;
                }
                return i;
            }
            let o = false;
            function getDefs(e1) {
                return {
                    gutter: e1.gray,
                    marker: compose(e1.red, e1.bold),
                    message: compose(e1.red, e1.bold)
                };
            }
            const l = /\r\n|[\n\r\u2028\u2029]/;
            function getMarkerLines(e1, t, r) {
                const n = Object.assign({
                    column: 0,
                    line: -1
                }, e1.start);
                const s = Object.assign({}, n, e1.end);
                const { linesAbove: i = 2, linesBelow: a = 3 } = r || {};
                const o = n.line;
                const l = n.column;
                const c = s.line;
                const u = s.column;
                let p = Math.max(o - (i + 1), 0);
                let f = Math.min(t.length, c + a);
                if (o === -1) {
                    p = 0;
                }
                if (c === -1) {
                    f = t.length;
                }
                const d = c - o;
                const h = {};
                if (d) {
                    for(let e1 = 0; e1 <= d; e1++){
                        const r = e1 + o;
                        if (!l) {
                            h[r] = true;
                        } else if (e1 === 0) {
                            const e1 = t[r - 1].length;
                            h[r] = [
                                l,
                                e1 - l + 1
                            ];
                        } else if (e1 === d) {
                            h[r] = [
                                0,
                                u
                            ];
                        } else {
                            const n = t[r - e1].length;
                            h[r] = [
                                0,
                                n
                            ];
                        }
                    }
                } else {
                    if (l === u) {
                        if (l) {
                            h[o] = [
                                l,
                                0
                            ];
                        } else {
                            h[o] = true;
                        }
                    } else {
                        h[o] = [
                            l,
                            u - l
                        ];
                    }
                }
                return {
                    start: p,
                    end: f,
                    markerLines: h
                };
            }
            function codeFrameColumns(e1, t, r = {}) {
                const s = (r.highlightCode || r.forceColor) && (0, n.shouldHighlight)(r);
                const i = getColors(r.forceColor);
                const a = getDefs(i);
                const maybeHighlight = (e1, t)=>s ? e1(t) : t;
                const o = e1.split(l);
                const { start: c, end: u, markerLines: p } = getMarkerLines(t, o, r);
                const f = t.start && typeof t.start.column === "number";
                const d = String(u).length;
                const h = s ? (0, n.default)(e1, r) : e1;
                let m = h.split(l, u).slice(c, u).map((e1, t)=>{
                    const n = c + 1 + t;
                    const s = ` ${n}`.slice(-d);
                    const i = ` ${s} |`;
                    const o = p[n];
                    const l = !p[n + 1];
                    if (o) {
                        let t = "";
                        if (Array.isArray(o)) {
                            const n = e1.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " ");
                            const s = o[1] || 1;
                            t = [
                                "\n ",
                                maybeHighlight(a.gutter, i.replace(/\d/g, " ")),
                                " ",
                                n,
                                maybeHighlight(a.marker, "^").repeat(s)
                            ].join("");
                            if (l && r.message) {
                                t += " " + maybeHighlight(a.message, r.message);
                            }
                        }
                        return [
                            maybeHighlight(a.marker, ">"),
                            maybeHighlight(a.gutter, i),
                            e1.length > 0 ? ` ${e1}` : "",
                            t
                        ].join("");
                    } else {
                        return ` ${maybeHighlight(a.gutter, i)}${e1.length > 0 ? ` ${e1}` : ""}`;
                    }
                }).join("\n");
                if (r.message && !f) {
                    m = `${" ".repeat(d + 1)}${r.message}\n${m}`;
                }
                if (s) {
                    return i.reset(m);
                } else {
                    return m;
                }
            }
            function _default(e1, t, r, n = {}) {
                if (!o) {
                    o = true;
                    const e1 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                    if (process.emitWarning) {
                        process.emitWarning(e1, "DeprecationWarning");
                    } else {
                        const t = new Error(e1);
                        t.name = "DeprecationWarning";
                        console.warn(new Error(e1));
                    }
                }
                r = Math.max(r, 0);
                const s = {
                    start: {
                        column: r,
                        line: t
                    }
                };
                return codeFrameColumns(e1, s, n);
            }
        },
        1371: (e1, t, r)=>{
            e1.exports = r(212);
        },
        2204: (e1, t, r)=>{
            e1.exports = r(2735);
        },
        9608: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.assertSimpleType = assertSimpleType;
            t.makeStrongCache = makeStrongCache;
            t.makeStrongCacheSync = makeStrongCacheSync;
            t.makeWeakCache = makeWeakCache;
            t.makeWeakCacheSync = makeWeakCacheSync;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(9367);
            var s = r(7376);
            const synchronize = (e1)=>_gensync()(e1).sync;
            function* genTrue() {
                return true;
            }
            function makeWeakCache(e1) {
                return makeCachedFunction(WeakMap, e1);
            }
            function makeWeakCacheSync(e1) {
                return synchronize(makeWeakCache(e1));
            }
            function makeStrongCache(e1) {
                return makeCachedFunction(Map, e1);
            }
            function makeStrongCacheSync(e1) {
                return synchronize(makeStrongCache(e1));
            }
            function makeCachedFunction(e1, t) {
                const r = new e1;
                const i = new e1;
                const a = new e1;
                return function* cachedFunction(e1, o) {
                    const l = yield* (0, n.isAsync)();
                    const c = l ? i : r;
                    const u = yield* getCachedValueOrWait(l, c, a, e1, o);
                    if (u.valid) return u.value;
                    const p = new CacheConfigurator(o);
                    const f = t(e1, p);
                    let d;
                    let h;
                    if ((0, s.isIterableIterator)(f)) {
                        h = yield* (0, n.onFirstPause)(f, ()=>{
                            d = setupAsyncLocks(p, a, e1);
                        });
                    } else {
                        h = f;
                    }
                    updateFunctionCache(c, p, e1, h);
                    if (d) {
                        a.delete(e1);
                        d.release(h);
                    }
                    return h;
                };
            }
            function* getCachedValue(e1, t, r) {
                const n = e1.get(t);
                if (n) {
                    for (const { value: e1, valid: t } of n){
                        if (yield* t(r)) return {
                            valid: true,
                            value: e1
                        };
                    }
                }
                return {
                    valid: false,
                    value: null
                };
            }
            function* getCachedValueOrWait(e1, t, r, s, i) {
                const a = yield* getCachedValue(t, s, i);
                if (a.valid) {
                    return a;
                }
                if (e1) {
                    const e1 = yield* getCachedValue(r, s, i);
                    if (e1.valid) {
                        const t = yield* (0, n.waitFor)(e1.value.promise);
                        return {
                            valid: true,
                            value: t
                        };
                    }
                }
                return {
                    valid: false,
                    value: null
                };
            }
            function setupAsyncLocks(e1, t, r) {
                const n = new Lock;
                updateFunctionCache(t, e1, r, n);
                return n;
            }
            function updateFunctionCache(e1, t, r, n) {
                if (!t.configured()) t.forever();
                let s = e1.get(r);
                t.deactivate();
                switch(t.mode()){
                    case "forever":
                        s = [
                            {
                                value: n,
                                valid: genTrue
                            }
                        ];
                        e1.set(r, s);
                        break;
                    case "invalidate":
                        s = [
                            {
                                value: n,
                                valid: t.validator()
                            }
                        ];
                        e1.set(r, s);
                        break;
                    case "valid":
                        if (s) {
                            s.push({
                                value: n,
                                valid: t.validator()
                            });
                        } else {
                            s = [
                                {
                                    value: n,
                                    valid: t.validator()
                                }
                            ];
                            e1.set(r, s);
                        }
                }
            }
            class CacheConfigurator {
                constructor(e1){
                    this._active = true;
                    this._never = false;
                    this._forever = false;
                    this._invalidate = false;
                    this._configured = false;
                    this._pairs = [];
                    this._data = void 0;
                    this._data = e1;
                }
                simple() {
                    return makeSimpleConfigurator(this);
                }
                mode() {
                    if (this._never) return "never";
                    if (this._forever) return "forever";
                    if (this._invalidate) return "invalidate";
                    return "valid";
                }
                forever() {
                    if (!this._active) {
                        throw new Error("Cannot change caching after evaluation has completed.");
                    }
                    if (this._never) {
                        throw new Error("Caching has already been configured with .never()");
                    }
                    this._forever = true;
                    this._configured = true;
                }
                never() {
                    if (!this._active) {
                        throw new Error("Cannot change caching after evaluation has completed.");
                    }
                    if (this._forever) {
                        throw new Error("Caching has already been configured with .forever()");
                    }
                    this._never = true;
                    this._configured = true;
                }
                using(e1) {
                    if (!this._active) {
                        throw new Error("Cannot change caching after evaluation has completed.");
                    }
                    if (this._never || this._forever) {
                        throw new Error("Caching has already been configured with .never or .forever()");
                    }
                    this._configured = true;
                    const t = e1(this._data);
                    const r = (0, n.maybeAsync)(e1, `You appear to be using an async cache handler, but Babel has been called synchronously`);
                    if ((0, n.isThenable)(t)) {
                        return t.then((e1)=>{
                            this._pairs.push([
                                e1,
                                r
                            ]);
                            return e1;
                        });
                    }
                    this._pairs.push([
                        t,
                        r
                    ]);
                    return t;
                }
                invalidate(e1) {
                    this._invalidate = true;
                    return this.using(e1);
                }
                validator() {
                    const e1 = this._pairs;
                    return function*(t) {
                        for (const [r, n] of e1){
                            if (r !== (yield* n(t))) return false;
                        }
                        return true;
                    };
                }
                deactivate() {
                    this._active = false;
                }
                configured() {
                    return this._configured;
                }
            }
            function makeSimpleConfigurator(e1) {
                function cacheFn(t) {
                    if (typeof t === "boolean") {
                        if (t) e1.forever();
                        else e1.never();
                        return;
                    }
                    return e1.using(()=>assertSimpleType(t()));
                }
                cacheFn.forever = ()=>e1.forever();
                cacheFn.never = ()=>e1.never();
                cacheFn.using = (t)=>e1.using(()=>assertSimpleType(t()));
                cacheFn.invalidate = (t)=>e1.invalidate(()=>assertSimpleType(t()));
                return cacheFn;
            }
            function assertSimpleType(e1) {
                if ((0, n.isThenable)(e1)) {
                    throw new Error(`You appear to be using an async cache handler, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously handle your caching logic.`);
                }
                if (e1 != null && typeof e1 !== "string" && typeof e1 !== "boolean" && typeof e1 !== "number") {
                    throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
                }
                return e1;
            }
            class Lock {
                constructor(){
                    this.released = false;
                    this.promise = void 0;
                    this._resolve = void 0;
                    this.promise = new Promise((e1)=>{
                        this._resolve = e1;
                    });
                }
                release(e1) {
                    this.released = true;
                    this._resolve(e1);
                }
            }
            0 && 0;
        },
        4672: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.buildPresetChain = buildPresetChain;
            t.buildPresetChainWalker = void 0;
            t.buildRootChain = buildRootChain;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function _debug() {
                const e1 = r(6937);
                _debug = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(2420);
            var s = r(1034);
            var i = r(7526);
            var a = r(3585);
            var o = r(8208);
            var l = r(4613);
            var c = r(9608);
            var u = r(8680);
            const p = _debug()("babel:config:config-chain");
            function* buildPresetChain(e1, t) {
                const r = yield* f(e1, t);
                if (!r) return null;
                return {
                    plugins: dedupDescriptors(r.plugins),
                    presets: dedupDescriptors(r.presets),
                    options: r.options.map((e1)=>normalizeOptions(e1)),
                    files: new Set
                };
            }
            const f = makeChainWalker({
                root: (e1)=>d(e1),
                env: (e1, t)=>h(e1)(t),
                overrides: (e1, t)=>m(e1)(t),
                overridesEnv: (e1, t, r)=>y(e1)(t)(r),
                createLogger: ()=>()=>{}
            });
            t.buildPresetChainWalker = f;
            const d = (0, c.makeWeakCacheSync)((e1)=>buildRootDescriptors(e1, e1.alias, u.createUncachedDescriptors));
            const h = (0, c.makeWeakCacheSync)((e1)=>(0, c.makeStrongCacheSync)((t)=>buildEnvDescriptors(e1, e1.alias, u.createUncachedDescriptors, t)));
            const m = (0, c.makeWeakCacheSync)((e1)=>(0, c.makeStrongCacheSync)((t)=>buildOverrideDescriptors(e1, e1.alias, u.createUncachedDescriptors, t)));
            const y = (0, c.makeWeakCacheSync)((e1)=>(0, c.makeStrongCacheSync)((t)=>(0, c.makeStrongCacheSync)((r)=>buildOverrideEnvDescriptors(e1, e1.alias, u.createUncachedDescriptors, t, r))));
            function* buildRootChain(e1, t) {
                let r, n;
                const s = new i.ConfigPrinter;
                const a = yield* S({
                    options: e1,
                    dirname: t.cwd
                }, t, undefined, s);
                if (!a) return null;
                const o = yield* s.output();
                let c;
                if (typeof e1.configFile === "string") {
                    c = yield* (0, l.loadConfig)(e1.configFile, t.cwd, t.envName, t.caller);
                } else if (e1.configFile !== false) {
                    c = yield* (0, l.findRootConfig)(t.root, t.envName, t.caller);
                }
                let { babelrc: u, babelrcRoots: p } = e1;
                let f = t.cwd;
                const d = emptyChain();
                const h = new i.ConfigPrinter;
                if (c) {
                    const e1 = g(c);
                    const n = yield* loadFileChain(e1, t, undefined, h);
                    if (!n) return null;
                    r = yield* h.output();
                    if (u === undefined) {
                        u = e1.options.babelrc;
                    }
                    if (p === undefined) {
                        f = e1.dirname;
                        p = e1.options.babelrcRoots;
                    }
                    mergeChain(d, n);
                }
                let m, y;
                let T = false;
                const E = emptyChain();
                if ((u === true || u === undefined) && typeof t.filename === "string") {
                    const e1 = yield* (0, l.findPackageData)(t.filename);
                    if (e1 && babelrcLoadEnabled(t, e1, p, f)) {
                        ({ ignore: m, config: y } = yield* (0, l.findRelativeConfig)(e1, t.envName, t.caller));
                        if (m) {
                            E.files.add(m.filepath);
                        }
                        if (m && shouldIgnore(t, m.ignore, null, m.dirname)) {
                            T = true;
                        }
                        if (y && !T) {
                            const e1 = b(y);
                            const r = new i.ConfigPrinter;
                            const s = yield* loadFileChain(e1, t, undefined, r);
                            if (!s) {
                                T = true;
                            } else {
                                n = yield* r.output();
                                mergeChain(E, s);
                            }
                        }
                        if (y && T) {
                            E.files.add(y.filepath);
                        }
                    }
                }
                if (t.showConfig) {
                    console.log(`Babel configs on "${t.filename}" (ascending priority):\n` + [
                        r,
                        n,
                        o
                    ].filter((e1)=>!!e1).join("\n\n") + "\n-----End Babel configs-----");
                }
                const v = mergeChain(mergeChain(mergeChain(emptyChain(), d), E), a);
                return {
                    plugins: T ? [] : dedupDescriptors(v.plugins),
                    presets: T ? [] : dedupDescriptors(v.presets),
                    options: T ? [] : v.options.map((e1)=>normalizeOptions(e1)),
                    fileHandling: T ? "ignored" : "transpile",
                    ignore: m || undefined,
                    babelrc: y || undefined,
                    config: c || undefined,
                    files: v.files
                };
            }
            function babelrcLoadEnabled(e1, t, r, n) {
                if (typeof r === "boolean") return r;
                const i = e1.root;
                if (r === undefined) {
                    return t.directories.indexOf(i) !== -1;
                }
                let a = r;
                if (!Array.isArray(a)) {
                    a = [
                        a
                    ];
                }
                a = a.map((e1)=>typeof e1 === "string" ? _path().resolve(n, e1) : e1);
                if (a.length === 1 && a[0] === i) {
                    return t.directories.indexOf(i) !== -1;
                }
                return a.some((r)=>{
                    if (typeof r === "string") {
                        r = (0, s.default)(r, n);
                    }
                    return t.directories.some((t)=>matchPattern(r, n, t, e1));
                });
            }
            const g = (0, c.makeWeakCacheSync)((e1)=>({
                    filepath: e1.filepath,
                    dirname: e1.dirname,
                    options: (0, n.validate)("configfile", e1.options, e1.filepath)
                }));
            const b = (0, c.makeWeakCacheSync)((e1)=>({
                    filepath: e1.filepath,
                    dirname: e1.dirname,
                    options: (0, n.validate)("babelrcfile", e1.options, e1.filepath)
                }));
            const T = (0, c.makeWeakCacheSync)((e1)=>({
                    filepath: e1.filepath,
                    dirname: e1.dirname,
                    options: (0, n.validate)("extendsfile", e1.options, e1.filepath)
                }));
            const S = makeChainWalker({
                root: (e1)=>buildRootDescriptors(e1, "base", u.createCachedDescriptors),
                env: (e1, t)=>buildEnvDescriptors(e1, "base", u.createCachedDescriptors, t),
                overrides: (e1, t)=>buildOverrideDescriptors(e1, "base", u.createCachedDescriptors, t),
                overridesEnv: (e1, t, r)=>buildOverrideEnvDescriptors(e1, "base", u.createCachedDescriptors, t, r),
                createLogger: (e1, t, r)=>buildProgrammaticLogger(e1, t, r)
            });
            const E = makeChainWalker({
                root: (e1)=>v(e1),
                env: (e1, t)=>x(e1)(t),
                overrides: (e1, t)=>P(e1)(t),
                overridesEnv: (e1, t, r)=>w(e1)(t)(r),
                createLogger: (e1, t, r)=>buildFileLogger(e1.filepath, t, r)
            });
            function* loadFileChain(e1, t, r, n) {
                const s = yield* E(e1, t, r, n);
                if (s) {
                    s.files.add(e1.filepath);
                }
                return s;
            }
            const v = (0, c.makeWeakCacheSync)((e1)=>buildRootDescriptors(e1, e1.filepath, u.createUncachedDescriptors));
            const x = (0, c.makeWeakCacheSync)((e1)=>(0, c.makeStrongCacheSync)((t)=>buildEnvDescriptors(e1, e1.filepath, u.createUncachedDescriptors, t)));
            const P = (0, c.makeWeakCacheSync)((e1)=>(0, c.makeStrongCacheSync)((t)=>buildOverrideDescriptors(e1, e1.filepath, u.createUncachedDescriptors, t)));
            const w = (0, c.makeWeakCacheSync)((e1)=>(0, c.makeStrongCacheSync)((t)=>(0, c.makeStrongCacheSync)((r)=>buildOverrideEnvDescriptors(e1, e1.filepath, u.createUncachedDescriptors, t, r))));
            function buildFileLogger(e1, t, r) {
                if (!r) {
                    return ()=>{};
                }
                return r.configure(t.showConfig, i.ChainFormatter.Config, {
                    filepath: e1
                });
            }
            function buildRootDescriptors({ dirname: e1, options: t }, r, n) {
                return n(e1, t, r);
            }
            function buildProgrammaticLogger(e1, t, r) {
                var n;
                if (!r) {
                    return ()=>{};
                }
                return r.configure(t.showConfig, i.ChainFormatter.Programmatic, {
                    callerName: (n = t.caller) == null ? void 0 : n.name
                });
            }
            function buildEnvDescriptors({ dirname: e1, options: t }, r, n, s) {
                const i = t.env && t.env[s];
                return i ? n(e1, i, `${r}.env["${s}"]`) : null;
            }
            function buildOverrideDescriptors({ dirname: e1, options: t }, r, n, s) {
                const i = t.overrides && t.overrides[s];
                if (!i) throw new Error("Assertion failure - missing override");
                return n(e1, i, `${r}.overrides[${s}]`);
            }
            function buildOverrideEnvDescriptors({ dirname: e1, options: t }, r, n, s, i) {
                const a = t.overrides && t.overrides[s];
                if (!a) throw new Error("Assertion failure - missing override");
                const o = a.env && a.env[i];
                return o ? n(e1, o, `${r}.overrides[${s}].env["${i}"]`) : null;
            }
            function makeChainWalker({ root: e1, env: t, overrides: r, overridesEnv: n, createLogger: s }) {
                return function* chainWalker(i, a, o = new Set, l) {
                    const { dirname: c } = i;
                    const u = [];
                    const p = e1(i);
                    if (configIsApplicable(p, c, a, i.filepath)) {
                        u.push({
                            config: p,
                            envName: undefined,
                            index: undefined
                        });
                        const e1 = t(i, a.envName);
                        if (e1 && configIsApplicable(e1, c, a, i.filepath)) {
                            u.push({
                                config: e1,
                                envName: a.envName,
                                index: undefined
                            });
                        }
                        (p.options.overrides || []).forEach((e1, t)=>{
                            const s = r(i, t);
                            if (configIsApplicable(s, c, a, i.filepath)) {
                                u.push({
                                    config: s,
                                    index: t,
                                    envName: undefined
                                });
                                const e1 = n(i, t, a.envName);
                                if (e1 && configIsApplicable(e1, c, a, i.filepath)) {
                                    u.push({
                                        config: e1,
                                        index: t,
                                        envName: a.envName
                                    });
                                }
                            }
                        });
                    }
                    if (u.some(({ config: { options: { ignore: e1, only: t } } })=>shouldIgnore(a, e1, t, c))) {
                        return null;
                    }
                    const f = emptyChain();
                    const d = s(i, a, l);
                    for (const { config: e1, index: t, envName: r } of u){
                        if (!(yield* mergeExtendsChain(f, e1.options, c, a, o, l))) {
                            return null;
                        }
                        d(e1, t, r);
                        yield* mergeChainOpts(f, e1);
                    }
                    return f;
                };
            }
            function* mergeExtendsChain(e1, t, r, n, s, i) {
                if (t.extends === undefined) return true;
                const a = yield* (0, l.loadConfig)(t.extends, r, n.envName, n.caller);
                if (s.has(a)) {
                    throw new Error(`Configuration cycle detected loading ${a.filepath}.\n` + `File already loaded following the config chain:\n` + Array.from(s, (e1)=>` - ${e1.filepath}`).join("\n"));
                }
                s.add(a);
                const o = yield* loadFileChain(T(a), n, s, i);
                s.delete(a);
                if (!o) return false;
                mergeChain(e1, o);
                return true;
            }
            function mergeChain(e1, t) {
                e1.options.push(...t.options);
                e1.plugins.push(...t.plugins);
                e1.presets.push(...t.presets);
                for (const r of t.files){
                    e1.files.add(r);
                }
                return e1;
            }
            function* mergeChainOpts(e1, { options: t, plugins: r, presets: n }) {
                e1.options.push(t);
                e1.plugins.push(...yield* r());
                e1.presets.push(...yield* n());
                return e1;
            }
            function emptyChain() {
                return {
                    options: [],
                    presets: [],
                    plugins: [],
                    files: new Set
                };
            }
            function normalizeOptions(e1) {
                const t = Object.assign({}, e1);
                delete t.extends;
                delete t.env;
                delete t.overrides;
                delete t.plugins;
                delete t.presets;
                delete t.passPerPreset;
                delete t.ignore;
                delete t.only;
                delete t.test;
                delete t.include;
                delete t.exclude;
                if (Object.prototype.hasOwnProperty.call(t, "sourceMap")) {
                    t.sourceMaps = t.sourceMap;
                    delete t.sourceMap;
                }
                return t;
            }
            function dedupDescriptors(e1) {
                const t = new Map;
                const r = [];
                for (const n of e1){
                    if (typeof n.value === "function") {
                        const e1 = n.value;
                        let s = t.get(e1);
                        if (!s) {
                            s = new Map;
                            t.set(e1, s);
                        }
                        let i = s.get(n.name);
                        if (!i) {
                            i = {
                                value: n
                            };
                            r.push(i);
                            if (!n.ownPass) s.set(n.name, i);
                        } else {
                            i.value = n;
                        }
                    } else {
                        r.push({
                            value: n
                        });
                    }
                }
                return r.reduce((e1, t)=>{
                    e1.push(t.value);
                    return e1;
                }, []);
            }
            function configIsApplicable({ options: e1 }, t, r, n) {
                return (e1.test === undefined || configFieldIsApplicable(r, e1.test, t, n)) && (e1.include === undefined || configFieldIsApplicable(r, e1.include, t, n)) && (e1.exclude === undefined || !configFieldIsApplicable(r, e1.exclude, t, n));
            }
            function configFieldIsApplicable(e1, t, r, n) {
                const s = Array.isArray(t) ? t : [
                    t
                ];
                return matchesPatterns(e1, s, r, n);
            }
            function ignoreListReplacer(e1, t) {
                if (t instanceof RegExp) {
                    return String(t);
                }
                return t;
            }
            function shouldIgnore(e1, t, r, n) {
                if (t && matchesPatterns(e1, t, n)) {
                    var s;
                    const r = `No config is applied to "${(s = e1.filename) != null ? s : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(t, ignoreListReplacer)}\` from "${n}"`;
                    p(r);
                    if (e1.showConfig) {
                        console.log(r);
                    }
                    return true;
                }
                if (r && !matchesPatterns(e1, r, n)) {
                    var i;
                    const t = `No config is applied to "${(i = e1.filename) != null ? i : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(r, ignoreListReplacer)}\` from "${n}"`;
                    p(t);
                    if (e1.showConfig) {
                        console.log(t);
                    }
                    return true;
                }
                return false;
            }
            function matchesPatterns(e1, t, r, n) {
                return t.some((t)=>matchPattern(t, r, e1.filename, e1, n));
            }
            function matchPattern(e1, t, r, n, i) {
                if (typeof e1 === "function") {
                    return !!(0, a.endHiddenCallStack)(e1)(r, {
                        dirname: t,
                        envName: n.envName,
                        caller: n.caller
                    });
                }
                if (typeof r !== "string") {
                    throw new o.default(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`, i);
                }
                if (typeof e1 === "string") {
                    e1 = (0, s.default)(e1, t);
                }
                return e1.test(r);
            }
            0 && 0;
        },
        8680: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createCachedDescriptors = createCachedDescriptors;
            t.createDescriptor = createDescriptor;
            t.createUncachedDescriptors = createUncachedDescriptors;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(128);
            var s = r(4613);
            var i = r(1084);
            var a = r(9608);
            var o = r(9099);
            function isEqualDescriptor(e1, t) {
                return e1.name === t.name && e1.value === t.value && e1.options === t.options && e1.dirname === t.dirname && e1.alias === t.alias && e1.ownPass === t.ownPass && (e1.file && e1.file.request) === (t.file && t.file.request) && (e1.file && e1.file.resolved) === (t.file && t.file.resolved);
            }
            function* handlerOf(e1) {
                return e1;
            }
            function optionsWithResolvedBrowserslistConfigFile(e1, t) {
                if (typeof e1.browserslistConfigFile === "string") {
                    e1.browserslistConfigFile = (0, o.resolveBrowserslistConfigFile)(e1.browserslistConfigFile, t);
                }
                return e1;
            }
            function createCachedDescriptors(e1, t, r) {
                const { plugins: n, presets: s, passPerPreset: i } = t;
                return {
                    options: optionsWithResolvedBrowserslistConfigFile(t, e1),
                    plugins: n ? ()=>p(n, e1)(r) : ()=>handlerOf([]),
                    presets: s ? ()=>c(s, e1)(r)(!!i) : ()=>handlerOf([])
                };
            }
            function createUncachedDescriptors(e1, t, r) {
                return {
                    options: optionsWithResolvedBrowserslistConfigFile(t, e1),
                    plugins: (0, n.once)(()=>createPluginDescriptors(t.plugins || [], e1, r)),
                    presets: (0, n.once)(()=>createPresetDescriptors(t.presets || [], e1, r, !!t.passPerPreset))
                };
            }
            const l = new WeakMap;
            const c = (0, a.makeWeakCacheSync)((e1, t)=>{
                const r = t.using((e1)=>e1);
                return (0, a.makeStrongCacheSync)((t)=>(0, a.makeStrongCache)(function*(n) {
                        const s = yield* createPresetDescriptors(e1, r, t, n);
                        return s.map((e1)=>loadCachedDescriptor(l, e1));
                    }));
            });
            const u = new WeakMap;
            const p = (0, a.makeWeakCacheSync)((e1, t)=>{
                const r = t.using((e1)=>e1);
                return (0, a.makeStrongCache)(function*(t) {
                    const n = yield* createPluginDescriptors(e1, r, t);
                    return n.map((e1)=>loadCachedDescriptor(u, e1));
                });
            });
            const f = {};
            function loadCachedDescriptor(e1, t) {
                const { value: r, options: n = f } = t;
                if (n === false) return t;
                let s = e1.get(r);
                if (!s) {
                    s = new WeakMap;
                    e1.set(r, s);
                }
                let i = s.get(n);
                if (!i) {
                    i = [];
                    s.set(n, i);
                }
                if (i.indexOf(t) === -1) {
                    const e1 = i.filter((e1)=>isEqualDescriptor(e1, t));
                    if (e1.length > 0) {
                        return e1[0];
                    }
                    i.push(t);
                }
                return t;
            }
            function* createPresetDescriptors(e1, t, r, n) {
                return yield* createDescriptors("preset", e1, t, r, n);
            }
            function* createPluginDescriptors(e1, t, r) {
                return yield* createDescriptors("plugin", e1, t, r);
            }
            function* createDescriptors(e1, t, r, n, s) {
                const i = yield* _gensync().all(t.map((t, i)=>createDescriptor(t, r, {
                        type: e1,
                        alias: `${n}$${i}`,
                        ownPass: !!s
                    })));
                assertNoDuplicates(i);
                return i;
            }
            function* createDescriptor(e1, t, { type: r, alias: n, ownPass: a }) {
                const o = (0, i.getItemDescriptor)(e1);
                if (o) {
                    return o;
                }
                let l;
                let c;
                let u = e1;
                if (Array.isArray(u)) {
                    if (u.length === 3) {
                        [u, c, l] = u;
                    } else {
                        [u, c] = u;
                    }
                }
                let p = undefined;
                let f = null;
                if (typeof u === "string") {
                    if (typeof r !== "string") {
                        throw new Error("To resolve a string-based item, the type of item must be given");
                    }
                    const e1 = r === "plugin" ? s.loadPlugin : s.loadPreset;
                    const n = u;
                    ({ filepath: f, value: u } = yield* e1(u, t));
                    p = {
                        request: n,
                        resolved: f
                    };
                }
                if (!u) {
                    throw new Error(`Unexpected falsy value: ${String(u)}`);
                }
                if (typeof u === "object" && u.__esModule) {
                    if (u.default) {
                        u = u.default;
                    } else {
                        throw new Error("Must export a default export when using ES6 modules.");
                    }
                }
                if (typeof u !== "object" && typeof u !== "function") {
                    throw new Error(`Unsupported format: ${typeof u}. Expected an object or a function.`);
                }
                if (f !== null && typeof u === "object" && u) {
                    throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${f}`);
                }
                return {
                    name: l,
                    alias: f || n,
                    value: u,
                    options: c,
                    dirname: t,
                    ownPass: a,
                    file: p
                };
            }
            function assertNoDuplicates(e1) {
                const t = new Map;
                for (const r of e1){
                    if (typeof r.value !== "function") continue;
                    let n = t.get(r.value);
                    if (!n) {
                        n = new Set;
                        t.set(r.value, n);
                    }
                    if (n.has(r.name)) {
                        const t = e1.filter((e1)=>e1.value === r.value);
                        throw new Error([
                            `Duplicate plugin/preset detected.`,
                            `If you'd like to use two separate instances of a plugin,`,
                            `they need separate names, e.g.`,
                            ``,
                            `  plugins: [`,
                            `    ['some-plugin', {}],`,
                            `    ['some-plugin', {}, 'some unique name'],`,
                            `  ]`,
                            ``,
                            `Duplicates detected are:`,
                            `${JSON.stringify(t, null, 2)}`
                        ].join("\n"));
                    }
                    n.add(r.name);
                }
            }
            0 && 0;
        },
        2777: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ROOT_CONFIG_FILENAMES = void 0;
            t.findConfigUpwards = findConfigUpwards;
            t.findRelativeConfig = findRelativeConfig;
            t.findRootConfig = findRootConfig;
            t.loadConfig = loadConfig;
            t.resolveShowConfigPath = resolveShowConfigPath;
            function _debug() {
                const e1 = r(6937);
                _debug = function() {
                    return e1;
                };
                return e1;
            }
            function _fs() {
                const e1 = r(7147);
                _fs = function() {
                    return e1;
                };
                return e1;
            }
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function _json() {
                const e1 = r(8310);
                _json = function() {
                    return e1;
                };
                return e1;
            }
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(9608);
            var s = r(8836);
            var i = r(6727);
            var a = r(4759);
            var o = r(1034);
            var l = r(8208);
            var c = r(9724);
            var u = r(3585);
            const p = _debug()("babel:config:loading:files:configuration");
            const f = [
                "babel.config.js",
                "babel.config.cjs",
                "babel.config.mjs",
                "babel.config.json",
                "babel.config.cts"
            ];
            t.ROOT_CONFIG_FILENAMES = f;
            const d = [
                ".babelrc",
                ".babelrc.js",
                ".babelrc.cjs",
                ".babelrc.mjs",
                ".babelrc.json",
                ".babelrc.cts"
            ];
            const h = ".babelignore";
            const m = new Set;
            const y = (0, n.makeStrongCache)(function* readConfigCode(e1, t) {
                if (!_fs().existsSync(e1)) {
                    t.never();
                    return null;
                }
                if (m.has(e1)) {
                    t.never();
                    p("Auto-ignoring usage of config %o.", e1);
                    return {
                        filepath: e1,
                        dirname: _path().dirname(e1),
                        options: {}
                    };
                }
                let r;
                try {
                    m.add(e1);
                    r = yield* (0, a.default)(e1, "You appear to be using a native ECMAScript module configuration " + "file, which is only supported when running Babel asynchronously.");
                } finally{
                    m.delete(e1);
                }
                let n = false;
                if (typeof r === "function") {
                    yield* [];
                    r = (0, u.endHiddenCallStack)(r)((0, s.makeConfigAPI)(t));
                    n = true;
                }
                if (!r || typeof r !== "object" || Array.isArray(r)) {
                    throw new l.default(`Configuration should be an exported JavaScript object.`, e1);
                }
                if (typeof r.then === "function") {
                    throw new l.default(`You appear to be using an async configuration, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously return your config.`, e1);
                }
                if (n && !t.configured()) throwConfigError(e1);
                return {
                    filepath: e1,
                    dirname: _path().dirname(e1),
                    options: r
                };
            });
            const g = (0, n.makeWeakCacheSync)((e1)=>{
                const t = e1.options["babel"];
                if (typeof t === "undefined") return null;
                if (typeof t !== "object" || Array.isArray(t) || t === null) {
                    throw new l.default(`.babel property must be an object`, e1.filepath);
                }
                return {
                    filepath: e1.filepath,
                    dirname: e1.dirname,
                    options: t
                };
            });
            const b = (0, i.makeStaticFileCache)((e1, t)=>{
                let r;
                try {
                    r = _json().parse(t);
                } catch (t) {
                    throw new l.default(`Error while parsing config - ${t.message}`, e1);
                }
                if (!r) throw new l.default(`No config detected`, e1);
                if (typeof r !== "object") {
                    throw new l.default(`Config returned typeof ${typeof r}`, e1);
                }
                if (Array.isArray(r)) {
                    throw new l.default(`Expected config object but found array`, e1);
                }
                delete r["$schema"];
                return {
                    filepath: e1,
                    dirname: _path().dirname(e1),
                    options: r
                };
            });
            const T = (0, i.makeStaticFileCache)((e1, t)=>{
                const r = _path().dirname(e1);
                const n = t.split("\n").map((e1)=>e1.replace(/#(.*?)$/, "").trim()).filter((e1)=>!!e1);
                for (const t of n){
                    if (t[0] === "!") {
                        throw new l.default(`Negation of file paths is not supported.`, e1);
                    }
                }
                return {
                    filepath: e1,
                    dirname: _path().dirname(e1),
                    ignore: n.map((e1)=>(0, o.default)(e1, r))
                };
            });
            function findConfigUpwards(e1) {
                let t = e1;
                for(;;){
                    for (const e1 of f){
                        if (_fs().existsSync(_path().join(t, e1))) {
                            return t;
                        }
                    }
                    const e1 = _path().dirname(t);
                    if (t === e1) break;
                    t = e1;
                }
                return null;
            }
            function* findRelativeConfig(e1, t, r) {
                let n = null;
                let s = null;
                const i = _path().dirname(e1.filepath);
                for (const o of e1.directories){
                    if (!n) {
                        var a;
                        n = yield* loadOneConfig(d, o, t, r, ((a = e1.pkg) == null ? void 0 : a.dirname) === o ? g(e1.pkg) : null);
                    }
                    if (!s) {
                        const e1 = _path().join(o, h);
                        s = yield* T(e1);
                        if (s) {
                            p("Found ignore %o from %o.", s.filepath, i);
                        }
                    }
                }
                return {
                    config: n,
                    ignore: s
                };
            }
            function findRootConfig(e1, t, r) {
                return loadOneConfig(f, e1, t, r);
            }
            function* loadOneConfig(e1, t, r, n, s = null) {
                const i = yield* _gensync().all(e1.map((e1)=>readConfig(_path().join(t, e1), r, n)));
                const a = i.reduce((e1, r)=>{
                    if (r && e1) {
                        throw new l.default(`Multiple configuration files found. Please remove one:\n` + ` - ${_path().basename(e1.filepath)}\n` + ` - ${r.filepath}\n` + `from ${t}`);
                    }
                    return r || e1;
                }, s);
                if (a) {
                    p("Found configuration %o from %o.", a.filepath, t);
                }
                return a;
            }
            function* loadConfig(e1, t, n, s) {
                const i = (((e1, t)=>(e1 = e1.split("."), t = t.split("."), +e1[0] > +t[0] || e1[0] == t[0] && +e1[1] >= +t[1]))(process.versions.node, "8.9") ? require.resolve : (e1, { paths: [t] }, n = r(8188))=>{
                    let s = n._findPath(e1, n._nodeModulePaths(t).concat(t));
                    if (s) return s;
                    s = new Error(`Cannot resolve module '${e1}'`);
                    s.code = "MODULE_NOT_FOUND";
                    throw s;
                })(e1, {
                    paths: [
                        t
                    ]
                });
                const a = yield* readConfig(i, n, s);
                if (!a) {
                    throw new l.default(`Config file contains no configuration data`, i);
                }
                p("Loaded config %o from %o.", e1, t);
                return a;
            }
            function readConfig(e1, t, r) {
                const n = _path().extname(e1);
                switch(n){
                    case ".js":
                    case ".cjs":
                    case ".mjs":
                    case ".cts":
                        return y(e1, {
                            envName: t,
                            caller: r
                        });
                    default:
                        return b(e1);
                }
            }
            function* resolveShowConfigPath(e1) {
                const t = process.env.BABEL_SHOW_CONFIG_FOR;
                if (t != null) {
                    const r = _path().resolve(e1, t);
                    const n = yield* c.stat(r);
                    if (!n.isFile()) {
                        throw new Error(`${r}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
                    }
                    return r;
                }
                return null;
            }
            function throwConfigError(e1) {
                throw new l.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured\nfor various types of caching, using the first param of their handler functions:\n\nmodule.exports = function(api) {\n  // The API exposes the following:\n\n  // Cache the returned value forever and don't call this function again.\n  api.cache(true);\n\n  // Don't cache at all. Not recommended because it will be very slow.\n  api.cache(false);\n\n  // Cached based on the value of some function. If this function returns a value different from\n  // a previously-encountered value, the plugins will re-evaluate.\n  var env = api.cache(() => process.env.NODE_ENV);\n\n  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for\n  // any possible NODE_ENV value that might come up during plugin execution.\n  var isProd = api.cache(() => process.env.NODE_ENV === "production");\n\n  // .cache(fn) will perform a linear search though instances to find the matching plugin based\n  // based on previous instantiated plugins. If you want to recreate the plugin and discard the\n  // previous instance whenever something changes, you may use:\n  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");\n\n  // Note, we also expose the following more-verbose versions of the above examples:\n  api.cache.forever(); // api.cache(true)\n  api.cache.never();   // api.cache(false)\n  api.cache.using(fn); // api.cache(fn)\n\n  // Return the value that will be cached.\n  return { };\n};`, e1);
            }
            0 && 0;
        },
        1503: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = resolve;
            var n = r(5655);
            let s;
            {
                s = n.resolve;
            }
            function resolve(e1, t) {
                return s(e1, t);
            }
            0 && 0;
        },
        4613: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "ROOT_CONFIG_FILENAMES", {
                enumerable: true,
                get: function() {
                    return s.ROOT_CONFIG_FILENAMES;
                }
            });
            Object.defineProperty(t, "findConfigUpwards", {
                enumerable: true,
                get: function() {
                    return s.findConfigUpwards;
                }
            });
            Object.defineProperty(t, "findPackageData", {
                enumerable: true,
                get: function() {
                    return n.findPackageData;
                }
            });
            Object.defineProperty(t, "findRelativeConfig", {
                enumerable: true,
                get: function() {
                    return s.findRelativeConfig;
                }
            });
            Object.defineProperty(t, "findRootConfig", {
                enumerable: true,
                get: function() {
                    return s.findRootConfig;
                }
            });
            Object.defineProperty(t, "loadConfig", {
                enumerable: true,
                get: function() {
                    return s.loadConfig;
                }
            });
            Object.defineProperty(t, "loadPlugin", {
                enumerable: true,
                get: function() {
                    return i.loadPlugin;
                }
            });
            Object.defineProperty(t, "loadPreset", {
                enumerable: true,
                get: function() {
                    return i.loadPreset;
                }
            });
            Object.defineProperty(t, "resolvePlugin", {
                enumerable: true,
                get: function() {
                    return i.resolvePlugin;
                }
            });
            Object.defineProperty(t, "resolvePreset", {
                enumerable: true,
                get: function() {
                    return i.resolvePreset;
                }
            });
            Object.defineProperty(t, "resolveShowConfigPath", {
                enumerable: true,
                get: function() {
                    return s.resolveShowConfigPath;
                }
            });
            var n = r(9369);
            var s = r(2777);
            var i = r(2767);
            ({});
            0 && 0;
        },
        4759: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = loadCodeDefault;
            t.supportsESM = void 0;
            var n = r(9367);
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function _url() {
                const e1 = r(7310);
                _url = function() {
                    return e1;
                };
                return e1;
            }
            function _semver() {
                const e1 = r(7849);
                _semver = function() {
                    return e1;
                };
                return e1;
            }
            var s = r(3585);
            var i = r(8208);
            var a = r(5885);
            function asyncGeneratorStep(e1, t, r, n, s, i, a) {
                try {
                    var o = e1[i](a);
                    var l = o.value;
                } catch (e1) {
                    r(e1);
                    return;
                }
                if (o.done) {
                    t(l);
                } else {
                    Promise.resolve(l).then(n, s);
                }
            }
            function _asyncToGenerator(e1) {
                return function() {
                    var t = this, r = arguments;
                    return new Promise(function(n, s) {
                        var i = e1.apply(t, r);
                        function _next(e1) {
                            asyncGeneratorStep(i, n, s, _next, _throw, "next", e1);
                        }
                        function _throw(e1) {
                            asyncGeneratorStep(i, n, s, _next, _throw, "throw", e1);
                        }
                        _next(undefined);
                    });
                };
            }
            let o;
            try {
                o = r(8204);
            } catch (e1) {}
            const l = _semver().satisfies(process.versions.node, "^12.17 || >=13.2");
            t.supportsESM = l;
            function* loadCodeDefault(e1, t) {
                switch(_path().extname(e1)){
                    case ".cjs":
                        {
                            return loadCjsDefault(e1, arguments[2]);
                        }
                    case ".mjs":
                        break;
                    case ".cts":
                        return loadCtsDefault(e1);
                    default:
                        try {
                            {
                                return loadCjsDefault(e1, arguments[2]);
                            }
                        } catch (e1) {
                            if (e1.code !== "ERR_REQUIRE_ESM") throw e1;
                        }
                }
                if (yield* (0, n.isAsync)()) {
                    return yield* (0, n.waitFor)(loadMjsDefault(e1));
                }
                throw new i.default(t, e1);
            }
            function loadCtsDefault(e1) {
                const t = ".cts";
                const n = !!(require.extensions[".ts"] || require.extensions[".cts"] || require.extensions[".mts"]);
                let i;
                if (!n) {
                    const s = {
                        babelrc: false,
                        configFile: false,
                        sourceType: "unambiguous",
                        sourceMaps: "inline",
                        sourceFileName: _path().basename(e1),
                        presets: [
                            [
                                getTSPreset(e1),
                                Object.assign({
                                    onlyRemoveTypeImports: true,
                                    optimizeConstEnums: true
                                }, {
                                    allowDeclareFields: true
                                })
                            ]
                        ]
                    };
                    i = function(e1, o) {
                        if (i && o.endsWith(t)) {
                            try {
                                return e1._compile((0, a.transformFileSync)(o, Object.assign({}, s, {
                                    filename: o
                                })).code, o);
                            } catch (e1) {
                                if (!n) {
                                    const e1 = r(8819);
                                    if (_semver().lt(e1.version, "7.21.4")) {
                                        console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-typescript`.");
                                    }
                                }
                                throw e1;
                            }
                        }
                        return require.extensions[".js"](e1, o);
                    };
                    require.extensions[t] = i;
                }
                try {
                    const r = (0, s.endHiddenCallStack)(require)(e1);
                    return r != null && r.__esModule ? r.default : r;
                } finally{
                    if (!n) {
                        if (require.extensions[t] === i) delete require.extensions[t];
                        i = undefined;
                    }
                }
            }
            function loadCjsDefault(e1) {
                const t = (0, s.endHiddenCallStack)(require)(e1);
                {
                    return t != null && t.__esModule ? t.default || (arguments[1] ? t : undefined) : t;
                }
            }
            function loadMjsDefault(e1) {
                return _loadMjsDefault.apply(this, arguments);
            }
            function _loadMjsDefault() {
                _loadMjsDefault = _asyncToGenerator(function*(e1) {
                    if (!o) {
                        throw new i.default("Internal error: Native ECMAScript modules aren't supported by this platform.\n", e1);
                    }
                    const t = yield (0, s.endHiddenCallStack)(o)((0, _url().pathToFileURL)(e1));
                    return t.default;
                });
                return _loadMjsDefault.apply(this, arguments);
            }
            function getTSPreset(e1) {
                try {
                    return r(5432);
                } catch (t) {
                    if (t.code !== "MODULE_NOT_FOUND") throw t;
                    let r = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please install it!";
                    {
                        if (process.versions.pnp) {
                            r += `\nIf you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:\n\npackageExtensions:\n\t"@babel/core@*":\n\t\tpeerDependencies:\n\t\t\t"@babel/preset-typescript": "*"\n`;
                        }
                    }
                    throw new i.default(r, e1);
                }
            }
            0 && 0;
        },
        9369: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.findPackageData = findPackageData;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(6727);
            var s = r(8208);
            const i = "package.json";
            const a = (0, n.makeStaticFileCache)((e1, t)=>{
                let r;
                try {
                    r = JSON.parse(t);
                } catch (t) {
                    throw new s.default(`Error while parsing JSON - ${t.message}`, e1);
                }
                if (!r) throw new Error(`${e1}: No config detected`);
                if (typeof r !== "object") {
                    throw new s.default(`Config returned typeof ${typeof r}`, e1);
                }
                if (Array.isArray(r)) {
                    throw new s.default(`Expected config object but found array`, e1);
                }
                return {
                    filepath: e1,
                    dirname: _path().dirname(e1),
                    options: r
                };
            });
            function* findPackageData(e1) {
                let t = null;
                const r = [];
                let n = true;
                let s = _path().dirname(e1);
                while(!t && _path().basename(s) !== "node_modules"){
                    r.push(s);
                    t = yield* a(_path().join(s, i));
                    const e1 = _path().dirname(s);
                    if (s === e1) {
                        n = false;
                        break;
                    }
                    s = e1;
                }
                return {
                    filepath: e1,
                    directories: r,
                    pkg: t,
                    isPackage: n
                };
            }
            0 && 0;
        },
        2767: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.loadPlugin = loadPlugin;
            t.loadPreset = loadPreset;
            t.resolvePreset = t.resolvePlugin = void 0;
            function _debug() {
                const e1 = r(6937);
                _debug = function() {
                    return e1;
                };
                return e1;
            }
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(9367);
            var s = r(4759);
            function _url() {
                const e1 = r(7310);
                _url = function() {
                    return e1;
                };
                return e1;
            }
            var i = r(1503);
            const a = _debug()("babel:config:loading:files:plugins");
            const o = /^module:/;
            const l = /^(?!@|module:|[^/]+\/|babel-plugin-)/;
            const c = /^(?!@|module:|[^/]+\/|babel-preset-)/;
            const u = /^(@babel\/)(?!plugin-|[^/]+\/)/;
            const p = /^(@babel\/)(?!preset-|[^/]+\/)/;
            const f = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/;
            const d = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/;
            const h = /^(@(?!babel$)[^/]+)$/;
            const m = resolveStandardizedName.bind(null, "plugin");
            t.resolvePlugin = m;
            const y = resolveStandardizedName.bind(null, "preset");
            t.resolvePreset = y;
            function* loadPlugin(e1, t) {
                const r = m(e1, t, (yield* (0, n.isAsync)()));
                const s = yield* requireModule("plugin", r);
                a("Loaded plugin %o from %o.", e1, t);
                return {
                    filepath: r,
                    value: s
                };
            }
            function* loadPreset(e1, t) {
                const r = y(e1, t, (yield* (0, n.isAsync)()));
                const s = yield* requireModule("preset", r);
                a("Loaded preset %o from %o.", e1, t);
                return {
                    filepath: r,
                    value: s
                };
            }
            function standardizeName(e1, t) {
                if (_path().isAbsolute(t)) return t;
                const r = e1 === "preset";
                return t.replace(r ? c : l, `babel-${e1}-`).replace(r ? p : u, `$1${e1}-`).replace(r ? d : f, `$1babel-${e1}-`).replace(h, `$1/babel-${e1}`).replace(o, "");
            }
            function* resolveAlternativesHelper(e1, t) {
                const r = standardizeName(e1, t);
                const { error: n, value: s } = yield r;
                if (!n) return s;
                if (n.code !== "MODULE_NOT_FOUND") throw n;
                if (r !== t && !(yield t).error) {
                    n.message += `\n- If you want to resolve "${t}", use "module:${t}"`;
                }
                if (!(yield standardizeName(e1, "@babel/" + t)).error) {
                    n.message += `\n- Did you mean "@babel/${t}"?`;
                }
                const i = e1 === "preset" ? "plugin" : "preset";
                if (!(yield standardizeName(i, t)).error) {
                    n.message += `\n- Did you accidentally pass a ${i} as a ${e1}?`;
                }
                if (e1 === "plugin") {
                    const e1 = r.replace("-proposal-", "-transform-");
                    if (e1 !== r && !(yield e1).error) {
                        n.message += `\n- Did you mean "${e1}"?`;
                    }
                }
                n.message += `\n\nMake sure that all the Babel plugins and presets you are using\nare defined as dependencies or devDependencies in your package.json\nfile. It's possible that the missing plugin is loaded by a preset\nyou are using that forgot to add the plugin to its dependencies: you\ncan workaround this problem by explicitly adding the missing package\nto your top-level package.json.\n`;
                throw n;
            }
            function tryRequireResolve(e1, t) {
                try {
                    if (t) {
                        return {
                            error: null,
                            value: (((e1, t)=>(e1 = e1.split("."), t = t.split("."), +e1[0] > +t[0] || e1[0] == t[0] && +e1[1] >= +t[1]))(process.versions.node, "8.9") ? require.resolve : (e1, { paths: [t] }, n = r(8188))=>{
                                let s = n._findPath(e1, n._nodeModulePaths(t).concat(t));
                                if (s) return s;
                                s = new Error(`Cannot resolve module '${e1}'`);
                                s.code = "MODULE_NOT_FOUND";
                                throw s;
                            })(e1, {
                                paths: [
                                    t
                                ]
                            })
                        };
                    } else {
                        return {
                            error: null,
                            value: (()=>{
                                const e1 = new Error("Cannot find module as expression is too dynamic");
                                e1.code = 'MODULE_NOT_FOUND';
                                throw e1;
                            })()
                        };
                    }
                } catch (e1) {
                    return {
                        error: e1,
                        value: null
                    };
                }
            }
            function tryImportMetaResolve(e1, t) {
                try {
                    return {
                        error: null,
                        value: (0, i.default)(e1, t)
                    };
                } catch (e1) {
                    return {
                        error: e1,
                        value: null
                    };
                }
            }
            function resolveStandardizedNameForRequire(e1, t, r) {
                const n = resolveAlternativesHelper(e1, t);
                let s = n.next();
                while(!s.done){
                    s = n.next(tryRequireResolve(s.value, r));
                }
                return s.value;
            }
            function resolveStandardizedNameForImport(e1, t, r) {
                const n = (0, _url().pathToFileURL)(_path().join(r, "./babel-virtual-resolve-base.js")).href;
                const s = resolveAlternativesHelper(e1, t);
                let i = s.next();
                while(!i.done){
                    i = s.next(tryImportMetaResolve(i.value, n));
                }
                return (0, _url().fileURLToPath)(i.value);
            }
            function resolveStandardizedName(e1, t, r, n) {
                if (!s.supportsESM || !n) {
                    return resolveStandardizedNameForRequire(e1, t, r);
                }
                try {
                    return resolveStandardizedNameForImport(e1, t, r);
                } catch (n) {
                    try {
                        return resolveStandardizedNameForRequire(e1, t, r);
                    } catch (e1) {
                        if (n.type === "MODULE_NOT_FOUND") throw n;
                        if (e1.type === "MODULE_NOT_FOUND") throw e1;
                        throw n;
                    }
                }
            }
            {
                var g = new Set;
            }
            function* requireModule(e1, t) {
                {
                    if (!(yield* (0, n.isAsync)()) && g.has(t)) {
                        throw new Error(`Reentrant ${e1} detected trying to load "${t}". This module is not ignored ` + "and is trying to load itself while compiling itself, leading to a dependency cycle. " + 'We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.');
                    }
                }
                try {
                    {
                        g.add(t);
                    }
                    {
                        return yield* (0, s.default)(t, `You appear to be using a native ECMAScript module ${e1}, ` + "which is only supported when running Babel asynchronously.", true);
                    }
                } catch (e1) {
                    e1.message = `[BABEL]: ${e1.message} (While processing: ${t})`;
                    throw e1;
                } finally{
                    {
                        g.delete(t);
                    }
                }
            }
            0 && 0;
        },
        6727: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.makeStaticFileCache = makeStaticFileCache;
            var n = r(9608);
            var s = r(9724);
            function _fs2() {
                const e1 = r(7147);
                _fs2 = function() {
                    return e1;
                };
                return e1;
            }
            function makeStaticFileCache(e1) {
                return (0, n.makeStrongCache)(function*(t, r) {
                    const n = r.invalidate(()=>fileMtime(t));
                    if (n === null) {
                        return null;
                    }
                    return e1(t, (yield* s.readFile(t, "utf8")));
                });
            }
            function fileMtime(e1) {
                if (!_fs2().existsSync(e1)) return null;
                try {
                    return +_fs2().statSync(e1).mtime;
                } catch (e1) {
                    if (e1.code !== "ENOENT" && e1.code !== "ENOTDIR") throw e1;
                }
                return null;
            }
            0 && 0;
        },
        402: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(9367);
            var s = r(7376);
            var i = r(3688);
            var a = r(7916);
            var o = r(1084);
            var l = r(4672);
            var c = r(9435);
            function _traverse() {
                const e1 = r(2297);
                _traverse = function() {
                    return e1;
                };
                return e1;
            }
            var u = r(9608);
            var p = r(2420);
            var f = r(4059);
            var d = r(8836);
            var h = r(1949);
            var m = r(8208);
            var y = _gensync()(function* loadFullConfig(e1) {
                var t;
                const r = yield* (0, h.default)(e1);
                if (!r) {
                    return null;
                }
                const { options: n, context: i, fileHandling: a } = r;
                if (a === "ignored") {
                    return null;
                }
                const l = {};
                const { plugins: u, presets: f } = n;
                if (!u || !f) {
                    throw new Error("Assertion failure - plugins and presets exist");
                }
                const d = Object.assign({}, i, {
                    targets: n.targets
                });
                const toDescriptor = (e1)=>{
                    const t = (0, o.getItemDescriptor)(e1);
                    if (!t) {
                        throw new Error("Assertion failure - must be config item");
                    }
                    return t;
                };
                const m = f.map(toDescriptor);
                const y = u.map(toDescriptor);
                const g = [
                    []
                ];
                const b = [];
                const T = [];
                const S = yield* enhanceError(i, function* recursePresetDescriptors(e1, t) {
                    const r = [];
                    for(let s = 0; s < e1.length; s++){
                        const i = e1[s];
                        if (i.options !== false) {
                            try {
                                var n = yield* loadPresetDescriptor(i, d);
                            } catch (t) {
                                if (t.code === "BABEL_UNKNOWN_OPTION") {
                                    (0, p.checkNoUnwrappedItemOptionPairs)(e1, s, "preset", t);
                                }
                                throw t;
                            }
                            T.push(n.externalDependencies);
                            if (i.ownPass) {
                                r.push({
                                    preset: n.chain,
                                    pass: []
                                });
                            } else {
                                r.unshift({
                                    preset: n.chain,
                                    pass: t
                                });
                            }
                        }
                    }
                    if (r.length > 0) {
                        g.splice(1, 0, ...r.map((e1)=>e1.pass).filter((e1)=>e1 !== t));
                        for (const { preset: e1, pass: t } of r){
                            if (!e1) return true;
                            t.push(...e1.plugins);
                            const r = yield* recursePresetDescriptors(e1.presets, t);
                            if (r) return true;
                            e1.options.forEach((e1)=>{
                                (0, s.mergeOptions)(l, e1);
                            });
                        }
                    }
                })(m, g[0]);
                if (S) return null;
                const E = l;
                (0, s.mergeOptions)(E, n);
                const v = Object.assign({}, d, {
                    assumptions: (t = E.assumptions) != null ? t : {}
                });
                yield* enhanceError(i, function* loadPluginDescriptors() {
                    g[0].unshift(...y);
                    for (const t of g){
                        const r = [];
                        b.push(r);
                        for(let n = 0; n < t.length; n++){
                            const s = t[n];
                            if (s.options !== false) {
                                try {
                                    var e1 = yield* loadPluginDescriptor(s, v);
                                } catch (e1) {
                                    if (e1.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY") {
                                        (0, p.checkNoUnwrappedItemOptionPairs)(t, n, "plugin", e1);
                                    }
                                    throw e1;
                                }
                                r.push(e1);
                                T.push(e1.externalDependencies);
                            }
                        }
                    }
                })();
                E.plugins = b[0];
                E.presets = b.slice(1).filter((e1)=>e1.length > 0).map((e1)=>({
                        plugins: e1
                    }));
                E.passPerPreset = E.presets.length > 0;
                return {
                    options: E,
                    passes: b,
                    externalDependencies: (0, c.finalize)(T)
                };
            });
            t["default"] = y;
            function enhanceError(e1, t) {
                return function*(r, n) {
                    try {
                        return yield* t(r, n);
                    } catch (t) {
                        if (!/^\[BABEL\]/.test(t.message)) {
                            var s;
                            t.message = `[BABEL] ${(s = e1.filename) != null ? s : "unknown file"}: ${t.message}`;
                        }
                        throw t;
                    }
                };
            }
            const makeDescriptorLoader = (e1)=>(0, u.makeWeakCache)(function*({ value: t, options: r, dirname: s, alias: a }, o) {
                    if (r === false) throw new Error("Assertion failure");
                    r = r || {};
                    const l = [];
                    let u = t;
                    if (typeof t === "function") {
                        const c = (0, n.maybeAsync)(t, `You appear to be using an async plugin/preset, but Babel has been called synchronously`);
                        const p = Object.assign({}, i, e1(o, l));
                        try {
                            u = yield* c(p, r, s);
                        } catch (e1) {
                            if (a) {
                                e1.message += ` (While processing: ${JSON.stringify(a)})`;
                            }
                            throw e1;
                        }
                    }
                    if (!u || typeof u !== "object") {
                        throw new Error("Plugin/Preset did not return an object.");
                    }
                    if ((0, n.isThenable)(u)) {
                        yield* [];
                        throw new Error(`You appear to be using a promise as a plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version. ` + `As an alternative, you can prefix the promise with "await". ` + `(While processing: ${JSON.stringify(a)})`);
                    }
                    if (l.length > 0 && (!o.configured() || o.mode() === "forever")) {
                        let e1 = `A plugin/preset has external untracked dependencies ` + `(${l[0]}), but the cache `;
                        if (!o.configured()) {
                            e1 += `has not been configured to be invalidated when the external dependencies change. `;
                        } else {
                            e1 += ` has been configured to never be invalidated. `;
                        }
                        e1 += `Plugins/presets should configure their cache to be invalidated when the external ` + `dependencies change, for example using \`api.cache.invalidate(() => ` + `statSync(filepath).mtimeMs)\` or \`api.cache.never()\`\n` + `(While processing: ${JSON.stringify(a)})`;
                        throw new Error(e1);
                    }
                    return {
                        value: u,
                        options: r,
                        dirname: s,
                        alias: a,
                        externalDependencies: (0, c.finalize)(l)
                    };
                });
            const g = makeDescriptorLoader(d.makePluginAPI);
            const b = makeDescriptorLoader(d.makePresetAPI);
            const T = (0, u.makeWeakCache)(function*({ value: e1, options: t, dirname: r, alias: s, externalDependencies: i }, o) {
                const l = (0, f.validatePluginObject)(e1);
                const u = Object.assign({}, l);
                if (u.visitor) {
                    u.visitor = _traverse().default.explode(Object.assign({}, u.visitor));
                }
                if (u.inherits) {
                    const e1 = {
                        name: undefined,
                        alias: `${s}$inherits`,
                        value: u.inherits,
                        options: t,
                        dirname: r
                    };
                    const a = yield* (0, n.forwardAsync)(loadPluginDescriptor, (t)=>o.invalidate((r)=>t(e1, r)));
                    u.pre = chain(a.pre, u.pre);
                    u.post = chain(a.post, u.post);
                    u.manipulateOptions = chain(a.manipulateOptions, u.manipulateOptions);
                    u.visitor = _traverse().default.visitors.merge([
                        a.visitor || {},
                        u.visitor || {}
                    ]);
                    if (a.externalDependencies.length > 0) {
                        if (i.length === 0) {
                            i = a.externalDependencies;
                        } else {
                            i = (0, c.finalize)([
                                i,
                                a.externalDependencies
                            ]);
                        }
                    }
                }
                return new a.default(u, t, s, i);
            });
            function* loadPluginDescriptor(e1, t) {
                if (e1.value instanceof a.default) {
                    if (e1.options) {
                        throw new Error("Passed options to an existing Plugin instance will not work.");
                    }
                    return e1.value;
                }
                return yield* T((yield* g(e1, t)), t);
            }
            const needsFilename = (e1)=>e1 && typeof e1 !== "function";
            const validateIfOptionNeedsFilename = (e1, t)=>{
                if (needsFilename(e1.test) || needsFilename(e1.include) || needsFilename(e1.exclude)) {
                    const e1 = t.name ? `"${t.name}"` : "/* your preset */";
                    throw new m.default([
                        `Preset ${e1} requires a filename to be set when babel is called directly,`,
                        `\`\`\``,
                        `babel.transformSync(code, { filename: 'file.ts', presets: [${e1}] });`,
                        `\`\`\``,
                        `See https://babeljs.io/docs/en/options#filename for more information.`
                    ].join("\n"));
                }
            };
            const validatePreset = (e1, t, r)=>{
                if (!t.filename) {
                    const { options: t } = e1;
                    validateIfOptionNeedsFilename(t, r);
                    if (t.overrides) {
                        t.overrides.forEach((e1)=>validateIfOptionNeedsFilename(e1, r));
                    }
                }
            };
            const S = (0, u.makeWeakCacheSync)(({ value: e1, dirname: t, alias: r, externalDependencies: n })=>({
                    options: (0, p.validate)("preset", e1),
                    alias: r,
                    dirname: t,
                    externalDependencies: n
                }));
            function* loadPresetDescriptor(e1, t) {
                const r = S((yield* b(e1, t)));
                validatePreset(r, t, e1);
                return {
                    chain: yield* (0, l.buildPresetChain)(r, t),
                    externalDependencies: r.externalDependencies
                };
            }
            function chain(e1, t) {
                const r = [
                    e1,
                    t
                ].filter(Boolean);
                if (r.length <= 1) return r[0];
                return function(...e1) {
                    for (const t of r){
                        t.apply(this, e1);
                    }
                };
            }
            0 && 0;
        },
        8836: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.makeConfigAPI = makeConfigAPI;
            t.makePluginAPI = makePluginAPI;
            t.makePresetAPI = makePresetAPI;
            function _semver() {
                const e1 = r(7849);
                _semver = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(3688);
            var s = r(9608);
            function makeConfigAPI(e1) {
                const env = (t)=>e1.using((e1)=>{
                        if (typeof t === "undefined") return e1.envName;
                        if (typeof t === "function") {
                            return (0, s.assertSimpleType)(t(e1.envName));
                        }
                        return (Array.isArray(t) ? t : [
                            t
                        ]).some((t)=>{
                            if (typeof t !== "string") {
                                throw new Error("Unexpected non-string value");
                            }
                            return t === e1.envName;
                        });
                    });
                const caller = (t)=>e1.using((e1)=>(0, s.assertSimpleType)(t(e1.caller)));
                return {
                    version: n.version,
                    cache: e1.simple(),
                    env: env,
                    async: ()=>false,
                    caller: caller,
                    assertVersion: assertVersion
                };
            }
            function makePresetAPI(e1, t) {
                const targets = ()=>JSON.parse(e1.using((e1)=>JSON.stringify(e1.targets)));
                const addExternalDependency = (e1)=>{
                    t.push(e1);
                };
                return Object.assign({}, makeConfigAPI(e1), {
                    targets: targets,
                    addExternalDependency: addExternalDependency
                });
            }
            function makePluginAPI(e1, t) {
                const assumption = (t)=>e1.using((e1)=>e1.assumptions[t]);
                return Object.assign({}, makePresetAPI(e1, t), {
                    assumption: assumption
                });
            }
            function assertVersion(e1) {
                if (typeof e1 === "number") {
                    if (!Number.isInteger(e1)) {
                        throw new Error("Expected string or integer value.");
                    }
                    e1 = `^${e1}.0.0-0`;
                }
                if (typeof e1 !== "string") {
                    throw new Error("Expected string or integer value.");
                }
                if (_semver().satisfies(n.version, e1)) return;
                const t = Error.stackTraceLimit;
                if (typeof t === "number" && t < 25) {
                    Error.stackTraceLimit = 25;
                }
                const r = new Error(`Requires Babel "${e1}", but was loaded with "${n.version}". ` + `If you are sure you have a compatible version of @babel/core, ` + `it is likely that something in your build process is loading the ` + `wrong version. Inspect the stack trace of this error to look for ` + `the first entry that doesn't mention "@babel/core" or "babel-core" ` + `to see what is calling Babel.`);
                if (typeof t === "number") {
                    Error.stackTraceLimit = t;
                }
                throw Object.assign(r, {
                    code: "BABEL_VERSION_UNSUPPORTED",
                    version: n.version,
                    range: e1
                });
            }
            0 && 0;
        },
        9435: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.finalize = finalize;
            t.flattenToSet = flattenToSet;
            function finalize(e1) {
                return Object.freeze(e1);
            }
            function flattenToSet(e1) {
                const t = new Set;
                const r = [
                    e1
                ];
                while(r.length > 0){
                    for (const e1 of r.pop()){
                        if (Array.isArray(e1)) r.push(e1);
                        else t.add(e1);
                    }
                }
                return t;
            }
            0 && 0;
        },
        9658: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.getEnv = getEnv;
            function getEnv(e1 = "development") {
                return process.env.BABEL_ENV || ("TURBOPACK compile-time value", "development") || e1;
            }
            0 && 0;
        },
        4455: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createConfigItem = createConfigItem;
            t.createConfigItemSync = t.createConfigItemAsync = void 0;
            Object.defineProperty(t, "default", {
                enumerable: true,
                get: function() {
                    return n.default;
                }
            });
            t.loadPartialConfigSync = t.loadPartialConfigAsync = t.loadPartialConfig = t.loadOptionsSync = t.loadOptionsAsync = t.loadOptions = void 0;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(402);
            var s = r(1949);
            var i = r(1084);
            const a = _gensync()(function*(e1) {
                var t;
                const r = yield* (0, n.default)(e1);
                return (t = r == null ? void 0 : r.options) != null ? t : null;
            });
            const o = _gensync()(i.createConfigItem);
            const maybeErrback = (e1)=>(t, r)=>{
                    let n;
                    let s;
                    if (r === undefined && typeof t === "function") {
                        s = t;
                        n = undefined;
                    } else {
                        s = r;
                        n = t;
                    }
                    if (!s) {
                        return e1.sync(n);
                    }
                    e1.errback(n, s);
                };
            const l = maybeErrback(s.loadPartialConfig);
            t.loadPartialConfig = l;
            const c = s.loadPartialConfig.sync;
            t.loadPartialConfigSync = c;
            const u = s.loadPartialConfig.async;
            t.loadPartialConfigAsync = u;
            const p = maybeErrback(a);
            t.loadOptions = p;
            const f = a.sync;
            t.loadOptionsSync = f;
            const d = a.async;
            t.loadOptionsAsync = d;
            const h = o.sync;
            t.createConfigItemSync = h;
            const m = o.async;
            t.createConfigItemAsync = m;
            function createConfigItem(e1, t, r) {
                if (r !== undefined) {
                    o.errback(e1, t, r);
                } else if (typeof t === "function") {
                    o.errback(e1, undefined, r);
                } else {
                    return o.sync(e1, t);
                }
            }
            0 && 0;
        },
        1084: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createConfigItem = createConfigItem;
            t.createItemFromDescriptor = createItemFromDescriptor;
            t.getItemDescriptor = getItemDescriptor;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(8680);
            function createItemFromDescriptor(e1) {
                return new ConfigItem(e1);
            }
            function* createConfigItem(e1, { dirname: t = ".", type: r } = {}) {
                const s = yield* (0, n.createDescriptor)(e1, _path().resolve(t), {
                    type: r,
                    alias: "programmatic item"
                });
                return createItemFromDescriptor(s);
            }
            const s = Symbol.for("@babel/core@7 - ConfigItem");
            function getItemDescriptor(e1) {
                if (e1 != null && e1[s]) {
                    return e1._descriptor;
                }
                return undefined;
            }
            class ConfigItem {
                constructor(e1){
                    this._descriptor = void 0;
                    this[s] = true;
                    this.value = void 0;
                    this.options = void 0;
                    this.dirname = void 0;
                    this.name = void 0;
                    this.file = void 0;
                    this._descriptor = e1;
                    Object.defineProperty(this, "_descriptor", {
                        enumerable: false
                    });
                    Object.defineProperty(this, s, {
                        enumerable: false
                    });
                    this.value = this._descriptor.value;
                    this.options = this._descriptor.options;
                    this.dirname = this._descriptor.dirname;
                    this.name = this._descriptor.name;
                    this.file = this._descriptor.file ? {
                        request: this._descriptor.file.request,
                        resolved: this._descriptor.file.resolved
                    } : undefined;
                    Object.freeze(this);
                }
            }
            Object.freeze(ConfigItem.prototype);
            0 && 0;
        },
        1949: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = loadPrivatePartialConfig;
            t.loadPartialConfig = void 0;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(7916);
            var s = r(7376);
            var i = r(1084);
            var a = r(4672);
            var o = r(9658);
            var l = r(2420);
            var c = r(4613);
            var u = r(9099);
            const p = [
                "showIgnoredFiles"
            ];
            function _objectWithoutPropertiesLoose(e1, t) {
                if (e1 == null) return {};
                var r = {};
                var n = Object.keys(e1);
                var s, i;
                for(i = 0; i < n.length; i++){
                    s = n[i];
                    if (t.indexOf(s) >= 0) continue;
                    r[s] = e1[s];
                }
                return r;
            }
            function resolveRootMode(e1, t) {
                switch(t){
                    case "root":
                        return e1;
                    case "upward-optional":
                        {
                            const t = (0, c.findConfigUpwards)(e1);
                            return t === null ? e1 : t;
                        }
                    case "upward":
                        {
                            const t = (0, c.findConfigUpwards)(e1);
                            if (t !== null) return t;
                            throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not ` + `be found when searching upward from "${e1}".\n` + `One of the following config files must be in the directory tree: ` + `"${c.ROOT_CONFIG_FILENAMES.join(", ")}".`), {
                                code: "BABEL_ROOT_NOT_FOUND",
                                dirname: e1
                            });
                        }
                    default:
                        throw new Error(`Assertion failure - unknown rootMode value.`);
                }
            }
            function* loadPrivatePartialConfig(e1) {
                if (e1 != null && (typeof e1 !== "object" || Array.isArray(e1))) {
                    throw new Error("Babel options must be an object, null, or undefined");
                }
                const t = e1 ? (0, l.validate)("arguments", e1) : {};
                const { envName: r = (0, o.getEnv)(), cwd: n = ".", root: p = ".", rootMode: f = "root", caller: d, cloneInputAst: h = true } = t;
                const m = _path().resolve(n);
                const y = resolveRootMode(_path().resolve(m, p), f);
                const g = typeof t.filename === "string" ? _path().resolve(n, t.filename) : undefined;
                const b = yield* (0, c.resolveShowConfigPath)(m);
                const T = {
                    filename: g,
                    cwd: m,
                    root: y,
                    envName: r,
                    caller: d,
                    showConfig: b === g
                };
                const S = yield* (0, a.buildRootChain)(t, T);
                if (!S) return null;
                const E = {
                    assumptions: {}
                };
                S.options.forEach((e1)=>{
                    (0, s.mergeOptions)(E, e1);
                });
                const v = Object.assign({}, E, {
                    targets: (0, u.resolveTargets)(E, y),
                    cloneInputAst: h,
                    babelrc: false,
                    configFile: false,
                    browserslistConfigFile: false,
                    passPerPreset: false,
                    envName: T.envName,
                    cwd: T.cwd,
                    root: T.root,
                    rootMode: "root",
                    filename: typeof T.filename === "string" ? T.filename : undefined,
                    plugins: S.plugins.map((e1)=>(0, i.createItemFromDescriptor)(e1)),
                    presets: S.presets.map((e1)=>(0, i.createItemFromDescriptor)(e1))
                });
                return {
                    options: v,
                    context: T,
                    fileHandling: S.fileHandling,
                    ignore: S.ignore,
                    babelrc: S.babelrc,
                    config: S.config,
                    files: S.files
                };
            }
            const f = _gensync()(function*(e1) {
                let t = false;
                if (typeof e1 === "object" && e1 !== null && !Array.isArray(e1)) {
                    var r = e1;
                    ({ showIgnoredFiles: t } = r);
                    e1 = _objectWithoutPropertiesLoose(r, p);
                    r;
                }
                const s = yield* loadPrivatePartialConfig(e1);
                if (!s) return null;
                const { options: i, babelrc: a, ignore: o, config: l, fileHandling: c, files: u } = s;
                if (c === "ignored" && !t) {
                    return null;
                }
                (i.plugins || []).forEach((e1)=>{
                    if (e1.value instanceof n.default) {
                        throw new Error("Passing cached plugin instances is not supported in " + "babel.loadPartialConfig()");
                    }
                });
                return new PartialConfig(i, a ? a.filepath : undefined, o ? o.filepath : undefined, l ? l.filepath : undefined, c, u);
            });
            t.loadPartialConfig = f;
            class PartialConfig {
                constructor(e1, t, r, n, s, i){
                    this.options = void 0;
                    this.babelrc = void 0;
                    this.babelignore = void 0;
                    this.config = void 0;
                    this.fileHandling = void 0;
                    this.files = void 0;
                    this.options = e1;
                    this.babelignore = r;
                    this.babelrc = t;
                    this.config = n;
                    this.fileHandling = s;
                    this.files = i;
                    Object.freeze(this);
                }
                hasFilesystemConfig() {
                    return this.babelrc !== undefined || this.config !== undefined;
                }
            }
            Object.freeze(PartialConfig.prototype);
            0 && 0;
        },
        1034: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = pathToPattern;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            const n = `\\${_path().sep}`;
            const s = `(?:${n}|$)`;
            const i = `[^${n}]+`;
            const a = `(?:${i}${n})`;
            const o = `(?:${i}${s})`;
            const l = `${a}*?`;
            const c = `${a}*?${o}?`;
            function escapeRegExp(e1) {
                return e1.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
            }
            function pathToPattern(e1, t) {
                const r = _path().resolve(t, e1).split(_path().sep);
                return new RegExp([
                    "^",
                    ...r.map((e1, t)=>{
                        const u = t === r.length - 1;
                        if (e1 === "**") return u ? c : l;
                        if (e1 === "*") return u ? o : a;
                        if (e1.indexOf("*.") === 0) {
                            return i + escapeRegExp(e1.slice(1)) + (u ? s : n);
                        }
                        return escapeRegExp(e1) + (u ? s : n);
                    })
                ].join(""));
            }
            0 && 0;
        },
        7916: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(9435);
            class Plugin {
                constructor(e1, t, r, s = (0, n.finalize)([])){
                    this.key = void 0;
                    this.manipulateOptions = void 0;
                    this.post = void 0;
                    this.pre = void 0;
                    this.visitor = void 0;
                    this.parserOverride = void 0;
                    this.generatorOverride = void 0;
                    this.options = void 0;
                    this.externalDependencies = void 0;
                    this.key = e1.name || r;
                    this.manipulateOptions = e1.manipulateOptions;
                    this.post = e1.post;
                    this.pre = e1.pre;
                    this.visitor = e1.visitor || {};
                    this.parserOverride = e1.parserOverride;
                    this.generatorOverride = e1.generatorOverride;
                    this.options = t;
                    this.externalDependencies = s;
                }
            }
            t["default"] = Plugin;
            0 && 0;
        },
        7526: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ConfigPrinter = t.ChainFormatter = void 0;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            const n = {
                Programmatic: 0,
                Config: 1
            };
            t.ChainFormatter = n;
            const s = {
                title (e1, t, r) {
                    let s = "";
                    if (e1 === n.Programmatic) {
                        s = "programmatic options";
                        if (t) {
                            s += " from " + t;
                        }
                    } else {
                        s = "config " + r;
                    }
                    return s;
                },
                loc (e1, t) {
                    let r = "";
                    if (e1 != null) {
                        r += `.overrides[${e1}]`;
                    }
                    if (t != null) {
                        r += `.env["${t}"]`;
                    }
                    return r;
                },
                *optionsAndDescriptors (e1) {
                    const t = Object.assign({}, e1.options);
                    delete t.overrides;
                    delete t.env;
                    const r = [
                        ...yield* e1.plugins()
                    ];
                    if (r.length) {
                        t.plugins = r.map((e1)=>descriptorToConfig(e1));
                    }
                    const n = [
                        ...yield* e1.presets()
                    ];
                    if (n.length) {
                        t.presets = [
                            ...n
                        ].map((e1)=>descriptorToConfig(e1));
                    }
                    return JSON.stringify(t, undefined, 2);
                }
            };
            function descriptorToConfig(e1) {
                var t;
                let r = (t = e1.file) == null ? void 0 : t.request;
                if (r == null) {
                    if (typeof e1.value === "object") {
                        r = e1.value;
                    } else if (typeof e1.value === "function") {
                        r = `[Function: ${e1.value.toString().slice(0, 50)} ... ]`;
                    }
                }
                if (r == null) {
                    r = "[Unknown]";
                }
                if (e1.options === undefined) {
                    return r;
                } else if (e1.name == null) {
                    return [
                        r,
                        e1.options
                    ];
                } else {
                    return [
                        r,
                        e1.options,
                        e1.name
                    ];
                }
            }
            class ConfigPrinter {
                constructor(){
                    this._stack = [];
                }
                configure(e1, t, { callerName: r, filepath: n }) {
                    if (!e1) return ()=>{};
                    return (e1, s, i)=>{
                        this._stack.push({
                            type: t,
                            callerName: r,
                            filepath: n,
                            content: e1,
                            index: s,
                            envName: i
                        });
                    };
                }
                static *format(e1) {
                    let t = s.title(e1.type, e1.callerName, e1.filepath);
                    const r = s.loc(e1.index, e1.envName);
                    if (r) t += ` ${r}`;
                    const n = yield* s.optionsAndDescriptors(e1.content);
                    return `${t}\n${n}`;
                }
                *output() {
                    if (this._stack.length === 0) return "";
                    const e1 = yield* _gensync().all(this._stack.map((e1)=>ConfigPrinter.format(e1)));
                    return e1.join("\n\n");
                }
            }
            t.ConfigPrinter = ConfigPrinter;
            0 && 0;
        },
        9099: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.resolveBrowserslistConfigFile = resolveBrowserslistConfigFile;
            t.resolveTargets = resolveTargets;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function _helperCompilationTargets() {
                const e1 = r(900);
                _helperCompilationTargets = function() {
                    return e1;
                };
                return e1;
            }
            ({});
            function resolveBrowserslistConfigFile(e1, t) {
                return _path().resolve(t, e1);
            }
            function resolveTargets(e1, t) {
                const r = e1.targets;
                let n;
                if (typeof r === "string" || Array.isArray(r)) {
                    n = {
                        browsers: r
                    };
                } else if (r) {
                    if ("esmodules" in r) {
                        n = Object.assign({}, r, {
                            esmodules: "intersect"
                        });
                    } else {
                        n = r;
                    }
                }
                const { browserslistConfigFile: s } = e1;
                let i;
                let a = false;
                if (typeof s === "string") {
                    i = s;
                } else {
                    a = s === false;
                }
                return (0, _helperCompilationTargets().default)(n, {
                    ignoreBrowserslistConfig: a,
                    configFile: i,
                    configPath: t,
                    browserslistEnv: e1.browserslistEnv
                });
            }
            0 && 0;
        },
        7376: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isIterableIterator = isIterableIterator;
            t.mergeOptions = mergeOptions;
            function mergeOptions(e1, t) {
                for (const r of Object.keys(t)){
                    if ((r === "parserOpts" || r === "generatorOpts" || r === "assumptions") && t[r]) {
                        const n = t[r];
                        const s = e1[r] || (e1[r] = {});
                        mergeDefaultFields(s, n);
                    } else {
                        const n = t[r];
                        if (n !== undefined) e1[r] = n;
                    }
                }
            }
            function mergeDefaultFields(e1, t) {
                for (const r of Object.keys(t)){
                    const n = t[r];
                    if (n !== undefined) e1[r] = n;
                }
            }
            function isIterableIterator(e1) {
                return !!e1 && typeof e1.next === "function" && typeof e1[Symbol.iterator] === "function";
            }
            0 && 0;
        },
        490: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.access = access;
            t.assertArray = assertArray;
            t.assertAssumptions = assertAssumptions;
            t.assertBabelrcSearch = assertBabelrcSearch;
            t.assertBoolean = assertBoolean;
            t.assertCallerMetadata = assertCallerMetadata;
            t.assertCompact = assertCompact;
            t.assertConfigApplicableTest = assertConfigApplicableTest;
            t.assertConfigFileSearch = assertConfigFileSearch;
            t.assertFunction = assertFunction;
            t.assertIgnoreList = assertIgnoreList;
            t.assertInputSourceMap = assertInputSourceMap;
            t.assertObject = assertObject;
            t.assertPluginList = assertPluginList;
            t.assertRootMode = assertRootMode;
            t.assertSourceMaps = assertSourceMaps;
            t.assertSourceType = assertSourceType;
            t.assertString = assertString;
            t.assertTargets = assertTargets;
            t.msg = msg;
            function _helperCompilationTargets() {
                const e1 = r(900);
                _helperCompilationTargets = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(2420);
            function msg(e1) {
                switch(e1.type){
                    case "root":
                        return ``;
                    case "env":
                        return `${msg(e1.parent)}.env["${e1.name}"]`;
                    case "overrides":
                        return `${msg(e1.parent)}.overrides[${e1.index}]`;
                    case "option":
                        return `${msg(e1.parent)}.${e1.name}`;
                    case "access":
                        return `${msg(e1.parent)}[${JSON.stringify(e1.name)}]`;
                    default:
                        throw new Error(`Assertion failure: Unknown type ${e1.type}`);
                }
            }
            function access(e1, t) {
                return {
                    type: "access",
                    name: t,
                    parent: e1
                };
            }
            function assertRootMode(e1, t) {
                if (t !== undefined && t !== "root" && t !== "upward" && t !== "upward-optional") {
                    throw new Error(`${msg(e1)} must be a "root", "upward", "upward-optional" or undefined`);
                }
                return t;
            }
            function assertSourceMaps(e1, t) {
                if (t !== undefined && typeof t !== "boolean" && t !== "inline" && t !== "both") {
                    throw new Error(`${msg(e1)} must be a boolean, "inline", "both", or undefined`);
                }
                return t;
            }
            function assertCompact(e1, t) {
                if (t !== undefined && typeof t !== "boolean" && t !== "auto") {
                    throw new Error(`${msg(e1)} must be a boolean, "auto", or undefined`);
                }
                return t;
            }
            function assertSourceType(e1, t) {
                if (t !== undefined && t !== "module" && t !== "script" && t !== "unambiguous") {
                    throw new Error(`${msg(e1)} must be "module", "script", "unambiguous", or undefined`);
                }
                return t;
            }
            function assertCallerMetadata(e1, t) {
                const r = assertObject(e1, t);
                if (r) {
                    if (typeof r.name !== "string") {
                        throw new Error(`${msg(e1)} set but does not contain "name" property string`);
                    }
                    for (const t of Object.keys(r)){
                        const n = access(e1, t);
                        const s = r[t];
                        if (s != null && typeof s !== "boolean" && typeof s !== "string" && typeof s !== "number") {
                            throw new Error(`${msg(n)} must be null, undefined, a boolean, a string, or a number.`);
                        }
                    }
                }
                return t;
            }
            function assertInputSourceMap(e1, t) {
                if (t !== undefined && typeof t !== "boolean" && (typeof t !== "object" || !t)) {
                    throw new Error(`${msg(e1)} must be a boolean, object, or undefined`);
                }
                return t;
            }
            function assertString(e1, t) {
                if (t !== undefined && typeof t !== "string") {
                    throw new Error(`${msg(e1)} must be a string, or undefined`);
                }
                return t;
            }
            function assertFunction(e1, t) {
                if (t !== undefined && typeof t !== "function") {
                    throw new Error(`${msg(e1)} must be a function, or undefined`);
                }
                return t;
            }
            function assertBoolean(e1, t) {
                if (t !== undefined && typeof t !== "boolean") {
                    throw new Error(`${msg(e1)} must be a boolean, or undefined`);
                }
                return t;
            }
            function assertObject(e1, t) {
                if (t !== undefined && (typeof t !== "object" || Array.isArray(t) || !t)) {
                    throw new Error(`${msg(e1)} must be an object, or undefined`);
                }
                return t;
            }
            function assertArray(e1, t) {
                if (t != null && !Array.isArray(t)) {
                    throw new Error(`${msg(e1)} must be an array, or undefined`);
                }
                return t;
            }
            function assertIgnoreList(e1, t) {
                const r = assertArray(e1, t);
                if (r) {
                    r.forEach((t, r)=>assertIgnoreItem(access(e1, r), t));
                }
                return r;
            }
            function assertIgnoreItem(e1, t) {
                if (typeof t !== "string" && typeof t !== "function" && !(t instanceof RegExp)) {
                    throw new Error(`${msg(e1)} must be an array of string/Function/RegExp values, or undefined`);
                }
                return t;
            }
            function assertConfigApplicableTest(e1, t) {
                if (t === undefined) {
                    return t;
                }
                if (Array.isArray(t)) {
                    t.forEach((t, r)=>{
                        if (!checkValidTest(t)) {
                            throw new Error(`${msg(access(e1, r))} must be a string/Function/RegExp.`);
                        }
                    });
                } else if (!checkValidTest(t)) {
                    throw new Error(`${msg(e1)} must be a string/Function/RegExp, or an array of those`);
                }
                return t;
            }
            function checkValidTest(e1) {
                return typeof e1 === "string" || typeof e1 === "function" || e1 instanceof RegExp;
            }
            function assertConfigFileSearch(e1, t) {
                if (t !== undefined && typeof t !== "boolean" && typeof t !== "string") {
                    throw new Error(`${msg(e1)} must be a undefined, a boolean, a string, ` + `got ${JSON.stringify(t)}`);
                }
                return t;
            }
            function assertBabelrcSearch(e1, t) {
                if (t === undefined || typeof t === "boolean") {
                    return t;
                }
                if (Array.isArray(t)) {
                    t.forEach((t, r)=>{
                        if (!checkValidTest(t)) {
                            throw new Error(`${msg(access(e1, r))} must be a string/Function/RegExp.`);
                        }
                    });
                } else if (!checkValidTest(t)) {
                    throw new Error(`${msg(e1)} must be a undefined, a boolean, a string/Function/RegExp ` + `or an array of those, got ${JSON.stringify(t)}`);
                }
                return t;
            }
            function assertPluginList(e1, t) {
                const r = assertArray(e1, t);
                if (r) {
                    r.forEach((t, r)=>assertPluginItem(access(e1, r), t));
                }
                return r;
            }
            function assertPluginItem(e1, t) {
                if (Array.isArray(t)) {
                    if (t.length === 0) {
                        throw new Error(`${msg(e1)} must include an object`);
                    }
                    if (t.length > 3) {
                        throw new Error(`${msg(e1)} may only be a two-tuple or three-tuple`);
                    }
                    assertPluginTarget(access(e1, 0), t[0]);
                    if (t.length > 1) {
                        const r = t[1];
                        if (r !== undefined && r !== false && (typeof r !== "object" || Array.isArray(r) || r === null)) {
                            throw new Error(`${msg(access(e1, 1))} must be an object, false, or undefined`);
                        }
                    }
                    if (t.length === 3) {
                        const r = t[2];
                        if (r !== undefined && typeof r !== "string") {
                            throw new Error(`${msg(access(e1, 2))} must be a string, or undefined`);
                        }
                    }
                } else {
                    assertPluginTarget(e1, t);
                }
                return t;
            }
            function assertPluginTarget(e1, t) {
                if ((typeof t !== "object" || !t) && typeof t !== "string" && typeof t !== "function") {
                    throw new Error(`${msg(e1)} must be a string, object, function`);
                }
                return t;
            }
            function assertTargets(e1, t) {
                if ((0, _helperCompilationTargets().isBrowsersQueryValid)(t)) return t;
                if (typeof t !== "object" || !t || Array.isArray(t)) {
                    throw new Error(`${msg(e1)} must be a string, an array of strings or an object`);
                }
                const r = access(e1, "browsers");
                const n = access(e1, "esmodules");
                assertBrowsersList(r, t.browsers);
                assertBoolean(n, t.esmodules);
                for (const r of Object.keys(t)){
                    const n = t[r];
                    const s = access(e1, r);
                    if (r === "esmodules") assertBoolean(s, n);
                    else if (r === "browsers") assertBrowsersList(s, n);
                    else if (!Object.hasOwnProperty.call(_helperCompilationTargets().TargetNames, r)) {
                        const e1 = Object.keys(_helperCompilationTargets().TargetNames).join(", ");
                        throw new Error(`${msg(s)} is not a valid target. Supported targets are ${e1}`);
                    } else assertBrowserVersion(s, n);
                }
                return t;
            }
            function assertBrowsersList(e1, t) {
                if (t !== undefined && !(0, _helperCompilationTargets().isBrowsersQueryValid)(t)) {
                    throw new Error(`${msg(e1)} must be undefined, a string or an array of strings`);
                }
            }
            function assertBrowserVersion(e1, t) {
                if (typeof t === "number" && Math.round(t) === t) return;
                if (typeof t === "string") return;
                throw new Error(`${msg(e1)} must be a string or an integer number`);
            }
            function assertAssumptions(e1, t) {
                if (t === undefined) return;
                if (typeof t !== "object" || t === null) {
                    throw new Error(`${msg(e1)} must be an object or undefined.`);
                }
                let r = e1;
                do {
                    r = r.parent;
                }while (r.type !== "root")
                const s = r.source === "preset";
                for (const r of Object.keys(t)){
                    const i = access(e1, r);
                    if (!n.assumptionsNames.has(r)) {
                        throw new Error(`${msg(i)} is not a supported assumption.`);
                    }
                    if (typeof t[r] !== "boolean") {
                        throw new Error(`${msg(i)} must be a boolean.`);
                    }
                    if (s && t[r] === false) {
                        throw new Error(`${msg(i)} cannot be set to 'false' inside presets.`);
                    }
                }
                return t;
            }
            0 && 0;
        },
        2420: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.assumptionsNames = void 0;
            t.checkNoUnwrappedItemOptionPairs = checkNoUnwrappedItemOptionPairs;
            t.validate = validate;
            var n = r(6212);
            var s = r(490);
            var i = r(8208);
            const a = {
                cwd: s.assertString,
                root: s.assertString,
                rootMode: s.assertRootMode,
                configFile: s.assertConfigFileSearch,
                caller: s.assertCallerMetadata,
                filename: s.assertString,
                filenameRelative: s.assertString,
                code: s.assertBoolean,
                ast: s.assertBoolean,
                cloneInputAst: s.assertBoolean,
                envName: s.assertString
            };
            const o = {
                babelrc: s.assertBoolean,
                babelrcRoots: s.assertBabelrcSearch
            };
            const l = {
                extends: s.assertString,
                ignore: s.assertIgnoreList,
                only: s.assertIgnoreList,
                targets: s.assertTargets,
                browserslistConfigFile: s.assertConfigFileSearch,
                browserslistEnv: s.assertString
            };
            const c = {
                inputSourceMap: s.assertInputSourceMap,
                presets: s.assertPluginList,
                plugins: s.assertPluginList,
                passPerPreset: s.assertBoolean,
                assumptions: s.assertAssumptions,
                env: assertEnvSet,
                overrides: assertOverridesList,
                test: s.assertConfigApplicableTest,
                include: s.assertConfigApplicableTest,
                exclude: s.assertConfigApplicableTest,
                retainLines: s.assertBoolean,
                comments: s.assertBoolean,
                shouldPrintComment: s.assertFunction,
                compact: s.assertCompact,
                minified: s.assertBoolean,
                auxiliaryCommentBefore: s.assertString,
                auxiliaryCommentAfter: s.assertString,
                sourceType: s.assertSourceType,
                wrapPluginVisitorMethod: s.assertFunction,
                highlightCode: s.assertBoolean,
                sourceMaps: s.assertSourceMaps,
                sourceMap: s.assertSourceMaps,
                sourceFileName: s.assertString,
                sourceRoot: s.assertString,
                parserOpts: s.assertObject,
                generatorOpts: s.assertObject
            };
            {
                Object.assign(c, {
                    getModuleId: s.assertFunction,
                    moduleRoot: s.assertString,
                    moduleIds: s.assertBoolean,
                    moduleId: s.assertString
                });
            }
            const u = [
                "arrayLikeIsIterable",
                "constantReexports",
                "constantSuper",
                "enumerableModuleMeta",
                "ignoreFunctionLength",
                "ignoreToPrimitiveHint",
                "iterableIsArray",
                "mutableTemplateObject",
                "noClassCalls",
                "noDocumentAll",
                "noIncompleteNsImportDetection",
                "noNewArrows",
                "objectRestNoSymbols",
                "privateFieldsAsSymbols",
                "privateFieldsAsProperties",
                "pureGetters",
                "setClassMethods",
                "setComputedProperties",
                "setPublicClassFields",
                "setSpreadProperties",
                "skipForOfIteratorClosing",
                "superIsCallableConstructor"
            ];
            const p = new Set(u);
            t.assumptionsNames = p;
            function getSource(e1) {
                return e1.type === "root" ? e1.source : getSource(e1.parent);
            }
            function validate(e1, t, r) {
                try {
                    return validateNested({
                        type: "root",
                        source: e1
                    }, t);
                } catch (e1) {
                    const t = new i.default(e1.message, r);
                    if (e1.code) t.code = e1.code;
                    throw t;
                }
            }
            function validateNested(e1, t) {
                const r = getSource(e1);
                assertNoDuplicateSourcemap(t);
                Object.keys(t).forEach((n)=>{
                    const i = {
                        type: "option",
                        name: n,
                        parent: e1
                    };
                    if (r === "preset" && l[n]) {
                        throw new Error(`${(0, s.msg)(i)} is not allowed in preset options`);
                    }
                    if (r !== "arguments" && a[n]) {
                        throw new Error(`${(0, s.msg)(i)} is only allowed in root programmatic options`);
                    }
                    if (r !== "arguments" && r !== "configfile" && o[n]) {
                        if (r === "babelrcfile" || r === "extendsfile") {
                            throw new Error(`${(0, s.msg)(i)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, ` + `or babel.config.js/config file options`);
                        }
                        throw new Error(`${(0, s.msg)(i)} is only allowed in root programmatic options, or babel.config.js/config file options`);
                    }
                    const u = c[n] || l[n] || o[n] || a[n] || throwUnknownError;
                    u(i, t[n]);
                });
                return t;
            }
            function throwUnknownError(e1) {
                const t = e1.name;
                if (n.default[t]) {
                    const { message: r, version: i = 5 } = n.default[t];
                    throw new Error(`Using removed Babel ${i} option: ${(0, s.msg)(e1)} - ${r}`);
                } else {
                    const t = new Error(`Unknown option: ${(0, s.msg)(e1)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
                    t.code = "BABEL_UNKNOWN_OPTION";
                    throw t;
                }
            }
            function has(e1, t) {
                return Object.prototype.hasOwnProperty.call(e1, t);
            }
            function assertNoDuplicateSourcemap(e1) {
                if (has(e1, "sourceMap") && has(e1, "sourceMaps")) {
                    throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
                }
            }
            function assertEnvSet(e1, t) {
                if (e1.parent.type === "env") {
                    throw new Error(`${(0, s.msg)(e1)} is not allowed inside of another .env block`);
                }
                const r = e1.parent;
                const n = (0, s.assertObject)(e1, t);
                if (n) {
                    for (const t of Object.keys(n)){
                        const i = (0, s.assertObject)((0, s.access)(e1, t), n[t]);
                        if (!i) continue;
                        const a = {
                            type: "env",
                            name: t,
                            parent: r
                        };
                        validateNested(a, i);
                    }
                }
                return n;
            }
            function assertOverridesList(e1, t) {
                if (e1.parent.type === "env") {
                    throw new Error(`${(0, s.msg)(e1)} is not allowed inside an .env block`);
                }
                if (e1.parent.type === "overrides") {
                    throw new Error(`${(0, s.msg)(e1)} is not allowed inside an .overrides block`);
                }
                const r = e1.parent;
                const n = (0, s.assertArray)(e1, t);
                if (n) {
                    for (const [t, i] of n.entries()){
                        const n = (0, s.access)(e1, t);
                        const a = (0, s.assertObject)(n, i);
                        if (!a) throw new Error(`${(0, s.msg)(n)} must be an object`);
                        const o = {
                            type: "overrides",
                            index: t,
                            parent: r
                        };
                        validateNested(o, a);
                    }
                }
                return n;
            }
            function checkNoUnwrappedItemOptionPairs(e1, t, r, n) {
                if (t === 0) return;
                const s = e1[t - 1];
                const i = e1[t];
                if (s.file && s.options === undefined && typeof i.value === "object") {
                    n.message += `\n- Maybe you meant to use\n` + `"${r}s": [\n  ["${s.file.request}", ${JSON.stringify(i.value, undefined, 2)}]\n]\n` + `To be a valid ${r}, its name and options should be wrapped in a pair of brackets`;
                }
            }
            0 && 0;
        },
        4059: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.validatePluginObject = validatePluginObject;
            var n = r(490);
            const s = {
                name: n.assertString,
                manipulateOptions: n.assertFunction,
                pre: n.assertFunction,
                post: n.assertFunction,
                inherits: n.assertFunction,
                visitor: assertVisitorMap,
                parserOverride: n.assertFunction,
                generatorOverride: n.assertFunction
            };
            function assertVisitorMap(e1, t) {
                const r = (0, n.assertObject)(e1, t);
                if (r) {
                    Object.keys(r).forEach((e1)=>assertVisitorHandler(e1, r[e1]));
                    if (r.enter || r.exit) {
                        throw new Error(`${(0, n.msg)(e1)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
                    }
                }
                return r;
            }
            function assertVisitorHandler(e1, t) {
                if (t && typeof t === "object") {
                    Object.keys(t).forEach((t)=>{
                        if (t !== "enter" && t !== "exit") {
                            throw new Error(`.visitor["${e1}"] may only have .enter and/or .exit handlers.`);
                        }
                    });
                } else if (typeof t !== "function") {
                    throw new Error(`.visitor["${e1}"] must be a function`);
                }
                return t;
            }
            function validatePluginObject(e1) {
                const t = {
                    type: "root",
                    source: "plugin"
                };
                Object.keys(e1).forEach((r)=>{
                    const n = s[r];
                    if (n) {
                        const s = {
                            type: "option",
                            name: r,
                            parent: t
                        };
                        n(s, e1[r]);
                    } else {
                        const e1 = new Error(`.${r} is not a valid Plugin property`);
                        e1.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY";
                        throw e1;
                    }
                });
                return e1;
            }
            0 && 0;
        },
        6212: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var r = {
                auxiliaryComment: {
                    message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
                },
                blacklist: {
                    message: "Put the specific transforms you want in the `plugins` option"
                },
                breakConfig: {
                    message: "This is not a necessary option in Babel 6"
                },
                experimental: {
                    message: "Put the specific transforms you want in the `plugins` option"
                },
                externalHelpers: {
                    message: "Use the `external-helpers` plugin instead. " + "Check out http://babeljs.io/docs/plugins/external-helpers/"
                },
                extra: {
                    message: ""
                },
                jsxPragma: {
                    message: "use the `pragma` option in the `react-jsx` plugin. " + "Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
                },
                loose: {
                    message: "Specify the `loose` option for the relevant plugin you are using " + "or use a preset that sets the option."
                },
                metadataUsedHelpers: {
                    message: "Not required anymore as this is enabled by default"
                },
                modules: {
                    message: "Use the corresponding module transform plugin in the `plugins` option. " + "Check out http://babeljs.io/docs/plugins/#modules"
                },
                nonStandard: {
                    message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. " + "Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
                },
                optional: {
                    message: "Put the specific transforms you want in the `plugins` option"
                },
                sourceMapName: {
                    message: "The `sourceMapName` option has been removed because it makes more sense for the " + "tooling that calls Babel to assign `map.file` themselves."
                },
                stage: {
                    message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
                },
                whitelist: {
                    message: "Put the specific transforms you want in the `plugins` option"
                },
                resolveModuleSource: {
                    version: 6,
                    message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
                },
                metadata: {
                    version: 6,
                    message: "Generated plugin metadata is always included in the output result"
                },
                sourceMapTarget: {
                    version: 6,
                    message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling " + "that calls Babel to assign `map.file` themselves."
                }
            };
            t["default"] = r;
            0 && 0;
        },
        8208: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(3585);
            class ConfigError extends Error {
                constructor(e1, t){
                    super(e1);
                    (0, n.expectedError)(this);
                    if (t) (0, n.injectVirtualStackFrame)(this, t);
                }
            }
            t["default"] = ConfigError;
            0 && 0;
        },
        3585: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.beginHiddenCallStack = beginHiddenCallStack;
            t.endHiddenCallStack = endHiddenCallStack;
            t.expectedError = expectedError;
            t.injectVirtualStackFrame = injectVirtualStackFrame;
            const r = Function.call.bind(Error.prototype.toString);
            const n = !!Error.captureStackTrace;
            const s = "startHiding - secret - don't use this - v1";
            const i = "stopHiding - secret - don't use this - v1";
            const a = new WeakSet;
            const o = new WeakMap;
            function CallSite(e1) {
                return Object.create({
                    isNative: ()=>false,
                    isConstructor: ()=>false,
                    isToplevel: ()=>true,
                    getFileName: ()=>e1,
                    getLineNumber: ()=>undefined,
                    getColumnNumber: ()=>undefined,
                    getFunctionName: ()=>undefined,
                    getMethodName: ()=>undefined,
                    getTypeName: ()=>undefined,
                    toString: ()=>e1
                });
            }
            function injectVirtualStackFrame(e1, t) {
                if (!n) return;
                let r = o.get(e1);
                if (!r) o.set(e1, r = []);
                r.push(CallSite(t));
                return e1;
            }
            function expectedError(e1) {
                if (!n) return;
                a.add(e1);
                return e1;
            }
            function beginHiddenCallStack(e1) {
                if (!n) return e1;
                return Object.defineProperty(function(...t) {
                    setupPrepareStackTrace();
                    return e1(...t);
                }, "name", {
                    value: i
                });
            }
            function endHiddenCallStack(e1) {
                if (!n) return e1;
                return Object.defineProperty(function(...t) {
                    return e1(...t);
                }, "name", {
                    value: s
                });
            }
            function setupPrepareStackTrace() {
                setupPrepareStackTrace = ()=>{};
                const { prepareStackTrace: e1 = defaultPrepareStackTrace } = Error;
                const t = 50;
                Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, t));
                Error.prepareStackTrace = function stackTraceRewriter(t, r) {
                    let n = [];
                    const l = a.has(t);
                    let c = l ? "hiding" : "unknown";
                    for(let e1 = 0; e1 < r.length; e1++){
                        const a = r[e1].getFunctionName();
                        if (a === s) {
                            c = "hiding";
                        } else if (a === i) {
                            if (c === "hiding") {
                                c = "showing";
                                if (o.has(t)) {
                                    n.unshift(...o.get(t));
                                }
                            } else if (c === "unknown") {
                                n = r;
                                break;
                            }
                        } else if (c !== "hiding") {
                            n.push(r[e1]);
                        }
                    }
                    return e1(t, n);
                };
            }
            function defaultPrepareStackTrace(e1, t) {
                if (t.length === 0) return r(e1);
                return `${r(e1)}\n    at ${t.join("\n    at ")}`;
            }
            0 && 0;
        },
        9367: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.forwardAsync = forwardAsync;
            t.isAsync = void 0;
            t.isThenable = isThenable;
            t.maybeAsync = maybeAsync;
            t.waitFor = t.onFirstPause = void 0;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            function asyncGeneratorStep(e1, t, r, n, s, i, a) {
                try {
                    var o = e1[i](a);
                    var l = o.value;
                } catch (e1) {
                    r(e1);
                    return;
                }
                if (o.done) {
                    t(l);
                } else {
                    Promise.resolve(l).then(n, s);
                }
            }
            function _asyncToGenerator(e1) {
                return function() {
                    var t = this, r = arguments;
                    return new Promise(function(n, s) {
                        var i = e1.apply(t, r);
                        function _next(e1) {
                            asyncGeneratorStep(i, n, s, _next, _throw, "next", e1);
                        }
                        function _throw(e1) {
                            asyncGeneratorStep(i, n, s, _next, _throw, "throw", e1);
                        }
                        _next(undefined);
                    });
                };
            }
            const n = _gensync()(function*(e1) {
                return yield* e1;
            });
            const s = _gensync()({
                sync: ()=>false,
                errback: (e1)=>e1(null, true)
            });
            t.isAsync = s;
            function maybeAsync(e1, t) {
                return _gensync()({
                    sync (...r) {
                        const n = e1.apply(this, r);
                        if (isThenable(n)) throw new Error(t);
                        return n;
                    },
                    async (...t) {
                        return Promise.resolve(e1.apply(this, t));
                    }
                });
            }
            const i = _gensync()({
                sync: (e1)=>e1("sync"),
                async: function() {
                    var e1 = _asyncToGenerator(function*(e1) {
                        return e1("async");
                    });
                    return function async(t) {
                        return e1.apply(this, arguments);
                    };
                }()
            });
            function forwardAsync(e1, t) {
                const r = _gensync()(e1);
                return i((e1)=>{
                    const n = r[e1];
                    return t(n);
                });
            }
            const a = _gensync()({
                name: "onFirstPause",
                arity: 2,
                sync: function(e1) {
                    return n.sync(e1);
                },
                errback: function(e1, t, r) {
                    let s = false;
                    n.errback(e1, (e1, t)=>{
                        s = true;
                        r(e1, t);
                    });
                    if (!s) {
                        t();
                    }
                }
            });
            t.onFirstPause = a;
            const o = _gensync()({
                sync: (e1)=>e1,
                async: function() {
                    var e1 = _asyncToGenerator(function*(e1) {
                        return e1;
                    });
                    return function async(t) {
                        return e1.apply(this, arguments);
                    };
                }()
            });
            t.waitFor = o;
            function isThenable(e1) {
                return !!e1 && (typeof e1 === "object" || typeof e1 === "function") && !!e1.then && typeof e1.then === "function";
            }
            0 && 0;
        },
        9724: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.stat = t.readFile = void 0;
            function _fs() {
                const e1 = r(7147);
                _fs = function() {
                    return e1;
                };
                return e1;
            }
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            const n = _gensync()({
                sync: _fs().readFileSync,
                errback: _fs().readFile
            });
            t.readFile = n;
            const s = _gensync()({
                sync: _fs().statSync,
                errback: _fs().stat
            });
            t.stat = s;
            0 && 0;
        },
        128: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.once = once;
            var n = r(9367);
            function once(e1) {
                let t;
                let r;
                return function*() {
                    if (t) return t;
                    if (!(yield* (0, n.isAsync)())) return t = yield* e1();
                    if (r) return yield* (0, n.waitFor)(r);
                    let s, i;
                    r = new Promise((e1, t)=>{
                        s = e1;
                        i = t;
                    });
                    try {
                        t = yield* e1();
                        r = null;
                        s(t);
                        return t;
                    } catch (e1) {
                        i(e1);
                        throw e1;
                    }
                };
            }
            0 && 0;
        },
        3688: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DEFAULT_EXTENSIONS = void 0;
            Object.defineProperty(t, "File", {
                enumerable: true,
                get: function() {
                    return n.default;
                }
            });
            Object.defineProperty(t, "buildExternalHelpers", {
                enumerable: true,
                get: function() {
                    return s.default;
                }
            });
            Object.defineProperty(t, "createConfigItem", {
                enumerable: true,
                get: function() {
                    return o.createConfigItem;
                }
            });
            Object.defineProperty(t, "createConfigItemAsync", {
                enumerable: true,
                get: function() {
                    return o.createConfigItemAsync;
                }
            });
            Object.defineProperty(t, "createConfigItemSync", {
                enumerable: true,
                get: function() {
                    return o.createConfigItemSync;
                }
            });
            Object.defineProperty(t, "getEnv", {
                enumerable: true,
                get: function() {
                    return a.getEnv;
                }
            });
            Object.defineProperty(t, "loadOptions", {
                enumerable: true,
                get: function() {
                    return o.loadOptions;
                }
            });
            Object.defineProperty(t, "loadOptionsAsync", {
                enumerable: true,
                get: function() {
                    return o.loadOptionsAsync;
                }
            });
            Object.defineProperty(t, "loadOptionsSync", {
                enumerable: true,
                get: function() {
                    return o.loadOptionsSync;
                }
            });
            Object.defineProperty(t, "loadPartialConfig", {
                enumerable: true,
                get: function() {
                    return o.loadPartialConfig;
                }
            });
            Object.defineProperty(t, "loadPartialConfigAsync", {
                enumerable: true,
                get: function() {
                    return o.loadPartialConfigAsync;
                }
            });
            Object.defineProperty(t, "loadPartialConfigSync", {
                enumerable: true,
                get: function() {
                    return o.loadPartialConfigSync;
                }
            });
            Object.defineProperty(t, "parse", {
                enumerable: true,
                get: function() {
                    return p.parse;
                }
            });
            Object.defineProperty(t, "parseAsync", {
                enumerable: true,
                get: function() {
                    return p.parseAsync;
                }
            });
            Object.defineProperty(t, "parseSync", {
                enumerable: true,
                get: function() {
                    return p.parseSync;
                }
            });
            Object.defineProperty(t, "resolvePlugin", {
                enumerable: true,
                get: function() {
                    return i.resolvePlugin;
                }
            });
            Object.defineProperty(t, "resolvePreset", {
                enumerable: true,
                get: function() {
                    return i.resolvePreset;
                }
            });
            Object.defineProperty((0, t), "template", {
                enumerable: true,
                get: function() {
                    return _template().default;
                }
            });
            Object.defineProperty((0, t), "tokTypes", {
                enumerable: true,
                get: function() {
                    return _parser().tokTypes;
                }
            });
            Object.defineProperty(t, "transform", {
                enumerable: true,
                get: function() {
                    return l.transform;
                }
            });
            Object.defineProperty(t, "transformAsync", {
                enumerable: true,
                get: function() {
                    return l.transformAsync;
                }
            });
            Object.defineProperty(t, "transformFile", {
                enumerable: true,
                get: function() {
                    return c.transformFile;
                }
            });
            Object.defineProperty(t, "transformFileAsync", {
                enumerable: true,
                get: function() {
                    return c.transformFileAsync;
                }
            });
            Object.defineProperty(t, "transformFileSync", {
                enumerable: true,
                get: function() {
                    return c.transformFileSync;
                }
            });
            Object.defineProperty(t, "transformFromAst", {
                enumerable: true,
                get: function() {
                    return u.transformFromAst;
                }
            });
            Object.defineProperty(t, "transformFromAstAsync", {
                enumerable: true,
                get: function() {
                    return u.transformFromAstAsync;
                }
            });
            Object.defineProperty(t, "transformFromAstSync", {
                enumerable: true,
                get: function() {
                    return u.transformFromAstSync;
                }
            });
            Object.defineProperty(t, "transformSync", {
                enumerable: true,
                get: function() {
                    return l.transformSync;
                }
            });
            Object.defineProperty((0, t), "traverse", {
                enumerable: true,
                get: function() {
                    return _traverse().default;
                }
            });
            t.version = t.types = void 0;
            var n = r(6103);
            var s = r(7472);
            var i = r(4613);
            var a = r(9658);
            function _types() {
                const e1 = r(776);
                _types = function() {
                    return e1;
                };
                return e1;
            }
            Object.defineProperty((0, t), "types", {
                enumerable: true,
                get: function() {
                    return _types();
                }
            });
            function _parser() {
                const e1 = r(7383);
                _parser = function() {
                    return e1;
                };
                return e1;
            }
            function _traverse() {
                const e1 = r(2297);
                _traverse = function() {
                    return e1;
                };
                return e1;
            }
            function _template() {
                const e1 = r(9128);
                _template = function() {
                    return e1;
                };
                return e1;
            }
            var o = r(4455);
            var l = r(9994);
            var c = r(5885);
            var u = r(6895);
            var p = r(352);
            var f = r(3688);
            const d = "7.22.5";
            t.version = d;
            const h = Object.freeze([
                ".js",
                ".jsx",
                ".es6",
                ".es",
                ".mjs",
                ".cjs"
            ]);
            t.DEFAULT_EXTENSIONS = h;
            {
                {
                    t.OptionManager = class OptionManager {
                        init(e1) {
                            return (0, o.loadOptionsSync)(e1);
                        }
                    };
                    t.Plugin = function Plugin(e1) {
                        throw new Error(`The (${e1}) Babel 5 plugin is being run with an unsupported Babel version.`);
                    };
                }
            }
            0 && 0;
        },
        352: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.parse = void 0;
            t.parseAsync = parseAsync;
            t.parseSync = parseSync;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(4455);
            var s = r(2865);
            var i = r(3907);
            var a = r(3585);
            const o = _gensync()(function* parse(e1, t) {
                const r = yield* (0, n.default)(t);
                if (r === null) {
                    return null;
                }
                return yield* (0, s.default)(r.passes, (0, i.default)(r), e1);
            });
            const l = function parse(e1, t, r) {
                if (typeof t === "function") {
                    r = t;
                    t = undefined;
                }
                if (r === undefined) {
                    {
                        return (0, a.beginHiddenCallStack)(o.sync)(e1, t);
                    }
                }
                (0, a.beginHiddenCallStack)(o.errback)(e1, t, r);
            };
            t.parse = l;
            function parseSync(...e1) {
                return (0, a.beginHiddenCallStack)(o.sync)(...e1);
            }
            function parseAsync(...e1) {
                return (0, a.beginHiddenCallStack)(o.async)(...e1);
            }
            0 && 0;
        },
        2865: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = parser;
            function _parser() {
                const e1 = r(7383);
                _parser = function() {
                    return e1;
                };
                return e1;
            }
            function _codeFrame() {
                const e1 = r(2430);
                _codeFrame = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(193);
            function* parser(e1, { parserOpts: t, highlightCode: r = true, filename: s = "unknown" }, i) {
                try {
                    const r = [];
                    for (const n of e1){
                        for (const e1 of n){
                            const { parserOverride: n } = e1;
                            if (n) {
                                const e1 = n(i, t, _parser().parse);
                                if (e1 !== undefined) r.push(e1);
                            }
                        }
                    }
                    if (r.length === 0) {
                        return (0, _parser().parse)(i, t);
                    } else if (r.length === 1) {
                        yield* [];
                        if (typeof r[0].then === "function") {
                            throw new Error(`You appear to be using an async parser plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);
                        }
                        return r[0];
                    }
                    throw new Error("More than one plugin attempted to override parsing.");
                } catch (e1) {
                    if (e1.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
                        e1.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module " + "or sourceType:unambiguous in your Babel config for this file.";
                    }
                    const { loc: t, missingPlugin: a } = e1;
                    if (t) {
                        const o = (0, _codeFrame().codeFrameColumns)(i, {
                            start: {
                                line: t.line,
                                column: t.column + 1
                            }
                        }, {
                            highlightCode: r
                        });
                        if (a) {
                            e1.message = `${s}: ` + (0, n.default)(a[0], t, o);
                        } else {
                            e1.message = `${s}: ${e1.message}\n\n` + o;
                        }
                        e1.code = "BABEL_PARSE_ERROR";
                    }
                    throw e1;
                }
            }
            0 && 0;
        },
        193: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = generateMissingPluginMessage;
            const r = {
                asyncDoExpressions: {
                    syntax: {
                        name: "@babel/plugin-syntax-async-do-expressions",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
                    }
                },
                decimal: {
                    syntax: {
                        name: "@babel/plugin-syntax-decimal",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
                    }
                },
                decorators: {
                    syntax: {
                        name: "@babel/plugin-syntax-decorators",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-decorators",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
                    }
                },
                doExpressions: {
                    syntax: {
                        name: "@babel/plugin-syntax-do-expressions",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-do-expressions",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
                    }
                },
                exportDefaultFrom: {
                    syntax: {
                        name: "@babel/plugin-syntax-export-default-from",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-export-default-from",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
                    }
                },
                flow: {
                    syntax: {
                        name: "@babel/plugin-syntax-flow",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
                    },
                    transform: {
                        name: "@babel/preset-flow",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
                    }
                },
                functionBind: {
                    syntax: {
                        name: "@babel/plugin-syntax-function-bind",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-function-bind",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
                    }
                },
                functionSent: {
                    syntax: {
                        name: "@babel/plugin-syntax-function-sent",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-function-sent",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
                    }
                },
                jsx: {
                    syntax: {
                        name: "@babel/plugin-syntax-jsx",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
                    },
                    transform: {
                        name: "@babel/preset-react",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
                    }
                },
                importAttributes: {
                    syntax: {
                        name: "@babel/plugin-syntax-import-attributes",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes"
                    }
                },
                pipelineOperator: {
                    syntax: {
                        name: "@babel/plugin-syntax-pipeline-operator",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-pipeline-operator",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
                    }
                },
                recordAndTuple: {
                    syntax: {
                        name: "@babel/plugin-syntax-record-and-tuple",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
                    }
                },
                throwExpressions: {
                    syntax: {
                        name: "@babel/plugin-syntax-throw-expressions",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
                    },
                    transform: {
                        name: "@babel/plugin-proposal-throw-expressions",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
                    }
                },
                typescript: {
                    syntax: {
                        name: "@babel/plugin-syntax-typescript",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
                    },
                    transform: {
                        name: "@babel/preset-typescript",
                        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
                    }
                }
            };
            {
                Object.assign(r, {
                    asyncGenerators: {
                        syntax: {
                            name: "@babel/plugin-syntax-async-generators",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
                        },
                        transform: {
                            name: "@babel/plugin-transform-async-generator-functions",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions"
                        }
                    },
                    classProperties: {
                        syntax: {
                            name: "@babel/plugin-syntax-class-properties",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
                        },
                        transform: {
                            name: "@babel/plugin-transform-class-properties",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
                        }
                    },
                    classPrivateProperties: {
                        syntax: {
                            name: "@babel/plugin-syntax-class-properties",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
                        },
                        transform: {
                            name: "@babel/plugin-transform-class-properties",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
                        }
                    },
                    classPrivateMethods: {
                        syntax: {
                            name: "@babel/plugin-syntax-class-properties",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
                        },
                        transform: {
                            name: "@babel/plugin-transform-private-methods",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods"
                        }
                    },
                    classStaticBlock: {
                        syntax: {
                            name: "@babel/plugin-syntax-class-static-block",
                            url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
                        },
                        transform: {
                            name: "@babel/plugin-transform-class-static-block",
                            url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block"
                        }
                    },
                    dynamicImport: {
                        syntax: {
                            name: "@babel/plugin-syntax-dynamic-import",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
                        }
                    },
                    exportNamespaceFrom: {
                        syntax: {
                            name: "@babel/plugin-syntax-export-namespace-from",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
                        },
                        transform: {
                            name: "@babel/plugin-transform-export-namespace-from",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from"
                        }
                    },
                    importAssertions: {
                        syntax: {
                            name: "@babel/plugin-syntax-import-assertions",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
                        }
                    },
                    importMeta: {
                        syntax: {
                            name: "@babel/plugin-syntax-import-meta",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
                        }
                    },
                    logicalAssignment: {
                        syntax: {
                            name: "@babel/plugin-syntax-logical-assignment-operators",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
                        },
                        transform: {
                            name: "@babel/plugin-transform-logical-assignment-operators",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators"
                        }
                    },
                    moduleStringNames: {
                        syntax: {
                            name: "@babel/plugin-syntax-module-string-names",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
                        }
                    },
                    numericSeparator: {
                        syntax: {
                            name: "@babel/plugin-syntax-numeric-separator",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
                        },
                        transform: {
                            name: "@babel/plugin-transform-numeric-separator",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator"
                        }
                    },
                    nullishCoalescingOperator: {
                        syntax: {
                            name: "@babel/plugin-syntax-nullish-coalescing-operator",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
                        },
                        transform: {
                            name: "@babel/plugin-transform-nullish-coalescing-operator",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
                        }
                    },
                    objectRestSpread: {
                        syntax: {
                            name: "@babel/plugin-syntax-object-rest-spread",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
                        },
                        transform: {
                            name: "@babel/plugin-transform-object-rest-spread",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread"
                        }
                    },
                    optionalCatchBinding: {
                        syntax: {
                            name: "@babel/plugin-syntax-optional-catch-binding",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
                        },
                        transform: {
                            name: "@babel/plugin-transform-optional-catch-binding",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding"
                        }
                    },
                    optionalChaining: {
                        syntax: {
                            name: "@babel/plugin-syntax-optional-chaining",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
                        },
                        transform: {
                            name: "@babel/plugin-transform-optional-chaining",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining"
                        }
                    },
                    privateIn: {
                        syntax: {
                            name: "@babel/plugin-syntax-private-property-in-object",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
                        },
                        transform: {
                            name: "@babel/plugin-transform-private-property-in-object",
                            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object"
                        }
                    },
                    regexpUnicodeSets: {
                        syntax: {
                            name: "@babel/plugin-syntax-unicode-sets-regex",
                            url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
                        },
                        transform: {
                            name: "@babel/plugin-transform-unicode-sets-regex",
                            url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
                        }
                    }
                });
            }
            const getNameURLCombination = ({ name: e1, url: t })=>`${e1} (${t})`;
            function generateMissingPluginMessage(e1, t, n) {
                let s = `Support for the experimental syntax '${e1}' isn't currently enabled ` + `(${t.line}:${t.column + 1}):\n\n` + n;
                const i = r[e1];
                if (i) {
                    const { syntax: e1, transform: t } = i;
                    if (e1) {
                        const r = getNameURLCombination(e1);
                        if (t) {
                            const e1 = getNameURLCombination(t);
                            const n = t.name.startsWith("@babel/plugin") ? "plugins" : "presets";
                            s += `\n\nAdd ${e1} to the '${n}' section of your Babel config to enable transformation.\nIf you want to leave it as-is, add ${r} to the 'plugins' section to enable parsing.`;
                        } else {
                            s += `\n\nAdd ${r} to the 'plugins' section of your Babel config ` + `to enable parsing.`;
                        }
                    }
                }
                return s;
            }
            0 && 0;
        },
        7472: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = _default;
            function helpers() {
                const e1 = r(1416);
                helpers = function() {
                    return e1;
                };
                return e1;
            }
            function _generator() {
                const e1 = r(3956);
                _generator = function() {
                    return e1;
                };
                return e1;
            }
            function _template() {
                const e1 = r(9128);
                _template = function() {
                    return e1;
                };
                return e1;
            }
            function _t() {
                const e1 = r(776);
                _t = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(6103);
            const { arrayExpression: s, assignmentExpression: i, binaryExpression: a, blockStatement: o, callExpression: l, cloneNode: c, conditionalExpression: u, exportNamedDeclaration: p, exportSpecifier: f, expressionStatement: d, functionExpression: h, identifier: m, memberExpression: y, objectExpression: g, program: b, stringLiteral: T, unaryExpression: S, variableDeclaration: E, variableDeclarator: v } = _t();
            const buildUmdWrapper = (e1)=>_template().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(e1);
            function buildGlobal(e1) {
                const t = m("babelHelpers");
                const r = [];
                const n = h(null, [
                    m("global")
                ], o(r));
                const s = b([
                    d(l(n, [
                        u(a("===", S("typeof", m("global")), T("undefined")), m("self"), m("global"))
                    ]))
                ]);
                r.push(E("var", [
                    v(t, i("=", y(m("global"), t), g([])))
                ]));
                buildHelpers(r, t, e1);
                return s;
            }
            function buildModule(e1) {
                const t = [];
                const r = buildHelpers(t, null, e1);
                t.unshift(p(null, Object.keys(r).map((e1)=>f(c(r[e1]), m(e1)))));
                return b(t, [], "module");
            }
            function buildUmd(e1) {
                const t = m("babelHelpers");
                const r = [];
                r.push(E("var", [
                    v(t, m("global"))
                ]));
                buildHelpers(r, t, e1);
                return b([
                    buildUmdWrapper({
                        FACTORY_PARAMETERS: m("global"),
                        BROWSER_ARGUMENTS: i("=", y(m("root"), t), g([])),
                        COMMON_ARGUMENTS: m("exports"),
                        AMD_ARGUMENTS: s([
                            T("exports")
                        ]),
                        FACTORY_BODY: r,
                        UMD_ROOT: m("this")
                    })
                ]);
            }
            function buildVar(e1) {
                const t = m("babelHelpers");
                const r = [];
                r.push(E("var", [
                    v(t, g([]))
                ]));
                const n = b(r);
                buildHelpers(r, t, e1);
                r.push(d(t));
                return n;
            }
            function buildHelpers(e1, t, r) {
                const getHelperReference = (e1)=>t ? y(t, m(e1)) : m(`_${e1}`);
                const s = {};
                helpers().list.forEach(function(t) {
                    if (r && r.indexOf(t) < 0) return;
                    const i = s[t] = getHelperReference(t);
                    helpers().ensure(t, n.default);
                    const { nodes: a } = helpers().get(t, getHelperReference, i);
                    e1.push(...a);
                });
                return s;
            }
            function _default(e1, t = "global") {
                let r;
                const n = {
                    global: buildGlobal,
                    module: buildModule,
                    umd: buildUmd,
                    var: buildVar
                }[t];
                if (n) {
                    r = n(e1);
                } else {
                    throw new Error(`Unsupported output type ${t}`);
                }
                return (0, _generator().default)(r).code;
            }
            0 && 0;
        },
        6895: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.transformFromAst = void 0;
            t.transformFromAstAsync = transformFromAstAsync;
            t.transformFromAstSync = transformFromAstSync;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(4455);
            var s = r(8589);
            var i = r(3585);
            const a = _gensync()(function*(e1, t, r) {
                const i = yield* (0, n.default)(r);
                if (i === null) return null;
                if (!e1) throw new Error("No AST given");
                return yield* (0, s.run)(i, t, e1);
            });
            const o = function transformFromAst(e1, t, r, n) {
                let s;
                let o;
                if (typeof r === "function") {
                    o = r;
                    s = undefined;
                } else {
                    s = r;
                    o = n;
                }
                if (o === undefined) {
                    {
                        return (0, i.beginHiddenCallStack)(a.sync)(e1, t, s);
                    }
                }
                (0, i.beginHiddenCallStack)(a.errback)(e1, t, s, o);
            };
            t.transformFromAst = o;
            function transformFromAstSync(...e1) {
                return (0, i.beginHiddenCallStack)(a.sync)(...e1);
            }
            function transformFromAstAsync(...e1) {
                return (0, i.beginHiddenCallStack)(a.async)(...e1);
            }
            0 && 0;
        },
        5885: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.transformFile = transformFile;
            t.transformFileAsync = transformFileAsync;
            t.transformFileSync = transformFileSync;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(4455);
            var s = r(8589);
            var i = r(9724);
            ({});
            const a = _gensync()(function*(e1, t) {
                const r = Object.assign({}, t, {
                    filename: e1
                });
                const a = yield* (0, n.default)(r);
                if (a === null) return null;
                const o = yield* i.readFile(e1, "utf8");
                return yield* (0, s.run)(a, o);
            });
            function transformFile(...e1) {
                a.errback(...e1);
            }
            function transformFileSync(...e1) {
                return a.sync(...e1);
            }
            function transformFileAsync(...e1) {
                return a.async(...e1);
            }
            0 && 0;
        },
        9994: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.transform = void 0;
            t.transformAsync = transformAsync;
            t.transformSync = transformSync;
            function _gensync() {
                const e1 = r(6433);
                _gensync = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(4455);
            var s = r(8589);
            var i = r(3585);
            const a = _gensync()(function* transform(e1, t) {
                const r = yield* (0, n.default)(t);
                if (r === null) return null;
                return yield* (0, s.run)(r, e1);
            });
            const o = function transform(e1, t, r) {
                let n;
                let s;
                if (typeof t === "function") {
                    s = t;
                    n = undefined;
                } else {
                    n = t;
                    s = r;
                }
                if (s === undefined) {
                    {
                        return (0, i.beginHiddenCallStack)(a.sync)(e1, n);
                    }
                }
                (0, i.beginHiddenCallStack)(a.errback)(e1, n, s);
            };
            t.transform = o;
            function transformSync(...e1) {
                return (0, i.beginHiddenCallStack)(a.sync)(...e1);
            }
            function transformAsync(...e1) {
                return (0, i.beginHiddenCallStack)(a.async)(...e1);
            }
            0 && 0;
        },
        2167: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = loadBlockHoistPlugin;
            function _traverse() {
                const e1 = r(2297);
                _traverse = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(7916);
            let s;
            const i = {
                name: "internal.blockHoist",
                visitor: {
                    Block: {
                        exit ({ node: e1 }) {
                            const { body: t } = e1;
                            let r = Math.pow(2, 30) - 1;
                            let n = false;
                            for(let e1 = 0; e1 < t.length; e1++){
                                const s = t[e1];
                                const i = priority(s);
                                if (i > r) {
                                    n = true;
                                    break;
                                }
                                r = i;
                            }
                            if (!n) return;
                            e1.body = stableSort(t.slice());
                        }
                    }
                }
            };
            function loadBlockHoistPlugin() {
                if (!s) {
                    s = new n.default(Object.assign({}, i, {
                        visitor: _traverse().default.explode(i.visitor)
                    }), {});
                }
                return s;
            }
            function priority(e1) {
                const t = e1 == null ? void 0 : e1._blockHoist;
                if (t == null) return 1;
                if (t === true) return 2;
                return t;
            }
            function stableSort(e1) {
                const t = Object.create(null);
                for(let r = 0; r < e1.length; r++){
                    const n = e1[r];
                    const s = priority(n);
                    const i = t[s] || (t[s] = []);
                    i.push(n);
                }
                const r = Object.keys(t).map((e1)=>+e1).sort((e1, t)=>t - e1);
                let n = 0;
                for (const s of r){
                    const r = t[s];
                    for (const t of r){
                        e1[n++] = t;
                    }
                }
                return e1;
            }
            0 && 0;
        },
        6103: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            function helpers() {
                const e1 = r(1416);
                helpers = function() {
                    return e1;
                };
                return e1;
            }
            function _traverse() {
                const e1 = r(2297);
                _traverse = function() {
                    return e1;
                };
                return e1;
            }
            function _codeFrame() {
                const e1 = r(2430);
                _codeFrame = function() {
                    return e1;
                };
                return e1;
            }
            function _t() {
                const e1 = r(776);
                _t = function() {
                    return e1;
                };
                return e1;
            }
            function _helperModuleTransforms() {
                const e1 = r(6646);
                _helperModuleTransforms = function() {
                    return e1;
                };
                return e1;
            }
            function _semver() {
                const e1 = r(7849);
                _semver = function() {
                    return e1;
                };
                return e1;
            }
            const { cloneNode: n, interpreterDirective: s } = _t();
            const i = {
                enter (e1, t) {
                    const r = e1.node.loc;
                    if (r) {
                        t.loc = r;
                        e1.stop();
                    }
                }
            };
            class File {
                constructor(e1, { code: t, ast: r, inputMap: n }){
                    this._map = new Map;
                    this.opts = void 0;
                    this.declarations = {};
                    this.path = void 0;
                    this.ast = void 0;
                    this.scope = void 0;
                    this.metadata = {};
                    this.code = "";
                    this.inputMap = void 0;
                    this.hub = {
                        file: this,
                        getCode: ()=>this.code,
                        getScope: ()=>this.scope,
                        addHelper: this.addHelper.bind(this),
                        buildError: this.buildCodeFrameError.bind(this)
                    };
                    this.opts = e1;
                    this.code = t;
                    this.ast = r;
                    this.inputMap = n;
                    this.path = _traverse().NodePath.get({
                        hub: this.hub,
                        parentPath: null,
                        parent: this.ast,
                        container: this.ast,
                        key: "program"
                    }).setContext();
                    this.scope = this.path.scope;
                }
                get shebang() {
                    const { interpreter: e1 } = this.path.node;
                    return e1 ? e1.value : "";
                }
                set shebang(e1) {
                    if (e1) {
                        this.path.get("interpreter").replaceWith(s(e1));
                    } else {
                        this.path.get("interpreter").remove();
                    }
                }
                set(e1, t) {
                    if (e1 === "helpersNamespace") {
                        throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility." + "If you are using @babel/plugin-external-helpers you will need to use a newer " + "version than the one you currently have installed. " + "If you have your own implementation, you'll want to explore using 'helperGenerator' " + "alongside 'file.availableHelper()'.");
                    }
                    this._map.set(e1, t);
                }
                get(e1) {
                    return this._map.get(e1);
                }
                has(e1) {
                    return this._map.has(e1);
                }
                getModuleName() {
                    return (0, _helperModuleTransforms().getModuleName)(this.opts, this.opts);
                }
                addImport() {
                    throw new Error("This API has been removed. If you're looking for this " + "functionality in Babel 7, you should import the " + "'@babel/helper-module-imports' module and use the functions exposed " + " from that module, such as 'addNamed' or 'addDefault'.");
                }
                availableHelper(e1, t) {
                    let r;
                    try {
                        r = helpers().minVersion(e1);
                    } catch (e1) {
                        if (e1.code !== "BABEL_HELPER_UNKNOWN") throw e1;
                        return false;
                    }
                    if (typeof t !== "string") return true;
                    if (_semver().valid(t)) t = `^${t}`;
                    return !_semver().intersects(`<${r}`, t) && !_semver().intersects(`>=8.0.0`, t);
                }
                addHelper(e1) {
                    const t = this.declarations[e1];
                    if (t) return n(t);
                    const r = this.get("helperGenerator");
                    if (r) {
                        const t = r(e1);
                        if (t) return t;
                    }
                    helpers().ensure(e1, File);
                    const s = this.declarations[e1] = this.scope.generateUidIdentifier(e1);
                    const i = {};
                    for (const t of helpers().getDependencies(e1)){
                        i[t] = this.addHelper(t);
                    }
                    const { nodes: a, globals: o } = helpers().get(e1, (e1)=>i[e1], s, Object.keys(this.scope.getAllBindings()));
                    o.forEach((e1)=>{
                        if (this.path.scope.hasBinding(e1, true)) {
                            this.path.scope.rename(e1);
                        }
                    });
                    a.forEach((e1)=>{
                        e1._compact = true;
                    });
                    this.path.unshiftContainer("body", a);
                    this.path.get("body").forEach((e1)=>{
                        if (a.indexOf(e1.node) === -1) return;
                        if (e1.isVariableDeclaration()) this.scope.registerDeclaration(e1);
                    });
                    return s;
                }
                addTemplateObject() {
                    throw new Error("This function has been moved into the template literal transform itself.");
                }
                buildCodeFrameError(e1, t, r = SyntaxError) {
                    let n = e1 && (e1.loc || e1._loc);
                    if (!n && e1) {
                        const r = {
                            loc: null
                        };
                        (0, _traverse().default)(e1, i, this.scope, r);
                        n = r.loc;
                        let s = "This is an error on an internal node. Probably an internal error.";
                        if (n) s += " Location has been estimated.";
                        t += ` (${s})`;
                    }
                    if (n) {
                        const { highlightCode: e1 = true } = this.opts;
                        t += "\n" + (0, _codeFrame().codeFrameColumns)(this.code, {
                            start: {
                                line: n.start.line,
                                column: n.start.column + 1
                            },
                            end: n.end && n.start.line === n.end.line ? {
                                line: n.end.line,
                                column: n.end.column + 1
                            } : undefined
                        }, {
                            highlightCode: e1
                        });
                    }
                    return new r(t);
                }
            }
            t["default"] = File;
            0 && 0;
        },
        4327: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = generateCode;
            function _convertSourceMap() {
                const e1 = r(9714);
                _convertSourceMap = function() {
                    return e1;
                };
                return e1;
            }
            function _generator() {
                const e1 = r(3956);
                _generator = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(2035);
            function generateCode(e1, t) {
                const { opts: r, ast: s, code: i, inputMap: a } = t;
                const { generatorOpts: o } = r;
                o.inputSourceMap = a == null ? void 0 : a.toObject();
                const l = [];
                for (const t of e1){
                    for (const e1 of t){
                        const { generatorOverride: t } = e1;
                        if (t) {
                            const e1 = t(s, o, i, _generator().default);
                            if (e1 !== undefined) l.push(e1);
                        }
                    }
                }
                let c;
                if (l.length === 0) {
                    c = (0, _generator().default)(s, o, i);
                } else if (l.length === 1) {
                    c = l[0];
                    if (typeof c.then === "function") {
                        throw new Error(`You appear to be using an async codegen plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version.`);
                    }
                } else {
                    throw new Error("More than one plugin attempted to override codegen.");
                }
                let { code: u, decodedMap: p = c.map } = c;
                if (c.__mergedMap) {
                    p = Object.assign({}, c.map);
                } else {
                    if (p) {
                        if (a) {
                            p = (0, n.default)(a.toObject(), p, o.sourceFileName);
                        } else {
                            p = c.map;
                        }
                    }
                }
                if (r.sourceMaps === "inline" || r.sourceMaps === "both") {
                    u += "\n" + _convertSourceMap().fromObject(p).toComment();
                }
                if (r.sourceMaps === "inline") {
                    p = null;
                }
                return {
                    outputCode: u,
                    outputMap: p
                };
            }
            0 && 0;
        },
        2035: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = mergeSourceMap;
            function _remapping() {
                const e1 = r(3914);
                _remapping = function() {
                    return e1;
                };
                return e1;
            }
            function mergeSourceMap(e1, t, r) {
                const n = r.replace(/\\/g, "/");
                let s = false;
                const i = _remapping()(rootless(t), (t, r)=>{
                    if (t === n && !s) {
                        s = true;
                        r.source = "";
                        return rootless(e1);
                    }
                    return null;
                });
                if (typeof e1.sourceRoot === "string") {
                    i.sourceRoot = e1.sourceRoot;
                }
                return Object.assign({}, i);
            }
            function rootless(e1) {
                return Object.assign({}, e1, {
                    sourceRoot: null
                });
            }
            0 && 0;
        },
        8589: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.run = run;
            function _traverse() {
                const e1 = r(2297);
                _traverse = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(1732);
            var s = r(2167);
            var i = r(3907);
            var a = r(4082);
            var o = r(4327);
            var l = r(9435);
            function* run(e1, t, r) {
                const n = yield* (0, a.default)(e1.passes, (0, i.default)(e1), t, r);
                const s = n.opts;
                try {
                    yield* transformFile(n, e1.passes);
                } catch (e1) {
                    var c;
                    e1.message = `${(c = s.filename) != null ? c : "unknown file"}: ${e1.message}`;
                    if (!e1.code) {
                        e1.code = "BABEL_TRANSFORM_ERROR";
                    }
                    throw e1;
                }
                let u, p;
                try {
                    if (s.code !== false) {
                        ({ outputCode: u, outputMap: p } = (0, o.default)(e1.passes, n));
                    }
                } catch (e1) {
                    var f;
                    e1.message = `${(f = s.filename) != null ? f : "unknown file"}: ${e1.message}`;
                    if (!e1.code) {
                        e1.code = "BABEL_GENERATE_ERROR";
                    }
                    throw e1;
                }
                return {
                    metadata: n.metadata,
                    options: s,
                    ast: s.ast === true ? n.ast : null,
                    code: u === undefined ? null : u,
                    map: p === undefined ? null : p,
                    sourceType: n.ast.program.sourceType,
                    externalDependencies: (0, l.flattenToSet)(e1.externalDependencies)
                };
            }
            function* transformFile(e1, t) {
                for (const r of t){
                    const t = [];
                    const i = [];
                    const a = [];
                    for (const o of r.concat([
                        (0, s.default)()
                    ])){
                        const r = new n.default(e1, o.key, o.options);
                        t.push([
                            o,
                            r
                        ]);
                        i.push(r);
                        a.push(o.visitor);
                    }
                    for (const [r, n] of t){
                        const t = r.pre;
                        if (t) {
                            const r = t.call(n, e1);
                            yield* [];
                            if (isThenable(r)) {
                                throw new Error(`You appear to be using an plugin with an async .pre, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);
                            }
                        }
                    }
                    const o = _traverse().default.visitors.merge(a, i, e1.opts.wrapPluginVisitorMethod);
                    (0, _traverse().default)(e1.ast, o, e1.scope);
                    for (const [r, n] of t){
                        const t = r.post;
                        if (t) {
                            const r = t.call(n, e1);
                            yield* [];
                            if (isThenable(r)) {
                                throw new Error(`You appear to be using an plugin with an async .post, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);
                            }
                        }
                    }
                }
            }
            function isThenable(e1) {
                return !!e1 && (typeof e1 === "object" || typeof e1 === "function") && !!e1.then && typeof e1.then === "function";
            }
            0 && 0;
        },
        4082: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = normalizeFile;
            function _fs() {
                const e1 = r(7147);
                _fs = function() {
                    return e1;
                };
                return e1;
            }
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function _debug() {
                const e1 = r(6937);
                _debug = function() {
                    return e1;
                };
                return e1;
            }
            function _t() {
                const e1 = r(776);
                _t = function() {
                    return e1;
                };
                return e1;
            }
            function _convertSourceMap() {
                const e1 = r(9714);
                _convertSourceMap = function() {
                    return e1;
                };
                return e1;
            }
            var n = r(6103);
            var s = r(2865);
            var i = r(9977);
            const { file: a, traverseFast: o } = _t();
            const l = _debug()("babel:transform:file");
            const c = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/;
            const u = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
            function* normalizeFile(e1, t, r, o) {
                r = `${r || ""}`;
                if (o) {
                    if (o.type === "Program") {
                        o = a(o, [], []);
                    } else if (o.type !== "File") {
                        throw new Error("AST root must be a Program or File node");
                    }
                    if (t.cloneInputAst) {
                        o = (0, i.default)(o);
                    }
                } else {
                    o = yield* (0, s.default)(e1, t, r);
                }
                let p = null;
                if (t.inputSourceMap !== false) {
                    if (typeof t.inputSourceMap === "object") {
                        p = _convertSourceMap().fromObject(t.inputSourceMap);
                    }
                    if (!p) {
                        const e1 = extractComments(c, o);
                        if (e1) {
                            try {
                                p = _convertSourceMap().fromComment(e1);
                            } catch (e1) {
                                l("discarding unknown inline input sourcemap", e1);
                            }
                        }
                    }
                    if (!p) {
                        const e1 = extractComments(u, o);
                        if (typeof t.filename === "string" && e1) {
                            try {
                                const r = u.exec(e1);
                                const n = _fs().readFileSync(_path().resolve(_path().dirname(t.filename), r[1]), "utf8");
                                p = _convertSourceMap().fromJSON(n);
                            } catch (e1) {
                                l("discarding unknown file input sourcemap", e1);
                            }
                        } else if (e1) {
                            l("discarding un-loadable file input sourcemap");
                        }
                    }
                }
                return new n.default(t, {
                    code: r,
                    ast: o,
                    inputMap: p
                });
            }
            function extractCommentsFromList(e1, t, r) {
                if (t) {
                    t = t.filter(({ value: t })=>{
                        if (e1.test(t)) {
                            r = t;
                            return false;
                        }
                        return true;
                    });
                }
                return [
                    t,
                    r
                ];
            }
            function extractComments(e1, t) {
                let r = null;
                o(t, (t)=>{
                    [t.leadingComments, r] = extractCommentsFromList(e1, t.leadingComments, r);
                    [t.innerComments, r] = extractCommentsFromList(e1, t.innerComments, r);
                    [t.trailingComments, r] = extractCommentsFromList(e1, t.trailingComments, r);
                });
                return r;
            }
            0 && 0;
        },
        3907: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = normalizeOptions;
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function normalizeOptions(e1) {
                const { filename: t, cwd: r, filenameRelative: n = typeof t === "string" ? _path().relative(r, t) : "unknown", sourceType: s = "module", inputSourceMap: i, sourceMaps: a = !!i, sourceRoot: o = e1.options.moduleRoot, sourceFileName: l = _path().basename(n), comments: c = true, compact: u = "auto" } = e1.options;
                const p = e1.options;
                const f = Object.assign({}, p, {
                    parserOpts: Object.assign({
                        sourceType: _path().extname(n) === ".mjs" ? "module" : s,
                        sourceFileName: t,
                        plugins: []
                    }, p.parserOpts),
                    generatorOpts: Object.assign({
                        filename: t,
                        auxiliaryCommentBefore: p.auxiliaryCommentBefore,
                        auxiliaryCommentAfter: p.auxiliaryCommentAfter,
                        retainLines: p.retainLines,
                        comments: c,
                        shouldPrintComment: p.shouldPrintComment,
                        compact: u,
                        minified: p.minified,
                        sourceMaps: a,
                        sourceRoot: o,
                        sourceFileName: l
                    }, p.generatorOpts)
                });
                for (const t of e1.passes){
                    for (const e1 of t){
                        if (e1.manipulateOptions) {
                            e1.manipulateOptions(f, f.parserOpts);
                        }
                    }
                }
                return f;
            }
            0 && 0;
        },
        1732: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            class PluginPass {
                constructor(e1, t, r){
                    this._map = new Map;
                    this.key = void 0;
                    this.file = void 0;
                    this.opts = void 0;
                    this.cwd = void 0;
                    this.filename = void 0;
                    this.key = t;
                    this.file = e1;
                    this.opts = r || {};
                    this.cwd = e1.opts.cwd;
                    this.filename = e1.opts.filename;
                }
                set(e1, t) {
                    this._map.set(e1, t);
                }
                get(e1) {
                    return this._map.get(e1);
                }
                availableHelper(e1, t) {
                    return this.file.availableHelper(e1, t);
                }
                addHelper(e1) {
                    return this.file.addHelper(e1);
                }
                buildCodeFrameError(e1, t, r) {
                    return this.file.buildCodeFrameError(e1, t, r);
                }
            }
            t["default"] = PluginPass;
            {
                PluginPass.prototype.getModuleName = function getModuleName() {
                    return this.file.getModuleName();
                };
                PluginPass.prototype.addImport = function addImport() {
                    this.file.addImport();
                };
            }
            0 && 0;
        },
        9977: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = _default;
            function deepClone(e1, t) {
                if (e1 !== null) {
                    if (t.has(e1)) return t.get(e1);
                    let r;
                    if (Array.isArray(e1)) {
                        r = new Array(e1.length);
                        t.set(e1, r);
                        for(let n = 0; n < e1.length; n++){
                            r[n] = typeof e1[n] !== "object" ? e1[n] : deepClone(e1[n], t);
                        }
                    } else {
                        r = {};
                        t.set(e1, r);
                        const n = Object.keys(e1);
                        for(let s = 0; s < n.length; s++){
                            const i = n[s];
                            r[i] = typeof e1[i] !== "object" ? e1[i] : deepClone(e1[i], t);
                        }
                    }
                    return r;
                }
                return e1;
            }
            function _default(e1) {
                if (typeof e1 !== "object") return e1;
                return deepClone(e1, new Map);
            }
            0 && 0;
        },
        5655: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.moduleResolve = moduleResolve;
            t.resolve = resolve;
            function _assert() {
                const e1 = r(9491);
                _assert = function() {
                    return e1;
                };
                return e1;
            }
            function _fs() {
                const e1 = _interopRequireWildcard(r(7147), true);
                _fs = function() {
                    return e1;
                };
                return e1;
            }
            function _process() {
                const e1 = r(7282);
                _process = function() {
                    return e1;
                };
                return e1;
            }
            function _url() {
                const e1 = r(7310);
                _url = function() {
                    return e1;
                };
                return e1;
            }
            function _path() {
                const e1 = r(1017);
                _path = function() {
                    return e1;
                };
                return e1;
            }
            function _module() {
                const e1 = r(8188);
                _module = function() {
                    return e1;
                };
                return e1;
            }
            function _v() {
                const e1 = r(4655);
                _v = function() {
                    return e1;
                };
                return e1;
            }
            function _util() {
                const e1 = r(3849);
                _util = function() {
                    return e1;
                };
                return e1;
            }
            function _getRequireWildcardCache(e1) {
                if (typeof WeakMap !== "function") return null;
                var t = new WeakMap;
                var r = new WeakMap;
                return (_getRequireWildcardCache = function(e1) {
                    return e1 ? r : t;
                })(e1);
            }
            function _interopRequireWildcard(e1, t) {
                if (!t && e1 && e1.__esModule) {
                    return e1;
                }
                if (e1 === null || typeof e1 !== "object" && typeof e1 !== "function") {
                    return {
                        default: e1
                    };
                }
                var r = _getRequireWildcardCache(t);
                if (r && r.has(e1)) {
                    return r.get(e1);
                }
                var n = {};
                var s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var i in e1){
                    if (i !== "default" && Object.prototype.hasOwnProperty.call(e1, i)) {
                        var a = s ? Object.getOwnPropertyDescriptor(e1, i) : null;
                        if (a && (a.get || a.set)) {
                            Object.defineProperty(n, i, a);
                        } else {
                            n[i] = e1[i];
                        }
                    }
                }
                n.default = e1;
                if (r) {
                    r.set(e1, n);
                }
                return n;
            }
            const n = _process().platform === "win32";
            const s = {}.hasOwnProperty;
            const i = /^([A-Z][a-z\d]*)+$/;
            const a = new Set([
                "string",
                "function",
                "number",
                "object",
                "Function",
                "Object",
                "boolean",
                "bigint",
                "symbol"
            ]);
            const o = {};
            function formatList(e1, t = "and") {
                return e1.length < 3 ? e1.join(` ${t} `) : `${e1.slice(0, -1).join(", ")}, ${t} ${e1[e1.length - 1]}`;
            }
            const l = new Map;
            const c = "__node_internal_";
            let u;
            o.ERR_INVALID_ARG_TYPE = createError("ERR_INVALID_ARG_TYPE", (e1, t, r)=>{
                _assert()(typeof e1 === "string", "'name' must be a string");
                if (!Array.isArray(t)) {
                    t = [
                        t
                    ];
                }
                let n = "The ";
                if (e1.endsWith(" argument")) {
                    n += `${e1} `;
                } else {
                    const t = e1.includes(".") ? "property" : "argument";
                    n += `"${e1}" ${t} `;
                }
                n += "must be ";
                const s = [];
                const o = [];
                const l = [];
                for (const e1 of t){
                    _assert()(typeof e1 === "string", "All expected entries have to be of type string");
                    if (a.has(e1)) {
                        s.push(e1.toLowerCase());
                    } else if (i.exec(e1) === null) {
                        _assert()(e1 !== "object", 'The value "object" should be written as "Object"');
                        l.push(e1);
                    } else {
                        o.push(e1);
                    }
                }
                if (o.length > 0) {
                    const e1 = s.indexOf("object");
                    if (e1 !== -1) {
                        s.slice(e1, 1);
                        o.push("Object");
                    }
                }
                if (s.length > 0) {
                    n += `${s.length > 1 ? "one of type" : "of type"} ${formatList(s, "or")}`;
                    if (o.length > 0 || l.length > 0) n += " or ";
                }
                if (o.length > 0) {
                    n += `an instance of ${formatList(o, "or")}`;
                    if (l.length > 0) n += " or ";
                }
                if (l.length > 0) {
                    if (l.length > 1) {
                        n += `one of ${formatList(l, "or")}`;
                    } else {
                        if (l[0].toLowerCase() !== l[0]) n += "an ";
                        n += `${l[0]}`;
                    }
                }
                n += `. Received ${determineSpecificType(r)}`;
                return n;
            }, TypeError);
            o.ERR_INVALID_MODULE_SPECIFIER = createError("ERR_INVALID_MODULE_SPECIFIER", (e1, t, r = undefined)=>`Invalid module "${e1}" ${t}${r ? ` imported from ${r}` : ""}`, TypeError);
            o.ERR_INVALID_PACKAGE_CONFIG = createError("ERR_INVALID_PACKAGE_CONFIG", (e1, t, r)=>`Invalid package config ${e1}${t ? ` while importing ${t}` : ""}${r ? `. ${r}` : ""}`, Error);
            o.ERR_INVALID_PACKAGE_TARGET = createError("ERR_INVALID_PACKAGE_TARGET", (e1, t, r, n = false, s = undefined)=>{
                const i = typeof r === "string" && !n && r.length > 0 && !r.startsWith("./");
                if (t === ".") {
                    _assert()(n === false);
                    return `Invalid "exports" main target ${JSON.stringify(r)} defined ` + `in the package config ${e1}package.json${s ? ` imported from ${s}` : ""}${i ? '; targets must start with "./"' : ""}`;
                }
                return `Invalid "${n ? "imports" : "exports"}" target ${JSON.stringify(r)} defined for '${t}' in the package config ${e1}package.json${s ? ` imported from ${s}` : ""}${i ? '; targets must start with "./"' : ""}`;
            }, Error);
            o.ERR_MODULE_NOT_FOUND = createError("ERR_MODULE_NOT_FOUND", (e1, t, r = "package")=>`Cannot find ${r} '${e1}' imported from ${t}`, Error);
            o.ERR_NETWORK_IMPORT_DISALLOWED = createError("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
            o.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError("ERR_PACKAGE_IMPORT_NOT_DEFINED", (e1, t, r)=>`Package import specifier "${e1}" is not defined${t ? ` in package ${t}package.json` : ""} imported from ${r}`, TypeError);
            o.ERR_PACKAGE_PATH_NOT_EXPORTED = createError("ERR_PACKAGE_PATH_NOT_EXPORTED", (e1, t, r = undefined)=>{
                if (t === ".") return `No "exports" main defined in ${e1}package.json${r ? ` imported from ${r}` : ""}`;
                return `Package subpath '${t}' is not defined by "exports" in ${e1}package.json${r ? ` imported from ${r}` : ""}`;
            }, Error);
            o.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported " + "resolving ES modules imported from %s", Error);
            o.ERR_UNKNOWN_FILE_EXTENSION = createError("ERR_UNKNOWN_FILE_EXTENSION", (e1, t)=>`Unknown file extension "${e1}" for ${t}`, TypeError);
            o.ERR_INVALID_ARG_VALUE = createError("ERR_INVALID_ARG_VALUE", (e1, t, r = "is invalid")=>{
                let n = (0, _util().inspect)(t);
                if (n.length > 128) {
                    n = `${n.slice(0, 128)}...`;
                }
                const s = e1.includes(".") ? "property" : "argument";
                return `The ${s} '${e1}' ${r}. Received ${n}`;
            }, TypeError);
            o.ERR_UNSUPPORTED_ESM_URL_SCHEME = createError("ERR_UNSUPPORTED_ESM_URL_SCHEME", (e1, t)=>{
                let r = `Only URLs with a scheme in: ${formatList(t)} are supported by the default ESM loader`;
                if (n && e1.protocol.length === 2) {
                    r += ". On Windows, absolute paths must be valid file:// URLs";
                }
                r += `. Received protocol '${e1.protocol}'`;
                return r;
            }, Error);
            function createError(e1, t, r) {
                l.set(e1, t);
                return makeNodeErrorWithCode(r, e1);
            }
            function makeNodeErrorWithCode(e1, t) {
                return NodeError;
                "TURBOPACK unreachable";
                function NodeError(...r) {
                    const n = Error.stackTraceLimit;
                    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
                    const s = new e1;
                    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = n;
                    const i = getMessage(t, r, s);
                    Object.defineProperties(s, {
                        message: {
                            value: i,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        },
                        toString: {
                            value () {
                                return `${this.name} [${t}]: ${this.message}`;
                            },
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    p(s);
                    s.code = t;
                    return s;
                }
            }
            function isErrorStackTraceLimitWritable() {
                try {
                    if (_v().startupSnapshot.isBuildingSnapshot()) {
                        return false;
                    }
                } catch (e1) {}
                const e1 = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
                if (e1 === undefined) {
                    return Object.isExtensible(Error);
                }
                return s.call(e1, "writable") && e1.writable !== undefined ? e1.writable : e1.set !== undefined;
            }
            function hideStackFrames(e1) {
                const t = c + e1.name;
                Object.defineProperty(e1, "name", {
                    value: t
                });
                return e1;
            }
            const p = hideStackFrames(function(e1) {
                const t = isErrorStackTraceLimitWritable();
                if (t) {
                    u = Error.stackTraceLimit;
                    Error.stackTraceLimit = Number.POSITIVE_INFINITY;
                }
                Error.captureStackTrace(e1);
                if (t) Error.stackTraceLimit = u;
                return e1;
            });
            function getMessage(e1, t, r) {
                const n = l.get(e1);
                _assert()(n !== undefined, "expected `message` to be found");
                if (typeof n === "function") {
                    _assert()(n.length <= t.length, `Code: ${e1}; The provided arguments length (${t.length}) does not ` + `match the required ones (${n.length}).`);
                    return Reflect.apply(n, r, t);
                }
                const s = /%[dfijoOs]/g;
                let i = 0;
                while(s.exec(n) !== null)i++;
                _assert()(i === t.length, `Code: ${e1}; The provided arguments length (${t.length}) does not ` + `match the required ones (${i}).`);
                if (t.length === 0) return n;
                t.unshift(n);
                return Reflect.apply(_util().format, null, t);
            }
            function determineSpecificType(e1) {
                if (e1 === null || e1 === undefined) {
                    return String(e1);
                }
                if (typeof e1 === "function" && e1.name) {
                    return `function ${e1.name}`;
                }
                if (typeof e1 === "object") {
                    if (e1.constructor && e1.constructor.name) {
                        return `an instance of ${e1.constructor.name}`;
                    }
                    return `${(0, _util().inspect)(e1, {
                        depth: -1
                    })}`;
                }
                let t = (0, _util().inspect)(e1, {
                    colors: false
                });
                if (t.length > 28) {
                    t = `${t.slice(0, 25)}...`;
                }
                return `type ${typeof e1} (${t})`;
            }
            const f = {
                read: read
            };
            var d = f;
            function read(e1) {
                try {
                    const t = _fs().default.readFileSync(_path().toNamespacedPath(_path().join(_path().dirname(e1), "package.json")), "utf8");
                    return {
                        string: t
                    };
                } catch (e1) {
                    const t = e1;
                    if (t.code === "ENOENT") {
                        return {
                            string: undefined
                        };
                    }
                    throw t;
                }
            }
            const { ERR_INVALID_PACKAGE_CONFIG: h } = o;
            const m = new Map;
            function getPackageConfig(e1, t, r) {
                const n = m.get(e1);
                if (n !== undefined) {
                    return n;
                }
                const s = d.read(e1).string;
                if (s === undefined) {
                    const t = {
                        pjsonPath: e1,
                        exists: false,
                        main: undefined,
                        name: undefined,
                        type: "none",
                        exports: undefined,
                        imports: undefined
                    };
                    m.set(e1, t);
                    return t;
                }
                let i;
                try {
                    i = JSON.parse(s);
                } catch (n) {
                    const s = n;
                    throw new h(e1, (r ? `"${t}" from ` : "") + (0, _url().fileURLToPath)(r || t), s.message);
                }
                const { exports: a, imports: o, main: l, name: c, type: u } = i;
                const p = {
                    pjsonPath: e1,
                    exists: true,
                    main: typeof l === "string" ? l : undefined,
                    name: typeof c === "string" ? c : undefined,
                    type: u === "module" || u === "commonjs" ? u : "none",
                    exports: a,
                    imports: o && typeof o === "object" ? o : undefined
                };
                m.set(e1, p);
                return p;
            }
            function getPackageScopeConfig(e1) {
                let t = new (_url()).URL("package.json", e1);
                while(true){
                    const r = t.pathname;
                    if (r.endsWith("node_modules/package.json")) break;
                    const n = getPackageConfig((0, _url().fileURLToPath)(t), e1);
                    if (n.exists) return n;
                    const s = t;
                    t = new (_url()).URL("../package.json", t);
                    if (t.pathname === s.pathname) break;
                }
                const r = (0, _url().fileURLToPath)(t);
                const n = {
                    pjsonPath: r,
                    exists: false,
                    main: undefined,
                    name: undefined,
                    type: "none",
                    exports: undefined,
                    imports: undefined
                };
                m.set(r, n);
                return n;
            }
            function getPackageType(e1) {
                const t = getPackageScopeConfig(e1);
                return t.type;
            }
            const { ERR_UNKNOWN_FILE_EXTENSION: y } = o;
            const g = {}.hasOwnProperty;
            const b = {
                __proto__: null,
                ".cjs": "commonjs",
                ".js": "module",
                ".json": "json",
                ".mjs": "module"
            };
            function mimeToFormat(e1) {
                if (e1 && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(e1)) return "module";
                if (e1 === "application/json") return "json";
                return null;
            }
            const T = {
                __proto__: null,
                "data:": getDataProtocolModuleFormat,
                "file:": getFileProtocolModuleFormat,
                "http:": getHttpProtocolModuleFormat,
                "https:": getHttpProtocolModuleFormat,
                "node:" () {
                    return "builtin";
                }
            };
            function getDataProtocolModuleFormat(e1) {
                const { 1: t } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(e1.pathname) || [
                    null,
                    null,
                    null
                ];
                return mimeToFormat(t);
            }
            function extname(e1) {
                const t = e1.pathname;
                let r = t.length;
                while(r--){
                    const e1 = t.codePointAt(r);
                    if (e1 === 47) {
                        return "";
                    }
                    if (e1 === 46) {
                        return t.codePointAt(r - 1) === 47 ? "" : t.slice(r);
                    }
                }
                return "";
            }
            function getFileProtocolModuleFormat(e1, t, r) {
                const n = extname(e1);
                if (n === ".js") {
                    return getPackageType(e1) === "module" ? "module" : "commonjs";
                }
                const s = b[n];
                if (s) return s;
                if (r) {
                    return undefined;
                }
                const i = (0, _url().fileURLToPath)(e1);
                throw new y(n, i);
            }
            function getHttpProtocolModuleFormat() {}
            function defaultGetFormatWithoutErrors(e1, t) {
                if (!g.call(T, e1.protocol)) {
                    return null;
                }
                return T[e1.protocol](e1, t, true) || null;
            }
            const { ERR_INVALID_ARG_VALUE: S } = o;
            const E = Object.freeze([
                "node",
                "import"
            ]);
            const v = new Set(E);
            function getDefaultConditions() {
                return E;
            }
            function getDefaultConditionsSet() {
                return v;
            }
            function getConditionsSet(e1) {
                if (e1 !== undefined && e1 !== getDefaultConditions()) {
                    if (!Array.isArray(e1)) {
                        throw new S("conditions", e1, "expected an array");
                    }
                    return new Set(e1);
                }
                return getDefaultConditionsSet();
            }
            const x = RegExp.prototype[Symbol.replace];
            const P = false;
            const { ERR_NETWORK_IMPORT_DISALLOWED: w, ERR_INVALID_MODULE_SPECIFIER: A, ERR_INVALID_PACKAGE_CONFIG: C, ERR_INVALID_PACKAGE_TARGET: I, ERR_MODULE_NOT_FOUND: O, ERR_PACKAGE_IMPORT_NOT_DEFINED: k, ERR_PACKAGE_PATH_NOT_EXPORTED: N, ERR_UNSUPPORTED_DIR_IMPORT: _, ERR_UNSUPPORTED_ESM_URL_SCHEME: D } = o;
            const M = {}.hasOwnProperty;
            const L = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
            const j = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
            const F = /^\.|%|\\/;
            const R = /\*/g;
            const B = /%2f|%5c/i;
            const U = new Set;
            const K = /[/\\]{2}/;
            function emitInvalidSegmentDeprecation(e1, t, r, n, s, i, a) {
                const o = (0, _url().fileURLToPath)(n);
                const l = K.exec(a ? e1 : t) !== null;
                _process().emitWarning(`Use of deprecated ${l ? "double slash" : "leading or trailing slash matching"} resolving "${e1}" for module ` + `request "${t}" ${t === r ? "" : `matched to "${r}" `}in the "${s ? "imports" : "exports"}" field module resolution of the package at ${o}${i ? ` imported from ${(0, _url().fileURLToPath)(i)}` : ""}.`, "DeprecationWarning", "DEP0166");
            }
            function emitLegacyIndexDeprecation(e1, t, r, n) {
                const s = defaultGetFormatWithoutErrors(e1, {
                    parentURL: r.href
                });
                if (s !== "module") return;
                const i = (0, _url().fileURLToPath)(e1.href);
                const a = (0, _url().fileURLToPath)(new (_url()).URL(".", t));
                const o = (0, _url().fileURLToPath)(r);
                if (n) _process().emitWarning(`Package ${a} has a "main" field set to ${JSON.stringify(n)}, ` + `excluding the full filename and extension to the resolved file at "${i.slice(a.length)}", imported from ${o}.\n Automatic extension resolution of the "main" field is` + "deprecated for ES modules.", "DeprecationWarning", "DEP0151");
                else _process().emitWarning(`No "main" or "exports" field defined in the package.json for ${a} resolving the main entry point "${i.slice(a.length)}", imported from ${o}.\nDefault "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
            }
            function tryStatSync(e1) {
                try {
                    return (0, _fs().statSync)(e1);
                } catch (e1) {
                    return new (_fs()).Stats;
                }
            }
            function fileExists(e1) {
                const t = (0, _fs().statSync)(e1, {
                    throwIfNoEntry: false
                });
                const r = t ? t.isFile() : undefined;
                return r === null || r === undefined ? false : r;
            }
            function legacyMainResolve(e1, t, r) {
                let n;
                if (t.main !== undefined) {
                    n = new (_url()).URL(t.main, e1);
                    if (fileExists(n)) return n;
                    const s = [
                        `./${t.main}.js`,
                        `./${t.main}.json`,
                        `./${t.main}.node`,
                        `./${t.main}/index.js`,
                        `./${t.main}/index.json`,
                        `./${t.main}/index.node`
                    ];
                    let i = -1;
                    while(++i < s.length){
                        n = new (_url()).URL(s[i], e1);
                        if (fileExists(n)) break;
                        n = undefined;
                    }
                    if (n) {
                        emitLegacyIndexDeprecation(n, e1, r, t.main);
                        return n;
                    }
                }
                const s = [
                    "./index.js",
                    "./index.json",
                    "./index.node"
                ];
                let i = -1;
                while(++i < s.length){
                    n = new (_url()).URL(s[i], e1);
                    if (fileExists(n)) break;
                    n = undefined;
                }
                if (n) {
                    emitLegacyIndexDeprecation(n, e1, r, t.main);
                    return n;
                }
                throw new O((0, _url().fileURLToPath)(new (_url()).URL(".", e1)), (0, _url().fileURLToPath)(r));
            }
            function finalizeResolution(e1, t, r) {
                if (B.exec(e1.pathname) !== null) throw new A(e1.pathname, 'must not include encoded "/" or "\\" characters', (0, _url().fileURLToPath)(t));
                const n = (0, _url().fileURLToPath)(e1);
                const s = tryStatSync(n.endsWith("/") ? n.slice(-1) : n);
                if (s.isDirectory()) {
                    const r = new _(n, (0, _url().fileURLToPath)(t));
                    r.url = String(e1);
                    throw r;
                }
                if (!s.isFile()) {
                    throw new O(n || e1.pathname, t && (0, _url().fileURLToPath)(t), "module");
                }
                if (!r) {
                    const t = (0, _fs().realpathSync)(n);
                    const { search: r, hash: s } = e1;
                    e1 = (0, _url().pathToFileURL)(t + (n.endsWith(_path().sep) ? "/" : ""));
                    e1.search = r;
                    e1.hash = s;
                }
                return e1;
            }
            function importNotDefined(e1, t, r) {
                return new k(e1, t && (0, _url().fileURLToPath)(new (_url()).URL(".", t)), (0, _url().fileURLToPath)(r));
            }
            function exportsNotFound(e1, t, r) {
                return new N((0, _url().fileURLToPath)(new (_url()).URL(".", t)), e1, r && (0, _url().fileURLToPath)(r));
            }
            function throwInvalidSubpath(e1, t, r, n, s) {
                const i = `request is not a valid match in pattern "${t}" for the "${n ? "imports" : "exports"}" resolution of ${(0, _url().fileURLToPath)(r)}`;
                throw new A(e1, i, s && (0, _url().fileURLToPath)(s));
            }
            function invalidPackageTarget(e1, t, r, n, s) {
                t = typeof t === "object" && t !== null ? JSON.stringify(t, null, "") : `${t}`;
                return new I((0, _url().fileURLToPath)(new (_url()).URL(".", r)), e1, t, n, s && (0, _url().fileURLToPath)(s));
            }
            function resolvePackageTargetString(e1, t, r, n, s, i, a, o, l) {
                if (t !== "" && !i && e1[e1.length - 1] !== "/") throw invalidPackageTarget(r, e1, n, a, s);
                if (!e1.startsWith("./")) {
                    if (a && !e1.startsWith("../") && !e1.startsWith("/")) {
                        let r = false;
                        try {
                            new (_url()).URL(e1);
                            r = true;
                        } catch (e1) {}
                        if (!r) {
                            const r = i ? x.call(R, e1, ()=>t) : e1 + t;
                            return packageResolve(r, n, l);
                        }
                    }
                    throw invalidPackageTarget(r, e1, n, a, s);
                }
                if (L.exec(e1.slice(2)) !== null) {
                    if (j.exec(e1.slice(2)) === null) {
                        if (!o) {
                            const o = i ? r.replace("*", ()=>t) : r + t;
                            const l = i ? x.call(R, e1, ()=>t) : e1;
                            emitInvalidSegmentDeprecation(l, o, r, n, a, s, true);
                        }
                    } else {
                        throw invalidPackageTarget(r, e1, n, a, s);
                    }
                }
                const c = new (_url()).URL(e1, n);
                const u = c.pathname;
                const p = new (_url()).URL(".", n).pathname;
                if (!u.startsWith(p)) throw invalidPackageTarget(r, e1, n, a, s);
                if (t === "") return c;
                if (L.exec(t) !== null) {
                    const l = i ? r.replace("*", ()=>t) : r + t;
                    if (j.exec(t) === null) {
                        if (!o) {
                            const o = i ? x.call(R, e1, ()=>t) : e1;
                            emitInvalidSegmentDeprecation(o, l, r, n, a, s, false);
                        }
                    } else {
                        throwInvalidSubpath(l, r, n, a, s);
                    }
                }
                if (i) {
                    return new (_url()).URL(x.call(R, c.href, ()=>t));
                }
                return new (_url()).URL(t, c);
            }
            function isArrayIndex(e1) {
                const t = Number(e1);
                if (`${t}` !== e1) return false;
                return t >= 0 && t < 4294967295;
            }
            function resolvePackageTarget(e1, t, r, n, s, i, a, o, l) {
                if (typeof t === "string") {
                    return resolvePackageTargetString(t, r, n, e1, s, i, a, o, l);
                }
                if (Array.isArray(t)) {
                    const c = t;
                    if (c.length === 0) return null;
                    let u;
                    let p = -1;
                    while(++p < c.length){
                        const t = c[p];
                        let f;
                        try {
                            f = resolvePackageTarget(e1, t, r, n, s, i, a, o, l);
                        } catch (e1) {
                            const t = e1;
                            u = t;
                            if (t.code === "ERR_INVALID_PACKAGE_TARGET") continue;
                            throw e1;
                        }
                        if (f === undefined) continue;
                        if (f === null) {
                            u = null;
                            continue;
                        }
                        return f;
                    }
                    if (u === undefined || u === null) {
                        return null;
                    }
                    throw u;
                }
                if (typeof t === "object" && t !== null) {
                    const c = Object.getOwnPropertyNames(t);
                    let u = -1;
                    while(++u < c.length){
                        const t = c[u];
                        if (isArrayIndex(t)) {
                            throw new C((0, _url().fileURLToPath)(e1), s, '"exports" cannot contain numeric property keys.');
                        }
                    }
                    u = -1;
                    while(++u < c.length){
                        const p = c[u];
                        if (p === "default" || l && l.has(p)) {
                            const c = t[p];
                            const u = resolvePackageTarget(e1, c, r, n, s, i, a, o, l);
                            if (u === undefined) continue;
                            return u;
                        }
                    }
                    return null;
                }
                if (t === null) {
                    return null;
                }
                throw invalidPackageTarget(n, t, e1, a, s);
            }
            function isConditionalExportsMainSugar(e1, t, r) {
                if (typeof e1 === "string" || Array.isArray(e1)) return true;
                if (typeof e1 !== "object" || e1 === null) return false;
                const n = Object.getOwnPropertyNames(e1);
                let s = false;
                let i = 0;
                let a = -1;
                while(++a < n.length){
                    const e1 = n[a];
                    const o = e1 === "" || e1[0] !== ".";
                    if (i++ === 0) {
                        s = o;
                    } else if (s !== o) {
                        throw new C((0, _url().fileURLToPath)(t), r, "\"exports\" cannot contain some keys starting with '.' and some not." + " The exports object must either be an object of package subpath keys" + " or an object of main entry condition name keys only.");
                    }
                }
                return s;
            }
            function emitTrailingSlashPatternDeprecation(e1, t, r) {
                const n = (0, _url().fileURLToPath)(t);
                if (U.has(n + "|" + e1)) return;
                U.add(n + "|" + e1);
                _process().emitWarning(`Use of deprecated trailing slash pattern mapping "${e1}" in the ` + `"exports" field module resolution of the package at ${n}${r ? ` imported from ${(0, _url().fileURLToPath)(r)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155");
            }
            function packageExportsResolve(e1, t, r, n, s) {
                let i = r.exports;
                if (isConditionalExportsMainSugar(i, e1, n)) {
                    i = {
                        ".": i
                    };
                }
                if (M.call(i, t) && !t.includes("*") && !t.endsWith("/")) {
                    const r = i[t];
                    const a = resolvePackageTarget(e1, r, "", t, n, false, false, false, s);
                    if (a === null || a === undefined) {
                        throw exportsNotFound(t, e1, n);
                    }
                    return a;
                }
                let a = "";
                let o = "";
                const l = Object.getOwnPropertyNames(i);
                let c = -1;
                while(++c < l.length){
                    const r = l[c];
                    const s = r.indexOf("*");
                    if (s !== -1 && t.startsWith(r.slice(0, s))) {
                        if (t.endsWith("/")) {
                            emitTrailingSlashPatternDeprecation(t, e1, n);
                        }
                        const i = r.slice(s + 1);
                        if (t.length >= r.length && t.endsWith(i) && patternKeyCompare(a, r) === 1 && r.lastIndexOf("*") === s) {
                            a = r;
                            o = t.slice(s, t.length - i.length);
                        }
                    }
                }
                if (a) {
                    const r = i[a];
                    const l = resolvePackageTarget(e1, r, o, a, n, true, false, t.endsWith("/"), s);
                    if (l === null || l === undefined) {
                        throw exportsNotFound(t, e1, n);
                    }
                    return l;
                }
                throw exportsNotFound(t, e1, n);
            }
            function patternKeyCompare(e1, t) {
                const r = e1.indexOf("*");
                const n = t.indexOf("*");
                const s = r === -1 ? e1.length : r + 1;
                const i = n === -1 ? t.length : n + 1;
                if (s > i) return -1;
                if (i > s) return 1;
                if (r === -1) return 1;
                if (n === -1) return -1;
                if (e1.length > t.length) return -1;
                if (t.length > e1.length) return 1;
                return 0;
            }
            function packageImportsResolve(e1, t, r) {
                if (e1 === "#" || e1.startsWith("#/") || e1.endsWith("/")) {
                    const r = "is not a valid internal imports specifier name";
                    throw new A(e1, r, (0, _url().fileURLToPath)(t));
                }
                let n;
                const s = getPackageScopeConfig(t);
                if (s.exists) {
                    n = (0, _url().pathToFileURL)(s.pjsonPath);
                    const i = s.imports;
                    if (i) {
                        if (M.call(i, e1) && !e1.includes("*")) {
                            const s = resolvePackageTarget(n, i[e1], "", e1, t, false, true, false, r);
                            if (s !== null && s !== undefined) {
                                return s;
                            }
                        } else {
                            let s = "";
                            let a = "";
                            const o = Object.getOwnPropertyNames(i);
                            let l = -1;
                            while(++l < o.length){
                                const t = o[l];
                                const r = t.indexOf("*");
                                if (r !== -1 && e1.startsWith(t.slice(0, -1))) {
                                    const n = t.slice(r + 1);
                                    if (e1.length >= t.length && e1.endsWith(n) && patternKeyCompare(s, t) === 1 && t.lastIndexOf("*") === r) {
                                        s = t;
                                        a = e1.slice(r, e1.length - n.length);
                                    }
                                }
                            }
                            if (s) {
                                const e1 = i[s];
                                const o = resolvePackageTarget(n, e1, a, s, t, true, true, false, r);
                                if (o !== null && o !== undefined) {
                                    return o;
                                }
                            }
                        }
                    }
                }
                throw importNotDefined(e1, n, t);
            }
            function parsePackageName(e1, t) {
                let r = e1.indexOf("/");
                let n = true;
                let s = false;
                if (e1[0] === "@") {
                    s = true;
                    if (r === -1 || e1.length === 0) {
                        n = false;
                    } else {
                        r = e1.indexOf("/", r + 1);
                    }
                }
                const i = r === -1 ? e1 : e1.slice(0, r);
                if (F.exec(i) !== null) {
                    n = false;
                }
                if (!n) {
                    throw new A(e1, "is not a valid package name", (0, _url().fileURLToPath)(t));
                }
                const a = "." + (r === -1 ? "" : e1.slice(r));
                return {
                    packageName: i,
                    packageSubpath: a,
                    isScoped: s
                };
            }
            function packageResolve(e1, t, r) {
                if (_module().builtinModules.includes(e1)) {
                    return new (_url()).URL("node:" + e1);
                }
                const { packageName: n, packageSubpath: s, isScoped: i } = parsePackageName(e1, t);
                const a = getPackageScopeConfig(t);
                if (a.exists) {
                    const e1 = (0, _url().pathToFileURL)(a.pjsonPath);
                    if (a.name === n && a.exports !== undefined && a.exports !== null) {
                        return packageExportsResolve(e1, s, a, t, r);
                    }
                }
                let o = new (_url()).URL("./node_modules/" + n + "/package.json", t);
                let l = (0, _url().fileURLToPath)(o);
                let c;
                do {
                    const a = tryStatSync(l.slice(0, -13));
                    if (!a.isDirectory()) {
                        c = l;
                        o = new (_url()).URL((i ? "../../../../node_modules/" : "../../../node_modules/") + n + "/package.json", o);
                        l = (0, _url().fileURLToPath)(o);
                        continue;
                    }
                    const u = getPackageConfig(l, e1, t);
                    if (u.exports !== undefined && u.exports !== null) {
                        return packageExportsResolve(o, s, u, t, r);
                    }
                    if (s === ".") {
                        return legacyMainResolve(o, u, t);
                    }
                    return new (_url()).URL(s, o);
                }while (l.length !== c.length)
                throw new O(n, (0, _url().fileURLToPath)(t));
            }
            function isRelativeSpecifier(e1) {
                if (e1[0] === ".") {
                    if (e1.length === 1 || e1[1] === "/") return true;
                    if (e1[1] === "." && (e1.length === 2 || e1[2] === "/")) {
                        return true;
                    }
                }
                return false;
            }
            function shouldBeTreatedAsRelativeOrAbsolutePath(e1) {
                if (e1 === "") return false;
                if (e1[0] === "/") return true;
                return isRelativeSpecifier(e1);
            }
            function moduleResolve(e1, t, r, n) {
                const s = t.protocol;
                const i = s === "http:" || s === "https:";
                let a;
                if (shouldBeTreatedAsRelativeOrAbsolutePath(e1)) {
                    a = new (_url()).URL(e1, t);
                } else if (!i && e1[0] === "#") {
                    a = packageImportsResolve(e1, t, r);
                } else {
                    try {
                        a = new (_url()).URL(e1);
                    } catch (n) {
                        if (!i) {
                            a = packageResolve(e1, t, r);
                        }
                    }
                }
                _assert()(a !== undefined, "expected to be defined");
                if (a.protocol !== "file:") {
                    return a;
                }
                return finalizeResolution(a, t, n);
            }
            function checkIfDisallowedImport(e1, t, r) {
                if (r) {
                    const n = r.protocol;
                    if (n === "http:" || n === "https:") {
                        if (shouldBeTreatedAsRelativeOrAbsolutePath(e1)) {
                            const n = t == null ? void 0 : t.protocol;
                            if (n && n !== "https:" && n !== "http:") {
                                throw new w(e1, r, "remote imports cannot import from a local location.");
                            }
                            return {
                                url: (t == null ? void 0 : t.href) || ""
                            };
                        }
                        if (_module().builtinModules.includes(e1)) {
                            throw new w(e1, r, "remote imports cannot import from a local location.");
                        }
                        throw new w(e1, r, "only relative and absolute specifiers are supported.");
                    }
                }
            }
            function isURL(e1) {
                return Boolean(e1 && typeof e1 === "object" && "href" in e1 && typeof e1.href === "string" && "protocol" in e1 && typeof e1.protocol === "string" && e1.href && e1.protocol);
            }
            function throwIfInvalidParentURL(e1) {
                if (e1 === undefined) {
                    return;
                }
                if (typeof e1 !== "string" && !isURL(e1)) {
                    throw new o.ERR_INVALID_ARG_TYPE("parentURL", [
                        "string",
                        "URL"
                    ], e1);
                }
            }
            function throwIfUnsupportedURLProtocol(e1) {
                const t = e1.protocol;
                if (t !== "file:" && t !== "data:" && t !== "node:") {
                    throw new D(e1);
                }
            }
            function throwIfUnsupportedURLScheme(e1, t) {
                const r = e1 == null ? void 0 : e1.protocol;
                if (r && r !== "file:" && r !== "data:" && (!t || r !== "https:" && r !== "http:")) {
                    throw new D(e1, [
                        "file",
                        "data"
                    ].concat(t ? [
                        "https",
                        "http"
                    ] : []));
                }
            }
            function defaultResolve(e1, t = {}) {
                const { parentURL: r } = t;
                _assert()(r !== undefined, "expected `parentURL` to be defined");
                throwIfInvalidParentURL(r);
                let n;
                if (r) {
                    try {
                        n = new (_url()).URL(r);
                    } catch (e1) {}
                }
                let s;
                try {
                    s = shouldBeTreatedAsRelativeOrAbsolutePath(e1) ? new (_url()).URL(e1, n) : new (_url()).URL(e1);
                    const t = s.protocol;
                    if (t === "data:" || P && (t === "https:" || t === "http:")) {
                        return {
                            url: s.href,
                            format: null
                        };
                    }
                } catch (e1) {}
                const i = checkIfDisallowedImport(e1, s, n);
                if (i) return i;
                if (s && s.protocol === "node:") return {
                    url: e1
                };
                throwIfUnsupportedURLScheme(s, P);
                const a = getConditionsSet(t.conditions);
                const o = moduleResolve(e1, new (_url()).URL(r), a, false);
                throwIfUnsupportedURLProtocol(o);
                return {
                    url: o.href,
                    format: defaultGetFormatWithoutErrors(o, {
                        parentURL: r
                    })
                };
            }
            function resolve(e1, t) {
                if (!t) {
                    throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
                }
                try {
                    return defaultResolve(e1, {
                        parentURL: t
                    }).url;
                } catch (e1) {
                    const t = e1;
                    if (t.code === "ERR_UNSUPPORTED_DIR_IMPORT" && typeof t.url === "string") {
                        return t.url;
                    }
                    throw e1;
                }
            }
            0 && 0;
        },
        9531: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            class Buffer1 {
                constructor(e1){
                    this._map = null;
                    this._buf = "";
                    this._str = "";
                    this._appendCount = 0;
                    this._last = 0;
                    this._queue = [];
                    this._queueCursor = 0;
                    this._canMarkIdName = true;
                    this._position = {
                        line: 1,
                        column: 0
                    };
                    this._sourcePosition = {
                        identifierName: undefined,
                        identifierNamePos: undefined,
                        line: undefined,
                        column: undefined,
                        filename: undefined
                    };
                    this._map = e1;
                    this._allocQueue();
                }
                _allocQueue() {
                    const e1 = this._queue;
                    for(let t = 0; t < 16; t++){
                        e1.push({
                            char: 0,
                            repeat: 1,
                            line: undefined,
                            column: undefined,
                            identifierName: undefined,
                            identifierNamePos: undefined,
                            filename: ""
                        });
                    }
                }
                _pushQueue(e1, t, r, n, s) {
                    const i = this._queueCursor;
                    if (i === this._queue.length) {
                        this._allocQueue();
                    }
                    const a = this._queue[i];
                    a.char = e1;
                    a.repeat = t;
                    a.line = r;
                    a.column = n;
                    a.filename = s;
                    this._queueCursor++;
                }
                _popQueue() {
                    if (this._queueCursor === 0) {
                        throw new Error("Cannot pop from empty queue");
                    }
                    return this._queue[--this._queueCursor];
                }
                get() {
                    this._flush();
                    const e1 = this._map;
                    const t = {
                        code: (this._buf + this._str).trimRight(),
                        decodedMap: e1 == null ? void 0 : e1.getDecoded(),
                        get __mergedMap () {
                            return this.map;
                        },
                        get map () {
                            const r = e1 ? e1.get() : null;
                            t.map = r;
                            return r;
                        },
                        set map (e){
                            Object.defineProperty(t, "map", {
                                value: e,
                                writable: true
                            });
                        },
                        get rawMappings () {
                            const r = e1 == null ? void 0 : e1.getRawMappings();
                            t.rawMappings = r;
                            return r;
                        },
                        set rawMappings (e){
                            Object.defineProperty(t, "rawMappings", {
                                value: e,
                                writable: true
                            });
                        }
                    };
                    return t;
                }
                append(e1, t) {
                    this._flush();
                    this._append(e1, this._sourcePosition, t);
                }
                appendChar(e1) {
                    this._flush();
                    this._appendChar(e1, 1, this._sourcePosition);
                }
                queue(e1) {
                    if (e1 === 10) {
                        while(this._queueCursor !== 0){
                            const e1 = this._queue[this._queueCursor - 1].char;
                            if (e1 !== 32 && e1 !== 9) {
                                break;
                            }
                            this._queueCursor--;
                        }
                    }
                    const t = this._sourcePosition;
                    this._pushQueue(e1, 1, t.line, t.column, t.filename);
                }
                queueIndentation(e1, t) {
                    this._pushQueue(e1, t, undefined, undefined, undefined);
                }
                _flush() {
                    const e1 = this._queueCursor;
                    const t = this._queue;
                    for(let r = 0; r < e1; r++){
                        const e1 = t[r];
                        this._appendChar(e1.char, e1.repeat, e1);
                    }
                    this._queueCursor = 0;
                }
                _appendChar(e1, t, r) {
                    this._last = e1;
                    this._str += t > 1 ? String.fromCharCode(e1).repeat(t) : String.fromCharCode(e1);
                    if (e1 !== 10) {
                        this._mark(r.line, r.column, r.identifierName, r.identifierNamePos, r.filename);
                        this._position.column += t;
                    } else {
                        this._position.line++;
                        this._position.column = 0;
                    }
                    if (this._canMarkIdName) {
                        r.identifierName = undefined;
                        r.identifierNamePos = undefined;
                    }
                }
                _append(e1, t, r) {
                    const n = e1.length;
                    const s = this._position;
                    this._last = e1.charCodeAt(n - 1);
                    if (++this._appendCount > 4096) {
                        +this._str;
                        this._buf += this._str;
                        this._str = e1;
                        this._appendCount = 0;
                    } else {
                        this._str += e1;
                    }
                    if (!r && !this._map) {
                        s.column += n;
                        return;
                    }
                    const { column: i, identifierName: a, identifierNamePos: o, filename: l } = t;
                    let c = t.line;
                    if ((a != null || o != null) && this._canMarkIdName) {
                        t.identifierName = undefined;
                        t.identifierNamePos = undefined;
                    }
                    let u = e1.indexOf("\n");
                    let p = 0;
                    if (u !== 0) {
                        this._mark(c, i, a, o, l);
                    }
                    while(u !== -1){
                        s.line++;
                        s.column = 0;
                        p = u + 1;
                        if (p < n && c !== undefined) {
                            this._mark(++c, 0, null, null, l);
                        }
                        u = e1.indexOf("\n", p);
                    }
                    s.column += n - p;
                }
                _mark(e1, t, r, n, s) {
                    var i;
                    (i = this._map) == null ? void 0 : i.mark(this._position, e1, t, r, n, s);
                }
                removeTrailingNewline() {
                    const e1 = this._queueCursor;
                    if (e1 !== 0 && this._queue[e1 - 1].char === 10) {
                        this._queueCursor--;
                    }
                }
                removeLastSemicolon() {
                    const e1 = this._queueCursor;
                    if (e1 !== 0 && this._queue[e1 - 1].char === 59) {
                        this._queueCursor--;
                    }
                }
                getLastChar() {
                    const e1 = this._queueCursor;
                    return e1 !== 0 ? this._queue[e1 - 1].char : this._last;
                }
                getNewlineCount() {
                    const e1 = this._queueCursor;
                    let t = 0;
                    if (e1 === 0) return this._last === 10 ? 1 : 0;
                    for(let r = e1 - 1; r >= 0; r--){
                        if (this._queue[r].char !== 10) {
                            break;
                        }
                        t++;
                    }
                    return t === e1 && this._last === 10 ? t + 1 : t;
                }
                endsWithCharAndNewline() {
                    const e1 = this._queue;
                    const t = this._queueCursor;
                    if (t !== 0) {
                        const r = e1[t - 1].char;
                        if (r !== 10) return;
                        if (t > 1) {
                            return e1[t - 2].char;
                        } else {
                            return this._last;
                        }
                    }
                }
                hasContent() {
                    return this._queueCursor !== 0 || !!this._last;
                }
                exactSource(e1, t) {
                    if (!this._map) {
                        t();
                        return;
                    }
                    this.source("start", e1);
                    const r = e1.identifierName;
                    const n = this._sourcePosition;
                    if (r) {
                        this._canMarkIdName = false;
                        n.identifierName = r;
                    }
                    t();
                    if (r) {
                        this._canMarkIdName = true;
                        n.identifierName = undefined;
                        n.identifierNamePos = undefined;
                    }
                    this.source("end", e1);
                }
                source(e1, t) {
                    if (!this._map) return;
                    this._normalizePosition(e1, t, 0, 0);
                }
                sourceWithOffset(e1, t, r, n) {
                    if (!this._map) return;
                    this._normalizePosition(e1, t, r, n);
                }
                withSource(e1, t, r) {
                    if (this._map) {
                        this.source(e1, t);
                    }
                    r();
                }
                _normalizePosition(e1, t, r, n) {
                    const s = t[e1];
                    const i = this._sourcePosition;
                    if (s) {
                        i.line = s.line + r;
                        i.column = s.column + n;
                        i.filename = t.filename;
                    }
                }
                getCurrentColumn() {
                    const e1 = this._queue;
                    const t = this._queueCursor;
                    let r = -1;
                    let n = 0;
                    for(let s = 0; s < t; s++){
                        const t = e1[s];
                        if (t.char === 10) {
                            r = n;
                        }
                        n += t.repeat;
                    }
                    return r === -1 ? this._position.column + n : n - 1 - r;
                }
                getCurrentLine() {
                    let e1 = 0;
                    const t = this._queue;
                    for(let r = 0; r < this._queueCursor; r++){
                        if (t[r].char === 10) {
                            e1++;
                        }
                    }
                    return this._position.line + e1;
                }
            }
            t["default"] = Buffer1;
        },
        3987: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BlockStatement = BlockStatement;
            t.Directive = Directive;
            t.DirectiveLiteral = DirectiveLiteral;
            t.File = File;
            t.InterpreterDirective = InterpreterDirective;
            t.Placeholder = Placeholder;
            t.Program = Program;
            function File(e1) {
                if (e1.program) {
                    this.print(e1.program.interpreter, e1);
                }
                this.print(e1.program, e1);
            }
            function Program(e1) {
                var t;
                this.noIndentInnerCommentsHere();
                this.printInnerComments();
                const r = (t = e1.directives) == null ? void 0 : t.length;
                if (r) {
                    var n;
                    const t = e1.body.length ? 2 : 1;
                    this.printSequence(e1.directives, e1, {
                        trailingCommentsLineOffset: t
                    });
                    if (!((n = e1.directives[r - 1].trailingComments) != null && n.length)) {
                        this.newline(t);
                    }
                }
                this.printSequence(e1.body, e1);
            }
            function BlockStatement(e1) {
                var t;
                this.tokenChar(123);
                const r = (t = e1.directives) == null ? void 0 : t.length;
                if (r) {
                    var n;
                    const t = e1.body.length ? 2 : 1;
                    this.printSequence(e1.directives, e1, {
                        indent: true,
                        trailingCommentsLineOffset: t
                    });
                    if (!((n = e1.directives[r - 1].trailingComments) != null && n.length)) {
                        this.newline(t);
                    }
                }
                this.printSequence(e1.body, e1, {
                    indent: true
                });
                this.rightBrace(e1);
            }
            function Directive(e1) {
                this.print(e1.value, e1);
                this.semicolon();
            }
            const r = /(?:^|[^\\])(?:\\\\)*'/;
            const n = /(?:^|[^\\])(?:\\\\)*"/;
            function DirectiveLiteral(e1) {
                const t = this.getPossibleRaw(e1);
                if (!this.format.minified && t !== undefined) {
                    this.token(t);
                    return;
                }
                const { value: s } = e1;
                if (!n.test(s)) {
                    this.token(`"${s}"`);
                } else if (!r.test(s)) {
                    this.token(`'${s}'`);
                } else {
                    throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
                }
            }
            function InterpreterDirective(e1) {
                this.token(`#!${e1.value}`);
                this.newline(1, true);
            }
            function Placeholder(e1) {
                this.token("%%");
                this.print(e1.name);
                this.token("%%");
                if (e1.expectedNode === "Statement") {
                    this.semicolon();
                }
            }
        },
        5103: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ClassAccessorProperty = ClassAccessorProperty;
            t.ClassBody = ClassBody;
            t.ClassExpression = t.ClassDeclaration = ClassDeclaration;
            t.ClassMethod = ClassMethod;
            t.ClassPrivateMethod = ClassPrivateMethod;
            t.ClassPrivateProperty = ClassPrivateProperty;
            t.ClassProperty = ClassProperty;
            t.StaticBlock = StaticBlock;
            t._classMethodHead = _classMethodHead;
            var n = r(776);
            const { isExportDefaultDeclaration: s, isExportNamedDeclaration: i } = n;
            function ClassDeclaration(e1, t) {
                const r = s(t) || i(t);
                if (!r || !this._shouldPrintDecoratorsBeforeExport(t)) {
                    this.printJoin(e1.decorators, e1);
                }
                if (e1.declare) {
                    this.word("declare");
                    this.space();
                }
                if (e1.abstract) {
                    this.word("abstract");
                    this.space();
                }
                this.word("class");
                if (e1.id) {
                    this.space();
                    this.print(e1.id, e1);
                }
                this.print(e1.typeParameters, e1);
                if (e1.superClass) {
                    this.space();
                    this.word("extends");
                    this.space();
                    this.print(e1.superClass, e1);
                    this.print(e1.superTypeParameters, e1);
                }
                if (e1.implements) {
                    this.space();
                    this.word("implements");
                    this.space();
                    this.printList(e1.implements, e1);
                }
                this.space();
                this.print(e1.body, e1);
            }
            function ClassBody(e1) {
                this.tokenChar(123);
                if (e1.body.length === 0) {
                    this.tokenChar(125);
                } else {
                    this.newline();
                    this.printSequence(e1.body, e1, {
                        indent: true
                    });
                    if (!this.endsWith(10)) this.newline();
                    this.rightBrace(e1);
                }
            }
            function ClassProperty(e1) {
                var t, r;
                this.printJoin(e1.decorators, e1);
                const n = (t = e1.key.loc) == null ? void 0 : (r = t.end) == null ? void 0 : r.line;
                if (n) this.catchUp(n);
                this.tsPrintClassMemberModifiers(e1);
                if (e1.computed) {
                    this.tokenChar(91);
                    this.print(e1.key, e1);
                    this.tokenChar(93);
                } else {
                    this._variance(e1);
                    this.print(e1.key, e1);
                }
                if (e1.optional) {
                    this.tokenChar(63);
                }
                if (e1.definite) {
                    this.tokenChar(33);
                }
                this.print(e1.typeAnnotation, e1);
                if (e1.value) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.value, e1);
                }
                this.semicolon();
            }
            function ClassAccessorProperty(e1) {
                var t, r;
                this.printJoin(e1.decorators, e1);
                const n = (t = e1.key.loc) == null ? void 0 : (r = t.end) == null ? void 0 : r.line;
                if (n) this.catchUp(n);
                this.tsPrintClassMemberModifiers(e1);
                this.word("accessor", true);
                this.space();
                if (e1.computed) {
                    this.tokenChar(91);
                    this.print(e1.key, e1);
                    this.tokenChar(93);
                } else {
                    this._variance(e1);
                    this.print(e1.key, e1);
                }
                if (e1.optional) {
                    this.tokenChar(63);
                }
                if (e1.definite) {
                    this.tokenChar(33);
                }
                this.print(e1.typeAnnotation, e1);
                if (e1.value) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.value, e1);
                }
                this.semicolon();
            }
            function ClassPrivateProperty(e1) {
                this.printJoin(e1.decorators, e1);
                if (e1.static) {
                    this.word("static");
                    this.space();
                }
                this.print(e1.key, e1);
                this.print(e1.typeAnnotation, e1);
                if (e1.value) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.value, e1);
                }
                this.semicolon();
            }
            function ClassMethod(e1) {
                this._classMethodHead(e1);
                this.space();
                this.print(e1.body, e1);
            }
            function ClassPrivateMethod(e1) {
                this._classMethodHead(e1);
                this.space();
                this.print(e1.body, e1);
            }
            function _classMethodHead(e1) {
                var t, r;
                this.printJoin(e1.decorators, e1);
                const n = (t = e1.key.loc) == null ? void 0 : (r = t.end) == null ? void 0 : r.line;
                if (n) this.catchUp(n);
                this.tsPrintClassMemberModifiers(e1);
                this._methodHead(e1);
            }
            function StaticBlock(e1) {
                this.word("static");
                this.space();
                this.tokenChar(123);
                if (e1.body.length === 0) {
                    this.tokenChar(125);
                } else {
                    this.newline();
                    this.printSequence(e1.body, e1, {
                        indent: true
                    });
                    this.rightBrace(e1);
                }
            }
        },
        9978: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LogicalExpression = t.BinaryExpression = t.AssignmentExpression = AssignmentExpression;
            t.AssignmentPattern = AssignmentPattern;
            t.AwaitExpression = AwaitExpression;
            t.BindExpression = BindExpression;
            t.CallExpression = CallExpression;
            t.ConditionalExpression = ConditionalExpression;
            t.Decorator = Decorator;
            t.DoExpression = DoExpression;
            t.EmptyStatement = EmptyStatement;
            t.ExpressionStatement = ExpressionStatement;
            t.Import = Import;
            t.MemberExpression = MemberExpression;
            t.MetaProperty = MetaProperty;
            t.ModuleExpression = ModuleExpression;
            t.NewExpression = NewExpression;
            t.OptionalCallExpression = OptionalCallExpression;
            t.OptionalMemberExpression = OptionalMemberExpression;
            t.ParenthesizedExpression = ParenthesizedExpression;
            t.PrivateName = PrivateName;
            t.SequenceExpression = SequenceExpression;
            t.Super = Super;
            t.ThisExpression = ThisExpression;
            t.UnaryExpression = UnaryExpression;
            t.UpdateExpression = UpdateExpression;
            t.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
            t.YieldExpression = YieldExpression;
            t._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
            var n = r(776);
            var s = r(9939);
            const { isCallExpression: i, isLiteral: a, isMemberExpression: o, isNewExpression: l } = n;
            function UnaryExpression(e1) {
                const { operator: t } = e1;
                if (t === "void" || t === "delete" || t === "typeof" || t === "throw") {
                    this.word(t);
                    this.space();
                } else {
                    this.token(t);
                }
                this.print(e1.argument, e1);
            }
            function DoExpression(e1) {
                if (e1.async) {
                    this.word("async", true);
                    this.space();
                }
                this.word("do");
                this.space();
                this.print(e1.body, e1);
            }
            function ParenthesizedExpression(e1) {
                this.tokenChar(40);
                this.print(e1.expression, e1);
                this.rightParens(e1);
            }
            function UpdateExpression(e1) {
                if (e1.prefix) {
                    this.token(e1.operator);
                    this.print(e1.argument, e1);
                } else {
                    this.printTerminatorless(e1.argument, e1, true);
                    this.token(e1.operator);
                }
            }
            function ConditionalExpression(e1) {
                this.print(e1.test, e1);
                this.space();
                this.tokenChar(63);
                this.space();
                this.print(e1.consequent, e1);
                this.space();
                this.tokenChar(58);
                this.space();
                this.print(e1.alternate, e1);
            }
            function NewExpression(e1, t) {
                this.word("new");
                this.space();
                this.print(e1.callee, e1);
                if (this.format.minified && e1.arguments.length === 0 && !e1.optional && !i(t, {
                    callee: e1
                }) && !o(t) && !l(t)) {
                    return;
                }
                this.print(e1.typeArguments, e1);
                this.print(e1.typeParameters, e1);
                if (e1.optional) {
                    this.token("?.");
                }
                this.tokenChar(40);
                this.printList(e1.arguments, e1);
                this.rightParens(e1);
            }
            function SequenceExpression(e1) {
                this.printList(e1.expressions, e1);
            }
            function ThisExpression() {
                this.word("this");
            }
            function Super() {
                this.word("super");
            }
            function isDecoratorMemberExpression(e1) {
                switch(e1.type){
                    case "Identifier":
                        return true;
                    case "MemberExpression":
                        return !e1.computed && e1.property.type === "Identifier" && isDecoratorMemberExpression(e1.object);
                    default:
                        return false;
                }
            }
            function shouldParenthesizeDecoratorExpression(e1) {
                if (e1.type === "ParenthesizedExpression") {
                    return false;
                }
                return !isDecoratorMemberExpression(e1.type === "CallExpression" ? e1.callee : e1);
            }
            function _shouldPrintDecoratorsBeforeExport(e1) {
                if (typeof this.format.decoratorsBeforeExport === "boolean") {
                    return this.format.decoratorsBeforeExport;
                }
                return typeof e1.start === "number" && e1.start === e1.declaration.start;
            }
            function Decorator(e1) {
                this.tokenChar(64);
                const { expression: t } = e1;
                if (shouldParenthesizeDecoratorExpression(t)) {
                    this.tokenChar(40);
                    this.print(t, e1);
                    this.tokenChar(41);
                } else {
                    this.print(t, e1);
                }
                this.newline();
            }
            function OptionalMemberExpression(e1) {
                let { computed: t } = e1;
                const { optional: r, property: n } = e1;
                this.print(e1.object, e1);
                if (!t && o(n)) {
                    throw new TypeError("Got a MemberExpression for MemberExpression property");
                }
                if (a(n) && typeof n.value === "number") {
                    t = true;
                }
                if (r) {
                    this.token("?.");
                }
                if (t) {
                    this.tokenChar(91);
                    this.print(n, e1);
                    this.tokenChar(93);
                } else {
                    if (!r) {
                        this.tokenChar(46);
                    }
                    this.print(n, e1);
                }
            }
            function OptionalCallExpression(e1) {
                this.print(e1.callee, e1);
                this.print(e1.typeParameters, e1);
                if (e1.optional) {
                    this.token("?.");
                }
                this.print(e1.typeArguments, e1);
                this.tokenChar(40);
                this.printList(e1.arguments, e1);
                this.rightParens(e1);
            }
            function CallExpression(e1) {
                this.print(e1.callee, e1);
                this.print(e1.typeArguments, e1);
                this.print(e1.typeParameters, e1);
                this.tokenChar(40);
                this.printList(e1.arguments, e1);
                this.rightParens(e1);
            }
            function Import() {
                this.word("import");
            }
            function AwaitExpression(e1) {
                this.word("await");
                if (e1.argument) {
                    this.space();
                    this.printTerminatorless(e1.argument, e1, false);
                }
            }
            function YieldExpression(e1) {
                this.word("yield", true);
                if (e1.delegate) {
                    this.tokenChar(42);
                    if (e1.argument) {
                        this.space();
                        this.print(e1.argument, e1);
                    }
                } else {
                    if (e1.argument) {
                        this.space();
                        this.printTerminatorless(e1.argument, e1, false);
                    }
                }
            }
            function EmptyStatement() {
                this.semicolon(true);
            }
            function ExpressionStatement(e1) {
                this.print(e1.expression, e1);
                this.semicolon();
            }
            function AssignmentPattern(e1) {
                this.print(e1.left, e1);
                if (e1.left.optional) this.tokenChar(63);
                this.print(e1.left.typeAnnotation, e1);
                this.space();
                this.tokenChar(61);
                this.space();
                this.print(e1.right, e1);
            }
            function AssignmentExpression(e1, t) {
                const r = this.inForStatementInitCounter && e1.operator === "in" && !s.needsParens(e1, t);
                if (r) {
                    this.tokenChar(40);
                }
                this.print(e1.left, e1);
                this.space();
                if (e1.operator === "in" || e1.operator === "instanceof") {
                    this.word(e1.operator);
                } else {
                    this.token(e1.operator);
                }
                this.space();
                this.print(e1.right, e1);
                if (r) {
                    this.tokenChar(41);
                }
            }
            function BindExpression(e1) {
                this.print(e1.object, e1);
                this.token("::");
                this.print(e1.callee, e1);
            }
            function MemberExpression(e1) {
                this.print(e1.object, e1);
                if (!e1.computed && o(e1.property)) {
                    throw new TypeError("Got a MemberExpression for MemberExpression property");
                }
                let t = e1.computed;
                if (a(e1.property) && typeof e1.property.value === "number") {
                    t = true;
                }
                if (t) {
                    this.tokenChar(91);
                    this.print(e1.property, e1);
                    this.tokenChar(93);
                } else {
                    this.tokenChar(46);
                    this.print(e1.property, e1);
                }
            }
            function MetaProperty(e1) {
                this.print(e1.meta, e1);
                this.tokenChar(46);
                this.print(e1.property, e1);
            }
            function PrivateName(e1) {
                this.tokenChar(35);
                this.print(e1.id, e1);
            }
            function V8IntrinsicIdentifier(e1) {
                this.tokenChar(37);
                this.word(e1.name);
            }
            function ModuleExpression(e1) {
                this.word("module", true);
                this.space();
                this.tokenChar(123);
                this.indent();
                const { body: t } = e1;
                if (t.body.length || t.directives.length) {
                    this.newline();
                }
                this.print(t, e1);
                this.dedent();
                this.rightBrace(e1);
            }
        },
        7138: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.AnyTypeAnnotation = AnyTypeAnnotation;
            t.ArrayTypeAnnotation = ArrayTypeAnnotation;
            t.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
            t.BooleanTypeAnnotation = BooleanTypeAnnotation;
            t.DeclareClass = DeclareClass;
            t.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
            t.DeclareExportDeclaration = DeclareExportDeclaration;
            t.DeclareFunction = DeclareFunction;
            t.DeclareInterface = DeclareInterface;
            t.DeclareModule = DeclareModule;
            t.DeclareModuleExports = DeclareModuleExports;
            t.DeclareOpaqueType = DeclareOpaqueType;
            t.DeclareTypeAlias = DeclareTypeAlias;
            t.DeclareVariable = DeclareVariable;
            t.DeclaredPredicate = DeclaredPredicate;
            t.EmptyTypeAnnotation = EmptyTypeAnnotation;
            t.EnumBooleanBody = EnumBooleanBody;
            t.EnumBooleanMember = EnumBooleanMember;
            t.EnumDeclaration = EnumDeclaration;
            t.EnumDefaultedMember = EnumDefaultedMember;
            t.EnumNumberBody = EnumNumberBody;
            t.EnumNumberMember = EnumNumberMember;
            t.EnumStringBody = EnumStringBody;
            t.EnumStringMember = EnumStringMember;
            t.EnumSymbolBody = EnumSymbolBody;
            t.ExistsTypeAnnotation = ExistsTypeAnnotation;
            t.FunctionTypeAnnotation = FunctionTypeAnnotation;
            t.FunctionTypeParam = FunctionTypeParam;
            t.IndexedAccessType = IndexedAccessType;
            t.InferredPredicate = InferredPredicate;
            t.InterfaceDeclaration = InterfaceDeclaration;
            t.GenericTypeAnnotation = t.ClassImplements = t.InterfaceExtends = InterfaceExtends;
            t.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
            t.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
            t.MixedTypeAnnotation = MixedTypeAnnotation;
            t.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
            t.NullableTypeAnnotation = NullableTypeAnnotation;
            Object.defineProperty(t, "NumberLiteralTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return i.NumericLiteral;
                }
            });
            t.NumberTypeAnnotation = NumberTypeAnnotation;
            t.ObjectTypeAnnotation = ObjectTypeAnnotation;
            t.ObjectTypeCallProperty = ObjectTypeCallProperty;
            t.ObjectTypeIndexer = ObjectTypeIndexer;
            t.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
            t.ObjectTypeProperty = ObjectTypeProperty;
            t.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
            t.OpaqueType = OpaqueType;
            t.OptionalIndexedAccessType = OptionalIndexedAccessType;
            t.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
            Object.defineProperty(t, "StringLiteralTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return i.StringLiteral;
                }
            });
            t.StringTypeAnnotation = StringTypeAnnotation;
            t.SymbolTypeAnnotation = SymbolTypeAnnotation;
            t.ThisTypeAnnotation = ThisTypeAnnotation;
            t.TupleTypeAnnotation = TupleTypeAnnotation;
            t.TypeAlias = TypeAlias;
            t.TypeAnnotation = TypeAnnotation;
            t.TypeCastExpression = TypeCastExpression;
            t.TypeParameter = TypeParameter;
            t.TypeParameterDeclaration = t.TypeParameterInstantiation = TypeParameterInstantiation;
            t.TypeofTypeAnnotation = TypeofTypeAnnotation;
            t.UnionTypeAnnotation = UnionTypeAnnotation;
            t.Variance = Variance;
            t.VoidTypeAnnotation = VoidTypeAnnotation;
            t._interfaceish = _interfaceish;
            t._variance = _variance;
            var n = r(776);
            var s = r(7104);
            var i = r(5973);
            const { isDeclareExportDeclaration: a, isStatement: o } = n;
            function AnyTypeAnnotation() {
                this.word("any");
            }
            function ArrayTypeAnnotation(e1) {
                this.print(e1.elementType, e1, true);
                this.tokenChar(91);
                this.tokenChar(93);
            }
            function BooleanTypeAnnotation() {
                this.word("boolean");
            }
            function BooleanLiteralTypeAnnotation(e1) {
                this.word(e1.value ? "true" : "false");
            }
            function NullLiteralTypeAnnotation() {
                this.word("null");
            }
            function DeclareClass(e1, t) {
                if (!a(t)) {
                    this.word("declare");
                    this.space();
                }
                this.word("class");
                this.space();
                this._interfaceish(e1);
            }
            function DeclareFunction(e1, t) {
                if (!a(t)) {
                    this.word("declare");
                    this.space();
                }
                this.word("function");
                this.space();
                this.print(e1.id, e1);
                this.print(e1.id.typeAnnotation.typeAnnotation, e1);
                if (e1.predicate) {
                    this.space();
                    this.print(e1.predicate, e1);
                }
                this.semicolon();
            }
            function InferredPredicate() {
                this.tokenChar(37);
                this.word("checks");
            }
            function DeclaredPredicate(e1) {
                this.tokenChar(37);
                this.word("checks");
                this.tokenChar(40);
                this.print(e1.value, e1);
                this.tokenChar(41);
            }
            function DeclareInterface(e1) {
                this.word("declare");
                this.space();
                this.InterfaceDeclaration(e1);
            }
            function DeclareModule(e1) {
                this.word("declare");
                this.space();
                this.word("module");
                this.space();
                this.print(e1.id, e1);
                this.space();
                this.print(e1.body, e1);
            }
            function DeclareModuleExports(e1) {
                this.word("declare");
                this.space();
                this.word("module");
                this.tokenChar(46);
                this.word("exports");
                this.print(e1.typeAnnotation, e1);
            }
            function DeclareTypeAlias(e1) {
                this.word("declare");
                this.space();
                this.TypeAlias(e1);
            }
            function DeclareOpaqueType(e1, t) {
                if (!a(t)) {
                    this.word("declare");
                    this.space();
                }
                this.OpaqueType(e1);
            }
            function DeclareVariable(e1, t) {
                if (!a(t)) {
                    this.word("declare");
                    this.space();
                }
                this.word("var");
                this.space();
                this.print(e1.id, e1);
                this.print(e1.id.typeAnnotation, e1);
                this.semicolon();
            }
            function DeclareExportDeclaration(e1) {
                this.word("declare");
                this.space();
                this.word("export");
                this.space();
                if (e1.default) {
                    this.word("default");
                    this.space();
                }
                FlowExportDeclaration.call(this, e1);
            }
            function DeclareExportAllDeclaration(e1) {
                this.word("declare");
                this.space();
                s.ExportAllDeclaration.call(this, e1);
            }
            function EnumDeclaration(e1) {
                const { id: t, body: r } = e1;
                this.word("enum");
                this.space();
                this.print(t, e1);
                this.print(r, e1);
            }
            function enumExplicitType(e1, t, r) {
                if (r) {
                    e1.space();
                    e1.word("of");
                    e1.space();
                    e1.word(t);
                }
                e1.space();
            }
            function enumBody(e1, t) {
                const { members: r } = t;
                e1.token("{");
                e1.indent();
                e1.newline();
                for (const n of r){
                    e1.print(n, t);
                    e1.newline();
                }
                if (t.hasUnknownMembers) {
                    e1.token("...");
                    e1.newline();
                }
                e1.dedent();
                e1.token("}");
            }
            function EnumBooleanBody(e1) {
                const { explicitType: t } = e1;
                enumExplicitType(this, "boolean", t);
                enumBody(this, e1);
            }
            function EnumNumberBody(e1) {
                const { explicitType: t } = e1;
                enumExplicitType(this, "number", t);
                enumBody(this, e1);
            }
            function EnumStringBody(e1) {
                const { explicitType: t } = e1;
                enumExplicitType(this, "string", t);
                enumBody(this, e1);
            }
            function EnumSymbolBody(e1) {
                enumExplicitType(this, "symbol", true);
                enumBody(this, e1);
            }
            function EnumDefaultedMember(e1) {
                const { id: t } = e1;
                this.print(t, e1);
                this.tokenChar(44);
            }
            function enumInitializedMember(e1, t) {
                const { id: r, init: n } = t;
                e1.print(r, t);
                e1.space();
                e1.token("=");
                e1.space();
                e1.print(n, t);
                e1.token(",");
            }
            function EnumBooleanMember(e1) {
                enumInitializedMember(this, e1);
            }
            function EnumNumberMember(e1) {
                enumInitializedMember(this, e1);
            }
            function EnumStringMember(e1) {
                enumInitializedMember(this, e1);
            }
            function FlowExportDeclaration(e1) {
                if (e1.declaration) {
                    const t = e1.declaration;
                    this.print(t, e1);
                    if (!o(t)) this.semicolon();
                } else {
                    this.tokenChar(123);
                    if (e1.specifiers.length) {
                        this.space();
                        this.printList(e1.specifiers, e1);
                        this.space();
                    }
                    this.tokenChar(125);
                    if (e1.source) {
                        this.space();
                        this.word("from");
                        this.space();
                        this.print(e1.source, e1);
                    }
                    this.semicolon();
                }
            }
            function ExistsTypeAnnotation() {
                this.tokenChar(42);
            }
            function FunctionTypeAnnotation(e1, t) {
                this.print(e1.typeParameters, e1);
                this.tokenChar(40);
                if (e1.this) {
                    this.word("this");
                    this.tokenChar(58);
                    this.space();
                    this.print(e1.this.typeAnnotation, e1);
                    if (e1.params.length || e1.rest) {
                        this.tokenChar(44);
                        this.space();
                    }
                }
                this.printList(e1.params, e1);
                if (e1.rest) {
                    if (e1.params.length) {
                        this.tokenChar(44);
                        this.space();
                    }
                    this.token("...");
                    this.print(e1.rest, e1);
                }
                this.tokenChar(41);
                const r = t == null ? void 0 : t.type;
                if (r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" && t.method)) {
                    this.tokenChar(58);
                } else {
                    this.space();
                    this.token("=>");
                }
                this.space();
                this.print(e1.returnType, e1);
            }
            function FunctionTypeParam(e1) {
                this.print(e1.name, e1);
                if (e1.optional) this.tokenChar(63);
                if (e1.name) {
                    this.tokenChar(58);
                    this.space();
                }
                this.print(e1.typeAnnotation, e1);
            }
            function InterfaceExtends(e1) {
                this.print(e1.id, e1);
                this.print(e1.typeParameters, e1, true);
            }
            function _interfaceish(e1) {
                var t;
                this.print(e1.id, e1);
                this.print(e1.typeParameters, e1);
                if ((t = e1.extends) != null && t.length) {
                    this.space();
                    this.word("extends");
                    this.space();
                    this.printList(e1.extends, e1);
                }
                if (e1.type === "DeclareClass") {
                    var r, n;
                    if ((r = e1.mixins) != null && r.length) {
                        this.space();
                        this.word("mixins");
                        this.space();
                        this.printList(e1.mixins, e1);
                    }
                    if ((n = e1.implements) != null && n.length) {
                        this.space();
                        this.word("implements");
                        this.space();
                        this.printList(e1.implements, e1);
                    }
                }
                this.space();
                this.print(e1.body, e1);
            }
            function _variance(e1) {
                var t;
                const r = (t = e1.variance) == null ? void 0 : t.kind;
                if (r != null) {
                    if (r === "plus") {
                        this.tokenChar(43);
                    } else if (r === "minus") {
                        this.tokenChar(45);
                    }
                }
            }
            function InterfaceDeclaration(e1) {
                this.word("interface");
                this.space();
                this._interfaceish(e1);
            }
            function andSeparator() {
                this.space();
                this.tokenChar(38);
                this.space();
            }
            function InterfaceTypeAnnotation(e1) {
                var t;
                this.word("interface");
                if ((t = e1.extends) != null && t.length) {
                    this.space();
                    this.word("extends");
                    this.space();
                    this.printList(e1.extends, e1);
                }
                this.space();
                this.print(e1.body, e1);
            }
            function IntersectionTypeAnnotation(e1) {
                this.printJoin(e1.types, e1, {
                    separator: andSeparator
                });
            }
            function MixedTypeAnnotation() {
                this.word("mixed");
            }
            function EmptyTypeAnnotation() {
                this.word("empty");
            }
            function NullableTypeAnnotation(e1) {
                this.tokenChar(63);
                this.print(e1.typeAnnotation, e1);
            }
            function NumberTypeAnnotation() {
                this.word("number");
            }
            function StringTypeAnnotation() {
                this.word("string");
            }
            function ThisTypeAnnotation() {
                this.word("this");
            }
            function TupleTypeAnnotation(e1) {
                this.tokenChar(91);
                this.printList(e1.types, e1);
                this.tokenChar(93);
            }
            function TypeofTypeAnnotation(e1) {
                this.word("typeof");
                this.space();
                this.print(e1.argument, e1);
            }
            function TypeAlias(e1) {
                this.word("type");
                this.space();
                this.print(e1.id, e1);
                this.print(e1.typeParameters, e1);
                this.space();
                this.tokenChar(61);
                this.space();
                this.print(e1.right, e1);
                this.semicolon();
            }
            function TypeAnnotation(e1) {
                this.tokenChar(58);
                this.space();
                if (e1.optional) this.tokenChar(63);
                this.print(e1.typeAnnotation, e1);
            }
            function TypeParameterInstantiation(e1) {
                this.tokenChar(60);
                this.printList(e1.params, e1, {});
                this.tokenChar(62);
            }
            function TypeParameter(e1) {
                this._variance(e1);
                this.word(e1.name);
                if (e1.bound) {
                    this.print(e1.bound, e1);
                }
                if (e1.default) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.default, e1);
                }
            }
            function OpaqueType(e1) {
                this.word("opaque");
                this.space();
                this.word("type");
                this.space();
                this.print(e1.id, e1);
                this.print(e1.typeParameters, e1);
                if (e1.supertype) {
                    this.tokenChar(58);
                    this.space();
                    this.print(e1.supertype, e1);
                }
                if (e1.impltype) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.impltype, e1);
                }
                this.semicolon();
            }
            function ObjectTypeAnnotation(e1) {
                if (e1.exact) {
                    this.token("{|");
                } else {
                    this.tokenChar(123);
                }
                const t = [
                    ...e1.properties,
                    ...e1.callProperties || [],
                    ...e1.indexers || [],
                    ...e1.internalSlots || []
                ];
                if (t.length) {
                    this.newline();
                    this.space();
                    this.printJoin(t, e1, {
                        addNewlines (e1) {
                            if (e1 && !t[0]) return 1;
                        },
                        indent: true,
                        statement: true,
                        iterator: ()=>{
                            if (t.length !== 1 || e1.inexact) {
                                this.tokenChar(44);
                                this.space();
                            }
                        }
                    });
                    this.space();
                }
                if (e1.inexact) {
                    this.indent();
                    this.token("...");
                    if (t.length) {
                        this.newline();
                    }
                    this.dedent();
                }
                if (e1.exact) {
                    this.token("|}");
                } else {
                    this.tokenChar(125);
                }
            }
            function ObjectTypeInternalSlot(e1) {
                if (e1.static) {
                    this.word("static");
                    this.space();
                }
                this.tokenChar(91);
                this.tokenChar(91);
                this.print(e1.id, e1);
                this.tokenChar(93);
                this.tokenChar(93);
                if (e1.optional) this.tokenChar(63);
                if (!e1.method) {
                    this.tokenChar(58);
                    this.space();
                }
                this.print(e1.value, e1);
            }
            function ObjectTypeCallProperty(e1) {
                if (e1.static) {
                    this.word("static");
                    this.space();
                }
                this.print(e1.value, e1);
            }
            function ObjectTypeIndexer(e1) {
                if (e1.static) {
                    this.word("static");
                    this.space();
                }
                this._variance(e1);
                this.tokenChar(91);
                if (e1.id) {
                    this.print(e1.id, e1);
                    this.tokenChar(58);
                    this.space();
                }
                this.print(e1.key, e1);
                this.tokenChar(93);
                this.tokenChar(58);
                this.space();
                this.print(e1.value, e1);
            }
            function ObjectTypeProperty(e1) {
                if (e1.proto) {
                    this.word("proto");
                    this.space();
                }
                if (e1.static) {
                    this.word("static");
                    this.space();
                }
                if (e1.kind === "get" || e1.kind === "set") {
                    this.word(e1.kind);
                    this.space();
                }
                this._variance(e1);
                this.print(e1.key, e1);
                if (e1.optional) this.tokenChar(63);
                if (!e1.method) {
                    this.tokenChar(58);
                    this.space();
                }
                this.print(e1.value, e1);
            }
            function ObjectTypeSpreadProperty(e1) {
                this.token("...");
                this.print(e1.argument, e1);
            }
            function QualifiedTypeIdentifier(e1) {
                this.print(e1.qualification, e1);
                this.tokenChar(46);
                this.print(e1.id, e1);
            }
            function SymbolTypeAnnotation() {
                this.word("symbol");
            }
            function orSeparator() {
                this.space();
                this.tokenChar(124);
                this.space();
            }
            function UnionTypeAnnotation(e1) {
                this.printJoin(e1.types, e1, {
                    separator: orSeparator
                });
            }
            function TypeCastExpression(e1) {
                this.tokenChar(40);
                this.print(e1.expression, e1);
                this.print(e1.typeAnnotation, e1);
                this.tokenChar(41);
            }
            function Variance(e1) {
                if (e1.kind === "plus") {
                    this.tokenChar(43);
                } else {
                    this.tokenChar(45);
                }
            }
            function VoidTypeAnnotation() {
                this.word("void");
            }
            function IndexedAccessType(e1) {
                this.print(e1.objectType, e1, true);
                this.tokenChar(91);
                this.print(e1.indexType, e1);
                this.tokenChar(93);
            }
            function OptionalIndexedAccessType(e1) {
                this.print(e1.objectType, e1);
                if (e1.optional) {
                    this.token("?.");
                }
                this.tokenChar(91);
                this.print(e1.indexType, e1);
                this.tokenChar(93);
            }
        },
        6376: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            var n = r(6010);
            Object.keys(n).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === n[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return n[e1];
                    }
                });
            });
            var s = r(9978);
            Object.keys(s).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === s[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return s[e1];
                    }
                });
            });
            var i = r(460);
            Object.keys(i).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === i[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return i[e1];
                    }
                });
            });
            var a = r(5103);
            Object.keys(a).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === a[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return a[e1];
                    }
                });
            });
            var o = r(5843);
            Object.keys(o).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === o[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return o[e1];
                    }
                });
            });
            var l = r(7104);
            Object.keys(l).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === l[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return l[e1];
                    }
                });
            });
            var c = r(5973);
            Object.keys(c).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === c[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return c[e1];
                    }
                });
            });
            var u = r(7138);
            Object.keys(u).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === u[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return u[e1];
                    }
                });
            });
            var p = r(3987);
            Object.keys(p).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === p[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return p[e1];
                    }
                });
            });
            var f = r(2280);
            Object.keys(f).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === f[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return f[e1];
                    }
                });
            });
            var d = r(470);
            Object.keys(d).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (e1 in t && t[e1] === d[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return d[e1];
                    }
                });
            });
        },
        2280: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.JSXAttribute = JSXAttribute;
            t.JSXClosingElement = JSXClosingElement;
            t.JSXClosingFragment = JSXClosingFragment;
            t.JSXElement = JSXElement;
            t.JSXEmptyExpression = JSXEmptyExpression;
            t.JSXExpressionContainer = JSXExpressionContainer;
            t.JSXFragment = JSXFragment;
            t.JSXIdentifier = JSXIdentifier;
            t.JSXMemberExpression = JSXMemberExpression;
            t.JSXNamespacedName = JSXNamespacedName;
            t.JSXOpeningElement = JSXOpeningElement;
            t.JSXOpeningFragment = JSXOpeningFragment;
            t.JSXSpreadAttribute = JSXSpreadAttribute;
            t.JSXSpreadChild = JSXSpreadChild;
            t.JSXText = JSXText;
            function JSXAttribute(e1) {
                this.print(e1.name, e1);
                if (e1.value) {
                    this.tokenChar(61);
                    this.print(e1.value, e1);
                }
            }
            function JSXIdentifier(e1) {
                this.word(e1.name);
            }
            function JSXNamespacedName(e1) {
                this.print(e1.namespace, e1);
                this.tokenChar(58);
                this.print(e1.name, e1);
            }
            function JSXMemberExpression(e1) {
                this.print(e1.object, e1);
                this.tokenChar(46);
                this.print(e1.property, e1);
            }
            function JSXSpreadAttribute(e1) {
                this.tokenChar(123);
                this.token("...");
                this.print(e1.argument, e1);
                this.tokenChar(125);
            }
            function JSXExpressionContainer(e1) {
                this.tokenChar(123);
                this.print(e1.expression, e1);
                this.tokenChar(125);
            }
            function JSXSpreadChild(e1) {
                this.tokenChar(123);
                this.token("...");
                this.print(e1.expression, e1);
                this.tokenChar(125);
            }
            function JSXText(e1) {
                const t = this.getPossibleRaw(e1);
                if (t !== undefined) {
                    this.token(t, true);
                } else {
                    this.token(e1.value, true);
                }
            }
            function JSXElement(e1) {
                const t = e1.openingElement;
                this.print(t, e1);
                if (t.selfClosing) return;
                this.indent();
                for (const t of e1.children){
                    this.print(t, e1);
                }
                this.dedent();
                this.print(e1.closingElement, e1);
            }
            function spaceSeparator() {
                this.space();
            }
            function JSXOpeningElement(e1) {
                this.tokenChar(60);
                this.print(e1.name, e1);
                this.print(e1.typeParameters, e1);
                if (e1.attributes.length > 0) {
                    this.space();
                    this.printJoin(e1.attributes, e1, {
                        separator: spaceSeparator
                    });
                }
                if (e1.selfClosing) {
                    this.space();
                    this.token("/>");
                } else {
                    this.tokenChar(62);
                }
            }
            function JSXClosingElement(e1) {
                this.token("</");
                this.print(e1.name, e1);
                this.tokenChar(62);
            }
            function JSXEmptyExpression() {
                this.printInnerComments();
            }
            function JSXFragment(e1) {
                this.print(e1.openingFragment, e1);
                this.indent();
                for (const t of e1.children){
                    this.print(t, e1);
                }
                this.dedent();
                this.print(e1.closingFragment, e1);
            }
            function JSXOpeningFragment() {
                this.tokenChar(60);
                this.tokenChar(62);
            }
            function JSXClosingFragment() {
                this.token("</");
                this.tokenChar(62);
            }
        },
        5843: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ArrowFunctionExpression = ArrowFunctionExpression;
            t.FunctionDeclaration = t.FunctionExpression = FunctionExpression;
            t._functionHead = _functionHead;
            t._methodHead = _methodHead;
            t._param = _param;
            t._parameters = _parameters;
            t._params = _params;
            t._predicate = _predicate;
            var n = r(776);
            const { isIdentifier: s } = n;
            function _params(e1, t, r) {
                this.print(e1.typeParameters, e1);
                const n = _getFuncIdName.call(this, t, r);
                if (n) {
                    this.sourceIdentifierName(n.name, n.pos);
                }
                this.tokenChar(40);
                this._parameters(e1.params, e1);
                this.tokenChar(41);
                const s = e1.type === "ArrowFunctionExpression";
                this.print(e1.returnType, e1, s);
                this._noLineTerminator = s;
            }
            function _parameters(e1, t) {
                const r = e1.length;
                for(let n = 0; n < r; n++){
                    this._param(e1[n], t);
                    if (n < e1.length - 1) {
                        this.tokenChar(44);
                        this.space();
                    }
                }
            }
            function _param(e1, t) {
                this.printJoin(e1.decorators, e1);
                this.print(e1, t);
                if (e1.optional) {
                    this.tokenChar(63);
                }
                this.print(e1.typeAnnotation, e1);
            }
            function _methodHead(e1) {
                const t = e1.kind;
                const r = e1.key;
                if (t === "get" || t === "set") {
                    this.word(t);
                    this.space();
                }
                if (e1.async) {
                    this.word("async", true);
                    this.space();
                }
                if (t === "method" || t === "init") {
                    if (e1.generator) {
                        this.tokenChar(42);
                    }
                }
                if (e1.computed) {
                    this.tokenChar(91);
                    this.print(r, e1);
                    this.tokenChar(93);
                } else {
                    this.print(r, e1);
                }
                if (e1.optional) {
                    this.tokenChar(63);
                }
                this._params(e1, e1.computed && e1.key.type !== "StringLiteral" ? undefined : e1.key, undefined);
            }
            function _predicate(e1, t) {
                if (e1.predicate) {
                    if (!e1.returnType) {
                        this.tokenChar(58);
                    }
                    this.space();
                    this.print(e1.predicate, e1, t);
                }
            }
            function _functionHead(e1, t) {
                if (e1.async) {
                    this.word("async");
                    this._endsWithInnerRaw = false;
                    this.space();
                }
                this.word("function");
                if (e1.generator) {
                    this._endsWithInnerRaw = false;
                    this.tokenChar(42);
                }
                this.space();
                if (e1.id) {
                    this.print(e1.id, e1);
                }
                this._params(e1, e1.id, t);
                if (e1.type !== "TSDeclareFunction") {
                    this._predicate(e1);
                }
            }
            function FunctionExpression(e1, t) {
                this._functionHead(e1, t);
                this.space();
                this.print(e1.body, e1);
            }
            function ArrowFunctionExpression(e1, t) {
                if (e1.async) {
                    this.word("async", true);
                    this.space();
                }
                let r;
                if (!this.format.retainLines && e1.params.length === 1 && s(r = e1.params[0]) && !hasTypesOrComments(e1, r)) {
                    this.print(r, e1, true);
                } else {
                    this._params(e1, undefined, t);
                }
                this._predicate(e1, true);
                this.space();
                this.printInnerComments();
                this.token("=>");
                this.space();
                this.print(e1.body, e1);
            }
            function hasTypesOrComments(e1, t) {
                var r, n;
                return !!(e1.typeParameters || e1.returnType || e1.predicate || t.typeAnnotation || t.optional || (r = t.leadingComments) != null && r.length || (n = t.trailingComments) != null && n.length);
            }
            function _getFuncIdName(e1, t) {
                let r = e1;
                if (!r && t) {
                    const e1 = t.type;
                    if (e1 === "VariableDeclarator") {
                        r = t.id;
                    } else if (e1 === "AssignmentExpression" || e1 === "AssignmentPattern") {
                        r = t.left;
                    } else if (e1 === "ObjectProperty" || e1 === "ClassProperty") {
                        if (!t.computed || t.key.type === "StringLiteral") {
                            r = t.key;
                        }
                    } else if (e1 === "ClassPrivateProperty" || e1 === "ClassAccessorProperty") {
                        r = t.key;
                    }
                }
                if (!r) return;
                let n;
                if (r.type === "Identifier") {
                    var s, i;
                    n = {
                        pos: (s = r.loc) == null ? void 0 : s.start,
                        name: ((i = r.loc) == null ? void 0 : i.identifierName) || r.name
                    };
                } else if (r.type === "PrivateName") {
                    var a;
                    n = {
                        pos: (a = r.loc) == null ? void 0 : a.start,
                        name: "#" + r.id.name
                    };
                } else if (r.type === "StringLiteral") {
                    var o;
                    n = {
                        pos: (o = r.loc) == null ? void 0 : o.start,
                        name: r.value
                    };
                }
                return n;
            }
        },
        7104: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ExportAllDeclaration = ExportAllDeclaration;
            t.ExportDefaultDeclaration = ExportDefaultDeclaration;
            t.ExportDefaultSpecifier = ExportDefaultSpecifier;
            t.ExportNamedDeclaration = ExportNamedDeclaration;
            t.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
            t.ExportSpecifier = ExportSpecifier;
            t.ImportAttribute = ImportAttribute;
            t.ImportDeclaration = ImportDeclaration;
            t.ImportDefaultSpecifier = ImportDefaultSpecifier;
            t.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
            t.ImportSpecifier = ImportSpecifier;
            t._printAttributes = _printAttributes;
            var n = r(776);
            const { isClassDeclaration: s, isExportDefaultSpecifier: i, isExportNamespaceSpecifier: a, isImportDefaultSpecifier: o, isImportNamespaceSpecifier: l, isStatement: c } = n;
            function ImportSpecifier(e1) {
                if (e1.importKind === "type" || e1.importKind === "typeof") {
                    this.word(e1.importKind);
                    this.space();
                }
                this.print(e1.imported, e1);
                if (e1.local && e1.local.name !== e1.imported.name) {
                    this.space();
                    this.word("as");
                    this.space();
                    this.print(e1.local, e1);
                }
            }
            function ImportDefaultSpecifier(e1) {
                this.print(e1.local, e1);
            }
            function ExportDefaultSpecifier(e1) {
                this.print(e1.exported, e1);
            }
            function ExportSpecifier(e1) {
                if (e1.exportKind === "type") {
                    this.word("type");
                    this.space();
                }
                this.print(e1.local, e1);
                if (e1.exported && e1.local.name !== e1.exported.name) {
                    this.space();
                    this.word("as");
                    this.space();
                    this.print(e1.exported, e1);
                }
            }
            function ExportNamespaceSpecifier(e1) {
                this.tokenChar(42);
                this.space();
                this.word("as");
                this.space();
                this.print(e1.exported, e1);
            }
            let u = false;
            function _printAttributes(e1) {
                const { importAttributesKeyword: t } = this.format;
                const { attributes: r, assertions: n } = e1;
                if (r && !t && !u) {
                    u = true;
                    console.warn(`You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : \`import { a } from "b" with { type: "json" };\`\n - "assert"      : \`import { a } from "b" assert { type: "json" };\`\n - "with-legacy" : \`import { a } from "b" with type: "json";\`\n`);
                }
                const s = t === "assert" || !t && n;
                this.word(s ? "assert" : "with");
                this.space();
                if (!s && t !== "with") {
                    this.printList(r || n, e1);
                    return;
                }
                this.tokenChar(123);
                this.space();
                this.printList(r || n, e1);
                this.space();
                this.tokenChar(125);
            }
            function ExportAllDeclaration(e1) {
                var t, r;
                this.word("export");
                this.space();
                if (e1.exportKind === "type") {
                    this.word("type");
                    this.space();
                }
                this.tokenChar(42);
                this.space();
                this.word("from");
                this.space();
                if ((t = e1.attributes) != null && t.length || (r = e1.assertions) != null && r.length) {
                    this.print(e1.source, e1, true);
                    this.space();
                    this._printAttributes(e1);
                } else {
                    this.print(e1.source, e1);
                }
                this.semicolon();
            }
            function maybePrintDecoratorsBeforeExport(e1, t) {
                if (s(t.declaration) && e1._shouldPrintDecoratorsBeforeExport(t)) {
                    e1.printJoin(t.declaration.decorators, t);
                }
            }
            function ExportNamedDeclaration(e1) {
                maybePrintDecoratorsBeforeExport(this, e1);
                this.word("export");
                this.space();
                if (e1.declaration) {
                    const t = e1.declaration;
                    this.print(t, e1);
                    if (!c(t)) this.semicolon();
                } else {
                    if (e1.exportKind === "type") {
                        this.word("type");
                        this.space();
                    }
                    const n = e1.specifiers.slice(0);
                    let s = false;
                    for(;;){
                        const t = n[0];
                        if (i(t) || a(t)) {
                            s = true;
                            this.print(n.shift(), e1);
                            if (n.length) {
                                this.tokenChar(44);
                                this.space();
                            }
                        } else {
                            break;
                        }
                    }
                    if (n.length || !n.length && !s) {
                        this.tokenChar(123);
                        if (n.length) {
                            this.space();
                            this.printList(n, e1);
                            this.space();
                        }
                        this.tokenChar(125);
                    }
                    if (e1.source) {
                        var t, r;
                        this.space();
                        this.word("from");
                        this.space();
                        if ((t = e1.attributes) != null && t.length || (r = e1.assertions) != null && r.length) {
                            this.print(e1.source, e1, true);
                            this.space();
                            this._printAttributes(e1);
                        } else {
                            this.print(e1.source, e1);
                        }
                    }
                    this.semicolon();
                }
            }
            function ExportDefaultDeclaration(e1) {
                maybePrintDecoratorsBeforeExport(this, e1);
                this.word("export");
                this.noIndentInnerCommentsHere();
                this.space();
                this.word("default");
                this.space();
                const t = e1.declaration;
                this.print(t, e1);
                if (!c(t)) this.semicolon();
            }
            function ImportDeclaration(e1) {
                var t, r;
                this.word("import");
                this.space();
                const n = e1.importKind === "type" || e1.importKind === "typeof";
                if (n) {
                    this.noIndentInnerCommentsHere();
                    this.word(e1.importKind);
                    this.space();
                } else if (e1.module) {
                    this.noIndentInnerCommentsHere();
                    this.word("module");
                    this.space();
                }
                const s = e1.specifiers.slice(0);
                const i = !!s.length;
                while(i){
                    const t = s[0];
                    if (o(t) || l(t)) {
                        this.print(s.shift(), e1);
                        if (s.length) {
                            this.tokenChar(44);
                            this.space();
                        }
                    } else {
                        break;
                    }
                }
                if (s.length) {
                    this.tokenChar(123);
                    this.space();
                    this.printList(s, e1);
                    this.space();
                    this.tokenChar(125);
                } else if (n && !i) {
                    this.tokenChar(123);
                    this.tokenChar(125);
                }
                if (i || n) {
                    this.space();
                    this.word("from");
                    this.space();
                }
                if ((t = e1.attributes) != null && t.length || (r = e1.assertions) != null && r.length) {
                    this.print(e1.source, e1, true);
                    this.space();
                    this._printAttributes(e1);
                } else {
                    this.print(e1.source, e1);
                }
                this.semicolon();
            }
            function ImportAttribute(e1) {
                this.print(e1.key);
                this.tokenChar(58);
                this.space();
                this.print(e1.value);
            }
            function ImportNamespaceSpecifier(e1) {
                this.tokenChar(42);
                this.space();
                this.word("as");
                this.space();
                this.print(e1.local, e1);
            }
        },
        460: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BreakStatement = BreakStatement;
            t.CatchClause = CatchClause;
            t.ContinueStatement = ContinueStatement;
            t.DebuggerStatement = DebuggerStatement;
            t.DoWhileStatement = DoWhileStatement;
            t.ForOfStatement = t.ForInStatement = void 0;
            t.ForStatement = ForStatement;
            t.IfStatement = IfStatement;
            t.LabeledStatement = LabeledStatement;
            t.ReturnStatement = ReturnStatement;
            t.SwitchCase = SwitchCase;
            t.SwitchStatement = SwitchStatement;
            t.ThrowStatement = ThrowStatement;
            t.TryStatement = TryStatement;
            t.VariableDeclaration = VariableDeclaration;
            t.VariableDeclarator = VariableDeclarator;
            t.WhileStatement = WhileStatement;
            t.WithStatement = WithStatement;
            var n = r(776);
            const { isFor: s, isForStatement: i, isIfStatement: a, isStatement: o } = n;
            function WithStatement(e1) {
                this.word("with");
                this.space();
                this.tokenChar(40);
                this.print(e1.object, e1);
                this.tokenChar(41);
                this.printBlock(e1);
            }
            function IfStatement(e1) {
                this.word("if");
                this.space();
                this.tokenChar(40);
                this.print(e1.test, e1);
                this.tokenChar(41);
                this.space();
                const t = e1.alternate && a(getLastStatement(e1.consequent));
                if (t) {
                    this.tokenChar(123);
                    this.newline();
                    this.indent();
                }
                this.printAndIndentOnComments(e1.consequent, e1);
                if (t) {
                    this.dedent();
                    this.newline();
                    this.tokenChar(125);
                }
                if (e1.alternate) {
                    if (this.endsWith(125)) this.space();
                    this.word("else");
                    this.space();
                    this.printAndIndentOnComments(e1.alternate, e1);
                }
            }
            function getLastStatement(e1) {
                const { body: t } = e1;
                if (o(t) === false) {
                    return e1;
                }
                return getLastStatement(t);
            }
            function ForStatement(e1) {
                this.word("for");
                this.space();
                this.tokenChar(40);
                this.inForStatementInitCounter++;
                this.print(e1.init, e1);
                this.inForStatementInitCounter--;
                this.tokenChar(59);
                if (e1.test) {
                    this.space();
                    this.print(e1.test, e1);
                }
                this.tokenChar(59);
                if (e1.update) {
                    this.space();
                    this.print(e1.update, e1);
                }
                this.tokenChar(41);
                this.printBlock(e1);
            }
            function WhileStatement(e1) {
                this.word("while");
                this.space();
                this.tokenChar(40);
                this.print(e1.test, e1);
                this.tokenChar(41);
                this.printBlock(e1);
            }
            function ForXStatement(e1) {
                this.word("for");
                this.space();
                const t = e1.type === "ForOfStatement";
                if (t && e1.await) {
                    this.word("await");
                    this.space();
                }
                this.noIndentInnerCommentsHere();
                this.tokenChar(40);
                this.print(e1.left, e1);
                this.space();
                this.word(t ? "of" : "in");
                this.space();
                this.print(e1.right, e1);
                this.tokenChar(41);
                this.printBlock(e1);
            }
            const l = ForXStatement;
            t.ForInStatement = l;
            const c = ForXStatement;
            t.ForOfStatement = c;
            function DoWhileStatement(e1) {
                this.word("do");
                this.space();
                this.print(e1.body, e1);
                this.space();
                this.word("while");
                this.space();
                this.tokenChar(40);
                this.print(e1.test, e1);
                this.tokenChar(41);
                this.semicolon();
            }
            function printStatementAfterKeyword(e1, t, r, n) {
                if (t) {
                    e1.space();
                    e1.printTerminatorless(t, r, n);
                }
                e1.semicolon();
            }
            function BreakStatement(e1) {
                this.word("break");
                printStatementAfterKeyword(this, e1.label, e1, true);
            }
            function ContinueStatement(e1) {
                this.word("continue");
                printStatementAfterKeyword(this, e1.label, e1, true);
            }
            function ReturnStatement(e1) {
                this.word("return");
                printStatementAfterKeyword(this, e1.argument, e1, false);
            }
            function ThrowStatement(e1) {
                this.word("throw");
                printStatementAfterKeyword(this, e1.argument, e1, false);
            }
            function LabeledStatement(e1) {
                this.print(e1.label, e1);
                this.tokenChar(58);
                this.space();
                this.print(e1.body, e1);
            }
            function TryStatement(e1) {
                this.word("try");
                this.space();
                this.print(e1.block, e1);
                this.space();
                if (e1.handlers) {
                    this.print(e1.handlers[0], e1);
                } else {
                    this.print(e1.handler, e1);
                }
                if (e1.finalizer) {
                    this.space();
                    this.word("finally");
                    this.space();
                    this.print(e1.finalizer, e1);
                }
            }
            function CatchClause(e1) {
                this.word("catch");
                this.space();
                if (e1.param) {
                    this.tokenChar(40);
                    this.print(e1.param, e1);
                    this.print(e1.param.typeAnnotation, e1);
                    this.tokenChar(41);
                    this.space();
                }
                this.print(e1.body, e1);
            }
            function SwitchStatement(e1) {
                this.word("switch");
                this.space();
                this.tokenChar(40);
                this.print(e1.discriminant, e1);
                this.tokenChar(41);
                this.space();
                this.tokenChar(123);
                this.printSequence(e1.cases, e1, {
                    indent: true,
                    addNewlines (t, r) {
                        if (!t && e1.cases[e1.cases.length - 1] === r) return -1;
                    }
                });
                this.rightBrace(e1);
            }
            function SwitchCase(e1) {
                if (e1.test) {
                    this.word("case");
                    this.space();
                    this.print(e1.test, e1);
                    this.tokenChar(58);
                } else {
                    this.word("default");
                    this.tokenChar(58);
                }
                if (e1.consequent.length) {
                    this.newline();
                    this.printSequence(e1.consequent, e1, {
                        indent: true
                    });
                }
            }
            function DebuggerStatement() {
                this.word("debugger");
                this.semicolon();
            }
            function VariableDeclaration(e1, t) {
                if (e1.declare) {
                    this.word("declare");
                    this.space();
                }
                const { kind: r } = e1;
                this.word(r, r === "using" || r === "await using");
                this.space();
                let n = false;
                if (!s(t)) {
                    for (const t of e1.declarations){
                        if (t.init) {
                            n = true;
                        }
                    }
                }
                this.printList(e1.declarations, e1, {
                    separator: n ? function() {
                        this.tokenChar(44);
                        this.newline();
                    } : undefined,
                    indent: e1.declarations.length > 1 ? true : false
                });
                if (s(t)) {
                    if (i(t)) {
                        if (t.init === e1) return;
                    } else {
                        if (t.left === e1) return;
                    }
                }
                this.semicolon();
            }
            function VariableDeclarator(e1) {
                this.print(e1.id, e1);
                if (e1.definite) this.tokenChar(33);
                this.print(e1.id.typeAnnotation, e1);
                if (e1.init) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.init, e1);
                }
            }
        },
        6010: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TaggedTemplateExpression = TaggedTemplateExpression;
            t.TemplateElement = TemplateElement;
            t.TemplateLiteral = TemplateLiteral;
            function TaggedTemplateExpression(e1) {
                this.print(e1.tag, e1);
                this.print(e1.typeParameters, e1);
                this.print(e1.quasi, e1);
            }
            function TemplateElement(e1, t) {
                const r = t.quasis[0] === e1;
                const n = t.quasis[t.quasis.length - 1] === e1;
                const s = (r ? "`" : "}") + e1.value.raw + (n ? "`" : "${");
                this.token(s, true);
            }
            function TemplateLiteral(e1) {
                const t = e1.quasis;
                for(let r = 0; r < t.length; r++){
                    this.print(t[r], e1);
                    if (r + 1 < t.length) {
                        this.print(e1.expressions[r], e1);
                    }
                }
            }
        },
        5973: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ArgumentPlaceholder = ArgumentPlaceholder;
            t.ArrayPattern = t.ArrayExpression = ArrayExpression;
            t.BigIntLiteral = BigIntLiteral;
            t.BooleanLiteral = BooleanLiteral;
            t.DecimalLiteral = DecimalLiteral;
            t.Identifier = Identifier;
            t.NullLiteral = NullLiteral;
            t.NumericLiteral = NumericLiteral;
            t.ObjectPattern = t.ObjectExpression = ObjectExpression;
            t.ObjectMethod = ObjectMethod;
            t.ObjectProperty = ObjectProperty;
            t.PipelineBareFunction = PipelineBareFunction;
            t.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
            t.PipelineTopicExpression = PipelineTopicExpression;
            t.RecordExpression = RecordExpression;
            t.RegExpLiteral = RegExpLiteral;
            t.SpreadElement = t.RestElement = RestElement;
            t.StringLiteral = StringLiteral;
            t.TopicReference = TopicReference;
            t.TupleExpression = TupleExpression;
            var n = r(776);
            var s = r(4011);
            const { isAssignmentPattern: i, isIdentifier: a } = n;
            function Identifier(e1) {
                var t;
                this.sourceIdentifierName(((t = e1.loc) == null ? void 0 : t.identifierName) || e1.name);
                this.word(e1.name);
            }
            function ArgumentPlaceholder() {
                this.tokenChar(63);
            }
            function RestElement(e1) {
                this.token("...");
                this.print(e1.argument, e1);
            }
            function ObjectExpression(e1) {
                const t = e1.properties;
                this.tokenChar(123);
                if (t.length) {
                    this.space();
                    this.printList(t, e1, {
                        indent: true,
                        statement: true
                    });
                    this.space();
                }
                this.sourceWithOffset("end", e1.loc, 0, -1);
                this.tokenChar(125);
            }
            function ObjectMethod(e1) {
                this.printJoin(e1.decorators, e1);
                this._methodHead(e1);
                this.space();
                this.print(e1.body, e1);
            }
            function ObjectProperty(e1) {
                this.printJoin(e1.decorators, e1);
                if (e1.computed) {
                    this.tokenChar(91);
                    this.print(e1.key, e1);
                    this.tokenChar(93);
                } else {
                    if (i(e1.value) && a(e1.key) && e1.key.name === e1.value.left.name) {
                        this.print(e1.value, e1);
                        return;
                    }
                    this.print(e1.key, e1);
                    if (e1.shorthand && a(e1.key) && a(e1.value) && e1.key.name === e1.value.name) {
                        return;
                    }
                }
                this.tokenChar(58);
                this.space();
                this.print(e1.value, e1);
            }
            function ArrayExpression(e1) {
                const t = e1.elements;
                const r = t.length;
                this.tokenChar(91);
                for(let n = 0; n < t.length; n++){
                    const s = t[n];
                    if (s) {
                        if (n > 0) this.space();
                        this.print(s, e1);
                        if (n < r - 1) this.tokenChar(44);
                    } else {
                        this.tokenChar(44);
                    }
                }
                this.tokenChar(93);
            }
            function RecordExpression(e1) {
                const t = e1.properties;
                let r;
                let n;
                if (this.format.recordAndTupleSyntaxType === "bar") {
                    r = "{|";
                    n = "|}";
                } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
                    throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
                } else {
                    r = "#{";
                    n = "}";
                }
                this.token(r);
                if (t.length) {
                    this.space();
                    this.printList(t, e1, {
                        indent: true,
                        statement: true
                    });
                    this.space();
                }
                this.token(n);
            }
            function TupleExpression(e1) {
                const t = e1.elements;
                const r = t.length;
                let n;
                let s;
                if (this.format.recordAndTupleSyntaxType === "bar") {
                    n = "[|";
                    s = "|]";
                } else if (this.format.recordAndTupleSyntaxType === "hash") {
                    n = "#[";
                    s = "]";
                } else {
                    throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
                }
                this.token(n);
                for(let n = 0; n < t.length; n++){
                    const s = t[n];
                    if (s) {
                        if (n > 0) this.space();
                        this.print(s, e1);
                        if (n < r - 1) this.tokenChar(44);
                    }
                }
                this.token(s);
            }
            function RegExpLiteral(e1) {
                this.word(`/${e1.pattern}/${e1.flags}`);
            }
            function BooleanLiteral(e1) {
                this.word(e1.value ? "true" : "false");
            }
            function NullLiteral() {
                this.word("null");
            }
            function NumericLiteral(e1) {
                const t = this.getPossibleRaw(e1);
                const r = this.format.jsescOption;
                const n = e1.value + "";
                if (r.numbers) {
                    this.number(s(e1.value, r));
                } else if (t == null) {
                    this.number(n);
                } else if (this.format.minified) {
                    this.number(t.length < n.length ? t : n);
                } else {
                    this.number(t);
                }
            }
            function StringLiteral(e1) {
                const t = this.getPossibleRaw(e1);
                if (!this.format.minified && t !== undefined) {
                    this.token(t);
                    return;
                }
                const r = s(e1.value, this.format.jsescOption);
                this.token(r);
            }
            function BigIntLiteral(e1) {
                const t = this.getPossibleRaw(e1);
                if (!this.format.minified && t !== undefined) {
                    this.word(t);
                    return;
                }
                this.word(e1.value + "n");
            }
            function DecimalLiteral(e1) {
                const t = this.getPossibleRaw(e1);
                if (!this.format.minified && t !== undefined) {
                    this.word(t);
                    return;
                }
                this.word(e1.value + "m");
            }
            const o = new Set([
                "^^",
                "@@",
                "^",
                "%",
                "#"
            ]);
            function TopicReference() {
                const { topicToken: e1 } = this.format;
                if (o.has(e1)) {
                    this.token(e1);
                } else {
                    const t = JSON.stringify(e1);
                    const r = Array.from(o, (e1)=>JSON.stringify(e1));
                    throw new Error(`The "topicToken" generator option must be one of ` + `${r.join(", ")} (${t} received instead).`);
                }
            }
            function PipelineTopicExpression(e1) {
                this.print(e1.expression, e1);
            }
            function PipelineBareFunction(e1) {
                this.print(e1.callee, e1);
            }
            function PipelinePrimaryTopicReference() {
                this.tokenChar(35);
            }
        },
        470: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TSAnyKeyword = TSAnyKeyword;
            t.TSArrayType = TSArrayType;
            t.TSSatisfiesExpression = t.TSAsExpression = TSTypeExpression;
            t.TSBigIntKeyword = TSBigIntKeyword;
            t.TSBooleanKeyword = TSBooleanKeyword;
            t.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
            t.TSConditionalType = TSConditionalType;
            t.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
            t.TSConstructorType = TSConstructorType;
            t.TSDeclareFunction = TSDeclareFunction;
            t.TSDeclareMethod = TSDeclareMethod;
            t.TSEnumDeclaration = TSEnumDeclaration;
            t.TSEnumMember = TSEnumMember;
            t.TSExportAssignment = TSExportAssignment;
            t.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
            t.TSExternalModuleReference = TSExternalModuleReference;
            t.TSFunctionType = TSFunctionType;
            t.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
            t.TSImportType = TSImportType;
            t.TSIndexSignature = TSIndexSignature;
            t.TSIndexedAccessType = TSIndexedAccessType;
            t.TSInferType = TSInferType;
            t.TSInstantiationExpression = TSInstantiationExpression;
            t.TSInterfaceBody = TSInterfaceBody;
            t.TSInterfaceDeclaration = TSInterfaceDeclaration;
            t.TSIntersectionType = TSIntersectionType;
            t.TSIntrinsicKeyword = TSIntrinsicKeyword;
            t.TSLiteralType = TSLiteralType;
            t.TSMappedType = TSMappedType;
            t.TSMethodSignature = TSMethodSignature;
            t.TSModuleBlock = TSModuleBlock;
            t.TSModuleDeclaration = TSModuleDeclaration;
            t.TSNamedTupleMember = TSNamedTupleMember;
            t.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
            t.TSNeverKeyword = TSNeverKeyword;
            t.TSNonNullExpression = TSNonNullExpression;
            t.TSNullKeyword = TSNullKeyword;
            t.TSNumberKeyword = TSNumberKeyword;
            t.TSObjectKeyword = TSObjectKeyword;
            t.TSOptionalType = TSOptionalType;
            t.TSParameterProperty = TSParameterProperty;
            t.TSParenthesizedType = TSParenthesizedType;
            t.TSPropertySignature = TSPropertySignature;
            t.TSQualifiedName = TSQualifiedName;
            t.TSRestType = TSRestType;
            t.TSStringKeyword = TSStringKeyword;
            t.TSSymbolKeyword = TSSymbolKeyword;
            t.TSThisType = TSThisType;
            t.TSTupleType = TSTupleType;
            t.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
            t.TSTypeAnnotation = TSTypeAnnotation;
            t.TSTypeAssertion = TSTypeAssertion;
            t.TSTypeLiteral = TSTypeLiteral;
            t.TSTypeOperator = TSTypeOperator;
            t.TSTypeParameter = TSTypeParameter;
            t.TSTypeParameterDeclaration = t.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
            t.TSTypePredicate = TSTypePredicate;
            t.TSTypeQuery = TSTypeQuery;
            t.TSTypeReference = TSTypeReference;
            t.TSUndefinedKeyword = TSUndefinedKeyword;
            t.TSUnionType = TSUnionType;
            t.TSUnknownKeyword = TSUnknownKeyword;
            t.TSVoidKeyword = TSVoidKeyword;
            t.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
            t.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
            t.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
            t.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
            t.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
            function TSTypeAnnotation(e1) {
                this.tokenChar(58);
                this.space();
                if (e1.optional) this.tokenChar(63);
                this.print(e1.typeAnnotation, e1);
            }
            function TSTypeParameterInstantiation(e1, t) {
                this.tokenChar(60);
                this.printList(e1.params, e1, {});
                if (t.type === "ArrowFunctionExpression" && e1.params.length === 1) {
                    this.tokenChar(44);
                }
                this.tokenChar(62);
            }
            function TSTypeParameter(e1) {
                if (e1.in) {
                    this.word("in");
                    this.space();
                }
                if (e1.out) {
                    this.word("out");
                    this.space();
                }
                this.word(e1.name);
                if (e1.constraint) {
                    this.space();
                    this.word("extends");
                    this.space();
                    this.print(e1.constraint, e1);
                }
                if (e1.default) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(e1.default, e1);
                }
            }
            function TSParameterProperty(e1) {
                if (e1.accessibility) {
                    this.word(e1.accessibility);
                    this.space();
                }
                if (e1.readonly) {
                    this.word("readonly");
                    this.space();
                }
                this._param(e1.parameter);
            }
            function TSDeclareFunction(e1, t) {
                if (e1.declare) {
                    this.word("declare");
                    this.space();
                }
                this._functionHead(e1, t);
                this.tokenChar(59);
            }
            function TSDeclareMethod(e1) {
                this._classMethodHead(e1);
                this.tokenChar(59);
            }
            function TSQualifiedName(e1) {
                this.print(e1.left, e1);
                this.tokenChar(46);
                this.print(e1.right, e1);
            }
            function TSCallSignatureDeclaration(e1) {
                this.tsPrintSignatureDeclarationBase(e1);
                this.tokenChar(59);
            }
            function TSConstructSignatureDeclaration(e1) {
                this.word("new");
                this.space();
                this.tsPrintSignatureDeclarationBase(e1);
                this.tokenChar(59);
            }
            function TSPropertySignature(e1) {
                const { readonly: t, initializer: r } = e1;
                if (t) {
                    this.word("readonly");
                    this.space();
                }
                this.tsPrintPropertyOrMethodName(e1);
                this.print(e1.typeAnnotation, e1);
                if (r) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(r, e1);
                }
                this.tokenChar(59);
            }
            function tsPrintPropertyOrMethodName(e1) {
                if (e1.computed) {
                    this.tokenChar(91);
                }
                this.print(e1.key, e1);
                if (e1.computed) {
                    this.tokenChar(93);
                }
                if (e1.optional) {
                    this.tokenChar(63);
                }
            }
            function TSMethodSignature(e1) {
                const { kind: t } = e1;
                if (t === "set" || t === "get") {
                    this.word(t);
                    this.space();
                }
                this.tsPrintPropertyOrMethodName(e1);
                this.tsPrintSignatureDeclarationBase(e1);
                this.tokenChar(59);
            }
            function TSIndexSignature(e1) {
                const { readonly: t, static: r } = e1;
                if (r) {
                    this.word("static");
                    this.space();
                }
                if (t) {
                    this.word("readonly");
                    this.space();
                }
                this.tokenChar(91);
                this._parameters(e1.parameters, e1);
                this.tokenChar(93);
                this.print(e1.typeAnnotation, e1);
                this.tokenChar(59);
            }
            function TSAnyKeyword() {
                this.word("any");
            }
            function TSBigIntKeyword() {
                this.word("bigint");
            }
            function TSUnknownKeyword() {
                this.word("unknown");
            }
            function TSNumberKeyword() {
                this.word("number");
            }
            function TSObjectKeyword() {
                this.word("object");
            }
            function TSBooleanKeyword() {
                this.word("boolean");
            }
            function TSStringKeyword() {
                this.word("string");
            }
            function TSSymbolKeyword() {
                this.word("symbol");
            }
            function TSVoidKeyword() {
                this.word("void");
            }
            function TSUndefinedKeyword() {
                this.word("undefined");
            }
            function TSNullKeyword() {
                this.word("null");
            }
            function TSNeverKeyword() {
                this.word("never");
            }
            function TSIntrinsicKeyword() {
                this.word("intrinsic");
            }
            function TSThisType() {
                this.word("this");
            }
            function TSFunctionType(e1) {
                this.tsPrintFunctionOrConstructorType(e1);
            }
            function TSConstructorType(e1) {
                if (e1.abstract) {
                    this.word("abstract");
                    this.space();
                }
                this.word("new");
                this.space();
                this.tsPrintFunctionOrConstructorType(e1);
            }
            function tsPrintFunctionOrConstructorType(e1) {
                const { typeParameters: t } = e1;
                const r = e1.parameters;
                this.print(t, e1);
                this.tokenChar(40);
                this._parameters(r, e1);
                this.tokenChar(41);
                this.space();
                this.token("=>");
                this.space();
                const n = e1.typeAnnotation;
                this.print(n.typeAnnotation, e1);
            }
            function TSTypeReference(e1) {
                this.print(e1.typeName, e1, true);
                this.print(e1.typeParameters, e1, true);
            }
            function TSTypePredicate(e1) {
                if (e1.asserts) {
                    this.word("asserts");
                    this.space();
                }
                this.print(e1.parameterName);
                if (e1.typeAnnotation) {
                    this.space();
                    this.word("is");
                    this.space();
                    this.print(e1.typeAnnotation.typeAnnotation);
                }
            }
            function TSTypeQuery(e1) {
                this.word("typeof");
                this.space();
                this.print(e1.exprName);
                if (e1.typeParameters) {
                    this.print(e1.typeParameters, e1);
                }
            }
            function TSTypeLiteral(e1) {
                this.tsPrintTypeLiteralOrInterfaceBody(e1.members, e1);
            }
            function tsPrintTypeLiteralOrInterfaceBody(e1, t) {
                tsPrintBraced(this, e1, t);
            }
            function tsPrintBraced(e1, t, r) {
                e1.token("{");
                if (t.length) {
                    e1.indent();
                    e1.newline();
                    for (const n of t){
                        e1.print(n, r);
                        e1.newline();
                    }
                    e1.dedent();
                }
                e1.rightBrace(r);
            }
            function TSArrayType(e1) {
                this.print(e1.elementType, e1, true);
                this.token("[]");
            }
            function TSTupleType(e1) {
                this.tokenChar(91);
                this.printList(e1.elementTypes, e1);
                this.tokenChar(93);
            }
            function TSOptionalType(e1) {
                this.print(e1.typeAnnotation, e1);
                this.tokenChar(63);
            }
            function TSRestType(e1) {
                this.token("...");
                this.print(e1.typeAnnotation, e1);
            }
            function TSNamedTupleMember(e1) {
                this.print(e1.label, e1);
                if (e1.optional) this.tokenChar(63);
                this.tokenChar(58);
                this.space();
                this.print(e1.elementType, e1);
            }
            function TSUnionType(e1) {
                tsPrintUnionOrIntersectionType(this, e1, "|");
            }
            function TSIntersectionType(e1) {
                tsPrintUnionOrIntersectionType(this, e1, "&");
            }
            function tsPrintUnionOrIntersectionType(e1, t, r) {
                e1.printJoin(t.types, t, {
                    separator () {
                        this.space();
                        this.token(r);
                        this.space();
                    }
                });
            }
            function TSConditionalType(e1) {
                this.print(e1.checkType);
                this.space();
                this.word("extends");
                this.space();
                this.print(e1.extendsType);
                this.space();
                this.tokenChar(63);
                this.space();
                this.print(e1.trueType);
                this.space();
                this.tokenChar(58);
                this.space();
                this.print(e1.falseType);
            }
            function TSInferType(e1) {
                this.token("infer");
                this.space();
                this.print(e1.typeParameter);
            }
            function TSParenthesizedType(e1) {
                this.tokenChar(40);
                this.print(e1.typeAnnotation, e1);
                this.tokenChar(41);
            }
            function TSTypeOperator(e1) {
                this.word(e1.operator);
                this.space();
                this.print(e1.typeAnnotation, e1);
            }
            function TSIndexedAccessType(e1) {
                this.print(e1.objectType, e1, true);
                this.tokenChar(91);
                this.print(e1.indexType, e1);
                this.tokenChar(93);
            }
            function TSMappedType(e1) {
                const { nameType: t, optional: r, readonly: n, typeParameter: s } = e1;
                this.tokenChar(123);
                this.space();
                if (n) {
                    tokenIfPlusMinus(this, n);
                    this.word("readonly");
                    this.space();
                }
                this.tokenChar(91);
                this.word(s.name);
                this.space();
                this.word("in");
                this.space();
                this.print(s.constraint, s);
                if (t) {
                    this.space();
                    this.word("as");
                    this.space();
                    this.print(t, e1);
                }
                this.tokenChar(93);
                if (r) {
                    tokenIfPlusMinus(this, r);
                    this.tokenChar(63);
                }
                this.tokenChar(58);
                this.space();
                this.print(e1.typeAnnotation, e1);
                this.space();
                this.tokenChar(125);
            }
            function tokenIfPlusMinus(e1, t) {
                if (t !== true) {
                    e1.token(t);
                }
            }
            function TSLiteralType(e1) {
                this.print(e1.literal, e1);
            }
            function TSExpressionWithTypeArguments(e1) {
                this.print(e1.expression, e1);
                this.print(e1.typeParameters, e1);
            }
            function TSInterfaceDeclaration(e1) {
                const { declare: t, id: r, typeParameters: n, extends: s, body: i } = e1;
                if (t) {
                    this.word("declare");
                    this.space();
                }
                this.word("interface");
                this.space();
                this.print(r, e1);
                this.print(n, e1);
                if (s != null && s.length) {
                    this.space();
                    this.word("extends");
                    this.space();
                    this.printList(s, e1);
                }
                this.space();
                this.print(i, e1);
            }
            function TSInterfaceBody(e1) {
                this.tsPrintTypeLiteralOrInterfaceBody(e1.body, e1);
            }
            function TSTypeAliasDeclaration(e1) {
                const { declare: t, id: r, typeParameters: n, typeAnnotation: s } = e1;
                if (t) {
                    this.word("declare");
                    this.space();
                }
                this.word("type");
                this.space();
                this.print(r, e1);
                this.print(n, e1);
                this.space();
                this.tokenChar(61);
                this.space();
                this.print(s, e1);
                this.tokenChar(59);
            }
            function TSTypeExpression(e1) {
                var t;
                const { type: r, expression: n, typeAnnotation: s } = e1;
                const i = !!((t = n.trailingComments) != null && t.length);
                this.print(n, e1, true, undefined, i);
                this.space();
                this.word(r === "TSAsExpression" ? "as" : "satisfies");
                this.space();
                this.print(s, e1);
            }
            function TSTypeAssertion(e1) {
                const { typeAnnotation: t, expression: r } = e1;
                this.tokenChar(60);
                this.print(t, e1);
                this.tokenChar(62);
                this.space();
                this.print(r, e1);
            }
            function TSInstantiationExpression(e1) {
                this.print(e1.expression, e1);
                this.print(e1.typeParameters, e1);
            }
            function TSEnumDeclaration(e1) {
                const { declare: t, const: r, id: n, members: s } = e1;
                if (t) {
                    this.word("declare");
                    this.space();
                }
                if (r) {
                    this.word("const");
                    this.space();
                }
                this.word("enum");
                this.space();
                this.print(n, e1);
                this.space();
                tsPrintBraced(this, s, e1);
            }
            function TSEnumMember(e1) {
                const { id: t, initializer: r } = e1;
                this.print(t, e1);
                if (r) {
                    this.space();
                    this.tokenChar(61);
                    this.space();
                    this.print(r, e1);
                }
                this.tokenChar(44);
            }
            function TSModuleDeclaration(e1) {
                const { declare: t, id: r } = e1;
                if (t) {
                    this.word("declare");
                    this.space();
                }
                if (!e1.global) {
                    this.word(r.type === "Identifier" ? "namespace" : "module");
                    this.space();
                }
                this.print(r, e1);
                if (!e1.body) {
                    this.tokenChar(59);
                    return;
                }
                let n = e1.body;
                while(n.type === "TSModuleDeclaration"){
                    this.tokenChar(46);
                    this.print(n.id, n);
                    n = n.body;
                }
                this.space();
                this.print(n, e1);
            }
            function TSModuleBlock(e1) {
                tsPrintBraced(this, e1.body, e1);
            }
            function TSImportType(e1) {
                const { argument: t, qualifier: r, typeParameters: n } = e1;
                this.word("import");
                this.tokenChar(40);
                this.print(t, e1);
                this.tokenChar(41);
                if (r) {
                    this.tokenChar(46);
                    this.print(r, e1);
                }
                if (n) {
                    this.print(n, e1);
                }
            }
            function TSImportEqualsDeclaration(e1) {
                const { isExport: t, id: r, moduleReference: n } = e1;
                if (t) {
                    this.word("export");
                    this.space();
                }
                this.word("import");
                this.space();
                this.print(r, e1);
                this.space();
                this.tokenChar(61);
                this.space();
                this.print(n, e1);
                this.tokenChar(59);
            }
            function TSExternalModuleReference(e1) {
                this.token("require(");
                this.print(e1.expression, e1);
                this.tokenChar(41);
            }
            function TSNonNullExpression(e1) {
                this.print(e1.expression, e1);
                this.tokenChar(33);
            }
            function TSExportAssignment(e1) {
                this.word("export");
                this.space();
                this.tokenChar(61);
                this.space();
                this.print(e1.expression, e1);
                this.tokenChar(59);
            }
            function TSNamespaceExportDeclaration(e1) {
                this.word("export");
                this.space();
                this.word("as");
                this.space();
                this.word("namespace");
                this.space();
                this.print(e1.id, e1);
            }
            function tsPrintSignatureDeclarationBase(e1) {
                const { typeParameters: t } = e1;
                const r = e1.parameters;
                this.print(t, e1);
                this.tokenChar(40);
                this._parameters(r, e1);
                this.tokenChar(41);
                const n = e1.typeAnnotation;
                this.print(n, e1);
            }
            function tsPrintClassMemberModifiers(e1) {
                const t = e1.type === "ClassAccessorProperty" || e1.type === "ClassProperty";
                if (t && e1.declare) {
                    this.word("declare");
                    this.space();
                }
                if (e1.accessibility) {
                    this.word(e1.accessibility);
                    this.space();
                }
                if (e1.static) {
                    this.word("static");
                    this.space();
                }
                if (e1.override) {
                    this.word("override");
                    this.space();
                }
                if (e1.abstract) {
                    this.word("abstract");
                    this.space();
                }
                if (t && e1.readonly) {
                    this.word("readonly");
                    this.space();
                }
            }
        },
        3956: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.CodeGenerator = void 0;
            t["default"] = generate;
            var n = r(4095);
            var s = r(7676);
            class Generator extends s.default {
                constructor(e1, t = {}, r){
                    const s = normalizeOptions(r, t);
                    const i = t.sourceMaps ? new n.default(t, r) : null;
                    super(s, i);
                    this.ast = void 0;
                    this.ast = e1;
                }
                generate() {
                    return super.generate(this.ast);
                }
            }
            function normalizeOptions(e1, t) {
                const r = {
                    auxiliaryCommentBefore: t.auxiliaryCommentBefore,
                    auxiliaryCommentAfter: t.auxiliaryCommentAfter,
                    shouldPrintComment: t.shouldPrintComment,
                    retainLines: t.retainLines,
                    retainFunctionParens: t.retainFunctionParens,
                    comments: t.comments == null || t.comments,
                    compact: t.compact,
                    minified: t.minified,
                    concise: t.concise,
                    indent: {
                        adjustMultilineComment: true,
                        style: "  "
                    },
                    jsescOption: Object.assign({
                        quotes: "double",
                        wrap: true,
                        minimal: false
                    }, t.jsescOption),
                    recordAndTupleSyntaxType: t.recordAndTupleSyntaxType,
                    topicToken: t.topicToken,
                    importAttributesKeyword: t.importAttributesKeyword
                };
                {
                    r.decoratorsBeforeExport = t.decoratorsBeforeExport;
                    r.jsescOption.json = t.jsonCompatibleStrings;
                }
                if (r.minified) {
                    r.compact = true;
                    r.shouldPrintComment = r.shouldPrintComment || (()=>r.comments);
                } else {
                    r.shouldPrintComment = r.shouldPrintComment || ((e1)=>r.comments || e1.includes("@license") || e1.includes("@preserve"));
                }
                if (r.compact === "auto") {
                    r.compact = typeof e1 === "string" && e1.length > 5e5;
                    if (r.compact) {
                        console.error("[BABEL] Note: The code generator has deoptimised the styling of " + `${t.filename} as it exceeds the max of ${"500KB"}.`);
                    }
                }
                if (r.compact) {
                    r.indent.adjustMultilineComment = false;
                }
                const { auxiliaryCommentBefore: n, auxiliaryCommentAfter: s, shouldPrintComment: i } = r;
                if (n && !i(n)) {
                    r.auxiliaryCommentBefore = undefined;
                }
                if (s && !i(s)) {
                    r.auxiliaryCommentAfter = undefined;
                }
                return r;
            }
            class CodeGenerator {
                constructor(e1, t, r){
                    this._generator = void 0;
                    this._generator = new Generator(e1, t, r);
                }
                generate() {
                    return this._generator.generate();
                }
            }
            t.CodeGenerator = CodeGenerator;
            function generate(e1, t, r) {
                const n = new Generator(e1, t, r);
                return n.generate();
            }
        },
        9939: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.needsParens = needsParens;
            t.needsWhitespace = needsWhitespace;
            t.needsWhitespaceAfter = needsWhitespaceAfter;
            t.needsWhitespaceBefore = needsWhitespaceBefore;
            var n = r(2575);
            var s = r(8526);
            var i = r(776);
            const { FLIPPED_ALIAS_KEYS: a, isCallExpression: o, isExpressionStatement: l, isMemberExpression: c, isNewExpression: u } = i;
            function expandAliases(e1) {
                const t = {};
                function add(e1, r) {
                    const n = t[e1];
                    t[e1] = n ? function(e1, t, s) {
                        const i = n(e1, t, s);
                        return i == null ? r(e1, t, s) : i;
                    } : r;
                }
                for (const t of Object.keys(e1)){
                    const r = a[t];
                    if (r) {
                        for (const n of r){
                            add(n, e1[t]);
                        }
                    } else {
                        add(t, e1[t]);
                    }
                }
                return t;
            }
            const p = expandAliases(s);
            const f = expandAliases(n.nodes);
            function find(e1, t, r, n) {
                const s = e1[t.type];
                return s ? s(t, r, n) : null;
            }
            function isOrHasCallExpression(e1) {
                if (o(e1)) {
                    return true;
                }
                return c(e1) && isOrHasCallExpression(e1.object);
            }
            function needsWhitespace(e1, t, r) {
                if (!e1) return false;
                if (l(e1)) {
                    e1 = e1.expression;
                }
                const n = find(f, e1, t);
                if (typeof n === "number") {
                    return (n & r) !== 0;
                }
                return false;
            }
            function needsWhitespaceBefore(e1, t) {
                return needsWhitespace(e1, t, 1);
            }
            function needsWhitespaceAfter(e1, t) {
                return needsWhitespace(e1, t, 2);
            }
            function needsParens(e1, t, r) {
                if (!t) return false;
                if (u(t) && t.callee === e1) {
                    if (isOrHasCallExpression(e1)) return true;
                }
                return find(p, e1, t, r);
            }
        },
        8526: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ArrowFunctionExpression = ArrowFunctionExpression;
            t.AssignmentExpression = AssignmentExpression;
            t.Binary = Binary;
            t.BinaryExpression = BinaryExpression;
            t.ClassExpression = ClassExpression;
            t.ConditionalExpression = ConditionalExpression;
            t.DoExpression = DoExpression;
            t.FunctionExpression = FunctionExpression;
            t.FunctionTypeAnnotation = FunctionTypeAnnotation;
            t.Identifier = Identifier;
            t.LogicalExpression = LogicalExpression;
            t.NullableTypeAnnotation = NullableTypeAnnotation;
            t.ObjectExpression = ObjectExpression;
            t.OptionalIndexedAccessType = OptionalIndexedAccessType;
            t.OptionalCallExpression = t.OptionalMemberExpression = OptionalMemberExpression;
            t.SequenceExpression = SequenceExpression;
            t.TSTypeAssertion = t.TSSatisfiesExpression = t.TSAsExpression = TSAsExpression;
            t.TSInferType = TSInferType;
            t.TSInstantiationExpression = TSInstantiationExpression;
            t.TSIntersectionType = t.TSUnionType = TSUnionType;
            t.UnaryLike = UnaryLike;
            t.IntersectionTypeAnnotation = t.UnionTypeAnnotation = UnionTypeAnnotation;
            t.UpdateExpression = UpdateExpression;
            t.AwaitExpression = t.YieldExpression = YieldExpression;
            var n = r(776);
            const { isArrayTypeAnnotation: s, isArrowFunctionExpression: i, isAssignmentExpression: a, isAwaitExpression: o, isBinary: l, isBinaryExpression: c, isUpdateExpression: u, isCallExpression: p, isClass: f, isClassExpression: d, isConditional: h, isConditionalExpression: m, isExportDeclaration: y, isExportDefaultDeclaration: g, isExpressionStatement: b, isFor: T, isForInStatement: S, isForOfStatement: E, isForStatement: v, isFunctionExpression: x, isIfStatement: P, isIndexedAccessType: w, isIntersectionTypeAnnotation: A, isLogicalExpression: C, isMemberExpression: I, isNewExpression: O, isNullableTypeAnnotation: k, isObjectPattern: N, isOptionalCallExpression: _, isOptionalMemberExpression: D, isReturnStatement: M, isSequenceExpression: L, isSwitchStatement: j, isTSArrayType: F, isTSAsExpression: R, isTSInstantiationExpression: B, isTSIntersectionType: U, isTSNonNullExpression: K, isTSOptionalType: V, isTSRestType: W, isTSTypeAssertion: $, isTSUnionType: q, isTaggedTemplateExpression: H, isThrowStatement: G, isTypeAnnotation: J, isUnaryLike: X, isUnionTypeAnnotation: z, isVariableDeclarator: Y, isWhileStatement: Q, isYieldExpression: Z, isTSSatisfiesExpression: ee } = n;
            const te = {
                "||": 0,
                "??": 0,
                "|>": 0,
                "&&": 1,
                "|": 2,
                "^": 3,
                "&": 4,
                "==": 5,
                "===": 5,
                "!=": 5,
                "!==": 5,
                "<": 6,
                ">": 6,
                "<=": 6,
                ">=": 6,
                in: 6,
                instanceof: 6,
                ">>": 7,
                "<<": 7,
                ">>>": 7,
                "+": 8,
                "-": 8,
                "*": 9,
                "/": 9,
                "%": 9,
                "**": 10
            };
            function isTSTypeExpression(e1) {
                return R(e1) || ee(e1) || $(e1);
            }
            const isClassExtendsClause = (e1, t)=>f(t, {
                    superClass: e1
                });
            const hasPostfixPart = (e1, t)=>(I(t) || D(t)) && t.object === e1 || (p(t) || _(t) || O(t)) && t.callee === e1 || H(t) && t.tag === e1 || K(t);
            function NullableTypeAnnotation(e1, t) {
                return s(t);
            }
            function FunctionTypeAnnotation(e1, t, r) {
                if (r.length < 3) return;
                return z(t) || A(t) || s(t) || J(t) && i(r[r.length - 3]);
            }
            function UpdateExpression(e1, t) {
                return hasPostfixPart(e1, t) || isClassExtendsClause(e1, t);
            }
            function ObjectExpression(e1, t, r) {
                return isFirstInContext(r, 1 | 2);
            }
            function DoExpression(e1, t, r) {
                return !e1.async && isFirstInContext(r, 1);
            }
            function Binary(e1, t) {
                if (e1.operator === "**" && c(t, {
                    operator: "**"
                })) {
                    return t.left === e1;
                }
                if (isClassExtendsClause(e1, t)) {
                    return true;
                }
                if (hasPostfixPart(e1, t) || X(t) || o(t)) {
                    return true;
                }
                if (l(t)) {
                    const r = t.operator;
                    const n = te[r];
                    const s = e1.operator;
                    const i = te[s];
                    if (n === i && t.right === e1 && !C(t) || n > i) {
                        return true;
                    }
                }
            }
            function UnionTypeAnnotation(e1, t) {
                return s(t) || k(t) || A(t) || z(t);
            }
            function OptionalIndexedAccessType(e1, t) {
                return w(t, {
                    objectType: e1
                });
            }
            function TSAsExpression() {
                return true;
            }
            function TSUnionType(e1, t) {
                return F(t) || V(t) || U(t) || q(t) || W(t);
            }
            function TSInferType(e1, t) {
                return F(t) || V(t);
            }
            function TSInstantiationExpression(e1, t) {
                return (p(t) || _(t) || O(t) || B(t)) && !!t.typeParameters;
            }
            function BinaryExpression(e1, t) {
                return e1.operator === "in" && (Y(t) || T(t));
            }
            function SequenceExpression(e1, t) {
                if (v(t) || G(t) || M(t) || P(t) && t.test === e1 || Q(t) && t.test === e1 || S(t) && t.right === e1 || j(t) && t.discriminant === e1 || b(t) && t.expression === e1) {
                    return false;
                }
                return true;
            }
            function YieldExpression(e1, t) {
                return l(t) || X(t) || hasPostfixPart(e1, t) || o(t) && Z(e1) || m(t) && e1 === t.test || isClassExtendsClause(e1, t);
            }
            function ClassExpression(e1, t, r) {
                return isFirstInContext(r, 1 | 4);
            }
            function UnaryLike(e1, t) {
                return hasPostfixPart(e1, t) || c(t, {
                    operator: "**",
                    left: e1
                }) || isClassExtendsClause(e1, t);
            }
            function FunctionExpression(e1, t, r) {
                return isFirstInContext(r, 1 | 4);
            }
            function ArrowFunctionExpression(e1, t) {
                return y(t) || ConditionalExpression(e1, t);
            }
            function ConditionalExpression(e1, t) {
                if (X(t) || l(t) || m(t, {
                    test: e1
                }) || o(t) || isTSTypeExpression(t)) {
                    return true;
                }
                return UnaryLike(e1, t);
            }
            function OptionalMemberExpression(e1, t) {
                return p(t, {
                    callee: e1
                }) || I(t, {
                    object: e1
                });
            }
            function AssignmentExpression(e1, t) {
                if (N(e1.left)) {
                    return true;
                } else {
                    return ConditionalExpression(e1, t);
                }
            }
            function LogicalExpression(e1, t) {
                if (isTSTypeExpression(t)) return true;
                switch(e1.operator){
                    case "||":
                        if (!C(t)) return false;
                        return t.operator === "??" || t.operator === "&&";
                    case "&&":
                        return C(t, {
                            operator: "??"
                        });
                    case "??":
                        return C(t) && t.operator !== "??";
                }
            }
            function Identifier(e1, t, r) {
                var n;
                if ((n = e1.extra) != null && n.parenthesized && a(t, {
                    left: e1
                }) && (x(t.right) || d(t.right)) && t.right.id == null) {
                    return true;
                }
                if (e1.name === "let") {
                    const n = I(t, {
                        object: e1,
                        computed: true
                    }) || D(t, {
                        object: e1,
                        computed: true,
                        optional: false
                    });
                    return isFirstInContext(r, n ? 1 | 8 | 16 | 32 : 32);
                }
                return e1.name === "async" && E(t) && e1 === t.left;
            }
            function isFirstInContext(e1, t) {
                const r = t & 1;
                const n = t & 2;
                const s = t & 4;
                const o = t & 8;
                const c = t & 16;
                const p = t & 32;
                let f = e1.length - 1;
                if (f <= 0) return;
                let d = e1[f];
                f--;
                let m = e1[f];
                while(f >= 0){
                    if (r && b(m, {
                        expression: d
                    }) || s && g(m, {
                        declaration: d
                    }) || n && i(m, {
                        body: d
                    }) || o && v(m, {
                        init: d
                    }) || c && S(m, {
                        left: d
                    }) || p && E(m, {
                        left: d
                    })) {
                        return true;
                    }
                    if (f > 0 && (hasPostfixPart(d, m) && !O(m) || L(m) && m.expressions[0] === d || u(m) && !m.prefix || h(m, {
                        test: d
                    }) || l(m, {
                        left: d
                    }) || a(m, {
                        left: d
                    }))) {
                        d = m;
                        f--;
                        m = e1[f];
                    } else {
                        return false;
                    }
                }
                return false;
            }
        },
        2575: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.nodes = void 0;
            var n = r(776);
            const { FLIPPED_ALIAS_KEYS: s, isArrayExpression: i, isAssignmentExpression: a, isBinary: o, isBlockStatement: l, isCallExpression: c, isFunction: u, isIdentifier: p, isLiteral: f, isMemberExpression: d, isObjectExpression: h, isOptionalCallExpression: m, isOptionalMemberExpression: y, isStringLiteral: g } = n;
            function crawlInternal(e1, t) {
                if (!e1) return t;
                if (d(e1) || y(e1)) {
                    crawlInternal(e1.object, t);
                    if (e1.computed) crawlInternal(e1.property, t);
                } else if (o(e1) || a(e1)) {
                    crawlInternal(e1.left, t);
                    crawlInternal(e1.right, t);
                } else if (c(e1) || m(e1)) {
                    t.hasCall = true;
                    crawlInternal(e1.callee, t);
                } else if (u(e1)) {
                    t.hasFunction = true;
                } else if (p(e1)) {
                    t.hasHelper = t.hasHelper || e1.callee && isHelper(e1.callee);
                }
                return t;
            }
            function crawl(e1) {
                return crawlInternal(e1, {
                    hasCall: false,
                    hasFunction: false,
                    hasHelper: false
                });
            }
            function isHelper(e1) {
                if (!e1) return false;
                if (d(e1)) {
                    return isHelper(e1.object) || isHelper(e1.property);
                } else if (p(e1)) {
                    return e1.name === "require" || e1.name.charCodeAt(0) === 95;
                } else if (c(e1)) {
                    return isHelper(e1.callee);
                } else if (o(e1) || a(e1)) {
                    return p(e1.left) && isHelper(e1.left) || isHelper(e1.right);
                } else {
                    return false;
                }
            }
            function isType(e1) {
                return f(e1) || h(e1) || i(e1) || p(e1) || d(e1);
            }
            const b = {
                AssignmentExpression (e1) {
                    const t = crawl(e1.right);
                    if (t.hasCall && t.hasHelper || t.hasFunction) {
                        return t.hasFunction ? 1 | 2 : 2;
                    }
                },
                SwitchCase (e1, t) {
                    return (!!e1.consequent.length || t.cases[0] === e1 ? 1 : 0) | (!e1.consequent.length && t.cases[t.cases.length - 1] === e1 ? 2 : 0);
                },
                LogicalExpression (e1) {
                    if (u(e1.left) || u(e1.right)) {
                        return 2;
                    }
                },
                Literal (e1) {
                    if (g(e1) && e1.value === "use strict") {
                        return 2;
                    }
                },
                CallExpression (e1) {
                    if (u(e1.callee) || isHelper(e1)) {
                        return 1 | 2;
                    }
                },
                OptionalCallExpression (e1) {
                    if (u(e1.callee)) {
                        return 1 | 2;
                    }
                },
                VariableDeclaration (e1) {
                    for(let t = 0; t < e1.declarations.length; t++){
                        const r = e1.declarations[t];
                        let n = isHelper(r.id) && !isType(r.init);
                        if (!n && r.init) {
                            const e1 = crawl(r.init);
                            n = isHelper(r.init) && e1.hasCall || e1.hasFunction;
                        }
                        if (n) {
                            return 1 | 2;
                        }
                    }
                },
                IfStatement (e1) {
                    if (l(e1.consequent)) {
                        return 1 | 2;
                    }
                }
            };
            t.nodes = b;
            b.ObjectProperty = b.ObjectTypeProperty = b.ObjectMethod = function(e1, t) {
                if (t.properties[0] === e1) {
                    return 1;
                }
            };
            b.ObjectTypeCallProperty = function(e1, t) {
                var r;
                if (t.callProperties[0] === e1 && !((r = t.properties) != null && r.length)) {
                    return 1;
                }
            };
            b.ObjectTypeIndexer = function(e1, t) {
                var r, n;
                if (t.indexers[0] === e1 && !((r = t.properties) != null && r.length) && !((n = t.callProperties) != null && n.length)) {
                    return 1;
                }
            };
            b.ObjectTypeInternalSlot = function(e1, t) {
                var r, n, s;
                if (t.internalSlots[0] === e1 && !((r = t.properties) != null && r.length) && !((n = t.callProperties) != null && n.length) && !((s = t.indexers) != null && s.length)) {
                    return 1;
                }
            };
            [
                [
                    "Function",
                    true
                ],
                [
                    "Class",
                    true
                ],
                [
                    "Loop",
                    true
                ],
                [
                    "LabeledStatement",
                    true
                ],
                [
                    "SwitchStatement",
                    true
                ],
                [
                    "TryStatement",
                    true
                ]
            ].forEach(function([e1, t]) {
                [
                    e1
                ].concat(s[e1] || []).forEach(function(e1) {
                    const r = t ? 1 | 2 : 0;
                    b[e1] = ()=>r;
                });
            });
        },
        7676: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(9531);
            var s = r(9939);
            var i = r(776);
            var a = r(6376);
            const { isFunction: o, isStatement: l, isClassBody: c, isTSInterfaceBody: u, isTSEnumDeclaration: p } = i;
            const f = /e/i;
            const d = /\.0+$/;
            const h = /^0[box]/;
            const m = /^\s*[@#]__PURE__\s*$/;
            const y = /[\n\r\u2028\u2029]/;
            const g = /\*\//;
            const { needsParens: b } = s;
            class Printer {
                constructor(e1, t){
                    this.inForStatementInitCounter = 0;
                    this._printStack = [];
                    this._indent = 0;
                    this._indentChar = 0;
                    this._indentRepeat = 0;
                    this._insideAux = false;
                    this._parenPushNewlineState = null;
                    this._noLineTerminator = false;
                    this._printAuxAfterOnNextUserNode = false;
                    this._printedComments = new Set;
                    this._endsWithInteger = false;
                    this._endsWithWord = false;
                    this._lastCommentLine = 0;
                    this._endsWithInnerRaw = false;
                    this._indentInnerComments = true;
                    this.format = e1;
                    this._buf = new n.default(t);
                    this._indentChar = e1.indent.style.charCodeAt(0);
                    this._indentRepeat = e1.indent.style.length;
                    this._inputMap = t == null ? void 0 : t._inputMap;
                }
                generate(e1) {
                    this.print(e1);
                    this._maybeAddAuxComment();
                    return this._buf.get();
                }
                indent() {
                    if (this.format.compact || this.format.concise) return;
                    this._indent++;
                }
                dedent() {
                    if (this.format.compact || this.format.concise) return;
                    this._indent--;
                }
                semicolon(e1 = false) {
                    this._maybeAddAuxComment();
                    if (e1) {
                        this._appendChar(59);
                    } else {
                        this._queue(59);
                    }
                    this._noLineTerminator = false;
                }
                rightBrace(e1) {
                    if (this.format.minified) {
                        this._buf.removeLastSemicolon();
                    }
                    this.sourceWithOffset("end", e1.loc, 0, -1);
                    this.tokenChar(125);
                }
                rightParens(e1) {
                    this.sourceWithOffset("end", e1.loc, 0, -1);
                    this.tokenChar(41);
                }
                space(e1 = false) {
                    if (this.format.compact) return;
                    if (e1) {
                        this._space();
                    } else if (this._buf.hasContent()) {
                        const e1 = this.getLastChar();
                        if (e1 !== 32 && e1 !== 10) {
                            this._space();
                        }
                    }
                }
                word(e1, t = false) {
                    this._maybePrintInnerComments();
                    if (this._endsWithWord || e1.charCodeAt(0) === 47 && this.endsWith(47)) {
                        this._space();
                    }
                    this._maybeAddAuxComment();
                    this._append(e1, false);
                    this._endsWithWord = true;
                    this._noLineTerminator = t;
                }
                number(e1) {
                    this.word(e1);
                    this._endsWithInteger = Number.isInteger(+e1) && !h.test(e1) && !f.test(e1) && !d.test(e1) && e1.charCodeAt(e1.length - 1) !== 46;
                }
                token(e1, t = false) {
                    this._maybePrintInnerComments();
                    const r = this.getLastChar();
                    const n = e1.charCodeAt(0);
                    if (r === 33 && (e1 === "--" || n === 61) || n === 43 && r === 43 || n === 45 && r === 45 || n === 46 && this._endsWithInteger) {
                        this._space();
                    }
                    this._maybeAddAuxComment();
                    this._append(e1, t);
                    this._noLineTerminator = false;
                }
                tokenChar(e1) {
                    this._maybePrintInnerComments();
                    const t = this.getLastChar();
                    if (e1 === 43 && t === 43 || e1 === 45 && t === 45 || e1 === 46 && this._endsWithInteger) {
                        this._space();
                    }
                    this._maybeAddAuxComment();
                    this._appendChar(e1);
                    this._noLineTerminator = false;
                }
                newline(e1 = 1, t) {
                    if (e1 <= 0) return;
                    if (!t) {
                        if (this.format.retainLines || this.format.compact) return;
                        if (this.format.concise) {
                            this.space();
                            return;
                        }
                    }
                    if (e1 > 2) e1 = 2;
                    e1 -= this._buf.getNewlineCount();
                    for(let t = 0; t < e1; t++){
                        this._newline();
                    }
                    return;
                }
                endsWith(e1) {
                    return this.getLastChar() === e1;
                }
                getLastChar() {
                    return this._buf.getLastChar();
                }
                endsWithCharAndNewline() {
                    return this._buf.endsWithCharAndNewline();
                }
                removeTrailingNewline() {
                    this._buf.removeTrailingNewline();
                }
                exactSource(e1, t) {
                    if (!e1) {
                        t();
                        return;
                    }
                    this._catchUp("start", e1);
                    this._buf.exactSource(e1, t);
                }
                source(e1, t) {
                    if (!t) return;
                    this._catchUp(e1, t);
                    this._buf.source(e1, t);
                }
                sourceWithOffset(e1, t, r, n) {
                    if (!t) return;
                    this._catchUp(e1, t);
                    this._buf.sourceWithOffset(e1, t, r, n);
                }
                withSource(e1, t, r) {
                    if (!t) {
                        r();
                        return;
                    }
                    this._catchUp(e1, t);
                    this._buf.withSource(e1, t, r);
                }
                sourceIdentifierName(e1, t) {
                    if (!this._buf._canMarkIdName) return;
                    const r = this._buf._sourcePosition;
                    r.identifierNamePos = t;
                    r.identifierName = e1;
                }
                _space() {
                    this._queue(32);
                }
                _newline() {
                    this._queue(10);
                }
                _append(e1, t) {
                    this._maybeAddParen(e1);
                    this._maybeIndent(e1.charCodeAt(0));
                    this._buf.append(e1, t);
                    this._endsWithWord = false;
                    this._endsWithInteger = false;
                }
                _appendChar(e1) {
                    this._maybeAddParenChar(e1);
                    this._maybeIndent(e1);
                    this._buf.appendChar(e1);
                    this._endsWithWord = false;
                    this._endsWithInteger = false;
                }
                _queue(e1) {
                    this._maybeAddParenChar(e1);
                    this._maybeIndent(e1);
                    this._buf.queue(e1);
                    this._endsWithWord = false;
                    this._endsWithInteger = false;
                }
                _maybeIndent(e1) {
                    if (this._indent && e1 !== 10 && this.endsWith(10)) {
                        this._buf.queueIndentation(this._indentChar, this._getIndent());
                    }
                }
                _shouldIndent(e1) {
                    if (this._indent && e1 !== 10 && this.endsWith(10)) {
                        return true;
                    }
                }
                _maybeAddParenChar(e1) {
                    const t = this._parenPushNewlineState;
                    if (!t) return;
                    if (e1 === 32) {
                        return;
                    }
                    if (e1 !== 10) {
                        this._parenPushNewlineState = null;
                        return;
                    }
                    this.tokenChar(40);
                    this.indent();
                    t.printed = true;
                }
                _maybeAddParen(e1) {
                    const t = this._parenPushNewlineState;
                    if (!t) return;
                    const r = e1.length;
                    let n;
                    for(n = 0; n < r && e1.charCodeAt(n) === 32; n++)continue;
                    if (n === r) {
                        return;
                    }
                    const s = e1.charCodeAt(n);
                    if (s !== 10) {
                        if (s !== 47 || n + 1 === r) {
                            this._parenPushNewlineState = null;
                            return;
                        }
                        const t = e1.charCodeAt(n + 1);
                        if (t === 42) {
                            if (m.test(e1.slice(n + 2, r - 2))) {
                                return;
                            }
                        } else if (t !== 47) {
                            this._parenPushNewlineState = null;
                            return;
                        }
                    }
                    this.tokenChar(40);
                    this.indent();
                    t.printed = true;
                }
                catchUp(e1) {
                    if (!this.format.retainLines) return;
                    const t = e1 - this._buf.getCurrentLine();
                    for(let e1 = 0; e1 < t; e1++){
                        this._newline();
                    }
                }
                _catchUp(e1, t) {
                    var r;
                    if (!this.format.retainLines) return;
                    const n = t == null ? void 0 : (r = t[e1]) == null ? void 0 : r.line;
                    if (n != null) {
                        const e1 = n - this._buf.getCurrentLine();
                        for(let t = 0; t < e1; t++){
                            this._newline();
                        }
                    }
                }
                _getIndent() {
                    return this._indentRepeat * this._indent;
                }
                printTerminatorless(e1, t, r) {
                    if (r) {
                        this._noLineTerminator = true;
                        this.print(e1, t);
                    } else {
                        const r = {
                            printed: false
                        };
                        this._parenPushNewlineState = r;
                        this.print(e1, t);
                        if (r.printed) {
                            this.dedent();
                            this.newline();
                            this.tokenChar(41);
                        }
                    }
                }
                print(e1, t, r, n, s) {
                    var i;
                    if (!e1) return;
                    this._endsWithInnerRaw = false;
                    const a = e1.type;
                    const o = this.format;
                    const l = o.concise;
                    if (e1._compact) {
                        o.concise = true;
                    }
                    const c = this[a];
                    if (c === undefined) {
                        throw new ReferenceError(`unknown node of type ${JSON.stringify(a)} with constructor ${JSON.stringify(e1.constructor.name)}`);
                    }
                    this._printStack.push(e1);
                    const u = this._insideAux;
                    this._insideAux = e1.loc == undefined;
                    this._maybeAddAuxComment(this._insideAux && !u);
                    const p = s || o.retainFunctionParens && a === "FunctionExpression" && ((i = e1.extra) == null ? void 0 : i.parenthesized) || b(e1, t, this._printStack);
                    if (p) {
                        this.tokenChar(40);
                        this._endsWithInnerRaw = false;
                    }
                    this._lastCommentLine = 0;
                    this._printLeadingComments(e1, t);
                    const f = a === "Program" || a === "File" ? null : e1.loc;
                    this.exactSource(f, c.bind(this, e1, t));
                    if (p) {
                        this._printTrailingComments(e1, t);
                        this.tokenChar(41);
                        this._noLineTerminator = r;
                    } else if (r && !this._noLineTerminator) {
                        this._noLineTerminator = true;
                        this._printTrailingComments(e1, t);
                    } else {
                        this._printTrailingComments(e1, t, n);
                    }
                    this._printStack.pop();
                    o.concise = l;
                    this._insideAux = u;
                    this._endsWithInnerRaw = false;
                }
                _maybeAddAuxComment(e1) {
                    if (e1) this._printAuxBeforeComment();
                    if (!this._insideAux) this._printAuxAfterComment();
                }
                _printAuxBeforeComment() {
                    if (this._printAuxAfterOnNextUserNode) return;
                    this._printAuxAfterOnNextUserNode = true;
                    const e1 = this.format.auxiliaryCommentBefore;
                    if (e1) {
                        this._printComment({
                            type: "CommentBlock",
                            value: e1
                        }, 0);
                    }
                }
                _printAuxAfterComment() {
                    if (!this._printAuxAfterOnNextUserNode) return;
                    this._printAuxAfterOnNextUserNode = false;
                    const e1 = this.format.auxiliaryCommentAfter;
                    if (e1) {
                        this._printComment({
                            type: "CommentBlock",
                            value: e1
                        }, 0);
                    }
                }
                getPossibleRaw(e1) {
                    const t = e1.extra;
                    if (t && t.raw != null && t.rawValue != null && e1.value === t.rawValue) {
                        return t.raw;
                    }
                }
                printJoin(e1, t, r = {}) {
                    if (!(e1 != null && e1.length)) return;
                    let { indent: n } = r;
                    if (n == null && this.format.retainLines) {
                        var s;
                        const t = (s = e1[0].loc) == null ? void 0 : s.start.line;
                        if (t != null && t !== this._buf.getCurrentLine()) {
                            n = true;
                        }
                    }
                    if (n) this.indent();
                    const i = {
                        addNewlines: r.addNewlines,
                        nextNodeStartLine: 0
                    };
                    const a = r.separator ? r.separator.bind(this) : null;
                    const o = e1.length;
                    for(let n = 0; n < o; n++){
                        const s = e1[n];
                        if (!s) continue;
                        if (r.statement) this._printNewline(n === 0, i);
                        this.print(s, t, undefined, r.trailingCommentsLineOffset || 0);
                        r.iterator == null ? void 0 : r.iterator(s, n);
                        if (n < o - 1) a == null ? void 0 : a();
                        if (r.statement) {
                            if (n + 1 === o) {
                                this.newline(1);
                            } else {
                                var l;
                                const t = e1[n + 1];
                                i.nextNodeStartLine = ((l = t.loc) == null ? void 0 : l.start.line) || 0;
                                this._printNewline(true, i);
                            }
                        }
                    }
                    if (n) this.dedent();
                }
                printAndIndentOnComments(e1, t) {
                    const r = e1.leadingComments && e1.leadingComments.length > 0;
                    if (r) this.indent();
                    this.print(e1, t);
                    if (r) this.dedent();
                }
                printBlock(e1) {
                    const t = e1.body;
                    if (t.type !== "EmptyStatement") {
                        this.space();
                    }
                    this.print(t, e1);
                }
                _printTrailingComments(e1, t, r) {
                    const { innerComments: n, trailingComments: s } = e1;
                    if (n != null && n.length) {
                        this._printComments(2, n, e1, t, r);
                    }
                    if (s != null && s.length) {
                        this._printComments(2, s, e1, t, r);
                    }
                }
                _printLeadingComments(e1, t) {
                    const r = e1.leadingComments;
                    if (!(r != null && r.length)) return;
                    this._printComments(0, r, e1, t);
                }
                _maybePrintInnerComments() {
                    if (this._endsWithInnerRaw) this.printInnerComments();
                    this._endsWithInnerRaw = true;
                    this._indentInnerComments = true;
                }
                printInnerComments() {
                    const e1 = this._printStack[this._printStack.length - 1];
                    const t = e1.innerComments;
                    if (!(t != null && t.length)) return;
                    const r = this.endsWith(32);
                    const n = this._indentInnerComments;
                    const s = this._printedComments.size;
                    if (n) this.indent();
                    this._printComments(1, t, e1);
                    if (r && s !== this._printedComments.size) {
                        this.space();
                    }
                    if (n) this.dedent();
                }
                noIndentInnerCommentsHere() {
                    this._indentInnerComments = false;
                }
                printSequence(e1, t, r = {}) {
                    var n;
                    r.statement = true;
                    (n = r.indent) != null ? n : r.indent = false;
                    this.printJoin(e1, t, r);
                }
                printList(e1, t, r = {}) {
                    if (r.separator == null) {
                        r.separator = commaSeparator;
                    }
                    this.printJoin(e1, t, r);
                }
                _printNewline(e1, t) {
                    const r = this.format;
                    if (r.retainLines || r.compact) return;
                    if (r.concise) {
                        this.space();
                        return;
                    }
                    if (!e1) {
                        return;
                    }
                    const n = t.nextNodeStartLine;
                    const s = this._lastCommentLine;
                    if (n > 0 && s > 0) {
                        const e1 = n - s;
                        if (e1 >= 0) {
                            this.newline(e1 || 1);
                            return;
                        }
                    }
                    if (this._buf.hasContent()) {
                        this.newline(1);
                    }
                }
                _shouldPrintComment(e1) {
                    if (e1.ignore) return 0;
                    if (this._printedComments.has(e1)) return 0;
                    if (this._noLineTerminator && (y.test(e1.value) || g.test(e1.value))) {
                        return 2;
                    }
                    this._printedComments.add(e1);
                    if (!this.format.shouldPrintComment(e1.value)) {
                        return 0;
                    }
                    return 1;
                }
                _printComment(e1, t) {
                    const r = this._noLineTerminator;
                    const n = e1.type === "CommentBlock";
                    const s = n && t !== 1 && !this._noLineTerminator;
                    if (s && this._buf.hasContent() && t !== 2) {
                        this.newline(1);
                    }
                    const i = this.getLastChar();
                    if (i !== 91 && i !== 123) {
                        this.space();
                    }
                    let a;
                    if (n) {
                        a = `/*${e1.value}*/`;
                        if (this.format.indent.adjustMultilineComment) {
                            var o;
                            const t = (o = e1.loc) == null ? void 0 : o.start.column;
                            if (t) {
                                const e1 = new RegExp("\\n\\s{1," + t + "}", "g");
                                a = a.replace(e1, "\n");
                            }
                            let r = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
                            if (this._shouldIndent(47) || this.format.retainLines) {
                                r += this._getIndent();
                            }
                            a = a.replace(/\n(?!$)/g, `\n${" ".repeat(r)}`);
                        }
                    } else if (!r) {
                        a = `//${e1.value}`;
                    } else {
                        a = `/*${e1.value}*/`;
                    }
                    if (this.endsWith(47)) this._space();
                    this.source("start", e1.loc);
                    this._append(a, n);
                    if (!n && !r) {
                        this.newline(1, true);
                    }
                    if (s && t !== 3) {
                        this.newline(1);
                    }
                }
                _printComments(e1, t, r, n, s = 0) {
                    const i = r.loc;
                    const a = t.length;
                    let f = !!i;
                    const d = f ? i.start.line : 0;
                    const h = f ? i.end.line : 0;
                    let m = 0;
                    let g = 0;
                    const b = this._noLineTerminator ? function() {} : this.newline.bind(this);
                    for(let i = 0; i < a; i++){
                        const T = t[i];
                        const S = this._shouldPrintComment(T);
                        if (S === 2) {
                            f = false;
                            break;
                        }
                        if (f && T.loc && S === 1) {
                            const t = T.loc.start.line;
                            const r = T.loc.end.line;
                            if (e1 === 0) {
                                let e1 = 0;
                                if (i === 0) {
                                    if (this._buf.hasContent() && (T.type === "CommentLine" || t != r)) {
                                        e1 = g = 1;
                                    }
                                } else {
                                    e1 = t - m;
                                }
                                m = r;
                                b(e1);
                                this._printComment(T, 1);
                                if (i + 1 === a) {
                                    b(Math.max(d - m, g));
                                    m = d;
                                }
                            } else if (e1 === 1) {
                                const e1 = t - (i === 0 ? d : m);
                                m = r;
                                b(e1);
                                this._printComment(T, 1);
                                if (i + 1 === a) {
                                    b(Math.min(1, h - m));
                                    m = h;
                                }
                            } else {
                                const e1 = t - (i === 0 ? h - s : m);
                                m = r;
                                b(e1);
                                this._printComment(T, 1);
                            }
                        } else {
                            f = false;
                            if (S !== 1) {
                                continue;
                            }
                            if (a === 1) {
                                const t = T.loc ? T.loc.start.line === T.loc.end.line : !y.test(T.value);
                                const s = t && !l(r) && !c(n) && !u(n) && !p(n);
                                if (e1 === 0) {
                                    this._printComment(T, s && r.type !== "ObjectExpression" || t && o(n, {
                                        body: r
                                    }) ? 1 : 0);
                                } else if (s && e1 === 2) {
                                    this._printComment(T, 1);
                                } else {
                                    this._printComment(T, 0);
                                }
                            } else if (e1 === 1 && !(r.type === "ObjectExpression" && r.properties.length > 1) && r.type !== "ClassBody" && r.type !== "TSInterfaceBody") {
                                this._printComment(T, i === 0 ? 2 : i === a - 1 ? 3 : 0);
                            } else {
                                this._printComment(T, 0);
                            }
                        }
                    }
                    if (e1 === 2 && f && m) {
                        this._lastCommentLine = m;
                    }
                }
            }
            Object.assign(Printer.prototype, a);
            {
                Printer.prototype.Noop = function Noop() {};
            }
            var T = Printer;
            t["default"] = T;
            function commaSeparator() {
                this.tokenChar(44);
                this.space();
            }
        },
        4095: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(2987);
            var s = r(4614);
            class SourceMap {
                constructor(e1, t){
                    var r;
                    this._map = void 0;
                    this._rawMappings = void 0;
                    this._sourceFileName = void 0;
                    this._lastGenLine = 0;
                    this._lastSourceLine = 0;
                    this._lastSourceColumn = 0;
                    this._inputMap = void 0;
                    const i = this._map = new n.GenMapping({
                        sourceRoot: e1.sourceRoot
                    });
                    this._sourceFileName = (r = e1.sourceFileName) == null ? void 0 : r.replace(/\\/g, "/");
                    this._rawMappings = undefined;
                    if (e1.inputSourceMap) {
                        this._inputMap = new s.TraceMap(e1.inputSourceMap);
                        const t = this._inputMap.resolvedSources;
                        if (t.length) {
                            for(let e1 = 0; e1 < t.length; e1++){
                                var a;
                                (0, n.setSourceContent)(i, t[e1], (a = this._inputMap.sourcesContent) == null ? void 0 : a[e1]);
                            }
                        }
                    }
                    if (typeof t === "string" && !e1.inputSourceMap) {
                        (0, n.setSourceContent)(i, this._sourceFileName, t);
                    } else if (typeof t === "object") {
                        for (const e1 of Object.keys(t)){
                            (0, n.setSourceContent)(i, e1.replace(/\\/g, "/"), t[e1]);
                        }
                    }
                }
                get() {
                    return (0, n.toEncodedMap)(this._map);
                }
                getDecoded() {
                    return (0, n.toDecodedMap)(this._map);
                }
                getRawMappings() {
                    return this._rawMappings || (this._rawMappings = (0, n.allMappings)(this._map));
                }
                mark(e1, t, r, i, a, o) {
                    var l;
                    this._rawMappings = undefined;
                    let c;
                    if (t != null) {
                        if (this._inputMap) {
                            c = (0, s.originalPositionFor)(this._inputMap, {
                                line: t,
                                column: r
                            });
                            if (!c.name && a) {
                                const e1 = (0, s.originalPositionFor)(this._inputMap, a);
                                if (e1.name) {
                                    i = e1.name;
                                }
                            }
                        } else {
                            c = {
                                source: (o == null ? void 0 : o.replace(/\\/g, "/")) || this._sourceFileName,
                                line: t,
                                column: r
                            };
                        }
                    }
                    (0, n.maybeAddMapping)(this._map, {
                        name: i,
                        generated: e1,
                        source: (l = c) == null ? void 0 : l.source,
                        original: c
                    });
                }
            }
            t["default"] = SourceMap;
        },
        365: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = annotateAsPure;
            var n = r(776);
            const { addComment: s } = n;
            const i = "#__PURE__";
            const isPureAnnotated = ({ leadingComments: e1 })=>!!e1 && e1.some((e1)=>/[@#]__PURE__/.test(e1.value));
            function annotateAsPure(e1) {
                const t = e1["node"] || e1;
                if (isPureAnnotated(t)) {
                    return;
                }
                s(t, "leading", i);
            }
        },
        7135: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = annotateAsPure;
            var n = r(776);
            const { addComment: s } = n;
            const i = "#__PURE__";
            const isPureAnnotated = ({ leadingComments: e1 })=>!!e1 && e1.some((e1)=>/[@#]__PURE__/.test(e1.value));
            function annotateAsPure(e1) {
                const t = e1["node"] || e1;
                if (isPureAnnotated(t)) {
                    return;
                }
                s(t, "leading", i);
            }
        },
        8288: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.getInclusionReasons = getInclusionReasons;
            var n = r(7849);
            var s = r(6783);
            var i = r(2423);
            function getInclusionReasons(e1, t, r) {
                const a = r[e1] || {};
                return Object.keys(t).reduce((e1, r)=>{
                    const o = (0, i.getLowestImplementedVersion)(a, r);
                    const l = t[r];
                    if (!o) {
                        e1[r] = (0, s.prettifyVersion)(l);
                    } else {
                        const t = (0, i.isUnreleasedVersion)(o, r);
                        const a = (0, i.isUnreleasedVersion)(l, r);
                        if (!a && (t || n.lt(l.toString(), (0, i.semverify)(o)))) {
                            e1[r] = (0, s.prettifyVersion)(l);
                        }
                    }
                    return e1;
                }, {});
            }
        },
        6743: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = filterItems;
            t.isRequired = isRequired;
            t.targetsSupported = targetsSupported;
            var n = r(7849);
            var s = r(2204);
            var i = r(2423);
            function targetsSupported(e1, t) {
                const r = Object.keys(e1);
                if (r.length === 0) {
                    return false;
                }
                const s = r.filter((r)=>{
                    const s = (0, i.getLowestImplementedVersion)(t, r);
                    if (!s) {
                        return true;
                    }
                    const a = e1[r];
                    if ((0, i.isUnreleasedVersion)(a, r)) {
                        return false;
                    }
                    if ((0, i.isUnreleasedVersion)(s, r)) {
                        return true;
                    }
                    if (!n.valid(a.toString())) {
                        throw new Error(`Invalid version passed for target "${r}": "${a}". ` + "Versions must be in semver format (major.minor.patch)");
                    }
                    return n.gt((0, i.semverify)(s), a.toString());
                });
                return s.length === 0;
            }
            function isRequired(e1, t, { compatData: r = s, includes: n, excludes: i } = {}) {
                if (i != null && i.has(e1)) return false;
                if (n != null && n.has(e1)) return true;
                return !targetsSupported(t, r[e1]);
            }
            function filterItems(e1, t, r, n, s, i, a) {
                const o = new Set;
                const l = {
                    compatData: e1,
                    includes: t,
                    excludes: r
                };
                for(const t in e1){
                    if (isRequired(t, n, l)) {
                        o.add(t);
                    } else if (a) {
                        const e1 = a.get(t);
                        if (e1) {
                            o.add(e1);
                        }
                    }
                }
                s == null ? void 0 : s.forEach((e1)=>!r.has(e1) && o.add(e1));
                i == null ? void 0 : i.forEach((e1)=>!t.has(e1) && o.delete(e1));
                return o;
            }
        },
        900: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "TargetNames", {
                enumerable: true,
                get: function() {
                    return c.TargetNames;
                }
            });
            t["default"] = getTargets;
            Object.defineProperty(t, "filterItems", {
                enumerable: true,
                get: function() {
                    return f.default;
                }
            });
            Object.defineProperty(t, "getInclusionReasons", {
                enumerable: true,
                get: function() {
                    return p.getInclusionReasons;
                }
            });
            t.isBrowsersQueryValid = isBrowsersQueryValid;
            Object.defineProperty(t, "isRequired", {
                enumerable: true,
                get: function() {
                    return f.isRequired;
                }
            });
            Object.defineProperty(t, "prettifyTargets", {
                enumerable: true,
                get: function() {
                    return u.prettifyTargets;
                }
            });
            Object.defineProperty(t, "unreleasedLabels", {
                enumerable: true,
                get: function() {
                    return l.unreleasedLabels;
                }
            });
            var n = r(4907);
            var s = r(4716);
            var i = r(1371);
            var a = r(7330);
            var o = r(2423);
            var l = r(3519);
            var c = r(9376);
            var u = r(6783);
            var p = r(8288);
            var f = r(6743);
            const d = i["es6.module"];
            const h = new s.OptionValidator("@babel/helper-compilation-targets");
            function validateTargetNames(e1) {
                const t = Object.keys(c.TargetNames);
                for (const r of Object.keys(e1)){
                    if (!(r in c.TargetNames)) {
                        throw new Error(h.formatMessage(`'${r}' is not a valid target\n- Did you mean '${(0, s.findSuggestion)(r, t)}'?`));
                    }
                }
                return e1;
            }
            function isBrowsersQueryValid(e1) {
                return typeof e1 === "string" || Array.isArray(e1) && e1.every((e1)=>typeof e1 === "string");
            }
            function validateBrowsers(e1) {
                h.invariant(e1 === undefined || isBrowsersQueryValid(e1), `'${String(e1)}' is not a valid browserslist query`);
                return e1;
            }
            function getLowestVersions(e1) {
                return e1.reduce((e1, t)=>{
                    const [r, n] = t.split(" ");
                    const s = l.browserNameMap[r];
                    if (!s) {
                        return e1;
                    }
                    try {
                        const t = n.split("-")[0].toLowerCase();
                        const r = (0, o.isUnreleasedVersion)(t, s);
                        if (!e1[s]) {
                            e1[s] = r ? t : (0, o.semverify)(t);
                            return e1;
                        }
                        const i = e1[s];
                        const a = (0, o.isUnreleasedVersion)(i, s);
                        if (a && r) {
                            e1[s] = (0, o.getLowestUnreleased)(i, t, s);
                        } else if (a) {
                            e1[s] = (0, o.semverify)(t);
                        } else if (!a && !r) {
                            const r = (0, o.semverify)(t);
                            e1[s] = (0, o.semverMin)(i, r);
                        }
                    } catch (e1) {}
                    return e1;
                }, {});
            }
            function outputDecimalWarning(e1) {
                if (!e1.length) {
                    return;
                }
                console.warn("Warning, the following targets are using a decimal version:\n");
                e1.forEach(({ target: e1, value: t })=>console.warn(`  ${e1}: ${t}`));
                console.warn(`\nWe recommend using a string for minor/patch versions to avoid numbers like 6.10\ngetting parsed as 6.1, which can lead to unexpected behavior.\n`);
            }
            function semverifyTarget(e1, t) {
                try {
                    return (0, o.semverify)(t);
                } catch (r) {
                    throw new Error(h.formatMessage(`'${t}' is not a valid value for 'targets.${e1}'.`));
                }
            }
            function nodeTargetParser(e1) {
                const t = e1 === true || e1 === "current" ? process.versions.node : semverifyTarget("node", e1);
                return [
                    "node",
                    t
                ];
            }
            function defaultTargetParser(e1, t) {
                const r = (0, o.isUnreleasedVersion)(t, e1) ? t.toLowerCase() : semverifyTarget(e1, t);
                return [
                    e1,
                    r
                ];
            }
            function generateTargets(e1) {
                const t = Object.assign({}, e1);
                delete t.esmodules;
                delete t.browsers;
                return t;
            }
            function resolveTargets(e1, t) {
                const r = n(e1, {
                    mobileToDesktop: true,
                    env: t
                });
                return getLowestVersions(r);
            }
            const m = new a({
                max: 64
            });
            function resolveTargetsCached(e1, t) {
                const r = typeof e1 === "string" ? e1 : e1.join() + t;
                let n = m.get(r);
                if (!n) {
                    n = resolveTargets(e1, t);
                    m.set(r, n);
                }
                return Object.assign({}, n);
            }
            function getTargets(e1 = {}, t = {}) {
                var r, s;
                let { browsers: i, esmodules: a } = e1;
                const { configPath: l = "." } = t;
                validateBrowsers(i);
                const c = generateTargets(e1);
                let u = validateTargetNames(c);
                const p = !!i;
                const f = p || Object.keys(u).length > 0;
                const h = !t.ignoreBrowserslistConfig && !f;
                if (!i && h) {
                    i = n.loadConfig({
                        config: t.configFile,
                        path: l,
                        env: t.browserslistEnv
                    });
                    if (i == null) {
                        {
                            i = [];
                        }
                    }
                }
                if (a && (a !== "intersect" || !((r = i) != null && r.length))) {
                    i = Object.keys(d).map((e1)=>`${e1} >= ${d[e1]}`).join(", ");
                    a = false;
                }
                if ((s = i) != null && s.length) {
                    const e1 = resolveTargetsCached(i, t.browserslistEnv);
                    if (a === "intersect") {
                        for (const t of Object.keys(e1)){
                            if (t !== "deno" && t !== "ie") {
                                const r = d[t === "opera_mobile" ? "op_mob" : t];
                                if (r) {
                                    const n = e1[t];
                                    e1[t] = (0, o.getHighestUnreleased)(n, (0, o.semverify)(r), t);
                                } else {
                                    delete e1[t];
                                }
                            } else {
                                delete e1[t];
                            }
                        }
                    }
                    u = Object.assign(e1, u);
                }
                const m = {};
                const y = [];
                for (const e1 of Object.keys(u).sort()){
                    const t = u[e1];
                    if (typeof t === "number" && t % 1 !== 0) {
                        y.push({
                            target: e1,
                            value: t
                        });
                    }
                    const [r, n] = e1 === "node" ? nodeTargetParser(t) : defaultTargetParser(e1, t);
                    if (n) {
                        m[r] = n;
                    }
                }
                outputDecimalWarning(y);
                return m;
            }
        },
        9376: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TargetNames = void 0;
            const r = {
                node: "node",
                deno: "deno",
                chrome: "chrome",
                opera: "opera",
                edge: "edge",
                firefox: "firefox",
                safari: "safari",
                ie: "ie",
                ios: "ios",
                android: "android",
                electron: "electron",
                samsung: "samsung",
                rhino: "rhino",
                opera_mobile: "opera_mobile"
            };
            t.TargetNames = r;
        },
        6783: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.prettifyTargets = prettifyTargets;
            t.prettifyVersion = prettifyVersion;
            var n = r(7849);
            var s = r(3519);
            function prettifyVersion(e1) {
                if (typeof e1 !== "string") {
                    return e1;
                }
                const { major: t, minor: r, patch: s } = n.parse(e1);
                const i = [
                    t
                ];
                if (r || s) {
                    i.push(r);
                }
                if (s) {
                    i.push(s);
                }
                return i.join(".");
            }
            function prettifyTargets(e1) {
                return Object.keys(e1).reduce((t, r)=>{
                    let n = e1[r];
                    const i = s.unreleasedLabels[r];
                    if (typeof n === "string" && i !== n) {
                        n = prettifyVersion(n);
                    }
                    t[r] = n;
                    return t;
                }, {});
            }
        },
        3519: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.unreleasedLabels = t.browserNameMap = void 0;
            const r = {
                safari: "tp"
            };
            t.unreleasedLabels = r;
            const n = {
                and_chr: "chrome",
                and_ff: "firefox",
                android: "android",
                chrome: "chrome",
                edge: "edge",
                firefox: "firefox",
                ie: "ie",
                ie_mob: "ie",
                ios_saf: "ios",
                node: "node",
                deno: "deno",
                op_mob: "opera_mobile",
                opera: "opera",
                safari: "safari",
                samsung: "samsung"
            };
            t.browserNameMap = n;
        },
        2423: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.getHighestUnreleased = getHighestUnreleased;
            t.getLowestImplementedVersion = getLowestImplementedVersion;
            t.getLowestUnreleased = getLowestUnreleased;
            t.isUnreleasedVersion = isUnreleasedVersion;
            t.semverMin = semverMin;
            t.semverify = semverify;
            var n = r(7849);
            var s = r(4716);
            var i = r(3519);
            const a = /^(\d+|\d+.\d+)$/;
            const o = new s.OptionValidator("@babel/helper-compilation-targets");
            function semverMin(e1, t) {
                return e1 && n.lt(e1, t) ? e1 : t;
            }
            function semverify(e1) {
                if (typeof e1 === "string" && n.valid(e1)) {
                    return e1;
                }
                o.invariant(typeof e1 === "number" || typeof e1 === "string" && a.test(e1), `'${e1}' is not a valid version`);
                e1 = e1.toString();
                let t = 0;
                let r = 0;
                while((t = e1.indexOf(".", t + 1)) > 0){
                    r++;
                }
                return e1 + ".0".repeat(2 - r);
            }
            function isUnreleasedVersion(e1, t) {
                const r = i.unreleasedLabels[t];
                return !!r && r === e1.toString().toLowerCase();
            }
            function getLowestUnreleased(e1, t, r) {
                const n = i.unreleasedLabels[r];
                if (e1 === n) {
                    return t;
                }
                if (t === n) {
                    return e1;
                }
                return semverMin(e1, t);
            }
            function getHighestUnreleased(e1, t, r) {
                return getLowestUnreleased(e1, t, r) === e1 ? t : e1;
            }
            function getLowestImplementedVersion(e1, t) {
                const r = e1[t];
                if (!r && t === "android") {
                    return e1.chrome;
                }
                return r;
            }
        },
        327: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.buildDecoratedClass = buildDecoratedClass;
            t.hasDecorators = hasDecorators;
            t.hasOwnDecorators = hasOwnDecorators;
            var n = r(3688);
            var s = r(4243);
            var i = r(2528);
            function hasOwnDecorators(e1) {
                var t;
                return !!((t = e1.decorators) != null && t.length);
            }
            function hasDecorators(e1) {
                return hasOwnDecorators(e1) || e1.body.body.some(hasOwnDecorators);
            }
            function prop(e1, t) {
                if (!t) return null;
                return n.types.objectProperty(n.types.identifier(e1), t);
            }
            function method(e1, t) {
                return n.types.objectMethod("method", n.types.identifier(e1), [], n.types.blockStatement(t));
            }
            function takeDecorators(e1) {
                let t;
                if (e1.decorators && e1.decorators.length > 0) {
                    t = n.types.arrayExpression(e1.decorators.map((e1)=>e1.expression));
                }
                e1.decorators = undefined;
                return t;
            }
            function getKey(e1) {
                if (e1.computed) {
                    return e1.key;
                } else if (n.types.isIdentifier(e1.key)) {
                    return n.types.stringLiteral(e1.key.name);
                } else {
                    return n.types.stringLiteral(String(e1.key.value));
                }
            }
            function extractElementDescriptor(e1, t, r, a) {
                const o = a.isClassMethod();
                if (a.isPrivate()) {
                    throw a.buildCodeFrameError(`Private ${o ? "methods" : "fields"} in decorated classes are not supported yet.`);
                }
                if (a.node.type === "ClassAccessorProperty") {
                    throw a.buildCodeFrameError(`Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.`);
                }
                if (a.node.type === "StaticBlock") {
                    throw a.buildCodeFrameError(`Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.`);
                }
                const { node: l, scope: c } = a;
                if (!a.isTSDeclareMethod()) {
                    new s.default({
                        methodPath: a,
                        objectRef: t,
                        superRef: r,
                        file: e1,
                        refToPreserve: t
                    }).replace();
                }
                const u = [
                    prop("kind", n.types.stringLiteral(n.types.isClassMethod(l) ? l.kind : "field")),
                    prop("decorators", takeDecorators(l)),
                    prop("static", l.static && n.types.booleanLiteral(true)),
                    prop("key", getKey(l))
                ].filter(Boolean);
                if (n.types.isClassMethod(l)) {
                    const e1 = l.computed ? null : l.key;
                    const t = n.types.toExpression(l);
                    u.push(prop("value", (0, i.default)({
                        node: t,
                        id: e1,
                        scope: c
                    }) || t));
                } else if (n.types.isClassProperty(l) && l.value) {
                    u.push(method("value", n.template.statements.ast`return ${l.value}`));
                } else {
                    u.push(prop("value", c.buildUndefinedNode()));
                }
                a.remove();
                return n.types.objectExpression(u);
            }
            function addDecorateHelper(e1) {
                return e1.addHelper("decorate");
            }
            function buildDecoratedClass(e1, t, r, s) {
                const { node: i, scope: a } = t;
                const o = a.generateUidIdentifier("initialize");
                const l = i.id && t.isDeclaration();
                const c = t.isInStrictMode();
                const { superClass: u } = i;
                i.type = "ClassDeclaration";
                if (!i.id) i.id = n.types.cloneNode(e1);
                let p;
                if (u) {
                    p = a.generateUidIdentifierBasedOnNode(i.superClass, "super");
                    i.superClass = p;
                }
                const f = takeDecorators(i);
                const d = n.types.arrayExpression(r.filter((e1)=>!e1.node.abstract && e1.node.type !== "TSIndexSignature").map((e1)=>extractElementDescriptor(s, i.id, p, e1)));
                const h = n.template.expression.ast`
    ${addDecorateHelper(s)}(
      ${f || n.types.nullLiteral()},
      function (${o}, ${u ? n.types.cloneNode(p) : null}) {
        ${i}
        return { F: ${n.types.cloneNode(i.id)}, d: ${d} };
      },
      ${u}
    )
  `;
                if (!c) {
                    h.arguments[1].body.directives.push(n.types.directive(n.types.directiveLiteral("use strict")));
                }
                let m = h;
                let y = "arguments.1.body.body.0";
                if (l) {
                    m = n.template.statement.ast`let ${e1} = ${h}`;
                    y = "declarations.0.init." + y;
                }
                return {
                    instanceNodes: [
                        n.template.statement.ast`${n.types.cloneNode(o)}(this)`
                    ],
                    wrapClass (e1) {
                        e1.replaceWith(m);
                        return e1.get(y);
                    }
                };
            }
        },
        5929: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.FEATURES = void 0;
            t.enableFeature = enableFeature;
            t.isLoose = isLoose;
            t.shouldTransform = shouldTransform;
            var n = r(327);
            const s = Object.freeze({
                fields: 1 << 1,
                privateMethods: 1 << 2,
                decorators: 1 << 3,
                privateIn: 1 << 4,
                staticBlocks: 1 << 5
            });
            t.FEATURES = s;
            const i = new Map([
                [
                    s.fields,
                    "@babel/plugin-transform-class-properties"
                ],
                [
                    s.privateMethods,
                    "@babel/plugin-transform-private-methods"
                ],
                [
                    s.privateIn,
                    "@babel/plugin-transform-private-property-in-object"
                ]
            ]);
            const a = "@babel/plugin-class-features/featuresKey";
            const o = "@babel/plugin-class-features/looseKey";
            const l = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
            function enableFeature(e1, t, r) {
                if (!hasFeature(e1, t) || canIgnoreLoose(e1, t)) {
                    e1.set(a, e1.get(a) | t);
                    if (r === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error") {
                        setLoose(e1, t, true);
                        e1.set(l, e1.get(l) | t);
                    } else if (r === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error") {
                        setLoose(e1, t, false);
                        e1.set(l, e1.get(l) | t);
                    } else {
                        setLoose(e1, t, r);
                    }
                }
                let n;
                let s;
                for (const [t, r] of i){
                    if (!hasFeature(e1, t)) continue;
                    const i = isLoose(e1, t);
                    if (canIgnoreLoose(e1, t)) {
                        continue;
                    } else if (n === !i) {
                        throw new Error("'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, " + "@babel/plugin-transform-private-methods and " + "@babel/plugin-transform-private-property-in-object (when they are enabled).");
                    } else {
                        n = i;
                        s = r;
                    }
                }
                if (n !== undefined) {
                    for (const [t, r] of i){
                        if (hasFeature(e1, t) && isLoose(e1, t) !== n) {
                            setLoose(e1, t, n);
                            console.warn(`Though the "loose" option was set to "${!n}" in your @babel/preset-env ` + `config, it will not be used for ${r} since the "loose" mode option was set to ` + `"${n}" for ${s}.\nThe "loose" option must be the ` + `same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods ` + `and @babel/plugin-transform-private-property-in-object (when they are enabled): you can ` + `silence this warning by explicitly adding\n` + `\t["${r}", { "loose": ${n} }]\n` + `to the "plugins" section of your Babel config.`);
                        }
                    }
                }
            }
            function hasFeature(e1, t) {
                return !!(e1.get(a) & t);
            }
            function isLoose(e1, t) {
                return !!(e1.get(o) & t);
            }
            function setLoose(e1, t, r) {
                if (r) e1.set(o, e1.get(o) | t);
                else e1.set(o, e1.get(o) & ~t);
                e1.set(l, e1.get(l) & ~t);
            }
            function canIgnoreLoose(e1, t) {
                return !!(e1.get(l) & t);
            }
            function shouldTransform(e1, t) {
                let r = null;
                let i = null;
                let a = null;
                let o = null;
                let l = null;
                if ((0, n.hasOwnDecorators)(e1.node)) {
                    r = e1.get("decorators.0");
                }
                for (const t of e1.get("body.body")){
                    if (!r && (0, n.hasOwnDecorators)(t.node)) {
                        r = t.get("decorators.0");
                    }
                    if (!i && t.isClassProperty()) {
                        i = t;
                    }
                    if (!a && t.isClassPrivateProperty()) {
                        a = t;
                    }
                    if (!o && t.isClassPrivateMethod != null && t.isClassPrivateMethod()) {
                        o = t;
                    }
                    if (!l && t.isStaticBlock != null && t.isStaticBlock()) {
                        l = t;
                    }
                }
                if (r && a) {
                    throw a.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
                }
                if (r && o) {
                    throw o.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
                }
                if (r && !hasFeature(t, s.decorators)) {
                    throw e1.buildCodeFrameError("Decorators are not enabled." + "\nIf you are using " + '["@babel/plugin-proposal-decorators", { "version": "legacy" }], ' + 'make sure it comes *before* "@babel/plugin-transform-class-properties" ' + "and enable loose mode, like so:\n" + '\t["@babel/plugin-proposal-decorators", { "version": "legacy" }]\n' + '\t["@babel/plugin-transform-class-properties", { "loose": true }]');
                }
                if (o && !hasFeature(t, s.privateMethods)) {
                    throw o.buildCodeFrameError("Class private methods are not enabled. " + "Please add `@babel/plugin-transform-private-methods` to your configuration.");
                }
                if ((i || a) && !hasFeature(t, s.fields) && !hasFeature(t, s.privateMethods)) {
                    throw e1.buildCodeFrameError("Class fields are not enabled. " + "Please add `@babel/plugin-transform-class-properties` to your configuration.");
                }
                if (l && !hasFeature(t, s.staticBlocks)) {
                    throw e1.buildCodeFrameError("Static class blocks are not enabled. " + "Please add `@babel/plugin-transform-class-static-block` to your configuration.");
                }
                if (r || o || l) {
                    return true;
                }
                if ((i || a) && hasFeature(t, s.fields)) {
                    return true;
                }
                return false;
            }
        },
        9076: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.buildCheckInRHS = buildCheckInRHS;
            t.buildFieldsInitNodes = buildFieldsInitNodes;
            t.buildPrivateNamesMap = buildPrivateNamesMap;
            t.buildPrivateNamesNodes = buildPrivateNamesNodes;
            t.transformPrivateNamesUsage = transformPrivateNamesUsage;
            var n = r(3688);
            var s = r(4243);
            var i = r(3336);
            var a = r(6265);
            var o = r(970);
            var l = r(7135);
            var c = r(9382);
            var u = r(5963);
            function buildPrivateNamesMap(e1) {
                const t = new Map;
                for (const r of e1){
                    if (r.isPrivate()) {
                        const { name: e1 } = r.node.key.id;
                        const n = t.has(e1) ? t.get(e1) : {
                            id: r.scope.generateUidIdentifier(e1),
                            static: r.node.static,
                            method: !r.isProperty()
                        };
                        if (r.isClassPrivateMethod()) {
                            if (r.node.kind === "get") {
                                n.getId = r.scope.generateUidIdentifier(`get_${e1}`);
                            } else if (r.node.kind === "set") {
                                n.setId = r.scope.generateUidIdentifier(`set_${e1}`);
                            } else if (r.node.kind === "method") {
                                n.methodId = r.scope.generateUidIdentifier(e1);
                            }
                        }
                        t.set(e1, n);
                    }
                }
                return t;
            }
            function buildPrivateNamesNodes(e1, t, r, s) {
                const i = [];
                for (const [a, o] of e1){
                    const { static: e1, method: c, getId: u, setId: p } = o;
                    const f = u || p;
                    const d = n.types.cloneNode(o.id);
                    let h;
                    if (t) {
                        h = n.types.callExpression(s.addHelper("classPrivateFieldLooseKey"), [
                            n.types.stringLiteral(a)
                        ]);
                    } else if (r) {
                        h = n.types.callExpression(n.types.identifier("Symbol"), [
                            n.types.stringLiteral(a)
                        ]);
                    } else if (!e1) {
                        h = n.types.newExpression(n.types.identifier(!c || f ? "WeakMap" : "WeakSet"), []);
                    }
                    if (h) {
                        (0, l.default)(h);
                        i.push(n.template.statement.ast`var ${d} = ${h}`);
                    }
                }
                return i;
            }
            function privateNameVisitorFactory(e1) {
                const t = n.traverse.visitors.merge([
                    Object.assign({}, e1),
                    i.default
                ]);
                const r = Object.assign({}, e1, {
                    Class (e1) {
                        const { privateNamesMap: n } = this;
                        const s = e1.get("body.body");
                        const i = new Map(n);
                        const a = [];
                        for (const e1 of s){
                            if (!e1.isPrivate()) continue;
                            const { name: t } = e1.node.key.id;
                            i.delete(t);
                            a.push(t);
                        }
                        if (!a.length) {
                            return;
                        }
                        e1.get("body").traverse(t, Object.assign({}, this, {
                            redeclared: a
                        }));
                        e1.traverse(r, Object.assign({}, this, {
                            privateNamesMap: i
                        }));
                        e1.skipKey("body");
                    }
                });
                return r;
            }
            const p = privateNameVisitorFactory({
                PrivateName (e1, { noDocumentAll: t }) {
                    const { privateNamesMap: r, redeclared: n } = this;
                    const { node: s, parentPath: i } = e1;
                    if (!i.isMemberExpression({
                        property: s
                    }) && !i.isOptionalMemberExpression({
                        property: s
                    })) {
                        return;
                    }
                    const { name: a } = s.id;
                    if (!r.has(a)) return;
                    if (n && n.includes(a)) return;
                    this.handle(i, t);
                }
            });
            function unshadow(e1, t, r) {
                while((n = t) != null && n.hasBinding(e1) && !t.bindingIdentifierEquals(e1, r)){
                    var n;
                    t.rename(e1);
                    t = t.parent;
                }
            }
            function buildCheckInRHS(e1, t, r) {
                if (r || !(t.availableHelper != null && t.availableHelper("checkInRHS"))) return e1;
                return n.types.callExpression(t.addHelper("checkInRHS"), [
                    e1
                ]);
            }
            const f = privateNameVisitorFactory({
                BinaryExpression (e1, { file: t }) {
                    const { operator: r, left: s, right: i } = e1.node;
                    if (r !== "in") return;
                    if (!n.types.isPrivateName(s)) return;
                    const { privateFieldsAsProperties: a, privateNamesMap: o, redeclared: l } = this;
                    const { name: c } = s.id;
                    if (!o.has(c)) return;
                    if (l && l.includes(c)) return;
                    unshadow(this.classRef.name, e1.scope, this.innerBinding);
                    if (a) {
                        const { id: r } = o.get(c);
                        e1.replaceWith(n.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(i, t)}, ${n.types.cloneNode(r)})
      `);
                        return;
                    }
                    const { id: u, static: p } = o.get(c);
                    if (p) {
                        e1.replaceWith(n.template.expression.ast`${buildCheckInRHS(i, t)} === ${n.types.cloneNode(this.classRef)}`);
                        return;
                    }
                    e1.replaceWith(n.template.expression.ast`${n.types.cloneNode(u)}.has(${buildCheckInRHS(i, t)})`);
                }
            });
            const d = {
                memoise (e1, t) {
                    const { scope: r } = e1;
                    const { object: n } = e1.node;
                    const s = r.maybeGenerateMemoised(n);
                    if (!s) {
                        return;
                    }
                    this.memoiser.set(n, s, t);
                },
                receiver (e1) {
                    const { object: t } = e1.node;
                    if (this.memoiser.has(t)) {
                        return n.types.cloneNode(this.memoiser.get(t));
                    }
                    return n.types.cloneNode(t);
                },
                get (e1) {
                    const { classRef: t, privateNamesMap: r, file: s, innerBinding: i } = this;
                    const { name: a } = e1.node.property.id;
                    const { id: o, static: l, method: c, methodId: u, getId: p, setId: f } = r.get(a);
                    const d = p || f;
                    if (l) {
                        const r = c && !d ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
                        unshadow(t.name, e1.scope, i);
                        return n.types.callExpression(s.addHelper(r), [
                            this.receiver(e1),
                            n.types.cloneNode(t),
                            n.types.cloneNode(o)
                        ]);
                    }
                    if (c) {
                        if (d) {
                            if (!p && f) {
                                if (s.availableHelper("writeOnlyError")) {
                                    return n.types.sequenceExpression([
                                        this.receiver(e1),
                                        n.types.callExpression(s.addHelper("writeOnlyError"), [
                                            n.types.stringLiteral(`#${a}`)
                                        ])
                                    ]);
                                }
                                console.warn(`@babel/helpers is outdated, update it to silence this warning.`);
                            }
                            return n.types.callExpression(s.addHelper("classPrivateFieldGet"), [
                                this.receiver(e1),
                                n.types.cloneNode(o)
                            ]);
                        }
                        return n.types.callExpression(s.addHelper("classPrivateMethodGet"), [
                            this.receiver(e1),
                            n.types.cloneNode(o),
                            n.types.cloneNode(u)
                        ]);
                    }
                    return n.types.callExpression(s.addHelper("classPrivateFieldGet"), [
                        this.receiver(e1),
                        n.types.cloneNode(o)
                    ]);
                },
                boundGet (e1) {
                    this.memoise(e1, 1);
                    return n.types.callExpression(n.types.memberExpression(this.get(e1), n.types.identifier("bind")), [
                        this.receiver(e1)
                    ]);
                },
                set (e1, t) {
                    const { classRef: r, privateNamesMap: s, file: i } = this;
                    const { name: a } = e1.node.property.id;
                    const { id: o, static: l, method: c, setId: u, getId: p } = s.get(a);
                    const f = p || u;
                    if (l) {
                        const s = c && !f ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
                        return n.types.callExpression(i.addHelper(s), [
                            this.receiver(e1),
                            n.types.cloneNode(r),
                            n.types.cloneNode(o),
                            t
                        ]);
                    }
                    if (c) {
                        if (u) {
                            return n.types.callExpression(i.addHelper("classPrivateFieldSet"), [
                                this.receiver(e1),
                                n.types.cloneNode(o),
                                t
                            ]);
                        }
                        return n.types.sequenceExpression([
                            this.receiver(e1),
                            t,
                            n.types.callExpression(i.addHelper("readOnlyError"), [
                                n.types.stringLiteral(`#${a}`)
                            ])
                        ]);
                    }
                    return n.types.callExpression(i.addHelper("classPrivateFieldSet"), [
                        this.receiver(e1),
                        n.types.cloneNode(o),
                        t
                    ]);
                },
                destructureSet (e1) {
                    const { classRef: t, privateNamesMap: r, file: s } = this;
                    const { name: i } = e1.node.property.id;
                    const { id: a, static: o } = r.get(i);
                    if (o) {
                        try {
                            var l = s.addHelper("classStaticPrivateFieldDestructureSet");
                        } catch (e1) {
                            throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \n" + "please update @babel/helpers to the latest version.");
                        }
                        return n.types.memberExpression(n.types.callExpression(l, [
                            this.receiver(e1),
                            n.types.cloneNode(t),
                            n.types.cloneNode(a)
                        ]), n.types.identifier("value"));
                    }
                    return n.types.memberExpression(n.types.callExpression(s.addHelper("classPrivateFieldDestructureSet"), [
                        this.receiver(e1),
                        n.types.cloneNode(a)
                    ]), n.types.identifier("value"));
                },
                call (e1, t) {
                    this.memoise(e1, 1);
                    return (0, o.default)(this.get(e1), this.receiver(e1), t, false);
                },
                optionalCall (e1, t) {
                    this.memoise(e1, 1);
                    return (0, o.default)(this.get(e1), this.receiver(e1), t, true);
                },
                delete () {
                    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
                }
            };
            const h = {
                get (e1) {
                    const { privateNamesMap: t, file: r } = this;
                    const { object: s } = e1.node;
                    const { name: i } = e1.node.property.id;
                    return n.template.expression`BASE(REF, PROP)[PROP]`({
                        BASE: r.addHelper("classPrivateFieldLooseBase"),
                        REF: n.types.cloneNode(s),
                        PROP: n.types.cloneNode(t.get(i).id)
                    });
                },
                set () {
                    throw new Error("private name handler with loose = true don't need set()");
                },
                boundGet (e1) {
                    return n.types.callExpression(n.types.memberExpression(this.get(e1), n.types.identifier("bind")), [
                        n.types.cloneNode(e1.node.object)
                    ]);
                },
                simpleSet (e1) {
                    return this.get(e1);
                },
                destructureSet (e1) {
                    return this.get(e1);
                },
                call (e1, t) {
                    return n.types.callExpression(this.get(e1), t);
                },
                optionalCall (e1, t) {
                    return n.types.optionalCallExpression(this.get(e1), t, true);
                },
                delete () {
                    throw new Error("Internal Babel error: deleting private elements is a parsing error.");
                }
            };
            function transformPrivateNamesUsage(e1, t, r, { privateFieldsAsProperties: n, noDocumentAll: s, innerBinding: i }, o) {
                if (!r.size) return;
                const l = t.get("body");
                const c = n ? h : d;
                (0, a.default)(l, p, Object.assign({
                    privateNamesMap: r,
                    classRef: e1,
                    file: o
                }, c, {
                    noDocumentAll: s,
                    innerBinding: i
                }));
                l.traverse(f, {
                    privateNamesMap: r,
                    classRef: e1,
                    file: o,
                    privateFieldsAsProperties: n,
                    innerBinding: i
                });
            }
            function buildPrivateFieldInitLoose(e1, t, r) {
                const { id: s } = r.get(t.node.key.id.name);
                const i = t.node.value || t.scope.buildUndefinedNode();
                return inheritPropComments(n.template.statement.ast`
      Object.defineProperty(${e1}, ${n.types.cloneNode(s)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${i}
      });
    `, t);
            }
            function buildPrivateInstanceFieldInitSpec(e1, t, r, s) {
                const { id: i } = r.get(t.node.key.id.name);
                const a = t.node.value || t.scope.buildUndefinedNode();
                {
                    if (!s.availableHelper("classPrivateFieldInitSpec")) {
                        return inheritPropComments(n.template.statement.ast`${n.types.cloneNode(i)}.set(${e1}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${a},
        })`, t);
                    }
                }
                const o = s.addHelper("classPrivateFieldInitSpec");
                return inheritPropComments(n.template.statement.ast`${o}(
      ${n.types.thisExpression()},
      ${n.types.cloneNode(i)},
      {
        writable: true,
        value: ${a}
      },
    )`, t);
            }
            function buildPrivateStaticFieldInitSpec(e1, t) {
                const r = t.get(e1.node.key.id.name);
                const { id: s, getId: i, setId: a, initAdded: o } = r;
                const l = i || a;
                if (!e1.isProperty() && (o || !l)) return;
                if (l) {
                    t.set(e1.node.key.id.name, Object.assign({}, r, {
                        initAdded: true
                    }));
                    return inheritPropComments(n.template.statement.ast`
        var ${n.types.cloneNode(s)} = {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${i ? i.name : e1.scope.buildUndefinedNode()},
          set: ${a ? a.name : e1.scope.buildUndefinedNode()}
        }
      `, e1);
                }
                const c = e1.node.value || e1.scope.buildUndefinedNode();
                return inheritPropComments(n.template.statement.ast`
      var ${n.types.cloneNode(s)} = {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${c}
      };
    `, e1);
            }
            function buildPrivateMethodInitLoose(e1, t, r) {
                const s = r.get(t.node.key.id.name);
                const { methodId: i, id: a, getId: o, setId: l, initAdded: c } = s;
                if (c) return;
                if (i) {
                    return inheritPropComments(n.template.statement.ast`
        Object.defineProperty(${e1}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${i.name}
        });
      `, t);
                }
                const u = o || l;
                if (u) {
                    r.set(t.node.key.id.name, Object.assign({}, s, {
                        initAdded: true
                    }));
                    return inheritPropComments(n.template.statement.ast`
        Object.defineProperty(${e1}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${o ? o.name : t.scope.buildUndefinedNode()},
          set: ${l ? l.name : t.scope.buildUndefinedNode()}
        });
      `, t);
                }
            }
            function buildPrivateInstanceMethodInitSpec(e1, t, r, n) {
                const s = r.get(t.node.key.id.name);
                const { getId: i, setId: a, initAdded: o } = s;
                if (o) return;
                const l = i || a;
                if (l) {
                    return buildPrivateAccessorInitialization(e1, t, r, n);
                }
                return buildPrivateInstanceMethodInitialization(e1, t, r, n);
            }
            function buildPrivateAccessorInitialization(e1, t, r, s) {
                const i = r.get(t.node.key.id.name);
                const { id: a, getId: o, setId: l } = i;
                r.set(t.node.key.id.name, Object.assign({}, i, {
                    initAdded: true
                }));
                {
                    if (!s.availableHelper("classPrivateFieldInitSpec")) {
                        return inheritPropComments(n.template.statement.ast`
          ${a}.set(${e1}, {
            get: ${o ? o.name : t.scope.buildUndefinedNode()},
            set: ${l ? l.name : t.scope.buildUndefinedNode()}
          });
        `, t);
                    }
                }
                const c = s.addHelper("classPrivateFieldInitSpec");
                return inheritPropComments(n.template.statement.ast`${c}(
      ${n.types.thisExpression()},
      ${n.types.cloneNode(a)},
      {
        get: ${o ? o.name : t.scope.buildUndefinedNode()},
        set: ${l ? l.name : t.scope.buildUndefinedNode()}
      },
    )`, t);
            }
            function buildPrivateInstanceMethodInitialization(e1, t, r, s) {
                const i = r.get(t.node.key.id.name);
                const { id: a } = i;
                {
                    if (!s.availableHelper("classPrivateMethodInitSpec")) {
                        return inheritPropComments(n.template.statement.ast`${a}.add(${e1})`, t);
                    }
                }
                const o = s.addHelper("classPrivateMethodInitSpec");
                return inheritPropComments(n.template.statement.ast`${o}(
      ${n.types.thisExpression()},
      ${n.types.cloneNode(a)}
    )`, t);
            }
            function buildPublicFieldInitLoose(e1, t) {
                const { key: r, computed: s } = t.node;
                const i = t.node.value || t.scope.buildUndefinedNode();
                return inheritPropComments(n.types.expressionStatement(n.types.assignmentExpression("=", n.types.memberExpression(e1, r, s || n.types.isLiteral(r)), i)), t);
            }
            function buildPublicFieldInitSpec(e1, t, r) {
                const { key: s, computed: i } = t.node;
                const a = t.node.value || t.scope.buildUndefinedNode();
                return inheritPropComments(n.types.expressionStatement(n.types.callExpression(r.addHelper("defineProperty"), [
                    e1,
                    i || n.types.isLiteral(s) ? s : n.types.stringLiteral(s.name),
                    a
                ])), t);
            }
            function buildPrivateStaticMethodInitLoose(e1, t, r, s) {
                const i = s.get(t.node.key.id.name);
                const { id: a, methodId: o, getId: l, setId: c, initAdded: u } = i;
                if (u) return;
                const p = l || c;
                if (p) {
                    s.set(t.node.key.id.name, Object.assign({}, i, {
                        initAdded: true
                    }));
                    return inheritPropComments(n.template.statement.ast`
        Object.defineProperty(${e1}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${l ? l.name : t.scope.buildUndefinedNode()},
          set: ${c ? c.name : t.scope.buildUndefinedNode()}
        })
      `, t);
                }
                return inheritPropComments(n.template.statement.ast`
      Object.defineProperty(${e1}, ${a}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${o.name}
      });
    `, t);
            }
            function buildPrivateMethodDeclaration(e1, t, r = false) {
                const s = t.get(e1.node.key.id.name);
                const { id: i, methodId: a, getId: o, setId: l, getterDeclared: c, setterDeclared: u, static: p } = s;
                const { params: f, body: d, generator: h, async: m } = e1.node;
                const y = o && !c && f.length === 0;
                const g = l && !u && f.length > 0;
                let b = a;
                if (y) {
                    t.set(e1.node.key.id.name, Object.assign({}, s, {
                        getterDeclared: true
                    }));
                    b = o;
                } else if (g) {
                    t.set(e1.node.key.id.name, Object.assign({}, s, {
                        setterDeclared: true
                    }));
                    b = l;
                } else if (p && !r) {
                    b = i;
                }
                return inheritPropComments(n.types.functionDeclaration(n.types.cloneNode(b), f, d, h, m), e1);
            }
            const m = n.traverse.visitors.merge([
                {
                    UnaryExpression (e1) {
                        const { node: t } = e1;
                        if (t.operator === "delete") {
                            const r = (0, c.skipTransparentExprWrapperNodes)(t.argument);
                            if (n.types.isThisExpression(r)) {
                                e1.replaceWith(n.types.booleanLiteral(true));
                            }
                        }
                    },
                    ThisExpression (e1, t) {
                        t.needsClassRef = true;
                        e1.replaceWith(n.types.cloneNode(t.classRef));
                    },
                    MetaProperty (e1) {
                        const { node: t, scope: r } = e1;
                        if (t.meta.name === "new" && t.property.name === "target") {
                            e1.replaceWith(r.buildUndefinedNode());
                        }
                    }
                },
                i.default
            ]);
            const y = {
                ReferencedIdentifier (e1, t) {
                    if (e1.scope.bindingIdentifierEquals(e1.node.name, t.innerBinding)) {
                        t.needsClassRef = true;
                        e1.node.name = t.classRef.name;
                    }
                }
            };
            function replaceThisContext(e1, t, r) {
                var n;
                const s = {
                    classRef: t,
                    needsClassRef: false,
                    innerBinding: r
                };
                if (!e1.isMethod()) {
                    e1.traverse(m, s);
                }
                if (r != null && (n = s.classRef) != null && n.name && s.classRef.name !== r.name) {
                    e1.traverse(y, s);
                }
                return s.needsClassRef;
            }
            function isNameOrLength({ key: e1, computed: t }) {
                if (e1.type === "Identifier") {
                    return !t && (e1.name === "name" || e1.name === "length");
                }
                if (e1.type === "StringLiteral") {
                    return e1.value === "name" || e1.value === "length";
                }
                return false;
            }
            function inheritPropComments(e1, t) {
                n.types.inheritLeadingComments(e1, t.node);
                n.types.inheritInnerComments(e1, t.node);
                return e1;
            }
            function buildFieldsInitNodes(e1, t, r, i, a, o, l, c, p) {
                var f, d;
                let h = 0;
                let m;
                const y = [];
                const g = [];
                const b = [];
                let T = null;
                const S = n.types.isIdentifier(t) ? ()=>t : ()=>{
                    var e1;
                    (e1 = m) != null ? e1 : m = r[0].scope.generateUidIdentifierBasedOnNode(t);
                    return m;
                };
                const E = (f = e1) != null ? f : r[0].scope.generateUidIdentifier("class");
                (d = e1) != null ? d : e1 = n.types.cloneNode(p);
                for (const t of r){
                    t.isClassProperty() && u.assertFieldTransformed(t);
                    const r = !(n.types.isStaticBlock != null && n.types.isStaticBlock(t.node)) && t.node.static;
                    const f = !r;
                    const d = t.isPrivate();
                    const m = !d;
                    const T = t.isProperty();
                    const v = !T;
                    const x = t.isStaticBlock == null ? void 0 : t.isStaticBlock();
                    if (r) h |= 1;
                    if (r || v && d || x) {
                        new s.default({
                            methodPath: t,
                            constantSuper: c,
                            file: a,
                            refToPreserve: p,
                            getSuperRef: S,
                            getObjectRef () {
                                h |= 2;
                                if (r || x) {
                                    return E;
                                } else {
                                    return n.types.memberExpression(E, n.types.identifier("prototype"));
                                }
                            }
                        }).replace();
                        const e1 = replaceThisContext(t, E, p);
                        if (e1) {
                            h |= 2;
                        }
                    }
                    switch(true){
                        case x:
                            {
                                const e1 = t.node.body;
                                if (e1.length === 1 && n.types.isExpressionStatement(e1[0])) {
                                    y.push(inheritPropComments(e1[0], t));
                                } else {
                                    y.push(n.types.inheritsComments(n.template.statement.ast`(() => { ${e1} })()`, t.node));
                                }
                                break;
                            }
                        case r && d && T && l:
                            y.push(buildPrivateFieldInitLoose(n.types.cloneNode(e1), t, i));
                            break;
                        case r && d && T && !l:
                            y.push(buildPrivateStaticFieldInitSpec(t, i));
                            break;
                        case r && m && T && o:
                            if (!isNameOrLength(t.node)) {
                                y.push(buildPublicFieldInitLoose(n.types.cloneNode(e1), t));
                                break;
                            }
                        case r && m && T && !o:
                            y.push(buildPublicFieldInitSpec(n.types.cloneNode(e1), t, a));
                            break;
                        case f && d && T && l:
                            g.push(buildPrivateFieldInitLoose(n.types.thisExpression(), t, i));
                            break;
                        case f && d && T && !l:
                            g.push(buildPrivateInstanceFieldInitSpec(n.types.thisExpression(), t, i, a));
                            break;
                        case f && d && v && l:
                            g.unshift(buildPrivateMethodInitLoose(n.types.thisExpression(), t, i));
                            b.push(buildPrivateMethodDeclaration(t, i, l));
                            break;
                        case f && d && v && !l:
                            g.unshift(buildPrivateInstanceMethodInitSpec(n.types.thisExpression(), t, i, a));
                            b.push(buildPrivateMethodDeclaration(t, i, l));
                            break;
                        case r && d && v && !l:
                            y.unshift(buildPrivateStaticFieldInitSpec(t, i));
                            b.push(buildPrivateMethodDeclaration(t, i, l));
                            break;
                        case r && d && v && l:
                            y.unshift(buildPrivateStaticMethodInitLoose(n.types.cloneNode(e1), t, a, i));
                            b.push(buildPrivateMethodDeclaration(t, i, l));
                            break;
                        case f && m && T && o:
                            g.push(buildPublicFieldInitLoose(n.types.thisExpression(), t));
                            break;
                        case f && m && T && !o:
                            g.push(buildPublicFieldInitSpec(n.types.thisExpression(), t, a));
                            break;
                        default:
                            throw new Error("Unreachable.");
                    }
                }
                if (h & 2 && p != null) {
                    T = n.types.expressionStatement(n.types.assignmentExpression("=", n.types.cloneNode(E), n.types.cloneNode(p)));
                }
                return {
                    staticNodes: y.filter(Boolean),
                    instanceNodes: g.filter(Boolean),
                    pureStaticNodes: b.filter(Boolean),
                    classBindingNode: T,
                    wrapClass (t) {
                        for (const e1 of r){
                            e1.node.leadingComments = null;
                            e1.remove();
                        }
                        if (m) {
                            t.scope.push({
                                id: n.types.cloneNode(m)
                            });
                            t.set("superClass", n.types.assignmentExpression("=", m, t.node.superClass));
                        }
                        if (h !== 0) {
                            if (t.isClassExpression()) {
                                t.scope.push({
                                    id: e1
                                });
                                t.replaceWith(n.types.assignmentExpression("=", n.types.cloneNode(e1), t.node));
                            } else {
                                if (p == null) {
                                    t.node.id = e1;
                                }
                                if (T != null) {
                                    t.scope.push({
                                        id: E
                                    });
                                }
                            }
                        }
                        return t;
                    }
                };
            }
        },
        269: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "FEATURES", {
                enumerable: true,
                get: function() {
                    return u.FEATURES;
                }
            });
            Object.defineProperty(t, "buildCheckInRHS", {
                enumerable: true,
                get: function() {
                    return o.buildCheckInRHS;
                }
            });
            t.createClassFeaturePlugin = createClassFeaturePlugin;
            Object.defineProperty(t, "enableFeature", {
                enumerable: true,
                get: function() {
                    return u.enableFeature;
                }
            });
            Object.defineProperty(t, "injectInitialization", {
                enumerable: true,
                get: function() {
                    return c.injectInitialization;
                }
            });
            var n = r(3688);
            var s = r(2528);
            var i = r(9053);
            var a = r(7849);
            var o = r(9076);
            var l = r(327);
            var c = r(1822);
            var u = r(5929);
            var p = r(5963);
            const f = "@babel/plugin-class-features/version";
            function createClassFeaturePlugin({ name: e1, feature: t, loose: r, manipulateOptions: d, api: h, inherits: m }) {
                {
                    var y;
                    (y = h) != null ? y : h = {
                        assumption: ()=>void 0
                    };
                }
                const g = h.assumption("setPublicClassFields");
                const b = h.assumption("privateFieldsAsSymbols");
                const T = h.assumption("privateFieldsAsProperties");
                const S = h.assumption("constantSuper");
                const E = h.assumption("noDocumentAll");
                if (T && b) {
                    throw new Error(`Cannot enable both the "privateFieldsAsProperties" and ` + `"privateFieldsAsSymbols" assumptions as the same time.`);
                }
                const v = T || b;
                if (r === true) {
                    const t = [];
                    if (g !== undefined) {
                        t.push(`"setPublicClassFields"`);
                    }
                    if (T !== undefined) {
                        t.push(`"privateFieldsAsProperties"`);
                    }
                    if (b !== undefined) {
                        t.push(`"privateFieldsAsSymbols"`);
                    }
                    if (t.length !== 0) {
                        console.warn(`[${e1}]: You are using the "loose: true" option and you are` + ` explicitly setting a value for the ${t.join(" and ")}` + ` assumption${t.length > 1 ? "s" : ""}. The "loose" option` + ` can cause incompatibilities with the other class features` + ` plugins, so it's recommended that you replace it with the` + ` following top-level option:\n` + `\t"assumptions": {\n` + `\t\t"setPublicClassFields": true,\n` + `\t\t"privateFieldsAsSymbols": true\n` + `\t}`);
                    }
                }
                return {
                    name: e1,
                    manipulateOptions: d,
                    inherits: m,
                    pre (e1) {
                        (0, u.enableFeature)(e1, t, r);
                        {
                            if (typeof e1.get(f) === "number") {
                                e1.set(f, "7.22.15");
                                return;
                            }
                        }
                        if (!e1.get(f) || a.lt(e1.get(f), "7.22.15")) {
                            e1.set(f, "7.22.15");
                        }
                    },
                    visitor: {
                        Class (e1, { file: r }) {
                            var i;
                            if (r.get(f) !== "7.22.15") return;
                            if (!(0, u.shouldTransform)(e1, r)) return;
                            const a = e1.isClassDeclaration();
                            if (a) (0, p.assertFieldTransformed)(e1);
                            const d = (0, u.isLoose)(r, t);
                            let h;
                            const m = (0, l.hasDecorators)(e1.node);
                            const y = [];
                            const x = [];
                            const P = [];
                            const w = new Set;
                            const A = e1.get("body");
                            for (const e1 of A.get("body")){
                                if ((e1.isClassProperty() || e1.isClassMethod()) && e1.node.computed) {
                                    P.push(e1);
                                }
                                if (e1.isPrivate()) {
                                    const { name: t } = e1.node.key.id;
                                    const r = `get ${t}`;
                                    const n = `set ${t}`;
                                    if (e1.isClassPrivateMethod()) {
                                        if (e1.node.kind === "get") {
                                            if (w.has(r) || w.has(t) && !w.has(n)) {
                                                throw e1.buildCodeFrameError("Duplicate private field");
                                            }
                                            w.add(r).add(t);
                                        } else if (e1.node.kind === "set") {
                                            if (w.has(n) || w.has(t) && !w.has(r)) {
                                                throw e1.buildCodeFrameError("Duplicate private field");
                                            }
                                            w.add(n).add(t);
                                        }
                                    } else {
                                        if (w.has(t) && !w.has(r) && !w.has(n) || w.has(t) && (w.has(r) || w.has(n))) {
                                            throw e1.buildCodeFrameError("Duplicate private field");
                                        }
                                        w.add(t);
                                    }
                                }
                                if (e1.isClassMethod({
                                    kind: "constructor"
                                })) {
                                    h = e1;
                                } else {
                                    x.push(e1);
                                    if (e1.isProperty() || e1.isPrivate() || e1.isStaticBlock != null && e1.isStaticBlock()) {
                                        y.push(e1);
                                    }
                                }
                            }
                            {
                                if (!y.length && !m) return;
                            }
                            const C = e1.node.id;
                            let I;
                            if (!C || !a) {
                                (0, s.default)(e1);
                                I = e1.scope.generateUidIdentifier("class");
                            }
                            const O = (i = I) != null ? i : n.types.cloneNode(C);
                            const k = (0, o.buildPrivateNamesMap)(y);
                            const N = (0, o.buildPrivateNamesNodes)(k, T != null ? T : d, b != null ? b : false, r);
                            (0, o.transformPrivateNamesUsage)(O, e1, k, {
                                privateFieldsAsProperties: v != null ? v : d,
                                noDocumentAll: E,
                                innerBinding: C
                            }, r);
                            let _, D, M, L, j, F;
                            {
                                if (m) {
                                    D = L = _ = [];
                                    ({ instanceNodes: M, wrapClass: F } = (0, l.buildDecoratedClass)(O, e1, x, r));
                                } else {
                                    _ = (0, c.extractComputedKeys)(e1, P, r);
                                    ({ staticNodes: D, pureStaticNodes: L, instanceNodes: M, classBindingNode: j, wrapClass: F } = (0, o.buildFieldsInitNodes)(I, e1.node.superClass, y, k, r, g != null ? g : d, v != null ? v : d, S != null ? S : d, C));
                                }
                            }
                            if (M.length > 0) {
                                (0, c.injectInitialization)(e1, h, M, (e1, t)=>{
                                    {
                                        if (m) return;
                                    }
                                    for (const r of y){
                                        if (n.types.isStaticBlock != null && n.types.isStaticBlock(r.node) || r.node.static) continue;
                                        r.traverse(e1, t);
                                    }
                                });
                            }
                            const R = F(e1);
                            R.insertBefore([
                                ...N,
                                ..._
                            ]);
                            if (D.length > 0) {
                                R.insertAfter(D);
                            }
                            if (L.length > 0) {
                                R.find((e1)=>e1.isStatement() || e1.isDeclaration()).insertAfter(L);
                            }
                            if (j != null && a) {
                                R.insertAfter(j);
                            }
                        },
                        ExportDefaultDeclaration (e1, { file: t }) {
                            {
                                if (t.get(f) !== "7.22.15") return;
                                const r = e1.get("declaration");
                                if (r.isClassDeclaration() && (0, l.hasDecorators)(r.node)) {
                                    if (r.node.id) {
                                        (0, i.default)(e1);
                                    } else {
                                        r.node.type = "ClassExpression";
                                    }
                                }
                            }
                        }
                    }
                };
            }
        },
        1822: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.extractComputedKeys = extractComputedKeys;
            t.injectInitialization = injectInitialization;
            var n = r(3688);
            var s = r(3336);
            const i = n.traverse.visitors.merge([
                {
                    Super (e1) {
                        const { node: t, parentPath: r } = e1;
                        if (r.isCallExpression({
                            callee: t
                        })) {
                            this.push(r);
                        }
                    }
                },
                s.default
            ]);
            const a = {
                "TSTypeAnnotation|TypeAnnotation" (e1) {
                    e1.skip();
                },
                ReferencedIdentifier (e1, { scope: t }) {
                    if (t.hasOwnBinding(e1.node.name)) {
                        t.rename(e1.node.name);
                        e1.skip();
                    }
                }
            };
            function handleClassTDZ(e1, t) {
                if (t.classBinding && t.classBinding === e1.scope.getBinding(e1.node.name)) {
                    const r = t.file.addHelper("classNameTDZError");
                    const s = n.types.callExpression(r, [
                        n.types.stringLiteral(e1.node.name)
                    ]);
                    e1.replaceWith(n.types.sequenceExpression([
                        s,
                        e1.node
                    ]));
                    e1.skip();
                }
            }
            const o = {
                ReferencedIdentifier: handleClassTDZ
            };
            function injectInitialization(e1, t, r, s) {
                if (!r.length) return;
                const o = !!e1.node.superClass;
                if (!t) {
                    const r = n.types.classMethod("constructor", n.types.identifier("constructor"), [], n.types.blockStatement([]));
                    if (o) {
                        r.params = [
                            n.types.restElement(n.types.identifier("args"))
                        ];
                        r.body.body.push(n.template.statement.ast`super(...args)`);
                    }
                    [t] = e1.get("body").unshiftContainer("body", r);
                }
                if (s) {
                    s(a, {
                        scope: t.scope
                    });
                }
                if (o) {
                    const e1 = [];
                    t.traverse(i, e1);
                    let s = true;
                    for (const t of e1){
                        if (s) {
                            t.insertAfter(r);
                            s = false;
                        } else {
                            t.insertAfter(r.map((e1)=>n.types.cloneNode(e1)));
                        }
                    }
                } else {
                    t.get("body").unshiftContainer("body", r);
                }
            }
            function extractComputedKeys(e1, t, r) {
                const s = [];
                const i = {
                    classBinding: e1.node.id && e1.scope.getBinding(e1.node.id.name),
                    file: r
                };
                for (const r of t){
                    const t = r.get("key");
                    if (t.isReferencedIdentifier()) {
                        handleClassTDZ(t, i);
                    } else {
                        t.traverse(o, i);
                    }
                    const a = r.node;
                    if (!t.isConstantExpression()) {
                        const t = e1.scope.generateUidIdentifierBasedOnNode(a.key);
                        e1.scope.push({
                            id: t,
                            kind: "let"
                        });
                        s.push(n.types.expressionStatement(n.types.assignmentExpression("=", n.types.cloneNode(t), a.key)));
                        a.key = n.types.cloneNode(t);
                    }
                }
                return s;
            }
        },
        5963: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.assertFieldTransformed = assertFieldTransformed;
            function assertFieldTransformed(e1) {
                if (e1.node.declare || false) {
                    throw e1.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by ` + `@babel/plugin-transform-typescript.\n` + `If you have already enabled that plugin (or '@babel/preset-typescript'), make sure ` + `that it runs before any plugin related to additional class features:\n` + ` - @babel/plugin-transform-class-properties\n` + ` - @babel/plugin-transform-private-methods\n` + ` - @babel/plugin-proposal-decorators`);
                }
            }
        },
        8552: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            t.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
            {
                t.skipAllButComputedKey = function skipAllButComputedKey(e1) {
                    e1.skip();
                    if (e1.node.computed) {
                        e1.context.maybeQueue(e1.get("key"));
                    }
                };
            }
            function requeueComputedKeyAndDecorators(e1) {
                const { context: t, node: r } = e1;
                if (r.computed) {
                    t.maybeQueue(e1.get("key"));
                }
                if (r.decorators) {
                    for (const r of e1.get("decorators")){
                        t.maybeQueue(r);
                    }
                }
            }
            const r = {
                FunctionParent (e1) {
                    if (e1.isArrowFunctionExpression()) {
                        return;
                    } else {
                        e1.skip();
                        if (e1.isMethod()) {
                            requeueComputedKeyAndDecorators(e1);
                        }
                    }
                },
                Property (e1) {
                    if (e1.isObjectProperty()) {
                        return;
                    }
                    e1.skip();
                    requeueComputedKeyAndDecorators(e1);
                }
            };
            var n = r;
            t["default"] = n;
        },
        3336: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            t.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
            {
                t.skipAllButComputedKey = function skipAllButComputedKey(e1) {
                    e1.skip();
                    if (e1.node.computed) {
                        e1.context.maybeQueue(e1.get("key"));
                    }
                };
            }
            function requeueComputedKeyAndDecorators(e1) {
                const { context: t, node: r } = e1;
                if (r.computed) {
                    t.maybeQueue(e1.get("key"));
                }
                if (r.decorators) {
                    for (const r of e1.get("decorators")){
                        t.maybeQueue(r);
                    }
                }
            }
            const r = {
                FunctionParent (e1) {
                    if (e1.isArrowFunctionExpression()) {
                        return;
                    } else {
                        e1.skip();
                        if (e1.isMethod()) {
                            requeueComputedKeyAndDecorators(e1);
                        }
                    }
                },
                Property (e1) {
                    if (e1.isObjectProperty()) {
                        return;
                    }
                    e1.skip();
                    requeueComputedKeyAndDecorators(e1);
                }
            };
            var n = t["default"] = r;
        },
        4940: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = _default;
            var n = r(9128);
            var s = r(776);
            const { NOT_LOCAL_BINDING: i, cloneNode: a, identifier: o, isAssignmentExpression: l, isAssignmentPattern: c, isFunction: u, isIdentifier: p, isLiteral: f, isNullLiteral: d, isObjectMethod: h, isObjectProperty: m, isRegExpLiteral: y, isRestElement: g, isTemplateLiteral: b, isVariableDeclarator: T, toBindingIdentifierName: S } = s;
            function getFunctionArity(e1) {
                const t = e1.params.findIndex((e1)=>c(e1) || g(e1));
                return t === -1 ? e1.params.length : t;
            }
            const E = n.default.statement(`\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);
            const v = n.default.statement(`\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);
            const x = {
                "ReferencedIdentifier|BindingIdentifier" (e1, t) {
                    if (e1.node.name !== t.name) return;
                    const r = e1.scope.getBindingIdentifier(t.name);
                    if (r !== t.outerDeclar) return;
                    t.selfReference = true;
                    e1.stop();
                }
            };
            function getNameFromLiteralId(e1) {
                if (d(e1)) {
                    return "null";
                }
                if (y(e1)) {
                    return `_${e1.pattern}_${e1.flags}`;
                }
                if (b(e1)) {
                    return e1.quasis.map((e1)=>e1.value.raw).join("");
                }
                if (e1.value !== undefined) {
                    return e1.value + "";
                }
                return "";
            }
            function wrap(e1, t, r, n) {
                if (e1.selfReference) {
                    if (n.hasBinding(r.name) && !n.hasGlobal(r.name)) {
                        n.rename(r.name);
                    } else {
                        if (!u(t)) return;
                        let e1 = E;
                        if (t.generator) {
                            e1 = v;
                        }
                        const s = e1({
                            FUNCTION: t,
                            FUNCTION_ID: r,
                            FUNCTION_KEY: n.generateUidIdentifier(r.name)
                        }).expression;
                        const i = s.callee.body.body[0].params;
                        for(let e1 = 0, r = getFunctionArity(t); e1 < r; e1++){
                            i.push(n.generateUidIdentifier("x"));
                        }
                        return s;
                    }
                }
                t.id = r;
                n.getProgramParent().references[r.name] = true;
            }
            function visit(e1, t, r) {
                const n = {
                    selfAssignment: false,
                    selfReference: false,
                    outerDeclar: r.getBindingIdentifier(t),
                    name: t
                };
                const s = r.getOwnBinding(t);
                if (s) {
                    if (s.kind === "param") {
                        n.selfReference = true;
                    } else {}
                } else if (n.outerDeclar || r.hasGlobal(t)) {
                    r.traverse(e1, x, n);
                }
                return n;
            }
            function _default({ node: e1, parent: t, scope: r, id: n }, s = false, c = false) {
                if (e1.id) return;
                if ((m(t) || h(t, {
                    kind: "method"
                })) && (!t.computed || f(t.key))) {
                    n = t.key;
                } else if (T(t)) {
                    n = t.id;
                    if (p(n) && !s) {
                        const t = r.parent.getBinding(n.name);
                        if (t && t.constant && r.getBinding(n.name) === t) {
                            e1.id = a(n);
                            e1.id[i] = true;
                            return;
                        }
                    }
                } else if (l(t, {
                    operator: "="
                })) {
                    n = t.left;
                } else if (!n) {
                    return;
                }
                let d;
                if (n && f(n)) {
                    d = getNameFromLiteralId(n);
                } else if (n && p(n)) {
                    d = n.name;
                }
                if (d === undefined) {
                    return;
                }
                if (!c && u(e1) && /[\uD800-\uDFFF]/.test(d)) {
                    return;
                }
                d = S(d);
                const y = o(d);
                y[i] = true;
                const g = visit(e1, d, r);
                return wrap(g, e1, y, r) || e1;
            }
        },
        2528: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = _default;
            var n = r(789);
            var s = r(776);
            const { NOT_LOCAL_BINDING: i, cloneNode: a, identifier: o, isAssignmentExpression: l, isAssignmentPattern: c, isFunction: u, isIdentifier: p, isLiteral: f, isNullLiteral: d, isObjectMethod: h, isObjectProperty: m, isRegExpLiteral: y, isRestElement: g, isTemplateLiteral: b, isVariableDeclarator: T, toBindingIdentifierName: S } = s;
            function getFunctionArity(e1) {
                const t = e1.params.findIndex((e1)=>c(e1) || g(e1));
                return t === -1 ? e1.params.length : t;
            }
            const E = n.default.statement(`\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);
            const v = n.default.statement(`\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);
            const x = {
                "ReferencedIdentifier|BindingIdentifier" (e1, t) {
                    if (e1.node.name !== t.name) return;
                    const r = e1.scope.getBindingIdentifier(t.name);
                    if (r !== t.outerDeclar) return;
                    t.selfReference = true;
                    e1.stop();
                }
            };
            function getNameFromLiteralId(e1) {
                if (d(e1)) {
                    return "null";
                }
                if (y(e1)) {
                    return `_${e1.pattern}_${e1.flags}`;
                }
                if (b(e1)) {
                    return e1.quasis.map((e1)=>e1.value.raw).join("");
                }
                if (e1.value !== undefined) {
                    return e1.value + "";
                }
                return "";
            }
            function wrap(e1, t, r, n) {
                if (e1.selfReference) {
                    if (n.hasBinding(r.name) && !n.hasGlobal(r.name)) {
                        n.rename(r.name);
                    } else {
                        if (!u(t)) return;
                        let e1 = E;
                        if (t.generator) {
                            e1 = v;
                        }
                        const s = e1({
                            FUNCTION: t,
                            FUNCTION_ID: r,
                            FUNCTION_KEY: n.generateUidIdentifier(r.name)
                        }).expression;
                        const i = s.callee.body.body[0].params;
                        for(let e1 = 0, r = getFunctionArity(t); e1 < r; e1++){
                            i.push(n.generateUidIdentifier("x"));
                        }
                        return s;
                    }
                }
                t.id = r;
                n.getProgramParent().references[r.name] = true;
            }
            function visit(e1, t, r) {
                const n = {
                    selfAssignment: false,
                    selfReference: false,
                    outerDeclar: r.getBindingIdentifier(t),
                    name: t
                };
                const s = r.getOwnBinding(t);
                if (s) {
                    if (s.kind === "param") {
                        n.selfReference = true;
                    } else {}
                } else if (n.outerDeclar || r.hasGlobal(t)) {
                    r.traverse(e1, x, n);
                }
                return n;
            }
            function _default({ node: e1, parent: t, scope: r, id: n }, s = false, c = false) {
                if (e1.id) return;
                if ((m(t) || h(t, {
                    kind: "method"
                })) && (!t.computed || f(t.key))) {
                    n = t.key;
                } else if (T(t)) {
                    n = t.id;
                    if (p(n) && !s) {
                        const t = r.parent.getBinding(n.name);
                        if (t && t.constant && r.getBinding(n.name) === t) {
                            e1.id = a(n);
                            e1.id[i] = true;
                            return;
                        }
                    }
                } else if (l(t, {
                    operator: "="
                })) {
                    n = t.left;
                } else if (!n) {
                    return;
                }
                let d;
                if (n && f(n)) {
                    d = getNameFromLiteralId(n);
                } else if (n && p(n)) {
                    d = n.name;
                }
                if (d === undefined) {
                    return;
                }
                if (!c && u(e1) && /[\uD800-\uDFFF]/.test(d)) {
                    return;
                }
                d = S(d);
                const y = o(d);
                y[i] = true;
                const g = visit(e1, d, r);
                return wrap(g, e1, y, r) || e1;
            }
        },
        405: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = hoistVariables;
            var n = r(776);
            const { assignmentExpression: s, expressionStatement: i, identifier: a } = n;
            const o = {
                Scope (e1, t) {
                    if (t.kind === "let") e1.skip();
                },
                FunctionParent (e1) {
                    e1.skip();
                },
                VariableDeclaration (e1, t) {
                    if (t.kind && e1.node.kind !== t.kind) return;
                    const r = [];
                    const n = e1.get("declarations");
                    let o;
                    for (const e1 of n){
                        o = e1.node.id;
                        if (e1.node.init) {
                            r.push(i(s("=", e1.node.id, e1.node.init)));
                        }
                        for (const r of Object.keys(e1.getBindingIdentifiers())){
                            t.emit(a(r), r, e1.node.init !== null);
                        }
                    }
                    if (e1.parentPath.isFor({
                        left: e1.node
                    })) {
                        e1.replaceWith(o);
                    } else {
                        e1.replaceWithMultiple(r);
                    }
                }
            };
            function hoistVariables(e1, t, r = "var") {
                e1.traverse(o, {
                    kind: r,
                    emit: t
                });
            }
        },
        6265: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            var n = r(776);
            function _interopNamespace(e1) {
                if (e1 && e1.__esModule) return e1;
                var t = Object.create(null);
                if (e1) {
                    Object.keys(e1).forEach(function(r) {
                        if (r !== "default") {
                            var n = Object.getOwnPropertyDescriptor(e1, r);
                            Object.defineProperty(t, r, n.get ? n : {
                                enumerable: true,
                                get: function() {
                                    return e1[r];
                                }
                            });
                        }
                    });
                }
                t.default = e1;
                return Object.freeze(t);
            }
            var s = _interopNamespace(n);
            function willPathCastToBoolean(e1) {
                const t = e1;
                const { node: r, parentPath: n } = t;
                if (n.isLogicalExpression()) {
                    const { operator: e1, right: t } = n.node;
                    if (e1 === "&&" || e1 === "||" || e1 === "??" && r === t) {
                        return willPathCastToBoolean(n);
                    }
                }
                if (n.isSequenceExpression()) {
                    const { expressions: e1 } = n.node;
                    if (e1[e1.length - 1] === r) {
                        return willPathCastToBoolean(n);
                    } else {
                        return true;
                    }
                }
                return n.isConditional({
                    test: r
                }) || n.isUnaryExpression({
                    operator: "!"
                }) || n.isLoop({
                    test: r
                });
            }
            const { LOGICAL_OPERATORS: i, arrowFunctionExpression: a, assignmentExpression: o, binaryExpression: l, booleanLiteral: c, callExpression: u, cloneNode: p, conditionalExpression: f, identifier: d, isMemberExpression: h, isOptionalCallExpression: m, isOptionalMemberExpression: y, isUpdateExpression: g, logicalExpression: b, memberExpression: T, nullLiteral: S, optionalCallExpression: E, optionalMemberExpression: v, sequenceExpression: x, updateExpression: P } = s;
            class AssignmentMemoiser {
                constructor(){
                    this._map = void 0;
                    this._map = new WeakMap;
                }
                has(e1) {
                    return this._map.has(e1);
                }
                get(e1) {
                    if (!this.has(e1)) return;
                    const t = this._map.get(e1);
                    const { value: r } = t;
                    t.count--;
                    if (t.count === 0) {
                        return o("=", r, e1);
                    }
                    return r;
                }
                set(e1, t, r) {
                    return this._map.set(e1, {
                        count: r,
                        value: t
                    });
                }
            }
            function toNonOptional(e1, t) {
                const { node: r } = e1;
                if (y(r)) {
                    return T(t, r.property, r.computed);
                }
                if (e1.isOptionalCallExpression()) {
                    const r = e1.get("callee");
                    if (e1.node.optional && r.isOptionalMemberExpression()) {
                        const n = r.node.object;
                        const s = e1.scope.maybeGenerateMemoised(n);
                        r.get("object").replaceWith(o("=", s, n));
                        return u(T(t, d("call")), [
                            s,
                            ...e1.node.arguments
                        ]);
                    }
                    return u(t, e1.node.arguments);
                }
                return e1.node;
            }
            function isInDetachedTree(e1) {
                while(e1){
                    if (e1.isProgram()) break;
                    const { parentPath: t, container: r, listKey: n } = e1;
                    const s = t.node;
                    if (n) {
                        if (r !== s[n]) {
                            return true;
                        }
                    } else {
                        if (r !== s) return true;
                    }
                    e1 = t;
                }
                return false;
            }
            const w = {
                memoise () {},
                handle (e1, t) {
                    const { node: r, parent: n, parentPath: s, scope: i } = e1;
                    if (e1.isOptionalMemberExpression()) {
                        if (isInDetachedTree(e1)) return;
                        const g = e1.find(({ node: t, parent: r })=>{
                            if (y(r)) {
                                return r.optional || r.object !== t;
                            }
                            if (m(r)) {
                                return t !== e1.node && r.optional || r.callee !== t;
                            }
                            return true;
                        });
                        if (i.path.isPattern()) {
                            g.replaceWith(u(a([], g.node), []));
                            return;
                        }
                        const T = willPathCastToBoolean(g);
                        const x = g.parentPath;
                        if (x.isUpdateExpression({
                            argument: r
                        })) {
                            throw e1.buildCodeFrameError(`can't handle update expression`);
                        }
                        const P = x.isAssignmentExpression({
                            left: g.node
                        });
                        const w = x.isUnaryExpression({
                            operator: "delete"
                        });
                        if (w && g.isOptionalMemberExpression() && g.get("property").isPrivateName()) {
                            throw e1.buildCodeFrameError(`can't delete a private class element`);
                        }
                        let A = e1;
                        for(;;){
                            if (A.isOptionalMemberExpression()) {
                                if (A.node.optional) break;
                                A = A.get("object");
                                continue;
                            } else if (A.isOptionalCallExpression()) {
                                if (A.node.optional) break;
                                A = A.get("callee");
                                continue;
                            }
                            throw new Error(`Internal error: unexpected ${A.node.type}`);
                        }
                        const C = A.isOptionalMemberExpression() ? A.node.object : A.node.callee;
                        const I = i.maybeGenerateMemoised(C);
                        const O = I != null ? I : C;
                        const k = s.isOptionalCallExpression({
                            callee: r
                        });
                        const isOptionalCall = (e1)=>k;
                        const N = s.isCallExpression({
                            callee: r
                        });
                        A.replaceWith(toNonOptional(A, O));
                        if (isOptionalCall()) {
                            if (n.optional) {
                                s.replaceWith(this.optionalCall(e1, n.arguments));
                            } else {
                                s.replaceWith(this.call(e1, n.arguments));
                            }
                        } else if (N) {
                            e1.replaceWith(this.boundGet(e1));
                        } else if (this.delete && s.isUnaryExpression({
                            operator: "delete"
                        })) {
                            s.replaceWith(this.delete(e1));
                        } else if (s.isAssignmentExpression()) {
                            handleAssignment(this, e1, s);
                        } else {
                            e1.replaceWith(this.get(e1));
                        }
                        let _ = e1.node;
                        for(let t = e1; t !== g;){
                            const e1 = t.parentPath;
                            if (e1 === g && isOptionalCall() && n.optional) {
                                _ = e1.node;
                                break;
                            }
                            _ = toNonOptional(e1, _);
                            t = e1;
                        }
                        let D;
                        const M = g.parentPath;
                        if (h(_) && M.isOptionalCallExpression({
                            callee: g.node,
                            optional: true
                        })) {
                            const { object: t } = _;
                            D = e1.scope.maybeGenerateMemoised(t);
                            if (D) {
                                _.object = o("=", D, t);
                            }
                        }
                        let L = g;
                        if (w || P) {
                            L = M;
                            _ = M.node;
                        }
                        const j = I ? o("=", p(O), p(C)) : p(O);
                        if (T) {
                            let e1;
                            if (t) {
                                e1 = l("!=", j, S());
                            } else {
                                e1 = b("&&", l("!==", j, S()), l("!==", p(O), i.buildUndefinedNode()));
                            }
                            L.replaceWith(b("&&", e1, _));
                        } else {
                            let e1;
                            if (t) {
                                e1 = l("==", j, S());
                            } else {
                                e1 = b("||", l("===", j, S()), l("===", p(O), i.buildUndefinedNode()));
                            }
                            L.replaceWith(f(e1, w ? c(true) : i.buildUndefinedNode(), _));
                        }
                        if (D) {
                            const e1 = M.node;
                            M.replaceWith(E(v(e1.callee, d("call"), false, true), [
                                p(D),
                                ...e1.arguments
                            ], false));
                        }
                        return;
                    }
                    if (g(n, {
                        argument: r
                    })) {
                        if (this.simpleSet) {
                            e1.replaceWith(this.simpleSet(e1));
                            return;
                        }
                        const { operator: t, prefix: a } = n;
                        this.memoise(e1, 2);
                        const l = i.generateUidIdentifierBasedOnNode(r);
                        i.push({
                            id: l
                        });
                        const c = [
                            o("=", p(l), this.get(e1))
                        ];
                        if (a) {
                            c.push(P(t, p(l), a));
                            const r = x(c);
                            s.replaceWith(this.set(e1, r));
                            return;
                        } else {
                            const n = i.generateUidIdentifierBasedOnNode(r);
                            i.push({
                                id: n
                            });
                            c.push(o("=", p(n), P(t, p(l), a)), p(l));
                            const u = x(c);
                            s.replaceWith(x([
                                this.set(e1, u),
                                p(n)
                            ]));
                            return;
                        }
                    }
                    if (s.isAssignmentExpression({
                        left: r
                    })) {
                        handleAssignment(this, e1, s);
                        return;
                    }
                    if (s.isCallExpression({
                        callee: r
                    })) {
                        s.replaceWith(this.call(e1, s.node.arguments));
                        return;
                    }
                    if (s.isOptionalCallExpression({
                        callee: r
                    })) {
                        if (i.path.isPattern()) {
                            s.replaceWith(u(a([], s.node), []));
                            return;
                        }
                        s.replaceWith(this.optionalCall(e1, s.node.arguments));
                        return;
                    }
                    if (this.delete && s.isUnaryExpression({
                        operator: "delete"
                    })) {
                        s.replaceWith(this.delete(e1));
                        return;
                    }
                    if (s.isForXStatement({
                        left: r
                    }) || s.isObjectProperty({
                        value: r
                    }) && s.parentPath.isObjectPattern() || s.isAssignmentPattern({
                        left: r
                    }) && s.parentPath.isObjectProperty({
                        value: n
                    }) && s.parentPath.parentPath.isObjectPattern() || s.isArrayPattern() || s.isAssignmentPattern({
                        left: r
                    }) && s.parentPath.isArrayPattern() || s.isRestElement()) {
                        e1.replaceWith(this.destructureSet(e1));
                        return;
                    }
                    if (s.isTaggedTemplateExpression()) {
                        e1.replaceWith(this.boundGet(e1));
                    } else {
                        e1.replaceWith(this.get(e1));
                    }
                }
            };
            function handleAssignment(e1, t, r) {
                if (e1.simpleSet) {
                    t.replaceWith(e1.simpleSet(t));
                    return;
                }
                const { operator: n, right: s } = r.node;
                if (n === "=") {
                    r.replaceWith(e1.set(t, s));
                } else {
                    const a = n.slice(0, -1);
                    if (i.includes(a)) {
                        e1.memoise(t, 1);
                        r.replaceWith(b(a, e1.get(t), e1.set(t, s)));
                    } else {
                        e1.memoise(t, 2);
                        r.replaceWith(e1.set(t, l(a, e1.get(t), s)));
                    }
                }
            }
            function memberExpressionToFunctions(e1, t, r) {
                e1.traverse(t, Object.assign({}, w, r, {
                    memoiser: new AssignmentMemoiser
                }));
            }
            t["default"] = memberExpressionToFunctions;
        },
        4835: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(9491);
            var s = r(776);
            const { callExpression: i, cloneNode: a, expressionStatement: o, identifier: l, importDeclaration: c, importDefaultSpecifier: u, importNamespaceSpecifier: p, importSpecifier: f, memberExpression: d, stringLiteral: h, variableDeclaration: m, variableDeclarator: y } = s;
            class ImportBuilder {
                constructor(e1, t, r){
                    this._statements = [];
                    this._resultName = null;
                    this._importedSource = void 0;
                    this._scope = t;
                    this._hub = r;
                    this._importedSource = e1;
                }
                done() {
                    return {
                        statements: this._statements,
                        resultName: this._resultName
                    };
                }
                import() {
                    this._statements.push(c([], h(this._importedSource)));
                    return this;
                }
                require() {
                    this._statements.push(o(i(l("require"), [
                        h(this._importedSource)
                    ])));
                    return this;
                }
                namespace(e1 = "namespace") {
                    const t = this._scope.generateUidIdentifier(e1);
                    const r = this._statements[this._statements.length - 1];
                    n(r.type === "ImportDeclaration");
                    n(r.specifiers.length === 0);
                    r.specifiers = [
                        p(t)
                    ];
                    this._resultName = a(t);
                    return this;
                }
                default(e1) {
                    const t = this._scope.generateUidIdentifier(e1);
                    const r = this._statements[this._statements.length - 1];
                    n(r.type === "ImportDeclaration");
                    n(r.specifiers.length === 0);
                    r.specifiers = [
                        u(t)
                    ];
                    this._resultName = a(t);
                    return this;
                }
                named(e1, t) {
                    if (t === "default") return this.default(e1);
                    const r = this._scope.generateUidIdentifier(e1);
                    const s = this._statements[this._statements.length - 1];
                    n(s.type === "ImportDeclaration");
                    n(s.specifiers.length === 0);
                    s.specifiers = [
                        f(r, l(t))
                    ];
                    this._resultName = a(r);
                    return this;
                }
                var(e1) {
                    const t = this._scope.generateUidIdentifier(e1);
                    let r = this._statements[this._statements.length - 1];
                    if (r.type !== "ExpressionStatement") {
                        n(this._resultName);
                        r = o(this._resultName);
                        this._statements.push(r);
                    }
                    this._statements[this._statements.length - 1] = m("var", [
                        y(t, r.expression)
                    ]);
                    this._resultName = a(t);
                    return this;
                }
                defaultInterop() {
                    return this._interop(this._hub.addHelper("interopRequireDefault"));
                }
                wildcardInterop() {
                    return this._interop(this._hub.addHelper("interopRequireWildcard"));
                }
                _interop(e1) {
                    const t = this._statements[this._statements.length - 1];
                    if (t.type === "ExpressionStatement") {
                        t.expression = i(e1, [
                            t.expression
                        ]);
                    } else if (t.type === "VariableDeclaration") {
                        n(t.declarations.length === 1);
                        t.declarations[0].init = i(e1, [
                            t.declarations[0].init
                        ]);
                    } else {
                        n.fail("Unexpected type.");
                    }
                    return this;
                }
                prop(e1) {
                    const t = this._statements[this._statements.length - 1];
                    if (t.type === "ExpressionStatement") {
                        t.expression = d(t.expression, l(e1));
                    } else if (t.type === "VariableDeclaration") {
                        n(t.declarations.length === 1);
                        t.declarations[0].init = d(t.declarations[0].init, l(e1));
                    } else {
                        n.fail("Unexpected type:" + t.type);
                    }
                    return this;
                }
                read(e1) {
                    this._resultName = d(this._resultName, l(e1));
                }
            }
            t["default"] = ImportBuilder;
        },
        8539: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(9491);
            var s = r(776);
            var i = r(4835);
            var a = r(8089);
            const { numericLiteral: o, sequenceExpression: l } = s;
            class ImportInjector {
                constructor(e1, t, r){
                    this._defaultOpts = {
                        importedSource: null,
                        importedType: "commonjs",
                        importedInterop: "babel",
                        importingInterop: "babel",
                        ensureLiveReference: false,
                        ensureNoContext: false,
                        importPosition: "before"
                    };
                    const n = e1.find((e1)=>e1.isProgram());
                    this._programPath = n;
                    this._programScope = n.scope;
                    this._hub = n.hub;
                    this._defaultOpts = this._applyDefaults(t, r, true);
                }
                addDefault(e1, t) {
                    return this.addNamed("default", e1, t);
                }
                addNamed(e1, t, r) {
                    n(typeof e1 === "string");
                    return this._generateImport(this._applyDefaults(t, r), e1);
                }
                addNamespace(e1, t) {
                    return this._generateImport(this._applyDefaults(e1, t), null);
                }
                addSideEffect(e1, t) {
                    return this._generateImport(this._applyDefaults(e1, t), void 0);
                }
                _applyDefaults(e1, t, r = false) {
                    let s;
                    if (typeof e1 === "string") {
                        s = Object.assign({}, this._defaultOpts, {
                            importedSource: e1
                        }, t);
                    } else {
                        n(!t, "Unexpected secondary arguments.");
                        s = Object.assign({}, this._defaultOpts, e1);
                    }
                    if (!r && t) {
                        if (t.nameHint !== undefined) s.nameHint = t.nameHint;
                        if (t.blockHoist !== undefined) s.blockHoist = t.blockHoist;
                    }
                    return s;
                }
                _generateImport(e1, t) {
                    const r = t === "default";
                    const n = !!t && !r;
                    const s = t === null;
                    const { importedSource: c, importedType: u, importedInterop: p, importingInterop: f, ensureLiveReference: d, ensureNoContext: h, nameHint: m, importPosition: y, blockHoist: g } = e1;
                    let b = m || t;
                    const T = (0, a.default)(this._programPath);
                    const S = T && f === "node";
                    const E = T && f === "babel";
                    if (y === "after" && !T) {
                        throw new Error(`"importPosition": "after" is only supported in modules`);
                    }
                    const v = new i.default(c, this._programScope, this._hub);
                    if (u === "es6") {
                        if (!S && !E) {
                            throw new Error("Cannot import an ES6 module from CommonJS");
                        }
                        v.import();
                        if (s) {
                            v.namespace(m || c);
                        } else if (r || n) {
                            v.named(b, t);
                        }
                    } else if (u !== "commonjs") {
                        throw new Error(`Unexpected interopType "${u}"`);
                    } else if (p === "babel") {
                        if (S) {
                            b = b !== "default" ? b : c;
                            const e1 = `${c}$es6Default`;
                            v.import();
                            if (s) {
                                v.default(e1).var(b || c).wildcardInterop();
                            } else if (r) {
                                if (d) {
                                    v.default(e1).var(b || c).defaultInterop().read("default");
                                } else {
                                    v.default(e1).var(b).defaultInterop().prop(t);
                                }
                            } else if (n) {
                                v.default(e1).read(t);
                            }
                        } else if (E) {
                            v.import();
                            if (s) {
                                v.namespace(b || c);
                            } else if (r || n) {
                                v.named(b, t);
                            }
                        } else {
                            v.require();
                            if (s) {
                                v.var(b || c).wildcardInterop();
                            } else if ((r || n) && d) {
                                if (r) {
                                    b = b !== "default" ? b : c;
                                    v.var(b).read(t);
                                    v.defaultInterop();
                                } else {
                                    v.var(c).read(t);
                                }
                            } else if (r) {
                                v.var(b).defaultInterop().prop(t);
                            } else if (n) {
                                v.var(b).prop(t);
                            }
                        }
                    } else if (p === "compiled") {
                        if (S) {
                            v.import();
                            if (s) {
                                v.default(b || c);
                            } else if (r || n) {
                                v.default(c).read(b);
                            }
                        } else if (E) {
                            v.import();
                            if (s) {
                                v.namespace(b || c);
                            } else if (r || n) {
                                v.named(b, t);
                            }
                        } else {
                            v.require();
                            if (s) {
                                v.var(b || c);
                            } else if (r || n) {
                                if (d) {
                                    v.var(c).read(b);
                                } else {
                                    v.prop(t).var(b);
                                }
                            }
                        }
                    } else if (p === "uncompiled") {
                        if (r && d) {
                            throw new Error("No live reference for commonjs default");
                        }
                        if (S) {
                            v.import();
                            if (s) {
                                v.default(b || c);
                            } else if (r) {
                                v.default(b);
                            } else if (n) {
                                v.default(c).read(b);
                            }
                        } else if (E) {
                            v.import();
                            if (s) {
                                v.default(b || c);
                            } else if (r) {
                                v.default(b);
                            } else if (n) {
                                v.named(b, t);
                            }
                        } else {
                            v.require();
                            if (s) {
                                v.var(b || c);
                            } else if (r) {
                                v.var(b);
                            } else if (n) {
                                if (d) {
                                    v.var(c).read(b);
                                } else {
                                    v.var(b).prop(t);
                                }
                            }
                        }
                    } else {
                        throw new Error(`Unknown importedInterop "${p}".`);
                    }
                    const { statements: x, resultName: P } = v.done();
                    this._insertStatements(x, y, g);
                    if ((r || n) && h && P.type !== "Identifier") {
                        return l([
                            o(0),
                            P
                        ]);
                    }
                    return P;
                }
                _insertStatements(e1, t = "before", r = 3) {
                    const n = this._programPath.get("body");
                    if (t === "after") {
                        for(let t = n.length - 1; t >= 0; t--){
                            if (n[t].isImportDeclaration()) {
                                n[t].insertAfter(e1);
                                return;
                            }
                        }
                    } else {
                        e1.forEach((e1)=>{
                            e1._blockHoist = r;
                        });
                        const t = n.find((e1)=>{
                            const t = e1.node._blockHoist;
                            return Number.isFinite(t) && t < 4;
                        });
                        if (t) {
                            t.insertBefore(e1);
                            return;
                        }
                    }
                    this._programPath.unshiftContainer("body", e1);
                }
            }
            t["default"] = ImportInjector;
        },
        3380: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "ImportInjector", {
                enumerable: true,
                get: function() {
                    return n.default;
                }
            });
            t.addDefault = addDefault;
            t.addNamed = addNamed;
            t.addNamespace = addNamespace;
            t.addSideEffect = addSideEffect;
            Object.defineProperty(t, "isModule", {
                enumerable: true,
                get: function() {
                    return s.default;
                }
            });
            var n = r(8539);
            var s = r(8089);
            function addDefault(e1, t, r) {
                return new n.default(e1).addDefault(t, r);
            }
            function addNamed(e1, t, r, s) {
                return new n.default(e1).addNamed(t, r, s);
            }
            function addNamespace(e1, t, r) {
                return new n.default(e1).addNamespace(t, r);
            }
            function addSideEffect(e1, t, r) {
                return new n.default(e1).addSideEffect(t, r);
            }
        },
        8089: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isModule;
            function isModule(e1) {
                return e1.node.sourceType === "module";
            }
        },
        3664: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.buildDynamicImport = buildDynamicImport;
            var n = r(3688);
            {
                t.getDynamicImportSource = function getDynamicImportSource(e1) {
                    const [t] = e1.arguments;
                    return n.types.isStringLiteral(t) || n.types.isTemplateLiteral(t) ? t : n.template.expression.ast`\`\${${t}}\``;
                };
            }
            function buildDynamicImport(e1, t, r, s) {
                const i = n.types.isCallExpression(e1) ? e1.arguments[0] : e1.source;
                if (n.types.isStringLiteral(i) || n.types.isTemplateLiteral(i) && i.quasis.length === 0) {
                    if (t) {
                        return n.template.expression.ast`
        Promise.resolve().then(() => ${s(i)})
      `;
                    } else return s(i);
                }
                const a = n.types.isTemplateLiteral(i) ? n.types.identifier("specifier") : n.types.templateLiteral([
                    n.types.templateElement({
                        raw: ""
                    }),
                    n.types.templateElement({
                        raw: ""
                    })
                ], [
                    n.types.identifier("specifier")
                ]);
                if (t) {
                    return n.template.expression.ast`
      (specifier =>
        new Promise(r => r(${a}))
          .then(s => ${s(n.types.identifier("s"))})
      )(${i})
    `;
                } else if (r) {
                    return n.template.expression.ast`
      (specifier =>
        new Promise(r => r(${s(a)}))
      )(${i})
    `;
                } else {
                    return n.template.expression.ast`
      (specifier => ${s(a)})(${i})
    `;
                }
            }
        },
        7406: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = getModuleName;
            {
                const e1 = getModuleName;
                t["default"] = getModuleName = function getModuleName(t, r) {
                    var n, s, i, a;
                    return e1(t, {
                        moduleId: (n = r.moduleId) != null ? n : t.moduleId,
                        moduleIds: (s = r.moduleIds) != null ? s : t.moduleIds,
                        getModuleId: (i = r.getModuleId) != null ? i : t.getModuleId,
                        moduleRoot: (a = r.moduleRoot) != null ? a : t.moduleRoot
                    });
                };
            }
            function getModuleName(e1, t) {
                const { filename: r, filenameRelative: n = r, sourceRoot: s = t.moduleRoot } = e1;
                const { moduleId: i, moduleIds: a = !!i, getModuleId: o, moduleRoot: l = s } = t;
                if (!a) return null;
                if (i != null && !o) {
                    return i;
                }
                let c = l != null ? l + "/" : "";
                if (n) {
                    const e1 = s != null ? new RegExp("^" + s + "/?") : "";
                    c += n.replace(e1, "").replace(/\.(\w*?)$/, "");
                }
                c = c.replace(/\\/g, "/");
                if (o) {
                    return o(c) || c;
                } else {
                    return c;
                }
            }
        },
        6646: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "buildDynamicImport", {
                enumerable: true,
                get: function() {
                    return u.buildDynamicImport;
                }
            });
            t.buildNamespaceInitStatements = buildNamespaceInitStatements;
            t.ensureStatementsHoisted = ensureStatementsHoisted;
            Object.defineProperty(t, "getModuleName", {
                enumerable: true,
                get: function() {
                    return p.default;
                }
            });
            Object.defineProperty(t, "hasExports", {
                enumerable: true,
                get: function() {
                    return l.hasExports;
                }
            });
            Object.defineProperty(t, "isModule", {
                enumerable: true,
                get: function() {
                    return i.isModule;
                }
            });
            Object.defineProperty(t, "isSideEffectImport", {
                enumerable: true,
                get: function() {
                    return l.isSideEffectImport;
                }
            });
            t.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;
            Object.defineProperty(t, "rewriteThis", {
                enumerable: true,
                get: function() {
                    return a.default;
                }
            });
            t.wrapInterop = wrapInterop;
            var n = r(9491);
            var s = r(3688);
            var i = r(3380);
            var a = r(2268);
            var o = r(7258);
            var l = r(4042);
            var c = r(8652);
            var u = r(3664);
            var p = r(7406);
            const { booleanLiteral: f, callExpression: d, cloneNode: h, directive: m, directiveLiteral: y, expressionStatement: g, identifier: b, isIdentifier: T, memberExpression: S, stringLiteral: E, valueToNode: v, variableDeclaration: x, variableDeclarator: P } = s.types;
            {
                t.getDynamicImportSource = r(3664).getDynamicImportSource;
            }
            function rewriteModuleStatementsAndPrepareHeader(e1, { exportName: t, strict: r, allowTopLevelThis: s, strictMode: u, noInterop: p, importInterop: f = p ? "none" : "babel", lazy: d, getWrapperPayload: h = c.toGetWrapperPayload(d != null ? d : false), wrapReference: g = c.wrapReference, esNamespaceOnly: b, filename: T, constantReexports: S = arguments[1].loose, enumerableModuleMeta: E = arguments[1].loose, noIncompleteNsImportDetection: v }) {
                (0, l.validateImportInteropOption)(f);
                n((0, i.isModule)(e1), "Cannot process module statements in a script");
                e1.node.sourceType = "script";
                const x = (0, l.default)(e1, t, {
                    importInterop: f,
                    initializeReexports: S,
                    getWrapperPayload: h,
                    esNamespaceOnly: b,
                    filename: T
                });
                if (!s) {
                    (0, a.default)(e1);
                }
                (0, o.default)(e1, x, g);
                if (u !== false) {
                    const t = e1.node.directives.some((e1)=>e1.value.value === "use strict");
                    if (!t) {
                        e1.unshiftContainer("directives", m(y("use strict")));
                    }
                }
                const P = [];
                if ((0, l.hasExports)(x) && !r) {
                    P.push(buildESModuleHeader(x, E));
                }
                const w = buildExportNameListDeclaration(e1, x);
                if (w) {
                    x.exportNameListName = w.name;
                    P.push(w.statement);
                }
                P.push(...buildExportInitializationStatements(e1, x, g, S, v));
                return {
                    meta: x,
                    headers: P
                };
            }
            function ensureStatementsHoisted(e1) {
                e1.forEach((e1)=>{
                    e1._blockHoist = 3;
                });
            }
            function wrapInterop(e1, t, r) {
                if (r === "none") {
                    return null;
                }
                if (r === "node-namespace") {
                    return d(e1.hub.addHelper("interopRequireWildcard"), [
                        t,
                        f(true)
                    ]);
                } else if (r === "node-default") {
                    return null;
                }
                let n;
                if (r === "default") {
                    n = "interopRequireDefault";
                } else if (r === "namespace") {
                    n = "interopRequireWildcard";
                } else {
                    throw new Error(`Unknown interop: ${r}`);
                }
                return d(e1.hub.addHelper(n), [
                    t
                ]);
            }
            function buildNamespaceInitStatements(e1, t, r = false, n = c.wrapReference) {
                var i;
                const a = [];
                const o = b(t.name);
                for (const e1 of t.importsNamespace){
                    if (e1 === t.name) continue;
                    a.push(s.template.statement`var NAME = SOURCE;`({
                        NAME: e1,
                        SOURCE: h(o)
                    }));
                }
                const l = (i = n(o, t.wrap)) != null ? i : o;
                if (r) {
                    a.push(...buildReexportsFromMeta(e1, t, true, n));
                }
                for (const r of t.reexportNamespace){
                    a.push((!s.types.isIdentifier(l) ? s.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          ` : s.template.statement`EXPORTS.NAME = NAMESPACE;`)({
                        EXPORTS: e1.exportName,
                        NAME: r,
                        NAMESPACE: h(l)
                    }));
                }
                if (t.reexportAll) {
                    const n = buildNamespaceReexport(e1, h(l), r);
                    n.loc = t.reexportAll.loc;
                    a.push(n);
                }
                return a;
            }
            const w = {
                constant: s.template.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,
                constantComputed: s.template.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`,
                spec: s.template.statement`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() {
        return NAMESPACE_IMPORT;
      },
    });
    `
            };
            function buildReexportsFromMeta(e1, t, r, n) {
                var s;
                let i = b(t.name);
                i = (s = n(i, t.wrap)) != null ? s : i;
                const { stringSpecifiers: a } = e1;
                return Array.from(t.reexports, ([n, s])=>{
                    let o = h(i);
                    if (s === "default" && t.interop === "node-default") {} else if (a.has(s)) {
                        o = S(o, E(s), true);
                    } else {
                        o = S(o, b(s));
                    }
                    const l = {
                        EXPORTS: e1.exportName,
                        EXPORT_NAME: n,
                        NAMESPACE_IMPORT: o
                    };
                    if (r || T(o)) {
                        if (a.has(n)) {
                            return w.constantComputed(l);
                        } else {
                            return w.constant(l);
                        }
                    } else {
                        return w.spec(l);
                    }
                });
            }
            function buildESModuleHeader(e1, t = false) {
                return (t ? s.template.statement`
        EXPORTS.__esModule = true;
      ` : s.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({
                    EXPORTS: e1.exportName
                });
            }
            function buildNamespaceReexport(e1, t, r) {
                return (r ? s.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : s.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
                    NAMESPACE: t,
                    EXPORTS: e1.exportName,
                    VERIFY_NAME_LIST: e1.exportNameListName ? (0, s.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
                        EXPORTS_LIST: e1.exportNameListName
                    }) : null
                });
            }
            function buildExportNameListDeclaration(e1, t) {
                const r = Object.create(null);
                for (const e1 of t.local.values()){
                    for (const t of e1.names){
                        r[t] = true;
                    }
                }
                let n = false;
                for (const e1 of t.source.values()){
                    for (const t of e1.reexports.keys()){
                        r[t] = true;
                    }
                    for (const t of e1.reexportNamespace){
                        r[t] = true;
                    }
                    n = n || !!e1.reexportAll;
                }
                if (!n || Object.keys(r).length === 0) return null;
                const s = e1.scope.generateUidIdentifier("exportNames");
                delete r.default;
                return {
                    name: s.name,
                    statement: x("var", [
                        P(s, v(r))
                    ])
                };
            }
            function buildExportInitializationStatements(e1, t, r, n = false, s = false) {
                const i = [];
                for (const [e1, r] of t.local){
                    if (r.kind === "import") {} else if (r.kind === "hoisted") {
                        i.push([
                            r.names[0],
                            buildInitStatement(t, r.names, b(e1))
                        ]);
                    } else if (!s) {
                        for (const e1 of r.names){
                            i.push([
                                e1,
                                null
                            ]);
                        }
                    }
                }
                for (const e1 of t.source.values()){
                    if (!n) {
                        const n = buildReexportsFromMeta(t, e1, false, r);
                        const s = [
                            ...e1.reexports.keys()
                        ];
                        for(let e1 = 0; e1 < n.length; e1++){
                            i.push([
                                s[e1],
                                n[e1]
                            ]);
                        }
                    }
                    if (!s) {
                        for (const t of e1.reexportNamespace){
                            i.push([
                                t,
                                null
                            ]);
                        }
                    }
                }
                i.sort(([e1], [t])=>{
                    if (e1 < t) return -1;
                    if (t < e1) return 1;
                    return 0;
                });
                const a = [];
                if (s) {
                    for (const [, e1] of i){
                        a.push(e1);
                    }
                } else {
                    const r = 100;
                    for(let n = 0; n < i.length; n += r){
                        let s = [];
                        for(let o = 0; o < r && n + o < i.length; o++){
                            const [r, l] = i[n + o];
                            if (l !== null) {
                                if (s.length > 0) {
                                    a.push(buildInitStatement(t, s, e1.scope.buildUndefinedNode()));
                                    s = [];
                                }
                                a.push(l);
                            } else {
                                s.push(r);
                            }
                        }
                        if (s.length > 0) {
                            a.push(buildInitStatement(t, s, e1.scope.buildUndefinedNode()));
                        }
                    }
                }
                return a;
            }
            const A = {
                computed: s.template.expression`EXPORTS["NAME"] = VALUE`,
                default: s.template.expression`EXPORTS.NAME = VALUE`
            };
            function buildInitStatement(e1, t, r) {
                const { stringSpecifiers: n, exportName: s } = e1;
                return g(t.reduce((e1, t)=>{
                    const r = {
                        EXPORTS: s,
                        NAME: t,
                        VALUE: e1
                    };
                    if (n.has(t)) {
                        return A.computed(r);
                    } else {
                        return A.default(r);
                    }
                }, r));
            }
        },
        8652: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.toGetWrapperPayload = toGetWrapperPayload;
            t.wrapReference = wrapReference;
            var n = r(3688);
            var s = r(4042);
            function toGetWrapperPayload(e1) {
                return (t, r)=>{
                    if (e1 === false) return null;
                    if ((0, s.isSideEffectImport)(r) || r.reexportAll) return null;
                    if (e1 === true) {
                        return /\./.test(t) ? null : "lazy";
                    }
                    if (Array.isArray(e1)) {
                        return e1.indexOf(t) === -1 ? null : "lazy";
                    }
                    if (typeof e1 === "function") {
                        return e1(t) ? "lazy" : null;
                    }
                    throw new Error(`.lazy must be a boolean, string array, or function`);
                };
            }
            function wrapReference(e1, t) {
                if (t === "lazy") return n.types.callExpression(e1, []);
                return null;
            }
        },
        4042: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = normalizeModuleAndLoadMetadata;
            t.hasExports = hasExports;
            t.isSideEffectImport = isSideEffectImport;
            t.validateImportInteropOption = validateImportInteropOption;
            var n = r(1017);
            var s = r(4975);
            var i = r(4097);
            function hasExports(e1) {
                return e1.hasExports;
            }
            function isSideEffectImport(e1) {
                return e1.imports.size === 0 && e1.importsNamespace.size === 0 && e1.reexports.size === 0 && e1.reexportNamespace.size === 0 && !e1.reexportAll;
            }
            function validateImportInteropOption(e1) {
                if (typeof e1 !== "function" && e1 !== "none" && e1 !== "babel" && e1 !== "node") {
                    throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${e1}).`);
                }
                return e1;
            }
            function resolveImportInterop(e1, t, r) {
                if (typeof e1 === "function") {
                    return validateImportInteropOption(e1(t, r));
                }
                return e1;
            }
            function normalizeModuleAndLoadMetadata(e1, t, { importInterop: r, initializeReexports: n = false, getWrapperPayload: s, esNamespaceOnly: i = false, filename: a }) {
                if (!t) {
                    t = e1.scope.generateUidIdentifier("exports").name;
                }
                const o = new Set;
                nameAnonymousExports(e1);
                const { local: l, sources: c, hasExports: u } = getModuleMetadata(e1, {
                    initializeReexports: n,
                    getWrapperPayload: s
                }, o);
                removeImportExportDeclarations(e1);
                for (const [e1, t] of c){
                    const { importsNamespace: n, imports: s } = t;
                    if (n.size > 0 && s.size === 0) {
                        const [e1] = n;
                        t.name = e1;
                    }
                    const o = resolveImportInterop(r, e1, a);
                    if (o === "none") {
                        t.interop = "none";
                    } else if (o === "node" && t.interop === "namespace") {
                        t.interop = "node-namespace";
                    } else if (o === "node" && t.interop === "default") {
                        t.interop = "node-default";
                    } else if (i && t.interop === "namespace") {
                        t.interop = "default";
                    }
                }
                return {
                    exportName: t,
                    exportNameListName: null,
                    hasExports: u,
                    local: l,
                    source: c,
                    stringSpecifiers: o
                };
            }
            function getExportSpecifierName(e1, t) {
                if (e1.isIdentifier()) {
                    return e1.node.name;
                } else if (e1.isStringLiteral()) {
                    const r = e1.node.value;
                    if (!(0, s.isIdentifierName)(r)) {
                        t.add(r);
                    }
                    return r;
                } else {
                    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${e1.node.type}`);
                }
            }
            function assertExportSpecifier(e1) {
                if (e1.isExportSpecifier()) {
                    return;
                } else if (e1.isExportNamespaceSpecifier()) {
                    throw e1.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.");
                } else {
                    throw e1.buildCodeFrameError("Unexpected export specifier type");
                }
            }
            function getModuleMetadata(e1, { getWrapperPayload: t, initializeReexports: r }, s) {
                const i = getLocalExportMetadata(e1, r, s);
                const a = new Map;
                const o = new Map;
                const getData = (t, r)=>{
                    const s = t.value;
                    let i = o.get(s);
                    if (!i) {
                        i = {
                            name: e1.scope.generateUidIdentifier((0, n.basename)(s, (0, n.extname)(s))).name,
                            interop: "none",
                            loc: null,
                            imports: new Map,
                            importsNamespace: new Set,
                            reexports: new Map,
                            reexportNamespace: new Set,
                            reexportAll: null,
                            wrap: null,
                            get lazy () {
                                return this.wrap === "lazy";
                            },
                            referenced: false
                        };
                        o.set(s, i);
                        a.set(s, [
                            r
                        ]);
                    } else {
                        a.get(s).push(r);
                    }
                    return i;
                };
                let l = false;
                e1.get("body").forEach((e1)=>{
                    if (e1.isImportDeclaration()) {
                        const t = getData(e1.node.source, e1.node);
                        if (!t.loc) t.loc = e1.node.loc;
                        e1.get("specifiers").forEach((e1)=>{
                            if (e1.isImportDefaultSpecifier()) {
                                const r = e1.get("local").node.name;
                                t.imports.set(r, "default");
                                const n = i.get(r);
                                if (n) {
                                    i.delete(r);
                                    n.names.forEach((e1)=>{
                                        t.reexports.set(e1, "default");
                                    });
                                    t.referenced = true;
                                }
                            } else if (e1.isImportNamespaceSpecifier()) {
                                const r = e1.get("local").node.name;
                                t.importsNamespace.add(r);
                                const n = i.get(r);
                                if (n) {
                                    i.delete(r);
                                    n.names.forEach((e1)=>{
                                        t.reexportNamespace.add(e1);
                                    });
                                    t.referenced = true;
                                }
                            } else if (e1.isImportSpecifier()) {
                                const r = getExportSpecifierName(e1.get("imported"), s);
                                const n = e1.get("local").node.name;
                                t.imports.set(n, r);
                                const a = i.get(n);
                                if (a) {
                                    i.delete(n);
                                    a.names.forEach((e1)=>{
                                        t.reexports.set(e1, r);
                                    });
                                    t.referenced = true;
                                }
                            }
                        });
                    } else if (e1.isExportAllDeclaration()) {
                        l = true;
                        const t = getData(e1.node.source, e1.node);
                        if (!t.loc) t.loc = e1.node.loc;
                        t.reexportAll = {
                            loc: e1.node.loc
                        };
                        t.referenced = true;
                    } else if (e1.isExportNamedDeclaration() && e1.node.source) {
                        l = true;
                        const t = getData(e1.node.source, e1.node);
                        if (!t.loc) t.loc = e1.node.loc;
                        e1.get("specifiers").forEach((e1)=>{
                            assertExportSpecifier(e1);
                            const r = getExportSpecifierName(e1.get("local"), s);
                            const n = getExportSpecifierName(e1.get("exported"), s);
                            t.reexports.set(n, r);
                            t.referenced = true;
                            if (n === "__esModule") {
                                throw e1.get("exported").buildCodeFrameError('Illegal export "__esModule".');
                            }
                        });
                    } else if (e1.isExportNamedDeclaration() || e1.isExportDefaultDeclaration()) {
                        l = true;
                    }
                });
                for (const e1 of o.values()){
                    let t = false;
                    let r = false;
                    if (e1.importsNamespace.size > 0) {
                        t = true;
                        r = true;
                    }
                    if (e1.reexportAll) {
                        r = true;
                    }
                    for (const n of e1.imports.values()){
                        if (n === "default") t = true;
                        else r = true;
                    }
                    for (const n of e1.reexports.values()){
                        if (n === "default") t = true;
                        else r = true;
                    }
                    if (t && r) {
                        e1.interop = "namespace";
                    } else if (t) {
                        e1.interop = "default";
                    }
                }
                if (t) {
                    for (const [e1, r] of o){
                        r.wrap = t(e1, r, a.get(e1));
                    }
                }
                return {
                    hasExports: l,
                    local: i,
                    sources: o
                };
            }
            function getLocalExportMetadata(e1, t, r) {
                const n = new Map;
                e1.get("body").forEach((e1)=>{
                    let r;
                    if (e1.isImportDeclaration()) {
                        r = "import";
                    } else {
                        if (e1.isExportDefaultDeclaration()) {
                            e1 = e1.get("declaration");
                        }
                        if (e1.isExportNamedDeclaration()) {
                            if (e1.node.declaration) {
                                e1 = e1.get("declaration");
                            } else if (t && e1.node.source && e1.get("source").isStringLiteral()) {
                                e1.get("specifiers").forEach((e1)=>{
                                    assertExportSpecifier(e1);
                                    n.set(e1.get("local").node.name, "block");
                                });
                                return;
                            }
                        }
                        if (e1.isFunctionDeclaration()) {
                            r = "hoisted";
                        } else if (e1.isClassDeclaration()) {
                            r = "block";
                        } else if (e1.isVariableDeclaration({
                            kind: "var"
                        })) {
                            r = "var";
                        } else if (e1.isVariableDeclaration()) {
                            r = "block";
                        } else {
                            return;
                        }
                    }
                    Object.keys(e1.getOuterBindingIdentifiers()).forEach((e1)=>{
                        n.set(e1, r);
                    });
                });
                const s = new Map;
                const getLocalMetadata = (e1)=>{
                    const t = e1.node.name;
                    let r = s.get(t);
                    if (!r) {
                        const i = n.get(t);
                        if (i === undefined) {
                            throw e1.buildCodeFrameError(`Exporting local "${t}", which is not declared.`);
                        }
                        r = {
                            names: [],
                            kind: i
                        };
                        s.set(t, r);
                    }
                    return r;
                };
                e1.get("body").forEach((e1)=>{
                    if (e1.isExportNamedDeclaration() && (t || !e1.node.source)) {
                        if (e1.node.declaration) {
                            const t = e1.get("declaration");
                            const r = t.getOuterBindingIdentifierPaths();
                            Object.keys(r).forEach((e1)=>{
                                if (e1 === "__esModule") {
                                    throw t.buildCodeFrameError('Illegal export "__esModule".');
                                }
                                getLocalMetadata(r[e1]).names.push(e1);
                            });
                        } else {
                            e1.get("specifiers").forEach((e1)=>{
                                const t = e1.get("local");
                                const n = e1.get("exported");
                                const s = getLocalMetadata(t);
                                const i = getExportSpecifierName(n, r);
                                if (i === "__esModule") {
                                    throw n.buildCodeFrameError('Illegal export "__esModule".');
                                }
                                s.names.push(i);
                            });
                        }
                    } else if (e1.isExportDefaultDeclaration()) {
                        const t = e1.get("declaration");
                        if (t.isFunctionDeclaration() || t.isClassDeclaration()) {
                            getLocalMetadata(t.get("id")).names.push("default");
                        } else {
                            throw t.buildCodeFrameError("Unexpected default expression export.");
                        }
                    }
                });
                return s;
            }
            function nameAnonymousExports(e1) {
                e1.get("body").forEach((e1)=>{
                    if (!e1.isExportDefaultDeclaration()) return;
                    (0, i.default)(e1);
                });
            }
            function removeImportExportDeclarations(e1) {
                e1.get("body").forEach((e1)=>{
                    if (e1.isImportDeclaration()) {
                        e1.remove();
                    } else if (e1.isExportNamedDeclaration()) {
                        if (e1.node.declaration) {
                            e1.node.declaration._blockHoist = e1.node._blockHoist;
                            e1.replaceWith(e1.node.declaration);
                        } else {
                            e1.remove();
                        }
                    } else if (e1.isExportDefaultDeclaration()) {
                        const t = e1.get("declaration");
                        if (t.isFunctionDeclaration() || t.isClassDeclaration()) {
                            t._blockHoist = e1.node._blockHoist;
                            e1.replaceWith(t);
                        } else {
                            throw t.buildCodeFrameError("Unexpected default expression export.");
                        }
                    } else if (e1.isExportAllDeclaration()) {
                        e1.remove();
                    }
                });
            }
        },
        7258: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = rewriteLiveReferences;
            var n = r(9491);
            var s = r(3688);
            var i = r(6118);
            const { assignmentExpression: a, cloneNode: o, expressionStatement: l, getOuterBindingIdentifiers: c, identifier: u, isArrowFunctionExpression: p, isClassExpression: f, isFunctionExpression: d, isIdentifier: h, isMemberExpression: m, isVariableDeclaration: y, jsxIdentifier: g, jsxMemberExpression: b, memberExpression: T, numericLiteral: S, sequenceExpression: E, stringLiteral: v, variableDeclaration: x, variableDeclarator: P } = s.types;
            function isInType(e1) {
                do {
                    switch(e1.parent.type){
                        case "TSTypeAnnotation":
                        case "TSTypeAliasDeclaration":
                        case "TSTypeReference":
                        case "TypeAnnotation":
                        case "TypeAlias":
                            return true;
                        case "ExportSpecifier":
                            return e1.parentPath.parent.exportKind === "type";
                        default:
                            if (e1.parentPath.isStatement() || e1.parentPath.isExpression()) {
                                return false;
                            }
                    }
                }while (e1 = e1.parentPath)
            }
            function rewriteLiveReferences(e1, t, r) {
                const n = new Map;
                const s = new Map;
                const requeueInParent = (t)=>{
                    e1.requeue(t);
                };
                for (const [e1, r] of t.source){
                    for (const [t, s] of r.imports){
                        n.set(t, [
                            e1,
                            s,
                            null
                        ]);
                    }
                    for (const t of r.importsNamespace){
                        n.set(t, [
                            e1,
                            null,
                            t
                        ]);
                    }
                }
                for (const [e1, r] of t.local){
                    let t = s.get(e1);
                    if (!t) {
                        t = [];
                        s.set(e1, t);
                    }
                    t.push(...r.names);
                }
                const a = {
                    metadata: t,
                    requeueInParent: requeueInParent,
                    scope: e1.scope,
                    exported: s
                };
                e1.traverse(w, a);
                const o = new Set([
                    ...Array.from(n.keys()),
                    ...Array.from(s.keys())
                ]);
                {
                    (0, i.default)(e1, o, false);
                }
                const l = {
                    seen: new WeakSet,
                    metadata: t,
                    requeueInParent: requeueInParent,
                    scope: e1.scope,
                    imported: n,
                    exported: s,
                    buildImportReference ([e1, n, s], i) {
                        const a = t.source.get(e1);
                        a.referenced = true;
                        if (s) {
                            if (a.wrap) {
                                var o;
                                i = (o = r(i, a.wrap)) != null ? o : i;
                            }
                            return i;
                        }
                        let l = u(a.name);
                        if (a.wrap) {
                            var c;
                            l = (c = r(l, a.wrap)) != null ? c : l;
                        }
                        if (n === "default" && a.interop === "node-default") {
                            return l;
                        }
                        const p = t.stringSpecifiers.has(n);
                        return T(l, p ? v(n) : u(n), p);
                    }
                };
                e1.traverse(A, l);
            }
            const w = {
                Scope (e1) {
                    e1.skip();
                },
                ClassDeclaration (e1) {
                    const { requeueInParent: t, exported: r, metadata: n } = this;
                    const { id: s } = e1.node;
                    if (!s) throw new Error("Expected class to have a name");
                    const i = s.name;
                    const a = r.get(i) || [];
                    if (a.length > 0) {
                        const r = l(buildBindingExportAssignmentExpression(n, a, u(i), e1.scope));
                        r._blockHoist = e1.node._blockHoist;
                        t(e1.insertAfter(r)[0]);
                    }
                },
                VariableDeclaration (e1) {
                    const { requeueInParent: t, exported: r, metadata: n } = this;
                    const s = e1.node.kind === "var";
                    for (const i of e1.get("declarations")){
                        const { id: a } = i.node;
                        let { init: o } = i.node;
                        if (h(a) && r.has(a.name) && !p(o) && (!d(o) || o.id) && (!f(o) || o.id)) {
                            if (!o) {
                                if (s) {
                                    continue;
                                } else {
                                    o = e1.scope.buildUndefinedNode();
                                }
                            }
                            i.node.init = buildBindingExportAssignmentExpression(n, r.get(a.name), o, e1.scope);
                            t(i.get("init"));
                        } else {
                            for (const s of Object.keys(i.getOuterBindingIdentifiers())){
                                if (r.has(s)) {
                                    const i = l(buildBindingExportAssignmentExpression(n, r.get(s), u(s), e1.scope));
                                    i._blockHoist = e1.node._blockHoist;
                                    t(e1.insertAfter(i)[0]);
                                }
                            }
                        }
                    }
                }
            };
            const buildBindingExportAssignmentExpression = (e1, t, r, n)=>{
                const s = e1.exportName;
                for(let e1 = n; e1 != null; e1 = e1.parent){
                    if (e1.hasOwnBinding(s)) {
                        e1.rename(s);
                    }
                }
                return (t || []).reduce((t, r)=>{
                    const { stringSpecifiers: n } = e1;
                    const i = n.has(r);
                    return a("=", T(u(s), i ? v(r) : u(r), i), t);
                }, r);
            };
            const buildImportThrow = (e1)=>s.template.expression.ast`
    (function() {
      throw new Error('"' + '${e1}' + '" is read-only.');
    })()
  `;
            const A = {
                ReferencedIdentifier (e1) {
                    const { seen: t, buildImportReference: r, scope: n, imported: s, requeueInParent: i } = this;
                    if (t.has(e1.node)) return;
                    t.add(e1.node);
                    const a = e1.node.name;
                    const o = s.get(a);
                    if (o) {
                        if (isInType(e1)) {
                            throw e1.buildCodeFrameError(`Cannot transform the imported binding "${a}" since it's also used in a type annotation. ` + `Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
                        }
                        const t = e1.scope.getBinding(a);
                        const s = n.getBinding(a);
                        if (s !== t) return;
                        const l = r(o, e1.node);
                        l.loc = e1.node.loc;
                        if ((e1.parentPath.isCallExpression({
                            callee: e1.node
                        }) || e1.parentPath.isOptionalCallExpression({
                            callee: e1.node
                        }) || e1.parentPath.isTaggedTemplateExpression({
                            tag: e1.node
                        })) && m(l)) {
                            e1.replaceWith(E([
                                S(0),
                                l
                            ]));
                        } else if (e1.isJSXIdentifier() && m(l)) {
                            const { object: t, property: r } = l;
                            e1.replaceWith(b(g(t.name), g(r.name)));
                        } else {
                            e1.replaceWith(l);
                        }
                        i(e1);
                        e1.skip();
                    }
                },
                UpdateExpression (e1) {
                    const { scope: t, seen: r, imported: n, exported: s, requeueInParent: i, buildImportReference: l } = this;
                    if (r.has(e1.node)) return;
                    r.add(e1.node);
                    const c = e1.get("argument");
                    if (c.isMemberExpression()) return;
                    const p = e1.node;
                    if (c.isIdentifier()) {
                        const r = c.node.name;
                        if (t.getBinding(r) !== e1.scope.getBinding(r)) {
                            return;
                        }
                        const i = s.get(r);
                        const f = n.get(r);
                        if ((i == null ? void 0 : i.length) > 0 || f) {
                            if (f) {
                                e1.replaceWith(a(p.operator[0] + "=", l(f, c.node), buildImportThrow(r)));
                            } else if (p.prefix) {
                                e1.replaceWith(buildBindingExportAssignmentExpression(this.metadata, i, o(p), e1.scope));
                            } else {
                                const n = t.generateDeclaredUidIdentifier(r);
                                e1.replaceWith(E([
                                    a("=", o(n), o(p)),
                                    buildBindingExportAssignmentExpression(this.metadata, i, u(r), e1.scope),
                                    o(n)
                                ]));
                            }
                        }
                    }
                    i(e1);
                    e1.skip();
                },
                AssignmentExpression: {
                    exit (e1) {
                        const { scope: t, seen: r, imported: s, exported: i, requeueInParent: a, buildImportReference: o } = this;
                        if (r.has(e1.node)) return;
                        r.add(e1.node);
                        const c = e1.get("left");
                        if (c.isMemberExpression()) return;
                        if (c.isIdentifier()) {
                            const r = c.node.name;
                            if (t.getBinding(r) !== e1.scope.getBinding(r)) {
                                return;
                            }
                            const l = i.get(r);
                            const u = s.get(r);
                            if ((l == null ? void 0 : l.length) > 0 || u) {
                                n(e1.node.operator === "=", "Path was not simplified");
                                const t = e1.node;
                                if (u) {
                                    t.left = o(u, c.node);
                                    t.right = E([
                                        t.right,
                                        buildImportThrow(r)
                                    ]);
                                }
                                e1.replaceWith(buildBindingExportAssignmentExpression(this.metadata, l, t, e1.scope));
                                a(e1);
                            }
                        } else {
                            const r = c.getOuterBindingIdentifiers();
                            const n = Object.keys(r).filter((r)=>t.getBinding(r) === e1.scope.getBinding(r));
                            const o = n.find((e1)=>s.has(e1));
                            if (o) {
                                e1.node.right = E([
                                    e1.node.right,
                                    buildImportThrow(o)
                                ]);
                            }
                            const p = [];
                            n.forEach((t)=>{
                                const r = i.get(t) || [];
                                if (r.length > 0) {
                                    p.push(buildBindingExportAssignmentExpression(this.metadata, r, u(t), e1.scope));
                                }
                            });
                            if (p.length > 0) {
                                let t = E(p);
                                if (e1.parentPath.isExpressionStatement()) {
                                    t = l(t);
                                    t._blockHoist = e1.parentPath.node._blockHoist;
                                }
                                const r = e1.insertAfter(t)[0];
                                a(r);
                            }
                        }
                    }
                },
                "ForOfStatement|ForInStatement" (e1) {
                    const { scope: t, node: r } = e1;
                    const { left: n } = r;
                    const { exported: s, imported: i, scope: u } = this;
                    if (!y(n)) {
                        let r = false, p;
                        const f = e1.get("body").scope;
                        for (const e1 of Object.keys(c(n))){
                            if (u.getBinding(e1) === t.getBinding(e1)) {
                                if (s.has(e1)) {
                                    r = true;
                                    if (f.hasOwnBinding(e1)) {
                                        f.rename(e1);
                                    }
                                }
                                if (i.has(e1) && !p) {
                                    p = e1;
                                }
                            }
                        }
                        if (!r && !p) {
                            return;
                        }
                        e1.ensureBlock();
                        const d = e1.get("body");
                        const h = t.generateUidIdentifierBasedOnNode(n);
                        e1.get("left").replaceWith(x("let", [
                            P(o(h))
                        ]));
                        t.registerDeclaration(e1.get("left"));
                        if (r) {
                            d.unshiftContainer("body", l(a("=", n, h)));
                        }
                        if (p) {
                            d.unshiftContainer("body", l(buildImportThrow(p)));
                        }
                    }
                }
            };
        },
        2268: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = rewriteThis;
            var n = r(8552);
            var s = r(3688);
            const { numericLiteral: i, unaryExpression: a } = s.types;
            const o = s.traverse.visitors.merge([
                n.default,
                {
                    ThisExpression (e1) {
                        e1.replaceWith(a("void", i(0), true));
                    }
                }
            ]);
            function rewriteThis(e1) {
                (0, s.traverse)(e1.node, Object.assign({}, o, {
                    noScope: true
                }));
            }
        },
        970: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = optimiseCallExpression;
            var n = r(776);
            const { callExpression: s, identifier: i, isIdentifier: a, isSpreadElement: o, memberExpression: l, optionalCallExpression: c, optionalMemberExpression: u } = n;
            function optimiseCallExpression(e1, t, r, n) {
                if (r.length === 1 && o(r[0]) && a(r[0].argument, {
                    name: "arguments"
                })) {
                    if (n) {
                        return c(u(e1, i("apply"), false, true), [
                            t,
                            r[0].argument
                        ], false);
                    }
                    return s(l(e1, i("apply")), [
                        t,
                        r[0].argument
                    ]);
                } else {
                    if (n) {
                        return c(u(e1, i("call"), false, true), [
                            t,
                            ...r
                        ], false);
                    }
                    return s(l(e1, i("call")), [
                        t,
                        ...r
                    ]);
                }
            }
        },
        5389: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.declare = declare;
            t.declarePreset = void 0;
            const r = {
                assertVersion: (e1)=>(t)=>{
                        throwVersionError(t, e1.version);
                    }
            };
            {
                Object.assign(r, {
                    targets: ()=>()=>({}),
                    assumption: ()=>()=>undefined
                });
            }
            function declare(e1) {
                return (t, n, s)=>{
                    var i;
                    let a;
                    for (const e1 of Object.keys(r)){
                        var o;
                        if (t[e1]) continue;
                        (o = a) != null ? o : a = copyApiObject(t);
                        a[e1] = r[e1](a);
                    }
                    return e1((i = a) != null ? i : t, n || {}, s);
                };
            }
            const n = declare;
            t.declarePreset = n;
            function copyApiObject(e1) {
                let t = null;
                if (typeof e1.version === "string" && /^7\./.test(e1.version)) {
                    t = Object.getPrototypeOf(e1);
                    if (t && (!has(t, "version") || !has(t, "transform") || !has(t, "template") || !has(t, "types"))) {
                        t = null;
                    }
                }
                return Object.assign({}, t, e1);
            }
            function has(e1, t) {
                return Object.prototype.hasOwnProperty.call(e1, t);
            }
            function throwVersionError(e1, t) {
                if (typeof e1 === "number") {
                    if (!Number.isInteger(e1)) {
                        throw new Error("Expected string or integer value.");
                    }
                    e1 = `^${e1}.0.0-0`;
                }
                if (typeof e1 !== "string") {
                    throw new Error("Expected string or integer value.");
                }
                const r = Error.stackTraceLimit;
                if (typeof r === "number" && r < 25) {
                    Error.stackTraceLimit = 25;
                }
                let n;
                if (t.slice(0, 2) === "7.") {
                    n = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${t}". ` + `You'll need to update your @babel/core version.`);
                } else {
                    n = new Error(`Requires Babel "${e1}", but was loaded with "${t}". ` + `If you are sure you have a compatible version of @babel/core, ` + `it is likely that something in your build process is loading the ` + `wrong version. Inspect the stack trace of this error to look for ` + `the first entry that doesn't mention "@babel/core" or "babel-core" ` + `to see what is calling Babel.`);
                }
                if (typeof r === "number") {
                    Error.stackTraceLimit = r;
                }
                throw Object.assign(n, {
                    code: "BABEL_VERSION_UNSUPPORTED",
                    version: t,
                    range: e1
                });
            }
        },
        8863: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.declare = declare;
            t.declarePreset = void 0;
            const r = {
                assertVersion: (e1)=>(t)=>{
                        throwVersionError(t, e1.version);
                    }
            };
            {
                Object.assign(r, {
                    targets: ()=>()=>({}),
                    assumption: ()=>()=>undefined
                });
            }
            function declare(e1) {
                return (t, n, s)=>{
                    var i;
                    let a;
                    for (const e1 of Object.keys(r)){
                        var o;
                        if (t[e1]) continue;
                        (o = a) != null ? o : a = copyApiObject(t);
                        a[e1] = r[e1](a);
                    }
                    return e1((i = a) != null ? i : t, n || {}, s);
                };
            }
            const n = t.declarePreset = declare;
            function copyApiObject(e1) {
                let t = null;
                if (typeof e1.version === "string" && /^7\./.test(e1.version)) {
                    t = Object.getPrototypeOf(e1);
                    if (t && (!hasOwnProperty.call(t, "version") || !hasOwnProperty.call(t, "transform") || !hasOwnProperty.call(t, "template") || !hasOwnProperty.call(t, "types"))) {
                        t = null;
                    }
                }
                return Object.assign({}, t, e1);
            }
            function throwVersionError(e1, t) {
                if (typeof e1 === "number") {
                    if (!Number.isInteger(e1)) {
                        throw new Error("Expected string or integer value.");
                    }
                    e1 = `^${e1}.0.0-0`;
                }
                if (typeof e1 !== "string") {
                    throw new Error("Expected string or integer value.");
                }
                const r = Error.stackTraceLimit;
                if (typeof r === "number" && r < 25) {
                    Error.stackTraceLimit = 25;
                }
                let n;
                if (t.slice(0, 2) === "7.") {
                    n = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${t}". ` + `You'll need to update your @babel/core version.`);
                } else {
                    n = new Error(`Requires Babel "${e1}", but was loaded with "${t}". ` + `If you are sure you have a compatible version of @babel/core, ` + `it is likely that something in your build process is loading the ` + `wrong version. Inspect the stack trace of this error to look for ` + `the first entry that doesn't mention "@babel/core" or "babel-core" ` + `to see what is calling Babel.`);
                }
                if (typeof r === "number") {
                    Error.stackTraceLimit = r;
                }
                throw Object.assign(n, {
                    code: "BABEL_VERSION_UNSUPPORTED",
                    version: t,
                    range: e1
                });
            }
        },
        4243: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(3336);
            var s = r(6265);
            var i = r(970);
            var a = r(3688);
            const { assignmentExpression: o, booleanLiteral: l, callExpression: c, cloneNode: u, identifier: p, memberExpression: f, sequenceExpression: d, stringLiteral: h, thisExpression: m } = a.types;
            {
                const e1 = r(3336);
                t.environmentVisitor = e1.default;
                t.skipAllButComputedKey = e1.skipAllButComputedKey;
            }
            function getPrototypeOfExpression(e1, t, r, n) {
                e1 = u(e1);
                const s = t || n ? e1 : f(e1, p("prototype"));
                return c(r.addHelper("getPrototypeOf"), [
                    s
                ]);
            }
            const y = a.traverse.visitors.merge([
                n.default,
                {
                    Super (e1, t) {
                        const { node: r, parentPath: n } = e1;
                        if (!n.isMemberExpression({
                            object: r
                        })) return;
                        t.handle(n);
                    }
                }
            ]);
            const g = a.traverse.visitors.merge([
                n.default,
                {
                    Scopable (e1, { refName: t }) {
                        const r = e1.scope.getOwnBinding(t);
                        if (r && r.identifier.name === t) {
                            e1.scope.rename(t);
                        }
                    }
                }
            ]);
            const b = {
                memoise (e1, t) {
                    const { scope: r, node: n } = e1;
                    const { computed: s, property: i } = n;
                    if (!s) {
                        return;
                    }
                    const a = r.maybeGenerateMemoised(i);
                    if (!a) {
                        return;
                    }
                    this.memoiser.set(i, a, t);
                },
                prop (e1) {
                    const { computed: t, property: r } = e1.node;
                    if (this.memoiser.has(r)) {
                        return u(this.memoiser.get(r));
                    }
                    if (t) {
                        return u(r);
                    }
                    return h(r.name);
                },
                get (e1) {
                    return this._get(e1, this._getThisRefs());
                },
                _get (e1, t) {
                    const r = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
                    return c(this.file.addHelper("get"), [
                        t.needAccessFirst ? d([
                            t.this,
                            r
                        ]) : r,
                        this.prop(e1),
                        t.this
                    ]);
                },
                _getThisRefs () {
                    return {
                        needAccessFirst: this.isDerivedConstructor,
                        this: m()
                    };
                },
                set (e1, t) {
                    const r = this._getThisRefs();
                    const n = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
                    return c(this.file.addHelper("set"), [
                        r.needAccessFirst ? d([
                            r.this,
                            n
                        ]) : n,
                        this.prop(e1),
                        t,
                        r.this,
                        l(e1.isInStrictMode())
                    ]);
                },
                destructureSet (e1) {
                    throw e1.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);
                },
                call (e1, t) {
                    const r = this._getThisRefs();
                    return (0, i.default)(this._get(e1, r), u(r.this), t, false);
                },
                optionalCall (e1, t) {
                    const r = this._getThisRefs();
                    return (0, i.default)(this._get(e1, r), u(r.this), t, true);
                },
                delete (e1) {
                    if (e1.node.computed) {
                        return d([
                            c(this.file.addHelper("toPropertyKey"), [
                                u(e1.node.property)
                            ]),
                            a.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `
                        ]);
                    } else {
                        return a.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
                    }
                }
            };
            const T = Object.assign({}, b, {
                prop (e1) {
                    const { property: t } = e1.node;
                    if (this.memoiser.has(t)) {
                        return u(this.memoiser.get(t));
                    }
                    return u(t);
                },
                get (e1) {
                    const { isStatic: t, getSuperRef: r } = this;
                    const { computed: n } = e1.node;
                    const s = this.prop(e1);
                    let i;
                    if (t) {
                        var a;
                        i = (a = r()) != null ? a : f(p("Function"), p("prototype"));
                    } else {
                        var o;
                        i = f((o = r()) != null ? o : p("Object"), p("prototype"));
                    }
                    return f(i, s, n);
                },
                set (e1, t) {
                    const { computed: r } = e1.node;
                    const n = this.prop(e1);
                    return o("=", f(m(), n, r), t);
                },
                destructureSet (e1) {
                    const { computed: t } = e1.node;
                    const r = this.prop(e1);
                    return f(m(), r, t);
                },
                call (e1, t) {
                    return (0, i.default)(this.get(e1), m(), t, false);
                },
                optionalCall (e1, t) {
                    return (0, i.default)(this.get(e1), m(), t, true);
                }
            });
            class ReplaceSupers {
                constructor(e1){
                    var t;
                    const r = e1.methodPath;
                    this.methodPath = r;
                    this.isDerivedConstructor = r.isClassMethod({
                        kind: "constructor"
                    }) && !!e1.superRef;
                    this.isStatic = r.isObjectMethod() || r.node.static || (r.isStaticBlock == null ? void 0 : r.isStaticBlock());
                    this.isPrivateMethod = r.isPrivate() && r.isMethod();
                    this.file = e1.file;
                    this.constantSuper = (t = e1.constantSuper) != null ? t : e1.isLoose;
                    this.opts = e1;
                }
                getObjectRef() {
                    return u(this.opts.objectRef || this.opts.getObjectRef());
                }
                getSuperRef() {
                    if (this.opts.superRef) return u(this.opts.superRef);
                    if (this.opts.getSuperRef) {
                        return u(this.opts.getSuperRef());
                    }
                }
                replace() {
                    const { methodPath: e1 } = this;
                    if (this.opts.refToPreserve) {
                        e1.traverse(g, {
                            refName: this.opts.refToPreserve.name
                        });
                    }
                    const t = this.constantSuper ? T : b;
                    y.shouldSkip = (t)=>{
                        if (t.parentPath === e1) {
                            if (t.parentKey === "decorators" || t.parentKey === "key") {
                                return true;
                            }
                        }
                    };
                    (0, s.default)(e1, y, Object.assign({
                        file: this.file,
                        scope: this.methodPath.scope,
                        isDerivedConstructor: this.isDerivedConstructor,
                        isStatic: this.isStatic,
                        isPrivateMethod: this.isPrivateMethod,
                        getObjectRef: this.getObjectRef.bind(this),
                        getSuperRef: this.getSuperRef.bind(this),
                        boundGet: t.get
                    }, t));
                }
            }
            t["default"] = ReplaceSupers;
        },
        6118: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = simplifyAccess;
            var n = r(776);
            const { LOGICAL_OPERATORS: s, assignmentExpression: i, binaryExpression: a, cloneNode: o, identifier: l, logicalExpression: c, numericLiteral: u, sequenceExpression: p, unaryExpression: f } = n;
            const d = {
                AssignmentExpression: {
                    exit (e1) {
                        const { scope: t, seen: r, bindingNames: n } = this;
                        if (e1.node.operator === "=") return;
                        if (r.has(e1.node)) return;
                        r.add(e1.node);
                        const l = e1.get("left");
                        if (!l.isIdentifier()) return;
                        const u = l.node.name;
                        if (!n.has(u)) return;
                        if (t.getBinding(u) !== e1.scope.getBinding(u)) {
                            return;
                        }
                        const p = e1.node.operator.slice(0, -1);
                        if (s.includes(p)) {
                            e1.replaceWith(c(p, e1.node.left, i("=", o(e1.node.left), e1.node.right)));
                        } else {
                            e1.node.right = a(p, o(e1.node.left), e1.node.right);
                            e1.node.operator = "=";
                        }
                    }
                }
            };
            {
                d.UpdateExpression = {
                    exit (e1) {
                        if (!this.includeUpdateExpression) return;
                        const { scope: t, bindingNames: r } = this;
                        const n = e1.get("argument");
                        if (!n.isIdentifier()) return;
                        const s = n.node.name;
                        if (!r.has(s)) return;
                        if (t.getBinding(s) !== e1.scope.getBinding(s)) {
                            return;
                        }
                        if (e1.parentPath.isExpressionStatement() && !e1.isCompletionRecord()) {
                            const t = e1.node.operator == "++" ? "+=" : "-=";
                            e1.replaceWith(i(t, n.node, u(1)));
                        } else if (e1.node.prefix) {
                            e1.replaceWith(i("=", l(s), a(e1.node.operator[0], f("+", n.node), u(1))));
                        } else {
                            const t = e1.scope.generateUidIdentifierBasedOnNode(n.node, "old");
                            const r = t.name;
                            e1.scope.push({
                                id: t
                            });
                            const s = a(e1.node.operator[0], l(r), u(1));
                            e1.replaceWith(p([
                                i("=", l(r), f("+", n.node)),
                                i("=", o(n.node), s),
                                l(r)
                            ]));
                        }
                    }
                };
            }
            function simplifyAccess(e1, t) {
                {
                    var r;
                    e1.traverse(d, {
                        scope: e1.scope,
                        bindingNames: t,
                        seen: new WeakSet,
                        includeUpdateExpression: (r = arguments[2]) != null ? r : true
                    });
                }
            }
        },
        9382: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isTransparentExprWrapper = isTransparentExprWrapper;
            t.skipTransparentExprWrapperNodes = skipTransparentExprWrapperNodes;
            t.skipTransparentExprWrappers = skipTransparentExprWrappers;
            var n = r(776);
            const { isParenthesizedExpression: s, isTSAsExpression: i, isTSNonNullExpression: a, isTSSatisfiesExpression: o, isTSTypeAssertion: l, isTypeCastExpression: c } = n;
            function isTransparentExprWrapper(e1) {
                return i(e1) || o(e1) || l(e1) || a(e1) || c(e1) || s(e1);
            }
            function skipTransparentExprWrappers(e1) {
                while(isTransparentExprWrapper(e1.node)){
                    e1 = e1.get("expression");
                }
                return e1;
            }
            function skipTransparentExprWrapperNodes(e1) {
                while(isTransparentExprWrapper(e1)){
                    e1 = e1.expression;
                }
                return e1;
            }
        },
        4097: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = splitExportDeclaration;
            var n = r(776);
            const { cloneNode: s, exportNamedDeclaration: i, exportSpecifier: a, identifier: o, variableDeclaration: l, variableDeclarator: c } = n;
            function splitExportDeclaration(e1) {
                if (!e1.isExportDeclaration() || e1.isExportAllDeclaration()) {
                    throw new Error("Only default and named export declarations can be split.");
                }
                if (e1.isExportDefaultDeclaration()) {
                    const t = e1.get("declaration");
                    const r = t.isFunctionDeclaration() || t.isClassDeclaration();
                    const n = t.isFunctionExpression() || t.isClassExpression();
                    const u = t.isScope() ? t.scope.parent : t.scope;
                    let p = t.node.id;
                    let f = false;
                    if (!p) {
                        f = true;
                        p = u.generateUidIdentifier("default");
                        if (r || n) {
                            t.node.id = s(p);
                        }
                    } else if (n && u.hasBinding(p.name)) {
                        f = true;
                        p = u.generateUidIdentifier(p.name);
                    }
                    const d = r ? t.node : l("var", [
                        c(s(p), t.node)
                    ]);
                    const h = i(null, [
                        a(s(p), o("default"))
                    ]);
                    e1.insertAfter(h);
                    e1.replaceWith(d);
                    if (f) {
                        u.registerDeclaration(e1);
                    }
                    return e1;
                } else if (e1.get("specifiers").length > 0) {
                    throw new Error("It doesn't make sense to split exported specifiers.");
                }
                const t = e1.get("declaration");
                const r = t.getOuterBindingIdentifiers();
                const n = Object.keys(r).map((e1)=>a(o(e1), o(e1)));
                const u = i(null, n);
                e1.insertAfter(u);
                e1.replaceWith(t.node);
                return e1;
            }
        },
        9053: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = splitExportDeclaration;
            var n = r(776);
            const { cloneNode: s, exportNamedDeclaration: i, exportSpecifier: a, identifier: o, variableDeclaration: l, variableDeclarator: c } = n;
            function splitExportDeclaration(e1) {
                if (!e1.isExportDeclaration() || e1.isExportAllDeclaration()) {
                    throw new Error("Only default and named export declarations can be split.");
                }
                if (e1.isExportDefaultDeclaration()) {
                    const t = e1.get("declaration");
                    const r = t.isFunctionDeclaration() || t.isClassDeclaration();
                    const n = t.isFunctionExpression() || t.isClassExpression();
                    const u = t.isScope() ? t.scope.parent : t.scope;
                    let p = t.node.id;
                    let f = false;
                    if (!p) {
                        f = true;
                        p = u.generateUidIdentifier("default");
                        if (r || n) {
                            t.node.id = s(p);
                        }
                    } else if (n && u.hasBinding(p.name)) {
                        f = true;
                        p = u.generateUidIdentifier(p.name);
                    }
                    const d = r ? t.node : l("var", [
                        c(s(p), t.node)
                    ]);
                    const h = i(null, [
                        a(s(p), o("default"))
                    ]);
                    e1.insertAfter(h);
                    e1.replaceWith(d);
                    if (f) {
                        u.registerDeclaration(e1);
                    }
                    return e1;
                } else if (e1.get("specifiers").length > 0) {
                    throw new Error("It doesn't make sense to split exported specifiers.");
                }
                const t = e1.get("declaration");
                const r = t.getOuterBindingIdentifiers();
                const n = Object.keys(r).map((e1)=>a(o(e1), o(e1)));
                const u = i(null, n);
                e1.insertAfter(u);
                e1.replaceWith(t.node);
                return e1;
            }
        },
        6476: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.readCodePoint = readCodePoint;
            t.readInt = readInt;
            t.readStringContents = readStringContents;
            var r = function isDigit(e1) {
                return e1 >= 48 && e1 <= 57;
            };
            const n = {
                decBinOct: new Set([
                    46,
                    66,
                    69,
                    79,
                    95,
                    98,
                    101,
                    111
                ]),
                hex: new Set([
                    46,
                    88,
                    95,
                    120
                ])
            };
            const s = {
                bin: (e1)=>e1 === 48 || e1 === 49,
                oct: (e1)=>e1 >= 48 && e1 <= 55,
                dec: (e1)=>e1 >= 48 && e1 <= 57,
                hex: (e1)=>e1 >= 48 && e1 <= 57 || e1 >= 65 && e1 <= 70 || e1 >= 97 && e1 <= 102
            };
            function readStringContents(e1, t, r, n, s, i) {
                const a = r;
                const o = n;
                const l = s;
                let c = "";
                let u = null;
                let p = r;
                const { length: f } = t;
                for(;;){
                    if (r >= f) {
                        i.unterminated(a, o, l);
                        c += t.slice(p, r);
                        break;
                    }
                    const d = t.charCodeAt(r);
                    if (isStringEnd(e1, d, t, r)) {
                        c += t.slice(p, r);
                        break;
                    }
                    if (d === 92) {
                        c += t.slice(p, r);
                        const a = readEscapedChar(t, r, n, s, e1 === "template", i);
                        if (a.ch === null && !u) {
                            u = {
                                pos: r,
                                lineStart: n,
                                curLine: s
                            };
                        } else {
                            c += a.ch;
                        }
                        ({ pos: r, lineStart: n, curLine: s } = a);
                        p = r;
                    } else if (d === 8232 || d === 8233) {
                        ++r;
                        ++s;
                        n = r;
                    } else if (d === 10 || d === 13) {
                        if (e1 === "template") {
                            c += t.slice(p, r) + "\n";
                            ++r;
                            if (d === 13 && t.charCodeAt(r) === 10) {
                                ++r;
                            }
                            ++s;
                            p = n = r;
                        } else {
                            i.unterminated(a, o, l);
                        }
                    } else {
                        ++r;
                    }
                }
                return {
                    pos: r,
                    str: c,
                    firstInvalidLoc: u,
                    lineStart: n,
                    curLine: s,
                    containsInvalid: !!u
                };
            }
            function isStringEnd(e1, t, r, n) {
                if (e1 === "template") {
                    return t === 96 || t === 36 && r.charCodeAt(n + 1) === 123;
                }
                return t === (e1 === "double" ? 34 : 39);
            }
            function readEscapedChar(e1, t, r, n, s, i) {
                const a = !s;
                t++;
                const res = (e1)=>({
                        pos: t,
                        ch: e1,
                        lineStart: r,
                        curLine: n
                    });
                const o = e1.charCodeAt(t++);
                switch(o){
                    case 110:
                        return res("\n");
                    case 114:
                        return res("\r");
                    case 120:
                        {
                            let s;
                            ({ code: s, pos: t } = readHexChar(e1, t, r, n, 2, false, a, i));
                            return res(s === null ? null : String.fromCharCode(s));
                        }
                    case 117:
                        {
                            let s;
                            ({ code: s, pos: t } = readCodePoint(e1, t, r, n, a, i));
                            return res(s === null ? null : String.fromCodePoint(s));
                        }
                    case 116:
                        return res("\t");
                    case 98:
                        return res("\b");
                    case 118:
                        return res("\v");
                    case 102:
                        return res("\f");
                    case 13:
                        if (e1.charCodeAt(t) === 10) {
                            ++t;
                        }
                    case 10:
                        r = t;
                        ++n;
                    case 8232:
                    case 8233:
                        return res("");
                    case 56:
                    case 57:
                        if (s) {
                            return res(null);
                        } else {
                            i.strictNumericEscape(t - 1, r, n);
                        }
                    default:
                        if (o >= 48 && o <= 55) {
                            const a = t - 1;
                            const o = e1.slice(a, t + 2).match(/^[0-7]+/);
                            let l = o[0];
                            let c = parseInt(l, 8);
                            if (c > 255) {
                                l = l.slice(0, -1);
                                c = parseInt(l, 8);
                            }
                            t += l.length - 1;
                            const u = e1.charCodeAt(t);
                            if (l !== "0" || u === 56 || u === 57) {
                                if (s) {
                                    return res(null);
                                } else {
                                    i.strictNumericEscape(a, r, n);
                                }
                            }
                            return res(String.fromCharCode(c));
                        }
                        return res(String.fromCharCode(o));
                }
            }
            function readHexChar(e1, t, r, n, s, i, a, o) {
                const l = t;
                let c;
                ({ n: c, pos: t } = readInt(e1, t, r, n, 16, s, i, false, o, !a));
                if (c === null) {
                    if (a) {
                        o.invalidEscapeSequence(l, r, n);
                    } else {
                        t = l - 1;
                    }
                }
                return {
                    code: c,
                    pos: t
                };
            }
            function readInt(e1, t, i, a, o, l, c, u, p, f) {
                const d = t;
                const h = o === 16 ? n.hex : n.decBinOct;
                const m = o === 16 ? s.hex : o === 10 ? s.dec : o === 8 ? s.oct : s.bin;
                let y = false;
                let g = 0;
                for(let n = 0, s = l == null ? Infinity : l; n < s; ++n){
                    const n = e1.charCodeAt(t);
                    let s;
                    if (n === 95 && u !== "bail") {
                        const r = e1.charCodeAt(t - 1);
                        const n = e1.charCodeAt(t + 1);
                        if (!u) {
                            if (f) return {
                                n: null,
                                pos: t
                            };
                            p.numericSeparatorInEscapeSequence(t, i, a);
                        } else if (Number.isNaN(n) || !m(n) || h.has(r) || h.has(n)) {
                            if (f) return {
                                n: null,
                                pos: t
                            };
                            p.unexpectedNumericSeparator(t, i, a);
                        }
                        ++t;
                        continue;
                    }
                    if (n >= 97) {
                        s = n - 97 + 10;
                    } else if (n >= 65) {
                        s = n - 65 + 10;
                    } else if (r(n)) {
                        s = n - 48;
                    } else {
                        s = Infinity;
                    }
                    if (s >= o) {
                        if (s <= 9 && f) {
                            return {
                                n: null,
                                pos: t
                            };
                        } else if (s <= 9 && p.invalidDigit(t, i, a, o)) {
                            s = 0;
                        } else if (c) {
                            s = 0;
                            y = true;
                        } else {
                            break;
                        }
                    }
                    ++t;
                    g = g * o + s;
                }
                if (t === d || l != null && t - d !== l || y) {
                    return {
                        n: null,
                        pos: t
                    };
                }
                return {
                    n: g,
                    pos: t
                };
            }
            function readCodePoint(e1, t, r, n, s, i) {
                const a = e1.charCodeAt(t);
                let o;
                if (a === 123) {
                    ++t;
                    ({ code: o, pos: t } = readHexChar(e1, t, r, n, e1.indexOf("}", t) - t, true, s, i));
                    ++t;
                    if (o !== null && o > 1114111) {
                        if (s) {
                            i.invalidCodePoint(t, r, n);
                        } else {
                            return {
                                code: null,
                                pos: t
                            };
                        }
                    }
                } else {
                    ({ code: o, pos: t } = readHexChar(e1, t, r, n, 4, false, s, i));
                }
                return {
                    code: o,
                    pos: t
                };
            }
        },
        4387: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isIdentifierChar = isIdentifierChar;
            t.isIdentifierName = isIdentifierName;
            t.isIdentifierStart = isIdentifierStart;
            let r = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
            let n = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
            const s = new RegExp("[" + r + "]");
            const i = new RegExp("[" + r + n + "]");
            r = n = null;
            const a = [
                0,
                11,
                2,
                25,
                2,
                18,
                2,
                1,
                2,
                14,
                3,
                13,
                35,
                122,
                70,
                52,
                268,
                28,
                4,
                48,
                48,
                31,
                14,
                29,
                6,
                37,
                11,
                29,
                3,
                35,
                5,
                7,
                2,
                4,
                43,
                157,
                19,
                35,
                5,
                35,
                5,
                39,
                9,
                51,
                13,
                10,
                2,
                14,
                2,
                6,
                2,
                1,
                2,
                10,
                2,
                14,
                2,
                6,
                2,
                1,
                68,
                310,
                10,
                21,
                11,
                7,
                25,
                5,
                2,
                41,
                2,
                8,
                70,
                5,
                3,
                0,
                2,
                43,
                2,
                1,
                4,
                0,
                3,
                22,
                11,
                22,
                10,
                30,
                66,
                18,
                2,
                1,
                11,
                21,
                11,
                25,
                71,
                55,
                7,
                1,
                65,
                0,
                16,
                3,
                2,
                2,
                2,
                28,
                43,
                28,
                4,
                28,
                36,
                7,
                2,
                27,
                28,
                53,
                11,
                21,
                11,
                18,
                14,
                17,
                111,
                72,
                56,
                50,
                14,
                50,
                14,
                35,
                349,
                41,
                7,
                1,
                79,
                28,
                11,
                0,
                9,
                21,
                43,
                17,
                47,
                20,
                28,
                22,
                13,
                52,
                58,
                1,
                3,
                0,
                14,
                44,
                33,
                24,
                27,
                35,
                30,
                0,
                3,
                0,
                9,
                34,
                4,
                0,
                13,
                47,
                15,
                3,
                22,
                0,
                2,
                0,
                36,
                17,
                2,
                24,
                20,
                1,
                64,
                6,
                2,
                0,
                2,
                3,
                2,
                14,
                2,
                9,
                8,
                46,
                39,
                7,
                3,
                1,
                3,
                21,
                2,
                6,
                2,
                1,
                2,
                4,
                4,
                0,
                19,
                0,
                13,
                4,
                159,
                52,
                19,
                3,
                21,
                2,
                31,
                47,
                21,
                1,
                2,
                0,
                185,
                46,
                42,
                3,
                37,
                47,
                21,
                0,
                60,
                42,
                14,
                0,
                72,
                26,
                38,
                6,
                186,
                43,
                117,
                63,
                32,
                7,
                3,
                0,
                3,
                7,
                2,
                1,
                2,
                23,
                16,
                0,
                2,
                0,
                95,
                7,
                3,
                38,
                17,
                0,
                2,
                0,
                29,
                0,
                11,
                39,
                8,
                0,
                22,
                0,
                12,
                45,
                20,
                0,
                19,
                72,
                264,
                8,
                2,
                36,
                18,
                0,
                50,
                29,
                113,
                6,
                2,
                1,
                2,
                37,
                22,
                0,
                26,
                5,
                2,
                1,
                2,
                31,
                15,
                0,
                328,
                18,
                16,
                0,
                2,
                12,
                2,
                33,
                125,
                0,
                80,
                921,
                103,
                110,
                18,
                195,
                2637,
                96,
                16,
                1071,
                18,
                5,
                4026,
                582,
                8634,
                568,
                8,
                30,
                18,
                78,
                18,
                29,
                19,
                47,
                17,
                3,
                32,
                20,
                6,
                18,
                689,
                63,
                129,
                74,
                6,
                0,
                67,
                12,
                65,
                1,
                2,
                0,
                29,
                6135,
                9,
                1237,
                43,
                8,
                8936,
                3,
                2,
                6,
                2,
                1,
                2,
                290,
                16,
                0,
                30,
                2,
                3,
                0,
                15,
                3,
                9,
                395,
                2309,
                106,
                6,
                12,
                4,
                8,
                8,
                9,
                5991,
                84,
                2,
                70,
                2,
                1,
                3,
                0,
                3,
                1,
                3,
                3,
                2,
                11,
                2,
                0,
                2,
                6,
                2,
                64,
                2,
                3,
                3,
                7,
                2,
                6,
                2,
                27,
                2,
                3,
                2,
                4,
                2,
                0,
                4,
                6,
                2,
                339,
                3,
                24,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                7,
                1845,
                30,
                7,
                5,
                262,
                61,
                147,
                44,
                11,
                6,
                17,
                0,
                322,
                29,
                19,
                43,
                485,
                27,
                757,
                6,
                2,
                3,
                2,
                1,
                2,
                14,
                2,
                196,
                60,
                67,
                8,
                0,
                1205,
                3,
                2,
                26,
                2,
                1,
                2,
                0,
                3,
                0,
                2,
                9,
                2,
                3,
                2,
                0,
                2,
                0,
                7,
                0,
                5,
                0,
                2,
                0,
                2,
                0,
                2,
                2,
                2,
                1,
                2,
                0,
                3,
                0,
                2,
                0,
                2,
                0,
                2,
                0,
                2,
                0,
                2,
                1,
                2,
                0,
                3,
                3,
                2,
                6,
                2,
                3,
                2,
                3,
                2,
                0,
                2,
                9,
                2,
                16,
                6,
                2,
                2,
                4,
                2,
                16,
                4421,
                42719,
                33,
                4153,
                7,
                221,
                3,
                5761,
                15,
                7472,
                16,
                621,
                2467,
                541,
                1507,
                4938,
                6,
                4191
            ];
            const o = [
                509,
                0,
                227,
                0,
                150,
                4,
                294,
                9,
                1368,
                2,
                2,
                1,
                6,
                3,
                41,
                2,
                5,
                0,
                166,
                1,
                574,
                3,
                9,
                9,
                370,
                1,
                81,
                2,
                71,
                10,
                50,
                3,
                123,
                2,
                54,
                14,
                32,
                10,
                3,
                1,
                11,
                3,
                46,
                10,
                8,
                0,
                46,
                9,
                7,
                2,
                37,
                13,
                2,
                9,
                6,
                1,
                45,
                0,
                13,
                2,
                49,
                13,
                9,
                3,
                2,
                11,
                83,
                11,
                7,
                0,
                3,
                0,
                158,
                11,
                6,
                9,
                7,
                3,
                56,
                1,
                2,
                6,
                3,
                1,
                3,
                2,
                10,
                0,
                11,
                1,
                3,
                6,
                4,
                4,
                193,
                17,
                10,
                9,
                5,
                0,
                82,
                19,
                13,
                9,
                214,
                6,
                3,
                8,
                28,
                1,
                83,
                16,
                16,
                9,
                82,
                12,
                9,
                9,
                84,
                14,
                5,
                9,
                243,
                14,
                166,
                9,
                71,
                5,
                2,
                1,
                3,
                3,
                2,
                0,
                2,
                1,
                13,
                9,
                120,
                6,
                3,
                6,
                4,
                0,
                29,
                9,
                41,
                6,
                2,
                3,
                9,
                0,
                10,
                10,
                47,
                15,
                406,
                7,
                2,
                7,
                17,
                9,
                57,
                21,
                2,
                13,
                123,
                5,
                4,
                0,
                2,
                1,
                2,
                6,
                2,
                0,
                9,
                9,
                49,
                4,
                2,
                1,
                2,
                4,
                9,
                9,
                330,
                3,
                10,
                1,
                2,
                0,
                49,
                6,
                4,
                4,
                14,
                9,
                5351,
                0,
                7,
                14,
                13835,
                9,
                87,
                9,
                39,
                4,
                60,
                6,
                26,
                9,
                1014,
                0,
                2,
                54,
                8,
                3,
                82,
                0,
                12,
                1,
                19628,
                1,
                4706,
                45,
                3,
                22,
                543,
                4,
                4,
                5,
                9,
                7,
                3,
                6,
                31,
                3,
                149,
                2,
                1418,
                49,
                513,
                54,
                5,
                49,
                9,
                0,
                15,
                0,
                23,
                4,
                2,
                14,
                1361,
                6,
                2,
                16,
                3,
                6,
                2,
                1,
                2,
                4,
                101,
                0,
                161,
                6,
                10,
                9,
                357,
                0,
                62,
                13,
                499,
                13,
                983,
                6,
                110,
                6,
                6,
                9,
                4759,
                9,
                787719,
                239
            ];
            function isInAstralSet(e1, t) {
                let r = 65536;
                for(let n = 0, s = t.length; n < s; n += 2){
                    r += t[n];
                    if (r > e1) return false;
                    r += t[n + 1];
                    if (r >= e1) return true;
                }
                return false;
            }
            function isIdentifierStart(e1) {
                if (e1 < 65) return e1 === 36;
                if (e1 <= 90) return true;
                if (e1 < 97) return e1 === 95;
                if (e1 <= 122) return true;
                if (e1 <= 65535) {
                    return e1 >= 170 && s.test(String.fromCharCode(e1));
                }
                return isInAstralSet(e1, a);
            }
            function isIdentifierChar(e1) {
                if (e1 < 48) return e1 === 36;
                if (e1 < 58) return true;
                if (e1 < 65) return false;
                if (e1 <= 90) return true;
                if (e1 < 97) return e1 === 95;
                if (e1 <= 122) return true;
                if (e1 <= 65535) {
                    return e1 >= 170 && i.test(String.fromCharCode(e1));
                }
                return isInAstralSet(e1, a) || isInAstralSet(e1, o);
            }
            function isIdentifierName(e1) {
                let t = true;
                for(let r = 0; r < e1.length; r++){
                    let n = e1.charCodeAt(r);
                    if ((n & 64512) === 55296 && r + 1 < e1.length) {
                        const t = e1.charCodeAt(++r);
                        if ((t & 64512) === 56320) {
                            n = 65536 + ((n & 1023) << 10) + (t & 1023);
                        }
                    }
                    if (t) {
                        t = false;
                        if (!isIdentifierStart(n)) {
                            return false;
                        }
                    } else if (!isIdentifierChar(n)) {
                        return false;
                    }
                }
                return !t;
            }
        },
        4975: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "isIdentifierChar", {
                enumerable: true,
                get: function() {
                    return n.isIdentifierChar;
                }
            });
            Object.defineProperty(t, "isIdentifierName", {
                enumerable: true,
                get: function() {
                    return n.isIdentifierName;
                }
            });
            Object.defineProperty(t, "isIdentifierStart", {
                enumerable: true,
                get: function() {
                    return n.isIdentifierStart;
                }
            });
            Object.defineProperty(t, "isKeyword", {
                enumerable: true,
                get: function() {
                    return s.isKeyword;
                }
            });
            Object.defineProperty(t, "isReservedWord", {
                enumerable: true,
                get: function() {
                    return s.isReservedWord;
                }
            });
            Object.defineProperty(t, "isStrictBindOnlyReservedWord", {
                enumerable: true,
                get: function() {
                    return s.isStrictBindOnlyReservedWord;
                }
            });
            Object.defineProperty(t, "isStrictBindReservedWord", {
                enumerable: true,
                get: function() {
                    return s.isStrictBindReservedWord;
                }
            });
            Object.defineProperty(t, "isStrictReservedWord", {
                enumerable: true,
                get: function() {
                    return s.isStrictReservedWord;
                }
            });
            var n = r(4387);
            var s = r(4348);
        },
        4348: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isKeyword = isKeyword;
            t.isReservedWord = isReservedWord;
            t.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
            t.isStrictBindReservedWord = isStrictBindReservedWord;
            t.isStrictReservedWord = isStrictReservedWord;
            const r = {
                keyword: [
                    "break",
                    "case",
                    "catch",
                    "continue",
                    "debugger",
                    "default",
                    "do",
                    "else",
                    "finally",
                    "for",
                    "function",
                    "if",
                    "return",
                    "switch",
                    "throw",
                    "try",
                    "var",
                    "const",
                    "while",
                    "with",
                    "new",
                    "this",
                    "super",
                    "class",
                    "extends",
                    "export",
                    "import",
                    "null",
                    "true",
                    "false",
                    "in",
                    "instanceof",
                    "typeof",
                    "void",
                    "delete"
                ],
                strict: [
                    "implements",
                    "interface",
                    "let",
                    "package",
                    "private",
                    "protected",
                    "public",
                    "static",
                    "yield"
                ],
                strictBind: [
                    "eval",
                    "arguments"
                ]
            };
            const n = new Set(r.keyword);
            const s = new Set(r.strict);
            const i = new Set(r.strictBind);
            function isReservedWord(e1, t) {
                return t && e1 === "await" || e1 === "enum";
            }
            function isStrictReservedWord(e1, t) {
                return isReservedWord(e1, t) || s.has(e1);
            }
            function isStrictBindOnlyReservedWord(e1) {
                return i.has(e1);
            }
            function isStrictBindReservedWord(e1, t) {
                return isStrictReservedWord(e1, t) || isStrictBindOnlyReservedWord(e1);
            }
            function isKeyword(e1) {
                return n.has(e1);
            }
        },
        2916: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isIdentifierChar = isIdentifierChar;
            t.isIdentifierName = isIdentifierName;
            t.isIdentifierStart = isIdentifierStart;
            let r = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
            let n = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
            const s = new RegExp("[" + r + "]");
            const i = new RegExp("[" + r + n + "]");
            r = n = null;
            const a = [
                0,
                11,
                2,
                25,
                2,
                18,
                2,
                1,
                2,
                14,
                3,
                13,
                35,
                122,
                70,
                52,
                268,
                28,
                4,
                48,
                48,
                31,
                14,
                29,
                6,
                37,
                11,
                29,
                3,
                35,
                5,
                7,
                2,
                4,
                43,
                157,
                19,
                35,
                5,
                35,
                5,
                39,
                9,
                51,
                13,
                10,
                2,
                14,
                2,
                6,
                2,
                1,
                2,
                10,
                2,
                14,
                2,
                6,
                2,
                1,
                68,
                310,
                10,
                21,
                11,
                7,
                25,
                5,
                2,
                41,
                2,
                8,
                70,
                5,
                3,
                0,
                2,
                43,
                2,
                1,
                4,
                0,
                3,
                22,
                11,
                22,
                10,
                30,
                66,
                18,
                2,
                1,
                11,
                21,
                11,
                25,
                71,
                55,
                7,
                1,
                65,
                0,
                16,
                3,
                2,
                2,
                2,
                28,
                43,
                28,
                4,
                28,
                36,
                7,
                2,
                27,
                28,
                53,
                11,
                21,
                11,
                18,
                14,
                17,
                111,
                72,
                56,
                50,
                14,
                50,
                14,
                35,
                349,
                41,
                7,
                1,
                79,
                28,
                11,
                0,
                9,
                21,
                43,
                17,
                47,
                20,
                28,
                22,
                13,
                52,
                58,
                1,
                3,
                0,
                14,
                44,
                33,
                24,
                27,
                35,
                30,
                0,
                3,
                0,
                9,
                34,
                4,
                0,
                13,
                47,
                15,
                3,
                22,
                0,
                2,
                0,
                36,
                17,
                2,
                24,
                20,
                1,
                64,
                6,
                2,
                0,
                2,
                3,
                2,
                14,
                2,
                9,
                8,
                46,
                39,
                7,
                3,
                1,
                3,
                21,
                2,
                6,
                2,
                1,
                2,
                4,
                4,
                0,
                19,
                0,
                13,
                4,
                159,
                52,
                19,
                3,
                21,
                2,
                31,
                47,
                21,
                1,
                2,
                0,
                185,
                46,
                42,
                3,
                37,
                47,
                21,
                0,
                60,
                42,
                14,
                0,
                72,
                26,
                38,
                6,
                186,
                43,
                117,
                63,
                32,
                7,
                3,
                0,
                3,
                7,
                2,
                1,
                2,
                23,
                16,
                0,
                2,
                0,
                95,
                7,
                3,
                38,
                17,
                0,
                2,
                0,
                29,
                0,
                11,
                39,
                8,
                0,
                22,
                0,
                12,
                45,
                20,
                0,
                19,
                72,
                264,
                8,
                2,
                36,
                18,
                0,
                50,
                29,
                113,
                6,
                2,
                1,
                2,
                37,
                22,
                0,
                26,
                5,
                2,
                1,
                2,
                31,
                15,
                0,
                328,
                18,
                16,
                0,
                2,
                12,
                2,
                33,
                125,
                0,
                80,
                921,
                103,
                110,
                18,
                195,
                2637,
                96,
                16,
                1071,
                18,
                5,
                4026,
                582,
                8634,
                568,
                8,
                30,
                18,
                78,
                18,
                29,
                19,
                47,
                17,
                3,
                32,
                20,
                6,
                18,
                689,
                63,
                129,
                74,
                6,
                0,
                67,
                12,
                65,
                1,
                2,
                0,
                29,
                6135,
                9,
                1237,
                43,
                8,
                8936,
                3,
                2,
                6,
                2,
                1,
                2,
                290,
                16,
                0,
                30,
                2,
                3,
                0,
                15,
                3,
                9,
                395,
                2309,
                106,
                6,
                12,
                4,
                8,
                8,
                9,
                5991,
                84,
                2,
                70,
                2,
                1,
                3,
                0,
                3,
                1,
                3,
                3,
                2,
                11,
                2,
                0,
                2,
                6,
                2,
                64,
                2,
                3,
                3,
                7,
                2,
                6,
                2,
                27,
                2,
                3,
                2,
                4,
                2,
                0,
                4,
                6,
                2,
                339,
                3,
                24,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                7,
                1845,
                30,
                7,
                5,
                262,
                61,
                147,
                44,
                11,
                6,
                17,
                0,
                322,
                29,
                19,
                43,
                485,
                27,
                757,
                6,
                2,
                3,
                2,
                1,
                2,
                14,
                2,
                196,
                60,
                67,
                8,
                0,
                1205,
                3,
                2,
                26,
                2,
                1,
                2,
                0,
                3,
                0,
                2,
                9,
                2,
                3,
                2,
                0,
                2,
                0,
                7,
                0,
                5,
                0,
                2,
                0,
                2,
                0,
                2,
                2,
                2,
                1,
                2,
                0,
                3,
                0,
                2,
                0,
                2,
                0,
                2,
                0,
                2,
                0,
                2,
                1,
                2,
                0,
                3,
                3,
                2,
                6,
                2,
                3,
                2,
                3,
                2,
                0,
                2,
                9,
                2,
                16,
                6,
                2,
                2,
                4,
                2,
                16,
                4421,
                42719,
                33,
                4153,
                7,
                221,
                3,
                5761,
                15,
                7472,
                16,
                621,
                2467,
                541,
                1507,
                4938,
                6,
                4191
            ];
            const o = [
                509,
                0,
                227,
                0,
                150,
                4,
                294,
                9,
                1368,
                2,
                2,
                1,
                6,
                3,
                41,
                2,
                5,
                0,
                166,
                1,
                574,
                3,
                9,
                9,
                370,
                1,
                81,
                2,
                71,
                10,
                50,
                3,
                123,
                2,
                54,
                14,
                32,
                10,
                3,
                1,
                11,
                3,
                46,
                10,
                8,
                0,
                46,
                9,
                7,
                2,
                37,
                13,
                2,
                9,
                6,
                1,
                45,
                0,
                13,
                2,
                49,
                13,
                9,
                3,
                2,
                11,
                83,
                11,
                7,
                0,
                3,
                0,
                158,
                11,
                6,
                9,
                7,
                3,
                56,
                1,
                2,
                6,
                3,
                1,
                3,
                2,
                10,
                0,
                11,
                1,
                3,
                6,
                4,
                4,
                193,
                17,
                10,
                9,
                5,
                0,
                82,
                19,
                13,
                9,
                214,
                6,
                3,
                8,
                28,
                1,
                83,
                16,
                16,
                9,
                82,
                12,
                9,
                9,
                84,
                14,
                5,
                9,
                243,
                14,
                166,
                9,
                71,
                5,
                2,
                1,
                3,
                3,
                2,
                0,
                2,
                1,
                13,
                9,
                120,
                6,
                3,
                6,
                4,
                0,
                29,
                9,
                41,
                6,
                2,
                3,
                9,
                0,
                10,
                10,
                47,
                15,
                406,
                7,
                2,
                7,
                17,
                9,
                57,
                21,
                2,
                13,
                123,
                5,
                4,
                0,
                2,
                1,
                2,
                6,
                2,
                0,
                9,
                9,
                49,
                4,
                2,
                1,
                2,
                4,
                9,
                9,
                330,
                3,
                10,
                1,
                2,
                0,
                49,
                6,
                4,
                4,
                14,
                9,
                5351,
                0,
                7,
                14,
                13835,
                9,
                87,
                9,
                39,
                4,
                60,
                6,
                26,
                9,
                1014,
                0,
                2,
                54,
                8,
                3,
                82,
                0,
                12,
                1,
                19628,
                1,
                4706,
                45,
                3,
                22,
                543,
                4,
                4,
                5,
                9,
                7,
                3,
                6,
                31,
                3,
                149,
                2,
                1418,
                49,
                513,
                54,
                5,
                49,
                9,
                0,
                15,
                0,
                23,
                4,
                2,
                14,
                1361,
                6,
                2,
                16,
                3,
                6,
                2,
                1,
                2,
                4,
                101,
                0,
                161,
                6,
                10,
                9,
                357,
                0,
                62,
                13,
                499,
                13,
                983,
                6,
                110,
                6,
                6,
                9,
                4759,
                9,
                787719,
                239
            ];
            function isInAstralSet(e1, t) {
                let r = 65536;
                for(let n = 0, s = t.length; n < s; n += 2){
                    r += t[n];
                    if (r > e1) return false;
                    r += t[n + 1];
                    if (r >= e1) return true;
                }
                return false;
            }
            function isIdentifierStart(e1) {
                if (e1 < 65) return e1 === 36;
                if (e1 <= 90) return true;
                if (e1 < 97) return e1 === 95;
                if (e1 <= 122) return true;
                if (e1 <= 65535) {
                    return e1 >= 170 && s.test(String.fromCharCode(e1));
                }
                return isInAstralSet(e1, a);
            }
            function isIdentifierChar(e1) {
                if (e1 < 48) return e1 === 36;
                if (e1 < 58) return true;
                if (e1 < 65) return false;
                if (e1 <= 90) return true;
                if (e1 < 97) return e1 === 95;
                if (e1 <= 122) return true;
                if (e1 <= 65535) {
                    return e1 >= 170 && i.test(String.fromCharCode(e1));
                }
                return isInAstralSet(e1, a) || isInAstralSet(e1, o);
            }
            function isIdentifierName(e1) {
                let t = true;
                for(let r = 0; r < e1.length; r++){
                    let n = e1.charCodeAt(r);
                    if ((n & 64512) === 55296 && r + 1 < e1.length) {
                        const t = e1.charCodeAt(++r);
                        if ((t & 64512) === 56320) {
                            n = 65536 + ((n & 1023) << 10) + (t & 1023);
                        }
                    }
                    if (t) {
                        t = false;
                        if (!isIdentifierStart(n)) {
                            return false;
                        }
                    } else if (!isIdentifierChar(n)) {
                        return false;
                    }
                }
                return !t;
            }
        },
        5018: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "isIdentifierChar", {
                enumerable: true,
                get: function() {
                    return n.isIdentifierChar;
                }
            });
            Object.defineProperty(t, "isIdentifierName", {
                enumerable: true,
                get: function() {
                    return n.isIdentifierName;
                }
            });
            Object.defineProperty(t, "isIdentifierStart", {
                enumerable: true,
                get: function() {
                    return n.isIdentifierStart;
                }
            });
            Object.defineProperty(t, "isKeyword", {
                enumerable: true,
                get: function() {
                    return s.isKeyword;
                }
            });
            Object.defineProperty(t, "isReservedWord", {
                enumerable: true,
                get: function() {
                    return s.isReservedWord;
                }
            });
            Object.defineProperty(t, "isStrictBindOnlyReservedWord", {
                enumerable: true,
                get: function() {
                    return s.isStrictBindOnlyReservedWord;
                }
            });
            Object.defineProperty(t, "isStrictBindReservedWord", {
                enumerable: true,
                get: function() {
                    return s.isStrictBindReservedWord;
                }
            });
            Object.defineProperty(t, "isStrictReservedWord", {
                enumerable: true,
                get: function() {
                    return s.isStrictReservedWord;
                }
            });
            var n = r(2916);
            var s = r(9676);
        },
        9676: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isKeyword = isKeyword;
            t.isReservedWord = isReservedWord;
            t.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
            t.isStrictBindReservedWord = isStrictBindReservedWord;
            t.isStrictReservedWord = isStrictReservedWord;
            const r = {
                keyword: [
                    "break",
                    "case",
                    "catch",
                    "continue",
                    "debugger",
                    "default",
                    "do",
                    "else",
                    "finally",
                    "for",
                    "function",
                    "if",
                    "return",
                    "switch",
                    "throw",
                    "try",
                    "var",
                    "const",
                    "while",
                    "with",
                    "new",
                    "this",
                    "super",
                    "class",
                    "extends",
                    "export",
                    "import",
                    "null",
                    "true",
                    "false",
                    "in",
                    "instanceof",
                    "typeof",
                    "void",
                    "delete"
                ],
                strict: [
                    "implements",
                    "interface",
                    "let",
                    "package",
                    "private",
                    "protected",
                    "public",
                    "static",
                    "yield"
                ],
                strictBind: [
                    "eval",
                    "arguments"
                ]
            };
            const n = new Set(r.keyword);
            const s = new Set(r.strict);
            const i = new Set(r.strictBind);
            function isReservedWord(e1, t) {
                return t && e1 === "await" || e1 === "enum";
            }
            function isStrictReservedWord(e1, t) {
                return isReservedWord(e1, t) || s.has(e1);
            }
            function isStrictBindOnlyReservedWord(e1) {
                return i.has(e1);
            }
            function isStrictBindReservedWord(e1, t) {
                return isStrictReservedWord(e1, t) || isStrictBindOnlyReservedWord(e1);
            }
            function isKeyword(e1) {
                return n.has(e1);
            }
        },
        8112: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.findSuggestion = findSuggestion;
            const { min: r } = Math;
            function levenshtein(e1, t) {
                let n = [], s = [], i, a;
                const o = e1.length, l = t.length;
                if (!o) {
                    return l;
                }
                if (!l) {
                    return o;
                }
                for(a = 0; a <= l; a++){
                    n[a] = a;
                }
                for(i = 1; i <= o; i++){
                    for(s = [
                        i
                    ], a = 1; a <= l; a++){
                        s[a] = e1[i - 1] === t[a - 1] ? n[a - 1] : r(n[a - 1], n[a], s[a - 1]) + 1;
                    }
                    n = s;
                }
                return s[l];
            }
            function findSuggestion(e1, t) {
                const n = t.map((t)=>levenshtein(t, e1));
                return t[n.indexOf(r(...n))];
            }
        },
        4716: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "OptionValidator", {
                enumerable: true,
                get: function() {
                    return n.OptionValidator;
                }
            });
            Object.defineProperty(t, "findSuggestion", {
                enumerable: true,
                get: function() {
                    return s.findSuggestion;
                }
            });
            var n = r(2729);
            var s = r(8112);
        },
        2729: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.OptionValidator = void 0;
            var n = r(8112);
            class OptionValidator {
                constructor(e1){
                    this.descriptor = e1;
                }
                validateTopLevelOptions(e1, t) {
                    const r = Object.keys(t);
                    for (const t of Object.keys(e1)){
                        if (!r.includes(t)) {
                            throw new Error(this.formatMessage(`'${t}' is not a valid top-level option.\n- Did you mean '${(0, n.findSuggestion)(t, r)}'?`));
                        }
                    }
                }
                validateBooleanOption(e1, t, r) {
                    if (t === undefined) {
                        return r;
                    } else {
                        this.invariant(typeof t === "boolean", `'${e1}' option must be a boolean.`);
                    }
                    return t;
                }
                validateStringOption(e1, t, r) {
                    if (t === undefined) {
                        return r;
                    } else {
                        this.invariant(typeof t === "string", `'${e1}' option must be a string.`);
                    }
                    return t;
                }
                invariant(e1, t) {
                    if (!e1) {
                        throw new Error(this.formatMessage(t));
                    }
                }
                formatMessage(e1) {
                    return `${this.descriptor}: ${e1}`;
                }
            }
            t.OptionValidator = OptionValidator;
        },
        3563: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(9128);
            function helper(e1, t) {
                return Object.freeze({
                    minVersion: e1,
                    ast: ()=>n.default.program.ast(t, {
                            preserveComments: true
                        })
                });
            }
            var s = Object.freeze({
                AsyncGenerator: helper("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};'),
                OverloadYield: helper("7.18.14", "export default function _OverloadYield(t,e){this.v=t,this.k=e}"),
                applyDecs: helper("7.17.8", 'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:t,isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a){var r;throw r=0===e?"field":10===e?"class":"method",new TypeError(r+" decorators must return a function or void 0")}}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&"undefined"!=typeof console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,h=a[0];if(n?c=0===o||1===o?{get:a[3],set:a[4]}:3===o?{get:a[3]}:4===o?{set:a[3]}:{value:a[3]}:0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?u={get:c.get,set:c.set}:2===o?u=c.value:3===o?u=c.get:4===o&&(u=c.set),"function"==typeof h)void 0!==(f=old_memberDec(h,r,c,l,s,o,i,n,u))&&(old_assertValidReturnValue(o,f),0===o?d=f:1===o?(d=old_getInit(f),p=f.get||u.get,v=f.set||u.set,u={get:p,set:v}):u=f);else for(var y=h.length-1;y>=0;y--){var b;if(void 0!==(f=old_memberDec(h[y],r,c,l,s,o,i,n,u)))old_assertValidReturnValue(o,f),0===o?b=f:1===o?(b=old_getInit(f),p=f.get||u.get,v=f.set||u.set,u={get:p,set:v}):u=f,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var m=d;d=function(e,t){return m.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=u.get,c.set=u.set):2===o?c.value=u:3===o?c.get=u:4===o&&(c.set=u),n?1===o?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===o?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],h=d[2],y=d.length>3,b=v>=5;if(b?(u=t,f=r,0!==(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!y){var g=b?s:l,m=g.get(h)||0;if(!0===m||3===m&&4!==v||4===m&&3!==v)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!m&&v>2?g.set(h,v):g.set(h,!0)}old_applyMemberDec(e,u,d,h,v,b,y,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}export default function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}'),
                applyDecs2203: helper("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}(t,"addInitializer"),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r){var a;throw a=0===e?"field":10===e?"class":"method",new TypeError(a+" decorators must return a function or void 0")}}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;if(void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u)))assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;export default function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}'),
                applyDecs2203R: helper("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}(t,"addInitializer"),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,s,o){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r){var n;throw n=0===e?"field":10===e?"class":"method",new TypeError(n+" decorators must return a function or void 0")}}function applyMemberDec(e,t,r,n,a,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===a||1===a?{get:r[3],set:r[4]}:3===a?{get:r[3]}:4===a?{set:r[3]}:{value:r[3]}:0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?u={get:c.get,set:c.set}:2===a?u=c.value:3===a?u=c.get:4===a&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,n,c,o,a,i,s,u))&&(assertValidReturnValue(a,f),0===a?l=f:1===a?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;if(void 0!==(f=memberDec(h[v],n,c,o,a,i,s,u)))assertValidReturnValue(a,f),0===a?g=f:1===a?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,n=0;n<y.length;n++)r=y[n].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=u.get,c.set=u.set):2===a?c.value=u:3===a?c.get=u:4===a&&(c.set=u),s?1===a?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===a?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,s=new Map,o=0;o<t.length;o++){var c=t[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!==(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}'),
                applyDecs2301: helper("7.21.0", 'import checkInRHS from"checkInRHS";function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}(t,"addInitializer"),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:t,static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r){var n;throw n=0===e?"field":10===e?"class":"method",new TypeError(n+" decorators must return a function or void 0")}}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,g=r[0];if(s?u=0===a||1===a?{get:(p=r[3],function(){return p(this)}),set:curryThis2(r[4])}:3===a?{get:r[3]}:4===a?{set:r[3]}:{value:r[3]}:0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:u.get,set:u.set}:2===a?f=u.value:3===a?f=u.get:4===a&&(f=u.set),"function"==typeof g)void 0!==(d=memberDec(g,n,u,o,a,i,s,f,c))&&(assertValidReturnValue(a,d),0===a?l=d:1===a?(l=d.init,h=d.get||f.get,v=d.set||f.set,f={get:h,set:v}):f=d);else for(var y=g.length-1;y>=0;y--){var m;if(void 0!==(d=memberDec(g[y],n,u,o,a,i,s,f,c)))assertValidReturnValue(a,d),0===a?m=d:1===a?(m=d.init,h=d.get||f.get,v=d.set||f.set,f={get:h,set:v}):f=d,void 0!==m&&(void 0===l?l=m:"function"==typeof l?l=[l,m]:l.push(m))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var b=l;l=function(e,t){for(var r=t,n=0;n<b.length;n++)r=b[n].call(e,r);return r}}else{var I=l;l=function(e,t){return I.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=f.get,u.set=f.set):2===a?u.value=f:3===a?u.get=f:4===a&&(u.set=f),s?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,g=d>=5,y=r;if(g?(f=e,0!==(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),y=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=g?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,g,v,p,y)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}export default function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}'),
                applyDecs2305: helper("7.21.0", 'import checkInRHS from"checkInRHS";function createAddInitializerMethod(e,t){return function(r){assertNotFinished(t,"addInitializer"),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,a,n,i,s,o,c,l,u){var f;switch(i){case 1:f="accessor";break;case 2:f="method";break;case 3:f="getter";break;case 4:f="setter";break;default:f="field"}var d,p,h={kind:f,name:o?"#"+r:r,static:s,private:o,metadata:u},v={v:!1};if(0!==i&&(h.addInitializer=createAddInitializerMethod(n,v)),o||0!==i&&2!==i)if(2===i)d=function(e){return assertInstanceIfPrivate(l,e),a.value};else{var y=0===i||1===i;(y||3===i)&&(d=o?function(e){return assertInstanceIfPrivate(l,e),a.get.call(e)}:function(e){return a.get.call(e)}),(y||4===i)&&(p=o?function(e,t){assertInstanceIfPrivate(l,e),a.set.call(e,t)}:function(e,t){a.set.call(e,t)})}else d=function(e){return e[r]},0===i&&(p=function(e,t){e[r]=t});var m=o?l.bind():function(e){return r in e};h.access=d&&p?{get:d,set:p,has:m}:d?{get:d,has:m}:{set:p,has:m};try{return e.call(t,c,h)}finally{v.v=!0}}function assertNotFinished(e,t){if(e.v)throw new Error("attempted to call "+t+" after decoration was finished")}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r){var a;throw a=0===e?"field":5===e?"class":"method",new TypeError(a+" decorators must return a function or void 0")}}function curryThis1(e){return function(){return e(this)}}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,a,n,i,s,o,c,l,u){var f,d,p,h,v,y,m=r[0];a||Array.isArray(m)||(m=[m]),o?f=0===i||1===i?{get:curryThis1(r[3]),set:curryThis2(r[4])}:3===i?{get:r[3]}:4===i?{set:r[3]}:{value:r[3]}:0!==i&&(f=Object.getOwnPropertyDescriptor(t,n)),1===i?p={get:f.get,set:f.set}:2===i?p=f.value:3===i?p=f.get:4===i&&(p=f.set);for(var g=a?2:1,b=m.length-1;b>=0;b-=g){var I;if(void 0!==(h=memberDec(m[b],a?m[b-1]:void 0,n,f,c,i,s,o,p,l,u)))assertValidReturnValue(i,h),0===i?I=h:1===i?(I=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==I&&(void 0===d?d=I:"function"==typeof d?d=[d,I]:d.push(I))}if(0===i||1===i){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var w=d;d=function(e,t){for(var r=t,a=w.length-1;a>=0;a--)r=w[a].call(e,r);return r}}else{var M=d;d=function(e,t){return M.call(e,t)}}e.push(d)}0!==i&&(1===i?(f.get=p.get,f.set=p.set):2===i?f.value=p:3===i?f.get=p:4===i&&(f.set=p),o?1===i?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===i?e.push(p):e.push((function(e,t){return p.call(e,t)})):Object.defineProperty(t,n,f))}function applyMemberDecs(e,t,r,a){for(var n,i,s,o=[],c=new Map,l=new Map,u=0;u<t.length;u++){var f=t[u];if(Array.isArray(f)){var d,p,h=f[1],v=f[2],y=f.length>3,m=16&h,g=!!(8&h),b=r;if(h&=7,g?(d=e,0!==h&&(p=i=i||[]),y&&!s&&(s=function(t){return checkInRHS(t)===e}),b=s):(d=e.prototype,0!==h&&(p=n=n||[])),0!==h&&!y){var I=g?l:c,w=I.get(v)||0;if(!0===w||3===w&&4!==h||4===w&&3!==h)throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+v);I.set(v,!(!w&&h>2)||h)}applyMemberDec(o,d,f,m,v,h,g,y,p,b,a)}}return pushInitializers(o,n),pushInitializers(o,i),o}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}function applyClassDecs(e,t,r,a){if(t.length){for(var n=[],i=e,s=e.name,o=r?2:1,c=t.length-1;c>=0;c-=o){var l={v:!1};try{var u=t[c].call(r?t[c-1]:void 0,i,{kind:"class",name:s,addInitializer:createAddInitializerMethod(n,l),metadata:a})}finally{l.v=!0}void 0!==u&&(assertValidReturnValue(5,u),i=u)}return[defineMetadata(i,a),function(){for(var e=0;e<n.length;e++)n[e].call(i)}]}}function defineMetadata(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}export default function applyDecs2305(e,t,r,a,n,i){if(arguments.length>=6)var s=i[Symbol.metadata||Symbol.for("Symbol.metadata")];var o=Object.create(void 0===s?null:s),c=applyMemberDecs(e,t,n,o);return r.length||defineMetadata(e,o),{e:c,get c(){return applyClassDecs(e,r,a,o)}}}'),
                asyncGeneratorDelegate: helper("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}'),
                asyncIterator: helper("7.15.9", 'export default function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}'),
                awaitAsyncGenerator: helper("7.0.0-beta.0", 'import OverloadYield from"OverloadYield";export default function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}'),
                checkInRHS: helper("7.20.5", 'export default function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of \'in\' should be an object, got "+(null!==e?typeof e:"null"));return e}'),
                defineAccessor: helper("7.20.7", "export default function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}"),
                dispose: helper("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=r,this.error=e,this.stack=(new Error).stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}export default function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(r,e):r,s=!0,next()}return next()}'),
                importDeferProxy: helper("7.23.0", "export default function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}"),
                iterableToArrayLimit: helper("7.0.0-beta.0", 'export default function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}'),
                iterableToArrayLimitLoose: helper("7.0.0-beta.0", 'export default function _iterableToArrayLimitLoose(e,r){var t=e&&("undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"]);if(null!=t){var o,l=[];for(t=t.call(e);e.length<r&&!(o=t.next()).done;)l.push(o.value);return l}}'),
                jsx: helper("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;export default function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=new Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}'),
                objectSpread2: helper("7.5.0", 'import defineProperty from"defineProperty";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}export default function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}'),
                regeneratorRuntime: helper("7.18.0", 'export default function _regeneratorRuntime(){"use strict";\n/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:function(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw new Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a \'"+n+"\' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}'),
                typeof: helper("7.0.0-beta.0", 'export default function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}'),
                using: helper("7.22.0", 'export default function _using(o,e,n){if(null==e)return e;if("object"!=typeof e)throw new TypeError("using declarations can only be used with objects, null, or undefined.");if(n)var r=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=e[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:e,d:r,a:n}),e}'),
                wrapRegExp: helper("7.19.0", 'import setPrototypeOf from"setPrototypeOf";import inherits from"inherits";export default function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=new RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)>/g,(function(e,r){var t=o[r];return"$"+(Array.isArray(t)?t.join("$"):t)})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}')
            });
            t["default"] = s;
        },
        5095: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(9128);
            var s = r(3563);
            const i = Object.assign({
                __proto__: null
            }, s.default);
            var a = i;
            t["default"] = a;
            const helper = (e1)=>(t)=>({
                        minVersion: e1,
                        ast: ()=>n.default.program.ast(t)
                    });
            {
                i.AwaitValue = helper("7.0.0-beta.0")`
    export default function _AwaitValue(value) {
      this.wrapped = value;
    }
  `;
            }
            i.wrapAsyncGenerator = helper("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`;
            i.asyncToGenerator = helper("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }
`;
            i.classCallCheck = helper("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`;
            i.createClass = helper("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
`;
            i.defineEnumerableProperties = helper("7.0.0-beta.0")`
  export default function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    // Symbols are not enumerated over by for-in loops. If native
    // Symbols are available, fetch all of the descs object's own
    // symbol properties and define them on our target object too.
    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);
      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }
    return obj;
  }
`;
            i.defaults = helper("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`;
            i.defineProperty = helper("7.0.0-beta.0")`
  import toPropertyKey from "toPropertyKey";
  export default function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`;
            i.extends = helper("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`;
            {
                i.objectSpread = helper("7.0.0-beta.0")`
    import defineProperty from "defineProperty";

    export default function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = (arguments[i] != null) ? Object(arguments[i]) : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
  `;
            }
            i.inherits = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    // We can't use defineProperty to set the prototype in a single step because it
    // doesn't work in Chrome <= 36. https://github.com/babel/babel/issues/14056
    // V8 bug: https://bugs.chromium.org/p/v8/issues/detail?id=3334
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`;
            i.inheritsLoose = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`;
            i.getPrototypeOf = helper("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`;
            i.setPrototypeOf = helper("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };
    return _setPrototypeOf(o, p);
  }
`;
            i.isNativeReflectConstruct = helper("7.9.0")`
  export default function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;

    // core-js@3
    if (Reflect.construct.sham) return false;

    // Proxy can't be polyfilled. Every browser implemented
    // proxies before or at the same time as Reflect.construct,
    // so if they support Proxy they also support Reflect.construct.
    if (typeof Proxy === "function") return true;

    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
      // If the internal slots aren't set, this throws an error similar to
      //   TypeError: this is not a Boolean object.

      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }
`;
            i.construct = helper("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";

  export default function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      // NOTE: If Parent !== Class, the correct __proto__ is set *after*
      //       calling the constructor.
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    // Avoid issues with Class being present but undefined when it wasn't
    // present in the original call.
    return _construct.apply(null, arguments);
  }
`;
            i.isNativeFunction = helper("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
`;
            i.wrapNativeSuper = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`;
            i.instanceof = helper("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`;
            i.interopRequireDefault = helper("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`;
            i.interopRequireWildcard = helper("7.14.0")`
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;

    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function (nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  export default function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
      return { default: obj }
    }

    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
`;
            i.newArrowCheck = helper("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`;
            i.objectDestructuringEmpty = helper("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure " + obj);
  }
`;
            i.objectWithoutPropertiesLoose = helper("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`;
            i.objectWithoutProperties = helper("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`;
            i.assertThisInitialized = helper("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`;
            i.possibleConstructorReturn = helper("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return assertThisInitialized(self);
  }
`;
            i.createSuper = helper("7.9.0")`
  import getPrototypeOf from "getPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";
  import possibleConstructorReturn from "possibleConstructorReturn";

  export default function _createSuper(Derived) {
    var hasNativeReflectConstruct = isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        // NOTE: This doesn't work if this.__proto__.constructor has been modified.
        var NewTarget = getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return possibleConstructorReturn(this, result);
    }
  }
 `;
            i.superPropBase = helper("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`;
            i.get = helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          // STEP 3. If receiver is not present, then set receiver to target.
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
`;
            i.set = helper("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new TypeError('failed to set property');
    }

    return value;
  }
`;
            i.taggedTemplateLiteral = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`;
            i.taggedTemplateLiteralLoose = helper("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`;
            i.readOnlyError = helper("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is read-only");
  }
`;
            i.writeOnlyError = helper("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is write-only");
  }
`;
            i.classNameTDZError = helper("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new ReferenceError("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`;
            i.temporalUndefined = helper("7.0.0-beta.0")`
  // This function isn't mean to be called, but to be used as a reference.
  // We can't use a normal object because it isn't hoisted.
  export default function _temporalUndefined() {}
`;
            i.tdz = helper("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`;
            i.temporalRef = helper("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`;
            i.slicedToArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
            i.slicedToArrayLoose = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`;
            i.toArray = helper("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`;
            i.toConsumableArray = helper("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`;
            i.arrayWithoutHoles = helper("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`;
            i.arrayWithHoles = helper("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`;
            i.maybeArrayLike = helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`;
            i.iterableToArray = helper("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
`;
            i.unsupportedIterableToArray = helper("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`;
            i.arrayLikeToArray = helper("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`;
            i.nonIterableSpread = helper("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`;
            i.nonIterableRest = helper("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`;
            i.createForOfIteratorHelper = helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`;
            i.createForOfIteratorHelperLoose = helper("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length === "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
`;
            i.skipFirstGeneratorNext = helper("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`;
            i.toPrimitive = helper("7.1.5")`
  export default function _toPrimitive(
    input,
    hint /*: "default" | "string" | "number" | void */
  ) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
`;
            i.toPropertyKey = helper("7.1.5")`
  import toPrimitive from "toPrimitive";

  export default function _toPropertyKey(arg) {
    var key = toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
`;
            i.initializerWarningHelper = helper("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'transform-class-properties is enabled and runs after the decorators transform.'
        );
    }
`;
            i.initializerDefineProperty = helper("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`;
            i.applyDecoratedDescriptor = helper("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`;
            i.classPrivateFieldLooseKey = helper("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`;
            i.classPrivateFieldLooseBase = helper("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`;
            i.classPrivateFieldGet = helper("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`;
            i.classPrivateFieldSet = helper("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`;
            i.classPrivateFieldDestructureSet = helper("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
            i.classExtractFieldDescriptor = helper("7.13.10")`
  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
  }
`;
            i.classStaticPrivateFieldSpecGet = helper("7.0.2")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`;
            i.classStaticPrivateFieldSpecSet = helper("7.0.2")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`;
            i.classStaticPrivateMethodGet = helper("7.3.2")`
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    return method;
  }
`;
            i.classStaticPrivateMethodSet = helper("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`;
            i.classApplyDescriptorGet = helper("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`;
            i.classApplyDescriptorSet = helper("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
`;
            i.classApplyDescriptorDestructureSet = helper("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }
`;
            i.classStaticPrivateFieldDestructureSet = helper("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`;
            i.classCheckPrivateStaticAccess = helper("7.13.10")`
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
  }
`;
            i.classCheckPrivateStaticFieldDescriptor = helper("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
  }
`;
            i.decorate = helper("7.1.5")`
  import toArray from "toArray";
  import toPropertyKey from "toPropertyKey";

  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () => any,
        set?: (v: any) => void,
        configurable: boolean,
        enumerable: boolean,
      };

  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };

  type Placement = "static" | "prototype" | "own";
  type Key = string | symbol; // PrivateName is not supported yet.

  type ElementDescriptor =
    | {
        kind: "method",
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: "field",
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () => any,
      };

  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
  };

  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: "Descriptor",
    kind: "class",
    elements: ElementDescriptor[],
  };

  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;

  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: "method",
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: "field",
        value: () => any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };

  declare function ClassFactory<C>(initialize: (instance: C) => void): {
    F: Class<C>,
    d: ElementDefinition[]
  }

  */

  /*::
  // Various combinations with/without extras and with one or many finishers

  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };

  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };

  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };

  */

  /*::

  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };

  */

  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
    mixins /*: ?Array<Function> */,
  ) /*: Class<*> */ {
    var api = _getDecoratorsApi();
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],

      // InitializeInstanceElements
      initializeInstanceElements: function(
        /*::<C>*/ O /*: C */,
        elements /*: ElementDescriptor[] */,
      ) {
        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },

      // InitializeClassElements
      initializeClassElements: function(
        /*::<C>*/ F /*: Class<C> */,
        elements /*: ElementDescriptor[] */,
      ) {
        var proto = F.prototype;

        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            var placement = element.placement;
            if (
              element.kind === kind &&
              (placement === "static" || placement === "prototype")
            ) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      // DefineClassElement
      defineClassElement: function(
        /*::<C>*/ receiver /*: C | Class<C> */,
        element /*: ElementDescriptor */,
      ) {
        var descriptor /*: PropertyDescriptor */ = element.descriptor;
        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver),
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      // DecorateClass
      decorateClass: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var newElements /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];
        var placements /*: Placements */ = {
          static: [],
          prototype: [],
          own: [],
        };

        elements.forEach(function(element /*: ElementDescriptor */) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element /*: ElementDescriptor */) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
            element,
            placements,
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return { elements: newElements, finishers: finishers };
        }

        var result /*: ElementsFinishers */ = this.decorateConstructor(
          newElements,
          decorators,
        );
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      // AddElementPlacement
      addElementPlacement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
        silent /*: boolean */,
      ) {
        var keys = placements[element.placement];
        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }
        keys.push(element.key);
      },

      // DecorateElement
      decorateElement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
      ) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i >= 0;
          i--
        ) {
          // (inlined) RemoveElementPlacement
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
            element,
          );
          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
              elementObject,
          );

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras /*: ElementDescriptor[] | void */ =
            elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }
            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      // DecorateConstructor
      decorateConstructor: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var finishers /*: ClassFinisher[] */ = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
            (0, decorators[i])(obj) /*: ClassObject */ || obj,
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &&
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    "Duplicated element (" + elements[j].key + ")",
                  );
                }
              }
            }
          }
        }

        return { elements: elements, finishers: finishers };
      },

      // FromElementDescriptor
      fromElementDescriptor: function(
        element /*: ElementDescriptor */,
      ) /*: ElementObject */ {
        var obj /*: ElementObject */ = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor,
        };

        var desc = {
          value: "Descriptor",
          configurable: true,
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        if (element.kind === "field") obj.initializer = element.initializer;

        return obj;
      },

      // ToElementDescriptors
      toElementDescriptors: function(
        elementObjects /*: ElementObject[] */,
      ) /*: ElementDescriptor[] */ {
        if (elementObjects === undefined) return;
        return toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },

      // ToElementDescriptor
      toElementDescriptor: function(
        elementObject /*: ElementObject */,
      ) /*: ElementDescriptor */ {
        var kind = String(elementObject.kind);
        if (kind !== "method" && kind !== "field") {
          throw new TypeError(
            'An element descriptor\\'s .kind property must be either "method" or' +
              ' "field", but a decorator created an element descriptor with' +
              ' .kind "' +
              kind +
              '"',
          );
        }

        var key = toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);
        if (
          placement !== "static" &&
          placement !== "prototype" &&
          placement !== "own"
        ) {
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"',
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(
            descriptor,
            "get",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "set",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "value",
            "The property descriptor of a field descriptor",
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          "finisher",
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: "Descriptor", configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class") {
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"',
          );
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class<*> */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static
        ? "static"
        : def.kind === "field"
        ? "own"
        : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }

`;
            i.classPrivateMethodGet = helper("7.1.6")`
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
  }
`;
            i.checkPrivateRedeclaration = helper("7.14.1")`
  export default function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
      throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
  }
`;
            i.classPrivateFieldInitSpec = helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateFieldInitSpec(obj, privateMap, value) {
    checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
  }
`;
            i.classPrivateMethodInitSpec = helper("7.14.1")`
  import checkPrivateRedeclaration from "checkPrivateRedeclaration";

  export default function _classPrivateMethodInitSpec(obj, privateSet) {
    checkPrivateRedeclaration(obj, privateSet);
    privateSet.add(obj);
  }
`;
            {
                i.classPrivateMethodSet = helper("7.1.6")`
    export default function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }
  `;
            }
            i.identity = helper("7.17.0")`
  export default function _identity(x) {
    return x;
  }
`;
            i.nullishReceiverError = helper("7.22.6")`
  export default function _nullishReceiverError(r) {
    throw new TypeError("Cannot set property of null or undefined.");
  }
`;
        },
        1416: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            t.ensure = ensure;
            t.get = get;
            t.getDependencies = getDependencies;
            t.list = void 0;
            t.minVersion = minVersion;
            var n = r(2297);
            var s = r(776);
            var i = r(5095);
            const { assignmentExpression: a, cloneNode: o, expressionStatement: l, file: c, identifier: u } = s;
            function makePath(e1) {
                const t = [];
                for(; e1.parentPath; e1 = e1.parentPath){
                    t.push(e1.key);
                    if (e1.inList) t.push(e1.listKey);
                }
                return t.reverse().join(".");
            }
            let p = undefined;
            function getHelperMetadata(e1) {
                const t = new Set;
                const r = new Set;
                const s = new Map;
                let a;
                let o;
                const l = [];
                const c = [];
                const u = [];
                const p = {
                    ImportDeclaration (e1) {
                        const t = e1.node.source.value;
                        if (!i.default[t]) {
                            throw e1.buildCodeFrameError(`Unknown helper ${t}`);
                        }
                        if (e1.get("specifiers").length !== 1 || !e1.get("specifiers.0").isImportDefaultSpecifier()) {
                            throw e1.buildCodeFrameError("Helpers can only import a default value");
                        }
                        const r = e1.node.specifiers[0].local;
                        s.set(r, t);
                        c.push(makePath(e1));
                    },
                    ExportDefaultDeclaration (e1) {
                        const t = e1.get("declaration");
                        if (!t.isFunctionDeclaration() || !t.node.id) {
                            throw t.buildCodeFrameError("Helpers can only export named function declarations");
                        }
                        a = t.node.id.name;
                        o = makePath(e1);
                    },
                    ExportAllDeclaration (e1) {
                        throw e1.buildCodeFrameError("Helpers can only export default");
                    },
                    ExportNamedDeclaration (e1) {
                        throw e1.buildCodeFrameError("Helpers can only export default");
                    },
                    Statement (e1) {
                        if (e1.isImportDeclaration() || e1.isExportDeclaration()) return;
                        e1.skip();
                    }
                };
                const f = {
                    Program (e1) {
                        const t = e1.scope.getAllBindings();
                        Object.keys(t).forEach((e1)=>{
                            if (e1 === a) return;
                            if (s.has(t[e1].identifier)) return;
                            r.add(e1);
                        });
                    },
                    ReferencedIdentifier (e1) {
                        const r = e1.node.name;
                        const n = e1.scope.getBinding(r);
                        if (!n) {
                            t.add(r);
                        } else if (s.has(n.identifier)) {
                            u.push(makePath(e1));
                        }
                    },
                    AssignmentExpression (e1) {
                        const t = e1.get("left");
                        if (!(a in t.getBindingIdentifiers())) return;
                        if (!t.isIdentifier()) {
                            throw t.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
                        }
                        const r = e1.scope.getBinding(a);
                        if (r != null && r.scope.path.isProgram()) {
                            l.push(makePath(e1));
                        }
                    }
                };
                (0, n.default)(e1.ast, p, e1.scope);
                (0, n.default)(e1.ast, f, e1.scope);
                if (!o) throw new Error("Helpers must have a default export.");
                l.reverse();
                return {
                    globals: Array.from(t),
                    localBindingNames: Array.from(r),
                    dependencies: s,
                    exportBindingAssignments: l,
                    exportPath: o,
                    exportName: a,
                    importBindingsReferences: u,
                    importPaths: c
                };
            }
            function permuteHelperAST(e1, t, r, n, s) {
                if (n && !r) {
                    throw new Error("Unexpected local bindings for module-based helpers.");
                }
                if (!r) return;
                const { localBindingNames: i, dependencies: c, exportBindingAssignments: p, exportPath: f, exportName: d, importBindingsReferences: h, importPaths: m } = t;
                const y = {};
                c.forEach((e1, t)=>{
                    y[t.name] = typeof s === "function" && s(e1) || t;
                });
                const g = {};
                const b = new Set(n || []);
                i.forEach((e1)=>{
                    let t = e1;
                    while(b.has(t))t = "_" + t;
                    if (t !== e1) g[e1] = t;
                });
                if (r.type === "Identifier" && d !== r.name) {
                    g[d] = r.name;
                }
                const { path: T } = e1;
                const S = T.get(f);
                const E = m.map((e1)=>T.get(e1));
                const v = h.map((e1)=>T.get(e1));
                const x = S.get("declaration");
                if (r.type === "Identifier") {
                    S.replaceWith(x);
                } else if (r.type === "MemberExpression") {
                    p.forEach((e1)=>{
                        const t = T.get(e1);
                        t.replaceWith(a("=", r, t.node));
                    });
                    S.replaceWith(x);
                    T.pushContainer("body", l(a("=", r, u(d))));
                } else {
                    throw new Error("Unexpected helper format.");
                }
                Object.keys(g).forEach((e1)=>{
                    T.scope.rename(e1, g[e1]);
                });
                for (const e1 of E)e1.remove();
                for (const e1 of v){
                    const t = o(y[e1.node.name]);
                    e1.replaceWith(t);
                }
            }
            const f = Object.create(null);
            function loadHelper(e1) {
                if (!f[e1]) {
                    const t = i.default[e1];
                    if (!t) {
                        throw Object.assign(new ReferenceError(`Unknown helper ${e1}`), {
                            code: "BABEL_HELPER_UNKNOWN",
                            helper: e1
                        });
                    }
                    const fn = ()=>{
                        {
                            if (!p) {
                                const e1 = {
                                    ast: c(t.ast()),
                                    path: null
                                };
                                (0, n.default)(e1.ast, {
                                    Program: (t)=>(e1.path = t).stop()
                                });
                                return e1;
                            }
                        }
                        return new p({
                            filename: `babel-helper://${e1}`
                        }, {
                            ast: c(t.ast()),
                            code: "[internal Babel helper code]",
                            inputMap: null
                        });
                    };
                    let r = null;
                    f[e1] = {
                        minVersion: t.minVersion,
                        build (e1, t, n) {
                            const s = fn();
                            r || (r = getHelperMetadata(s));
                            permuteHelperAST(s, r, t, n, e1);
                            return {
                                nodes: s.ast.program.body,
                                globals: r.globals
                            };
                        },
                        getDependencies () {
                            r || (r = getHelperMetadata(fn()));
                            return Array.from(r.dependencies.values());
                        }
                    };
                }
                return f[e1];
            }
            function get(e1, t, r, n) {
                return loadHelper(e1).build(t, r, n);
            }
            function minVersion(e1) {
                return loadHelper(e1).minVersion;
            }
            function getDependencies(e1) {
                return loadHelper(e1).getDependencies();
            }
            function ensure(e1, t) {
                p || (p = t);
                loadHelper(e1);
            }
            const d = Object.keys(i.default).map((e1)=>e1.replace(/^_/, ""));
            t.list = d;
            var h = get;
            t["default"] = h;
        },
        6448: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = highlight;
            t.shouldHighlight = shouldHighlight;
            var n = r(8874);
            var s = r(4975);
            var i = _interopRequireWildcard(r(6148), true);
            function _getRequireWildcardCache(e1) {
                if (typeof WeakMap !== "function") return null;
                var t = new WeakMap;
                var r = new WeakMap;
                return (_getRequireWildcardCache = function(e1) {
                    return e1 ? r : t;
                })(e1);
            }
            function _interopRequireWildcard(e1, t) {
                if (!t && e1 && e1.__esModule) {
                    return e1;
                }
                if (e1 === null || typeof e1 !== "object" && typeof e1 !== "function") {
                    return {
                        default: e1
                    };
                }
                var r = _getRequireWildcardCache(t);
                if (r && r.has(e1)) {
                    return r.get(e1);
                }
                var n = {};
                var s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var i in e1){
                    if (i !== "default" && Object.prototype.hasOwnProperty.call(e1, i)) {
                        var a = s ? Object.getOwnPropertyDescriptor(e1, i) : null;
                        if (a && (a.get || a.set)) {
                            Object.defineProperty(n, i, a);
                        } else {
                            n[i] = e1[i];
                        }
                    }
                }
                n.default = e1;
                if (r) {
                    r.set(e1, n);
                }
                return n;
            }
            const a = new Set([
                "as",
                "async",
                "from",
                "get",
                "of",
                "set"
            ]);
            function getDefs(e1) {
                return {
                    keyword: e1.cyan,
                    capitalized: e1.yellow,
                    jsxIdentifier: e1.yellow,
                    punctuator: e1.yellow,
                    number: e1.magenta,
                    string: e1.green,
                    regex: e1.magenta,
                    comment: e1.grey,
                    invalid: e1.white.bgRed.bold
                };
            }
            const o = /\r\n|[\n\r\u2028\u2029]/;
            const l = /^[()[\]{}]$/;
            let c;
            {
                const e1 = /^[a-z][\w-]*$/i;
                const getTokenType = function(t, r, n) {
                    if (t.type === "name") {
                        if ((0, s.isKeyword)(t.value) || (0, s.isStrictReservedWord)(t.value, true) || a.has(t.value)) {
                            return "keyword";
                        }
                        if (e1.test(t.value) && (n[r - 1] === "<" || n.slice(r - 2, r) == "</")) {
                            return "jsxIdentifier";
                        }
                        if (t.value[0] !== t.value[0].toLowerCase()) {
                            return "capitalized";
                        }
                    }
                    if (t.type === "punctuator" && l.test(t.value)) {
                        return "bracket";
                    }
                    if (t.type === "invalid" && (t.value === "@" || t.value === "#")) {
                        return "punctuator";
                    }
                    return t.type;
                };
                c = function*(e1) {
                    let t;
                    while(t = n.default.exec(e1)){
                        const r = n.matchToToken(t);
                        yield {
                            type: getTokenType(r, t.index, e1),
                            value: r.value
                        };
                    }
                };
            }
            function highlightTokens(e1, t) {
                let r = "";
                for (const { type: n, value: s } of c(t)){
                    const t = e1[n];
                    if (t) {
                        r += s.split(o).map((e1)=>t(e1)).join("\n");
                    } else {
                        r += s;
                    }
                }
                return r;
            }
            function shouldHighlight(e1) {
                return i.default.level > 0 || e1.forceColor;
            }
            let u = undefined;
            function getChalk(e1) {
                if (e1) {
                    var t;
                    (t = u) != null ? t : u = new i.default.constructor({
                        enabled: true,
                        level: 1
                    });
                    return u;
                }
                return i.default;
            }
            {
                t.getChalk = (e1)=>getChalk(e1.forceColor);
            }
            function highlight(e1, t = {}) {
                if (e1 !== "" && shouldHighlight(t)) {
                    const r = getDefs(getChalk(t.forceColor));
                    return highlightTokens(r, e1);
                } else {
                    return e1;
                }
            }
        },
        5771: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = highlight;
            t.shouldHighlight = shouldHighlight;
            var n = r(8874);
            var s = r(5018);
            var i = _interopRequireWildcard(r(1437), true);
            function _getRequireWildcardCache(e1) {
                if ("function" != typeof WeakMap) return null;
                var t = new WeakMap, r = new WeakMap;
                return (_getRequireWildcardCache = function(e1) {
                    return e1 ? r : t;
                })(e1);
            }
            function _interopRequireWildcard(e1, t) {
                if (!t && e1 && e1.__esModule) return e1;
                if (null === e1 || "object" != typeof e1 && "function" != typeof e1) return {
                    default: e1
                };
                var r = _getRequireWildcardCache(t);
                if (r && r.has(e1)) return r.get(e1);
                var n = {
                    __proto__: null
                }, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var i in e1)if ("default" !== i && ({}).hasOwnProperty.call(e1, i)) {
                    var a = s ? Object.getOwnPropertyDescriptor(e1, i) : null;
                    a && (a.get || a.set) ? Object.defineProperty(n, i, a) : n[i] = e1[i];
                }
                return n.default = e1, r && r.set(e1, n), n;
            }
            const a = typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? (0, i.createColors)(false) : i.default;
            const compose = (e1, t)=>(r)=>e1(t(r));
            const o = new Set([
                "as",
                "async",
                "from",
                "get",
                "of",
                "set"
            ]);
            function getDefs(e1) {
                return {
                    keyword: e1.cyan,
                    capitalized: e1.yellow,
                    jsxIdentifier: e1.yellow,
                    punctuator: e1.yellow,
                    number: e1.magenta,
                    string: e1.green,
                    regex: e1.magenta,
                    comment: e1.gray,
                    invalid: compose(compose(e1.white, e1.bgRed), e1.bold)
                };
            }
            const l = /\r\n|[\n\r\u2028\u2029]/;
            const c = /^[()[\]{}]$/;
            let u;
            {
                const e1 = /^[a-z][\w-]*$/i;
                const getTokenType = function(t, r, n) {
                    if (t.type === "name") {
                        if ((0, s.isKeyword)(t.value) || (0, s.isStrictReservedWord)(t.value, true) || o.has(t.value)) {
                            return "keyword";
                        }
                        if (e1.test(t.value) && (n[r - 1] === "<" || n.slice(r - 2, r) === "</")) {
                            return "jsxIdentifier";
                        }
                        if (t.value[0] !== t.value[0].toLowerCase()) {
                            return "capitalized";
                        }
                    }
                    if (t.type === "punctuator" && c.test(t.value)) {
                        return "bracket";
                    }
                    if (t.type === "invalid" && (t.value === "@" || t.value === "#")) {
                        return "punctuator";
                    }
                    return t.type;
                };
                u = function*(e1) {
                    let t;
                    while(t = n.default.exec(e1)){
                        const r = n.matchToToken(t);
                        yield {
                            type: getTokenType(r, t.index, e1),
                            value: r.value
                        };
                    }
                };
            }
            function highlightTokens(e1, t) {
                let r = "";
                for (const { type: n, value: s } of u(t)){
                    const t = e1[n];
                    if (t) {
                        r += s.split(l).map((e1)=>t(e1)).join("\n");
                    } else {
                        r += s;
                    }
                }
                return r;
            }
            function shouldHighlight(e1) {
                return a.isColorSupported || e1.forceColor;
            }
            let p = undefined;
            function getColors(e1) {
                if (e1) {
                    var t;
                    (t = p) != null ? t : p = (0, i.createColors)(true);
                    return p;
                }
                return a;
            }
            function highlight(e1, t = {}) {
                if (e1 !== "" && shouldHighlight(t)) {
                    const r = getDefs(getColors(t.forceColor));
                    return highlightTokens(r, e1);
                } else {
                    return e1;
                }
            }
            {
                let e1, n;
                t.getChalk = ({ forceColor: t })=>{
                    var s;
                    (s = e1) != null ? s : e1 = r(6148);
                    if (t) {
                        var i;
                        (i = n) != null ? i : n = new e1.constructor({
                            enabled: true,
                            level: 1
                        });
                        return n;
                    }
                    return e1;
                };
            }
        },
        7383: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            function _objectWithoutPropertiesLoose(e1, t) {
                if (e1 == null) return {};
                var r = {};
                var n = Object.keys(e1);
                var s, i;
                for(i = 0; i < n.length; i++){
                    s = n[i];
                    if (t.indexOf(s) >= 0) continue;
                    r[s] = e1[s];
                }
                return r;
            }
            class Position {
                constructor(e1, t, r){
                    this.line = void 0;
                    this.column = void 0;
                    this.index = void 0;
                    this.line = e1;
                    this.column = t;
                    this.index = r;
                }
            }
            class SourceLocation {
                constructor(e1, t){
                    this.start = void 0;
                    this.end = void 0;
                    this.filename = void 0;
                    this.identifierName = void 0;
                    this.start = e1;
                    this.end = t;
                }
            }
            function createPositionWithColumnOffset(e1, t) {
                const { line: r, column: n, index: s } = e1;
                return new Position(r, n + t, s + t);
            }
            var r = {
                SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
                SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
            };
            const reflect = (e1, t = e1.length - 1)=>({
                    get () {
                        return e1.reduce((e1, t)=>e1[t], this);
                    },
                    set (r) {
                        e1.reduce((e1, n, s)=>s === t ? e1[n] = r : e1[n], this);
                    }
                });
            const instantiate = (e1, t, r)=>Object.keys(r).map((e1)=>[
                        e1,
                        r[e1]
                    ]).filter(([, e1])=>!!e1).map(([e1, t])=>[
                        e1,
                        typeof t === "function" ? {
                            value: t,
                            enumerable: false
                        } : typeof t.reflect === "string" ? Object.assign({}, t, reflect(t.reflect.split("."))) : t
                    ]).reduce((e1, [t, r])=>Object.defineProperty(e1, t, Object.assign({
                        configurable: true
                    }, r)), Object.assign(new e1, t));
            var n = {
                ImportMetaOutsideModule: {
                    message: `import.meta may appear only with 'sourceType: "module"'`,
                    code: r.SourceTypeModuleError
                },
                ImportOutsideModule: {
                    message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
                    code: r.SourceTypeModuleError
                }
            };
            const s = {
                ArrayPattern: "array destructuring pattern",
                AssignmentExpression: "assignment expression",
                AssignmentPattern: "assignment expression",
                ArrowFunctionExpression: "arrow function expression",
                ConditionalExpression: "conditional expression",
                CatchClause: "catch clause",
                ForOfStatement: "for-of statement",
                ForInStatement: "for-in statement",
                ForStatement: "for-loop",
                FormalParameters: "function parameter list",
                Identifier: "identifier",
                ImportSpecifier: "import specifier",
                ImportDefaultSpecifier: "import default specifier",
                ImportNamespaceSpecifier: "import namespace specifier",
                ObjectPattern: "object destructuring pattern",
                ParenthesizedExpression: "parenthesized expression",
                RestElement: "rest element",
                UpdateExpression: {
                    true: "prefix operation",
                    false: "postfix operation"
                },
                VariableDeclarator: "variable declaration",
                YieldExpression: "yield expression"
            };
            const toNodeDescription = ({ type: e1, prefix: t })=>e1 === "UpdateExpression" ? s.UpdateExpression[String(t)] : s[e1];
            var i = {
                AccessorIsGenerator: ({ kind: e1 })=>`A ${e1}ter cannot be a generator.`,
                ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
                AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
                AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
                AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
                AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
                AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
                AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
                AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
                BadGetterArity: "A 'get' accessor must not have any formal parameters.",
                BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
                BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
                ConstructorClassField: "Classes may not have a field named 'constructor'.",
                ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
                ConstructorIsAccessor: "Class constructor may not be an accessor.",
                ConstructorIsAsync: "Constructor can't be an async function.",
                ConstructorIsGenerator: "Constructor can't be a generator.",
                DeclarationMissingInitializer: ({ kind: e1 })=>`Missing initializer in ${e1} declaration.`,
                DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
                DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
                DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
                DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
                DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
                DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
                DecoratorStaticBlock: "Decorators can't be used with a static block.",
                DeletePrivateField: "Deleting a private field is not allowed.",
                DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
                DuplicateConstructor: "Duplicate constructor in the same class.",
                DuplicateDefaultExport: "Only one default export allowed per module.",
                DuplicateExport: ({ exportName: e1 })=>`\`${e1}\` has already been exported. Exported identifiers must be unique.`,
                DuplicateProto: "Redefinition of __proto__ property.",
                DuplicateRegExpFlags: "Duplicate regular expression flag.",
                ElementAfterRest: "Rest element must be last element.",
                EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
                ExportBindingIsString: ({ localName: e1, exportName: t })=>`A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${e1}' as '${t}' } from 'some-module'\`?`,
                ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
                ForInOfLoopInitializer: ({ type: e1 })=>`'${e1 === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
                ForInUsing: "For-in loop may not start with 'using' declaration.",
                ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
                ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
                GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
                IllegalBreakContinue: ({ type: e1 })=>`Unsyntactic ${e1 === "BreakStatement" ? "break" : "continue"}.`,
                IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
                IllegalReturn: "'return' outside of function.",
                ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
                ImportBindingIsString: ({ importName: e1 })=>`A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${e1}" as foo }\`?`,
                ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
                ImportCallArity: ({ maxArgumentCount: e1 })=>`\`import()\` requires exactly ${e1 === 1 ? "one argument" : "one or two arguments"}.`,
                ImportCallNotNewExpression: "Cannot use new with import(...).",
                ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
                ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
                ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
                ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
                IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
                InvalidBigIntLiteral: "Invalid BigIntLiteral.",
                InvalidCodePoint: "Code point out of bounds.",
                InvalidCoverInitializedName: "Invalid shorthand property initializer.",
                InvalidDecimal: "Invalid decimal.",
                InvalidDigit: ({ radix: e1 })=>`Expected number in radix ${e1}.`,
                InvalidEscapeSequence: "Bad character escape sequence.",
                InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
                InvalidEscapedReservedWord: ({ reservedWord: e1 })=>`Escape sequence in keyword ${e1}.`,
                InvalidIdentifier: ({ identifierName: e1 })=>`Invalid identifier ${e1}.`,
                InvalidLhs: ({ ancestor: e1 })=>`Invalid left-hand side in ${toNodeDescription(e1)}.`,
                InvalidLhsBinding: ({ ancestor: e1 })=>`Binding invalid left-hand side in ${toNodeDescription(e1)}.`,
                InvalidNumber: "Invalid number.",
                InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
                InvalidOrUnexpectedToken: ({ unexpected: e1 })=>`Unexpected character '${e1}'.`,
                InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
                InvalidPrivateFieldResolution: ({ identifierName: e1 })=>`Private name #${e1} is not defined.`,
                InvalidPropertyBindingPattern: "Binding member expression.",
                InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
                InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
                LabelRedeclaration: ({ labelName: e1 })=>`Label '${e1}' is already declared.`,
                LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
                LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
                MalformedRegExpFlags: "Invalid regular expression flag.",
                MissingClassName: "A class name is required.",
                MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
                MissingSemicolon: "Missing semicolon.",
                MissingPlugin: ({ missingPlugin: e1 })=>`This experimental syntax requires enabling the parser plugin: ${e1.map((e1)=>JSON.stringify(e1)).join(", ")}.`,
                MissingOneOfPlugins: ({ missingPlugin: e1 })=>`This experimental syntax requires enabling one of the following parser plugin(s): ${e1.map((e1)=>JSON.stringify(e1)).join(", ")}.`,
                MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
                MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
                ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
                ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
                ModuleAttributesWithDuplicateKeys: ({ key: e1 })=>`Duplicate key "${e1}" is not allowed in module attributes.`,
                ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: e1 })=>`An export name cannot include a lone surrogate, found '\\u${e1.toString(16)}'.`,
                ModuleExportUndefined: ({ localName: e1 })=>`Export '${e1}' is not defined.`,
                MultipleDefaultsInSwitch: "Multiple default clauses.",
                NewlineAfterThrow: "Illegal newline after throw.",
                NoCatchOrFinally: "Missing catch or finally clause.",
                NumberIdentifier: "Identifier directly after number.",
                NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
                ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
                OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
                OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
                OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
                ParamDupe: "Argument name clash.",
                PatternHasAccessor: "Object pattern can't contain getter or setter.",
                PatternHasMethod: "Object pattern can't contain methods.",
                PrivateInExpectedIn: ({ identifierName: e1 })=>`Private names are only allowed in property accesses (\`obj.#${e1}\`) or in \`in\` expressions (\`#${e1} in obj\`).`,
                PrivateNameRedeclaration: ({ identifierName: e1 })=>`Duplicate private name #${e1}.`,
                RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
                RecordNoProto: "'__proto__' is not allowed in Record expressions.",
                RestTrailingComma: "Unexpected trailing comma after rest element.",
                SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
                SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
                StaticPrototype: "Classes may not have static property named prototype.",
                SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
                SuperPrivateField: "Private fields can't be accessed on super.",
                TrailingDecorator: "Decorators must be attached to a class element.",
                TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
                TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
                UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
                UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
                UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
                UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
                UnexpectedKeyword: ({ keyword: e1 })=>`Unexpected keyword '${e1}'.`,
                UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
                UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
                UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
                UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
                UnexpectedPrivateField: "Unexpected private name.",
                UnexpectedReservedWord: ({ reservedWord: e1 })=>`Unexpected reserved word '${e1}'.`,
                UnexpectedSuper: "'super' is only allowed in object methods and classes.",
                UnexpectedToken: ({ expected: e1, unexpected: t })=>`Unexpected token${t ? ` '${t}'.` : ""}${e1 ? `, expected "${e1}"` : ""}`,
                UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
                UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
                UnsupportedBind: "Binding should be performed on object property.",
                UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
                UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
                UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
                UnsupportedMetaProperty: ({ target: e1, onlyValidPropertyName: t })=>`The only valid meta property for ${e1} is ${e1}.${t}.`,
                UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
                UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
                UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
                UnterminatedComment: "Unterminated comment.",
                UnterminatedRegExp: "Unterminated regular expression.",
                UnterminatedString: "Unterminated string constant.",
                UnterminatedTemplate: "Unterminated template.",
                UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
                VarRedeclaration: ({ identifierName: e1 })=>`Identifier '${e1}' has already been declared.`,
                YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
                YieldInParameter: "Yield expression is not allowed in formal parameters.",
                ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
            };
            var a = {
                StrictDelete: "Deleting local variable in strict mode.",
                StrictEvalArguments: ({ referenceName: e1 })=>`Assigning to '${e1}' in strict mode.`,
                StrictEvalArgumentsBinding: ({ bindingName: e1 })=>`Binding '${e1}' in strict mode.`,
                StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
                StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
                StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
                StrictWith: "'with' in strict mode."
            };
            const o = new Set([
                "ArrowFunctionExpression",
                "AssignmentExpression",
                "ConditionalExpression",
                "YieldExpression"
            ]);
            var l = {
                PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
                PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
                PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
                PipeTopicUnconfiguredToken: ({ token: e1 })=>`Invalid topic token ${e1}. In order to use ${e1} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e1}" }.`,
                PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
                PipeUnparenthesizedBody: ({ type: e1 })=>`Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
                        type: e1
                    })}; please wrap it in parentheses.`,
                PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
                PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
                PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
                PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
                PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
                PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
            };
            const c = [
                "toMessage"
            ], u = [
                "message"
            ];
            function toParseErrorConstructor(e1) {
                let { toMessage: t } = e1, r = _objectWithoutPropertiesLoose(e1, c);
                return function constructor({ loc: e1, details: n }) {
                    return instantiate(SyntaxError, Object.assign({}, r, {
                        loc: e1
                    }), {
                        clone (e1 = {}) {
                            const t = e1.loc || {};
                            return constructor({
                                loc: new Position("line" in t ? t.line : this.loc.line, "column" in t ? t.column : this.loc.column, "index" in t ? t.index : this.loc.index),
                                details: Object.assign({}, this.details, e1.details)
                            });
                        },
                        details: {
                            value: n,
                            enumerable: false
                        },
                        message: {
                            get () {
                                return `${t(this.details)} (${this.loc.line}:${this.loc.column})`;
                            },
                            set (e1) {
                                Object.defineProperty(this, "message", {
                                    value: e1
                                });
                            }
                        },
                        pos: {
                            reflect: "loc.index",
                            enumerable: true
                        },
                        missingPlugin: "missingPlugin" in n && {
                            reflect: "details.missingPlugin",
                            enumerable: true
                        }
                    });
                };
            }
            function ParseErrorEnum(e1, t) {
                if (Array.isArray(e1)) {
                    return (t)=>ParseErrorEnum(t, e1[0]);
                }
                const n = {};
                for (const s of Object.keys(e1)){
                    const i = e1[s];
                    const a = typeof i === "string" ? {
                        message: ()=>i
                    } : typeof i === "function" ? {
                        message: i
                    } : i, { message: o } = a, l = _objectWithoutPropertiesLoose(a, u);
                    const c = typeof o === "string" ? ()=>o : o;
                    n[s] = toParseErrorConstructor(Object.assign({
                        code: r.SyntaxError,
                        reasonCode: s,
                        toMessage: c
                    }, t ? {
                        syntaxPlugin: t
                    } : {}, l));
                }
                return n;
            }
            const p = Object.assign({}, ParseErrorEnum(n), ParseErrorEnum(i), ParseErrorEnum(a), ParseErrorEnum`pipelineOperator`(l));
            const { defineProperty: f } = Object;
            const toUnenumerable = (e1, t)=>f(e1, t, {
                    enumerable: false,
                    value: e1[t]
                });
            function toESTreeLocation(e1) {
                e1.loc.start && toUnenumerable(e1.loc.start, "index");
                e1.loc.end && toUnenumerable(e1.loc.end, "index");
                return e1;
            }
            var estree = (e1)=>class ESTreeParserMixin extends e1 {
                    parse() {
                        const e1 = toESTreeLocation(super.parse());
                        if (this.options.tokens) {
                            e1.tokens = e1.tokens.map(toESTreeLocation);
                        }
                        return e1;
                    }
                    parseRegExpLiteral({ pattern: e1, flags: t }) {
                        let r = null;
                        try {
                            r = new RegExp(e1, t);
                        } catch (e1) {}
                        const n = this.estreeParseLiteral(r);
                        n.regex = {
                            pattern: e1,
                            flags: t
                        };
                        return n;
                    }
                    parseBigIntLiteral(e1) {
                        let t;
                        try {
                            t = BigInt(e1);
                        } catch (e1) {
                            t = null;
                        }
                        const r = this.estreeParseLiteral(t);
                        r.bigint = String(r.value || e1);
                        return r;
                    }
                    parseDecimalLiteral(e1) {
                        const t = null;
                        const r = this.estreeParseLiteral(t);
                        r.decimal = String(r.value || e1);
                        return r;
                    }
                    estreeParseLiteral(e1) {
                        return this.parseLiteral(e1, "Literal");
                    }
                    parseStringLiteral(e1) {
                        return this.estreeParseLiteral(e1);
                    }
                    parseNumericLiteral(e1) {
                        return this.estreeParseLiteral(e1);
                    }
                    parseNullLiteral() {
                        return this.estreeParseLiteral(null);
                    }
                    parseBooleanLiteral(e1) {
                        return this.estreeParseLiteral(e1);
                    }
                    directiveToStmt(e1) {
                        const t = e1.value;
                        delete e1.value;
                        t.type = "Literal";
                        t.raw = t.extra.raw;
                        t.value = t.extra.expressionValue;
                        const r = e1;
                        r.type = "ExpressionStatement";
                        r.expression = t;
                        r.directive = t.extra.rawValue;
                        delete t.extra;
                        return r;
                    }
                    initFunction(e1, t) {
                        super.initFunction(e1, t);
                        e1.expression = false;
                    }
                    checkDeclaration(e1) {
                        if (e1 != null && this.isObjectProperty(e1)) {
                            this.checkDeclaration(e1.value);
                        } else {
                            super.checkDeclaration(e1);
                        }
                    }
                    getObjectOrClassMethodParams(e1) {
                        return e1.value.params;
                    }
                    isValidDirective(e1) {
                        var t;
                        return e1.type === "ExpressionStatement" && e1.expression.type === "Literal" && typeof e1.expression.value === "string" && !((t = e1.expression.extra) != null && t.parenthesized);
                    }
                    parseBlockBody(e1, t, r, n, s) {
                        super.parseBlockBody(e1, t, r, n, s);
                        const i = e1.directives.map((e1)=>this.directiveToStmt(e1));
                        e1.body = i.concat(e1.body);
                        delete e1.directives;
                    }
                    pushClassMethod(e1, t, r, n, s, i) {
                        this.parseMethod(t, r, n, s, i, "ClassMethod", true);
                        if (t.typeParameters) {
                            t.value.typeParameters = t.typeParameters;
                            delete t.typeParameters;
                        }
                        e1.body.push(t);
                    }
                    parsePrivateName() {
                        const e1 = super.parsePrivateName();
                        {
                            if (!this.getPluginOption("estree", "classFeatures")) {
                                return e1;
                            }
                        }
                        return this.convertPrivateNameToPrivateIdentifier(e1);
                    }
                    convertPrivateNameToPrivateIdentifier(e1) {
                        const t = super.getPrivateNameSV(e1);
                        e1 = e1;
                        delete e1.id;
                        e1.name = t;
                        e1.type = "PrivateIdentifier";
                        return e1;
                    }
                    isPrivateName(e1) {
                        {
                            if (!this.getPluginOption("estree", "classFeatures")) {
                                return super.isPrivateName(e1);
                            }
                        }
                        return e1.type === "PrivateIdentifier";
                    }
                    getPrivateNameSV(e1) {
                        {
                            if (!this.getPluginOption("estree", "classFeatures")) {
                                return super.getPrivateNameSV(e1);
                            }
                        }
                        return e1.name;
                    }
                    parseLiteral(e1, t) {
                        const r = super.parseLiteral(e1, t);
                        r.raw = r.extra.raw;
                        delete r.extra;
                        return r;
                    }
                    parseFunctionBody(e1, t, r = false) {
                        super.parseFunctionBody(e1, t, r);
                        e1.expression = e1.body.type !== "BlockStatement";
                    }
                    parseMethod(e1, t, r, n, s, i, a = false) {
                        let o = this.startNode();
                        o.kind = e1.kind;
                        o = super.parseMethod(o, t, r, n, s, i, a);
                        o.type = "FunctionExpression";
                        delete o.kind;
                        e1.value = o;
                        if (i === "ClassPrivateMethod") {
                            e1.computed = false;
                        }
                        return this.finishNode(e1, "MethodDefinition");
                    }
                    parseClassProperty(...e1) {
                        const t = super.parseClassProperty(...e1);
                        {
                            if (!this.getPluginOption("estree", "classFeatures")) {
                                return t;
                            }
                        }
                        t.type = "PropertyDefinition";
                        return t;
                    }
                    parseClassPrivateProperty(...e1) {
                        const t = super.parseClassPrivateProperty(...e1);
                        {
                            if (!this.getPluginOption("estree", "classFeatures")) {
                                return t;
                            }
                        }
                        t.type = "PropertyDefinition";
                        t.computed = false;
                        return t;
                    }
                    parseObjectMethod(e1, t, r, n, s) {
                        const i = super.parseObjectMethod(e1, t, r, n, s);
                        if (i) {
                            i.type = "Property";
                            if (i.kind === "method") {
                                i.kind = "init";
                            }
                            i.shorthand = false;
                        }
                        return i;
                    }
                    parseObjectProperty(e1, t, r, n) {
                        const s = super.parseObjectProperty(e1, t, r, n);
                        if (s) {
                            s.kind = "init";
                            s.type = "Property";
                        }
                        return s;
                    }
                    isValidLVal(e1, t, r) {
                        return e1 === "Property" ? "value" : super.isValidLVal(e1, t, r);
                    }
                    isAssignable(e1, t) {
                        if (e1 != null && this.isObjectProperty(e1)) {
                            return this.isAssignable(e1.value, t);
                        }
                        return super.isAssignable(e1, t);
                    }
                    toAssignable(e1, t = false) {
                        if (e1 != null && this.isObjectProperty(e1)) {
                            const { key: r, value: n } = e1;
                            if (this.isPrivateName(r)) {
                                this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start);
                            }
                            this.toAssignable(n, t);
                        } else {
                            super.toAssignable(e1, t);
                        }
                    }
                    toAssignableObjectExpressionProp(e1, t, r) {
                        if (e1.kind === "get" || e1.kind === "set") {
                            this.raise(p.PatternHasAccessor, {
                                at: e1.key
                            });
                        } else if (e1.method) {
                            this.raise(p.PatternHasMethod, {
                                at: e1.key
                            });
                        } else {
                            super.toAssignableObjectExpressionProp(e1, t, r);
                        }
                    }
                    finishCallExpression(e1, t) {
                        const r = super.finishCallExpression(e1, t);
                        if (r.callee.type === "Import") {
                            r.type = "ImportExpression";
                            r.source = r.arguments[0];
                            if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
                                var n;
                                r.attributes = (n = r.arguments[1]) != null ? n : null;
                            }
                            delete r.arguments;
                            delete r.callee;
                        }
                        return r;
                    }
                    toReferencedArguments(e1) {
                        if (e1.type === "ImportExpression") {
                            return;
                        }
                        super.toReferencedArguments(e1);
                    }
                    parseExport(e1, t) {
                        const r = this.state.lastTokStartLoc;
                        const n = super.parseExport(e1, t);
                        switch(n.type){
                            case "ExportAllDeclaration":
                                n.exported = null;
                                break;
                            case "ExportNamedDeclaration":
                                if (n.specifiers.length === 1 && n.specifiers[0].type === "ExportNamespaceSpecifier") {
                                    n.type = "ExportAllDeclaration";
                                    n.exported = n.specifiers[0].exported;
                                    delete n.specifiers;
                                }
                            case "ExportDefaultDeclaration":
                                {
                                    var s;
                                    const { declaration: e1 } = n;
                                    if ((e1 == null ? void 0 : e1.type) === "ClassDeclaration" && ((s = e1.decorators) == null ? void 0 : s.length) > 0 && e1.start === n.start) {
                                        this.resetStartLocation(n, r);
                                    }
                                }
                                break;
                        }
                        return n;
                    }
                    parseSubscript(e1, t, r, n) {
                        const s = super.parseSubscript(e1, t, r, n);
                        if (n.optionalChainMember) {
                            if (s.type === "OptionalMemberExpression" || s.type === "OptionalCallExpression") {
                                s.type = s.type.substring(8);
                            }
                            if (n.stop) {
                                const e1 = this.startNodeAtNode(s);
                                e1.expression = s;
                                return this.finishNode(e1, "ChainExpression");
                            }
                        } else if (s.type === "MemberExpression" || s.type === "CallExpression") {
                            s.optional = false;
                        }
                        return s;
                    }
                    hasPropertyAsPrivateName(e1) {
                        if (e1.type === "ChainExpression") {
                            e1 = e1.expression;
                        }
                        return super.hasPropertyAsPrivateName(e1);
                    }
                    isObjectProperty(e1) {
                        return e1.type === "Property" && e1.kind === "init" && !e1.method;
                    }
                    isObjectMethod(e1) {
                        return e1.method || e1.kind === "get" || e1.kind === "set";
                    }
                    finishNodeAt(e1, t, r) {
                        return toESTreeLocation(super.finishNodeAt(e1, t, r));
                    }
                    resetStartLocation(e1, t) {
                        super.resetStartLocation(e1, t);
                        toESTreeLocation(e1);
                    }
                    resetEndLocation(e1, t = this.state.lastTokEndLoc) {
                        super.resetEndLocation(e1, t);
                        toESTreeLocation(e1);
                    }
                };
            class TokContext {
                constructor(e1, t){
                    this.token = void 0;
                    this.preserveSpace = void 0;
                    this.token = e1;
                    this.preserveSpace = !!t;
                }
            }
            const d = {
                brace: new TokContext("{"),
                j_oTag: new TokContext("<tag"),
                j_cTag: new TokContext("</tag"),
                j_expr: new TokContext("<tag>...</tag>", true)
            };
            {
                d.template = new TokContext("`", true);
            }
            const h = true;
            const m = true;
            const y = true;
            const g = true;
            const b = true;
            const T = true;
            class ExportedTokenType {
                constructor(e1, t = {}){
                    this.label = void 0;
                    this.keyword = void 0;
                    this.beforeExpr = void 0;
                    this.startsExpr = void 0;
                    this.rightAssociative = void 0;
                    this.isLoop = void 0;
                    this.isAssign = void 0;
                    this.prefix = void 0;
                    this.postfix = void 0;
                    this.binop = void 0;
                    this.label = e1;
                    this.keyword = t.keyword;
                    this.beforeExpr = !!t.beforeExpr;
                    this.startsExpr = !!t.startsExpr;
                    this.rightAssociative = !!t.rightAssociative;
                    this.isLoop = !!t.isLoop;
                    this.isAssign = !!t.isAssign;
                    this.prefix = !!t.prefix;
                    this.postfix = !!t.postfix;
                    this.binop = t.binop != null ? t.binop : null;
                    {
                        this.updateContext = null;
                    }
                }
            }
            const S = new Map;
            function createKeyword(e1, t = {}) {
                t.keyword = e1;
                const r = createToken(e1, t);
                S.set(e1, r);
                return r;
            }
            function createBinop(e1, t) {
                return createToken(e1, {
                    beforeExpr: h,
                    binop: t
                });
            }
            let E = -1;
            const v = [];
            const x = [];
            const P = [];
            const w = [];
            const A = [];
            const C = [];
            function createToken(e1, t = {}) {
                var r, n, s, i;
                ++E;
                x.push(e1);
                P.push((r = t.binop) != null ? r : -1);
                w.push((n = t.beforeExpr) != null ? n : false);
                A.push((s = t.startsExpr) != null ? s : false);
                C.push((i = t.prefix) != null ? i : false);
                v.push(new ExportedTokenType(e1, t));
                return E;
            }
            function createKeywordLike(e1, t = {}) {
                var r, n, s, i;
                ++E;
                S.set(e1, E);
                x.push(e1);
                P.push((r = t.binop) != null ? r : -1);
                w.push((n = t.beforeExpr) != null ? n : false);
                A.push((s = t.startsExpr) != null ? s : false);
                C.push((i = t.prefix) != null ? i : false);
                v.push(new ExportedTokenType("name", t));
                return E;
            }
            const I = {
                bracketL: createToken("[", {
                    beforeExpr: h,
                    startsExpr: m
                }),
                bracketHashL: createToken("#[", {
                    beforeExpr: h,
                    startsExpr: m
                }),
                bracketBarL: createToken("[|", {
                    beforeExpr: h,
                    startsExpr: m
                }),
                bracketR: createToken("]"),
                bracketBarR: createToken("|]"),
                braceL: createToken("{", {
                    beforeExpr: h,
                    startsExpr: m
                }),
                braceBarL: createToken("{|", {
                    beforeExpr: h,
                    startsExpr: m
                }),
                braceHashL: createToken("#{", {
                    beforeExpr: h,
                    startsExpr: m
                }),
                braceR: createToken("}"),
                braceBarR: createToken("|}"),
                parenL: createToken("(", {
                    beforeExpr: h,
                    startsExpr: m
                }),
                parenR: createToken(")"),
                comma: createToken(",", {
                    beforeExpr: h
                }),
                semi: createToken(";", {
                    beforeExpr: h
                }),
                colon: createToken(":", {
                    beforeExpr: h
                }),
                doubleColon: createToken("::", {
                    beforeExpr: h
                }),
                dot: createToken("."),
                question: createToken("?", {
                    beforeExpr: h
                }),
                questionDot: createToken("?."),
                arrow: createToken("=>", {
                    beforeExpr: h
                }),
                template: createToken("template"),
                ellipsis: createToken("...", {
                    beforeExpr: h
                }),
                backQuote: createToken("`", {
                    startsExpr: m
                }),
                dollarBraceL: createToken("${", {
                    beforeExpr: h,
                    startsExpr: m
                }),
                templateTail: createToken("...`", {
                    startsExpr: m
                }),
                templateNonTail: createToken("...${", {
                    beforeExpr: h,
                    startsExpr: m
                }),
                at: createToken("@"),
                hash: createToken("#", {
                    startsExpr: m
                }),
                interpreterDirective: createToken("#!..."),
                eq: createToken("=", {
                    beforeExpr: h,
                    isAssign: g
                }),
                assign: createToken("_=", {
                    beforeExpr: h,
                    isAssign: g
                }),
                slashAssign: createToken("_=", {
                    beforeExpr: h,
                    isAssign: g
                }),
                xorAssign: createToken("_=", {
                    beforeExpr: h,
                    isAssign: g
                }),
                moduloAssign: createToken("_=", {
                    beforeExpr: h,
                    isAssign: g
                }),
                incDec: createToken("++/--", {
                    prefix: b,
                    postfix: T,
                    startsExpr: m
                }),
                bang: createToken("!", {
                    beforeExpr: h,
                    prefix: b,
                    startsExpr: m
                }),
                tilde: createToken("~", {
                    beforeExpr: h,
                    prefix: b,
                    startsExpr: m
                }),
                doubleCaret: createToken("^^", {
                    startsExpr: m
                }),
                doubleAt: createToken("@@", {
                    startsExpr: m
                }),
                pipeline: createBinop("|>", 0),
                nullishCoalescing: createBinop("??", 1),
                logicalOR: createBinop("||", 1),
                logicalAND: createBinop("&&", 2),
                bitwiseOR: createBinop("|", 3),
                bitwiseXOR: createBinop("^", 4),
                bitwiseAND: createBinop("&", 5),
                equality: createBinop("==/!=/===/!==", 6),
                lt: createBinop("</>/<=/>=", 7),
                gt: createBinop("</>/<=/>=", 7),
                relational: createBinop("</>/<=/>=", 7),
                bitShift: createBinop("<</>>/>>>", 8),
                bitShiftL: createBinop("<</>>/>>>", 8),
                bitShiftR: createBinop("<</>>/>>>", 8),
                plusMin: createToken("+/-", {
                    beforeExpr: h,
                    binop: 9,
                    prefix: b,
                    startsExpr: m
                }),
                modulo: createToken("%", {
                    binop: 10,
                    startsExpr: m
                }),
                star: createToken("*", {
                    binop: 10
                }),
                slash: createBinop("/", 10),
                exponent: createToken("**", {
                    beforeExpr: h,
                    binop: 11,
                    rightAssociative: true
                }),
                _in: createKeyword("in", {
                    beforeExpr: h,
                    binop: 7
                }),
                _instanceof: createKeyword("instanceof", {
                    beforeExpr: h,
                    binop: 7
                }),
                _break: createKeyword("break"),
                _case: createKeyword("case", {
                    beforeExpr: h
                }),
                _catch: createKeyword("catch"),
                _continue: createKeyword("continue"),
                _debugger: createKeyword("debugger"),
                _default: createKeyword("default", {
                    beforeExpr: h
                }),
                _else: createKeyword("else", {
                    beforeExpr: h
                }),
                _finally: createKeyword("finally"),
                _function: createKeyword("function", {
                    startsExpr: m
                }),
                _if: createKeyword("if"),
                _return: createKeyword("return", {
                    beforeExpr: h
                }),
                _switch: createKeyword("switch"),
                _throw: createKeyword("throw", {
                    beforeExpr: h,
                    prefix: b,
                    startsExpr: m
                }),
                _try: createKeyword("try"),
                _var: createKeyword("var"),
                _const: createKeyword("const"),
                _with: createKeyword("with"),
                _new: createKeyword("new", {
                    beforeExpr: h,
                    startsExpr: m
                }),
                _this: createKeyword("this", {
                    startsExpr: m
                }),
                _super: createKeyword("super", {
                    startsExpr: m
                }),
                _class: createKeyword("class", {
                    startsExpr: m
                }),
                _extends: createKeyword("extends", {
                    beforeExpr: h
                }),
                _export: createKeyword("export"),
                _import: createKeyword("import", {
                    startsExpr: m
                }),
                _null: createKeyword("null", {
                    startsExpr: m
                }),
                _true: createKeyword("true", {
                    startsExpr: m
                }),
                _false: createKeyword("false", {
                    startsExpr: m
                }),
                _typeof: createKeyword("typeof", {
                    beforeExpr: h,
                    prefix: b,
                    startsExpr: m
                }),
                _void: createKeyword("void", {
                    beforeExpr: h,
                    prefix: b,
                    startsExpr: m
                }),
                _delete: createKeyword("delete", {
                    beforeExpr: h,
                    prefix: b,
                    startsExpr: m
                }),
                _do: createKeyword("do", {
                    isLoop: y,
                    beforeExpr: h
                }),
                _for: createKeyword("for", {
                    isLoop: y
                }),
                _while: createKeyword("while", {
                    isLoop: y
                }),
                _as: createKeywordLike("as", {
                    startsExpr: m
                }),
                _assert: createKeywordLike("assert", {
                    startsExpr: m
                }),
                _async: createKeywordLike("async", {
                    startsExpr: m
                }),
                _await: createKeywordLike("await", {
                    startsExpr: m
                }),
                _from: createKeywordLike("from", {
                    startsExpr: m
                }),
                _get: createKeywordLike("get", {
                    startsExpr: m
                }),
                _let: createKeywordLike("let", {
                    startsExpr: m
                }),
                _meta: createKeywordLike("meta", {
                    startsExpr: m
                }),
                _of: createKeywordLike("of", {
                    startsExpr: m
                }),
                _sent: createKeywordLike("sent", {
                    startsExpr: m
                }),
                _set: createKeywordLike("set", {
                    startsExpr: m
                }),
                _static: createKeywordLike("static", {
                    startsExpr: m
                }),
                _using: createKeywordLike("using", {
                    startsExpr: m
                }),
                _yield: createKeywordLike("yield", {
                    startsExpr: m
                }),
                _asserts: createKeywordLike("asserts", {
                    startsExpr: m
                }),
                _checks: createKeywordLike("checks", {
                    startsExpr: m
                }),
                _exports: createKeywordLike("exports", {
                    startsExpr: m
                }),
                _global: createKeywordLike("global", {
                    startsExpr: m
                }),
                _implements: createKeywordLike("implements", {
                    startsExpr: m
                }),
                _intrinsic: createKeywordLike("intrinsic", {
                    startsExpr: m
                }),
                _infer: createKeywordLike("infer", {
                    startsExpr: m
                }),
                _is: createKeywordLike("is", {
                    startsExpr: m
                }),
                _mixins: createKeywordLike("mixins", {
                    startsExpr: m
                }),
                _proto: createKeywordLike("proto", {
                    startsExpr: m
                }),
                _require: createKeywordLike("require", {
                    startsExpr: m
                }),
                _satisfies: createKeywordLike("satisfies", {
                    startsExpr: m
                }),
                _keyof: createKeywordLike("keyof", {
                    startsExpr: m
                }),
                _readonly: createKeywordLike("readonly", {
                    startsExpr: m
                }),
                _unique: createKeywordLike("unique", {
                    startsExpr: m
                }),
                _abstract: createKeywordLike("abstract", {
                    startsExpr: m
                }),
                _declare: createKeywordLike("declare", {
                    startsExpr: m
                }),
                _enum: createKeywordLike("enum", {
                    startsExpr: m
                }),
                _module: createKeywordLike("module", {
                    startsExpr: m
                }),
                _namespace: createKeywordLike("namespace", {
                    startsExpr: m
                }),
                _interface: createKeywordLike("interface", {
                    startsExpr: m
                }),
                _type: createKeywordLike("type", {
                    startsExpr: m
                }),
                _opaque: createKeywordLike("opaque", {
                    startsExpr: m
                }),
                name: createToken("name", {
                    startsExpr: m
                }),
                string: createToken("string", {
                    startsExpr: m
                }),
                num: createToken("num", {
                    startsExpr: m
                }),
                bigint: createToken("bigint", {
                    startsExpr: m
                }),
                decimal: createToken("decimal", {
                    startsExpr: m
                }),
                regexp: createToken("regexp", {
                    startsExpr: m
                }),
                privateName: createToken("#name", {
                    startsExpr: m
                }),
                eof: createToken("eof"),
                jsxName: createToken("jsxName"),
                jsxText: createToken("jsxText", {
                    beforeExpr: true
                }),
                jsxTagStart: createToken("jsxTagStart", {
                    startsExpr: true
                }),
                jsxTagEnd: createToken("jsxTagEnd"),
                placeholder: createToken("%%", {
                    startsExpr: true
                })
            };
            function tokenIsIdentifier(e1) {
                return e1 >= 93 && e1 <= 130;
            }
            function tokenKeywordOrIdentifierIsKeyword(e1) {
                return e1 <= 92;
            }
            function tokenIsKeywordOrIdentifier(e1) {
                return e1 >= 58 && e1 <= 130;
            }
            function tokenIsLiteralPropertyName(e1) {
                return e1 >= 58 && e1 <= 134;
            }
            function tokenComesBeforeExpression(e1) {
                return w[e1];
            }
            function tokenCanStartExpression(e1) {
                return A[e1];
            }
            function tokenIsAssignment(e1) {
                return e1 >= 29 && e1 <= 33;
            }
            function tokenIsFlowInterfaceOrTypeOrOpaque(e1) {
                return e1 >= 127 && e1 <= 129;
            }
            function tokenIsLoop(e1) {
                return e1 >= 90 && e1 <= 92;
            }
            function tokenIsKeyword(e1) {
                return e1 >= 58 && e1 <= 92;
            }
            function tokenIsOperator(e1) {
                return e1 >= 39 && e1 <= 59;
            }
            function tokenIsPostfix(e1) {
                return e1 === 34;
            }
            function tokenIsPrefix(e1) {
                return C[e1];
            }
            function tokenIsTSTypeOperator(e1) {
                return e1 >= 119 && e1 <= 121;
            }
            function tokenIsTSDeclarationStart(e1) {
                return e1 >= 122 && e1 <= 128;
            }
            function tokenLabelName(e1) {
                return x[e1];
            }
            function tokenOperatorPrecedence(e1) {
                return P[e1];
            }
            function tokenIsRightAssociative(e1) {
                return e1 === 57;
            }
            function tokenIsTemplate(e1) {
                return e1 >= 24 && e1 <= 25;
            }
            function getExportedToken(e1) {
                return v[e1];
            }
            {
                v[8].updateContext = (e1)=>{
                    e1.pop();
                };
                v[5].updateContext = v[7].updateContext = v[23].updateContext = (e1)=>{
                    e1.push(d.brace);
                };
                v[22].updateContext = (e1)=>{
                    if (e1[e1.length - 1] === d.template) {
                        e1.pop();
                    } else {
                        e1.push(d.template);
                    }
                };
                v[140].updateContext = (e1)=>{
                    e1.push(d.j_expr, d.j_oTag);
                };
            }
            let O = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
            let k = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
            const N = new RegExp("[" + O + "]");
            const _ = new RegExp("[" + O + k + "]");
            O = k = null;
            const D = [
                0,
                11,
                2,
                25,
                2,
                18,
                2,
                1,
                2,
                14,
                3,
                13,
                35,
                122,
                70,
                52,
                268,
                28,
                4,
                48,
                48,
                31,
                14,
                29,
                6,
                37,
                11,
                29,
                3,
                35,
                5,
                7,
                2,
                4,
                43,
                157,
                19,
                35,
                5,
                35,
                5,
                39,
                9,
                51,
                13,
                10,
                2,
                14,
                2,
                6,
                2,
                1,
                2,
                10,
                2,
                14,
                2,
                6,
                2,
                1,
                68,
                310,
                10,
                21,
                11,
                7,
                25,
                5,
                2,
                41,
                2,
                8,
                70,
                5,
                3,
                0,
                2,
                43,
                2,
                1,
                4,
                0,
                3,
                22,
                11,
                22,
                10,
                30,
                66,
                18,
                2,
                1,
                11,
                21,
                11,
                25,
                71,
                55,
                7,
                1,
                65,
                0,
                16,
                3,
                2,
                2,
                2,
                28,
                43,
                28,
                4,
                28,
                36,
                7,
                2,
                27,
                28,
                53,
                11,
                21,
                11,
                18,
                14,
                17,
                111,
                72,
                56,
                50,
                14,
                50,
                14,
                35,
                349,
                41,
                7,
                1,
                79,
                28,
                11,
                0,
                9,
                21,
                43,
                17,
                47,
                20,
                28,
                22,
                13,
                52,
                58,
                1,
                3,
                0,
                14,
                44,
                33,
                24,
                27,
                35,
                30,
                0,
                3,
                0,
                9,
                34,
                4,
                0,
                13,
                47,
                15,
                3,
                22,
                0,
                2,
                0,
                36,
                17,
                2,
                24,
                20,
                1,
                64,
                6,
                2,
                0,
                2,
                3,
                2,
                14,
                2,
                9,
                8,
                46,
                39,
                7,
                3,
                1,
                3,
                21,
                2,
                6,
                2,
                1,
                2,
                4,
                4,
                0,
                19,
                0,
                13,
                4,
                159,
                52,
                19,
                3,
                21,
                2,
                31,
                47,
                21,
                1,
                2,
                0,
                185,
                46,
                42,
                3,
                37,
                47,
                21,
                0,
                60,
                42,
                14,
                0,
                72,
                26,
                38,
                6,
                186,
                43,
                117,
                63,
                32,
                7,
                3,
                0,
                3,
                7,
                2,
                1,
                2,
                23,
                16,
                0,
                2,
                0,
                95,
                7,
                3,
                38,
                17,
                0,
                2,
                0,
                29,
                0,
                11,
                39,
                8,
                0,
                22,
                0,
                12,
                45,
                20,
                0,
                19,
                72,
                264,
                8,
                2,
                36,
                18,
                0,
                50,
                29,
                113,
                6,
                2,
                1,
                2,
                37,
                22,
                0,
                26,
                5,
                2,
                1,
                2,
                31,
                15,
                0,
                328,
                18,
                16,
                0,
                2,
                12,
                2,
                33,
                125,
                0,
                80,
                921,
                103,
                110,
                18,
                195,
                2637,
                96,
                16,
                1071,
                18,
                5,
                4026,
                582,
                8634,
                568,
                8,
                30,
                18,
                78,
                18,
                29,
                19,
                47,
                17,
                3,
                32,
                20,
                6,
                18,
                689,
                63,
                129,
                74,
                6,
                0,
                67,
                12,
                65,
                1,
                2,
                0,
                29,
                6135,
                9,
                1237,
                43,
                8,
                8936,
                3,
                2,
                6,
                2,
                1,
                2,
                290,
                16,
                0,
                30,
                2,
                3,
                0,
                15,
                3,
                9,
                395,
                2309,
                106,
                6,
                12,
                4,
                8,
                8,
                9,
                5991,
                84,
                2,
                70,
                2,
                1,
                3,
                0,
                3,
                1,
                3,
                3,
                2,
                11,
                2,
                0,
                2,
                6,
                2,
                64,
                2,
                3,
                3,
                7,
                2,
                6,
                2,
                27,
                2,
                3,
                2,
                4,
                2,
                0,
                4,
                6,
                2,
                339,
                3,
                24,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                30,
                2,
                24,
                2,
                7,
                1845,
                30,
                7,
                5,
                262,
                61,
                147,
                44,
                11,
                6,
                17,
                0,
                322,
                29,
                19,
                43,
                485,
                27,
                757,
                6,
                2,
                3,
                2,
                1,
                2,
                14,
                2,
                196,
                60,
                67,
                8,
                0,
                1205,
                3,
                2,
                26,
                2,
                1,
                2,
                0,
                3,
                0,
                2,
                9,
                2,
                3,
                2,
                0,
                2,
                0,
                7,
                0,
                5,
                0,
                2,
                0,
                2,
                0,
                2,
                2,
                2,
                1,
                2,
                0,
                3,
                0,
                2,
                0,
                2,
                0,
                2,
                0,
                2,
                0,
                2,
                1,
                2,
                0,
                3,
                3,
                2,
                6,
                2,
                3,
                2,
                3,
                2,
                0,
                2,
                9,
                2,
                16,
                6,
                2,
                2,
                4,
                2,
                16,
                4421,
                42719,
                33,
                4153,
                7,
                221,
                3,
                5761,
                15,
                7472,
                3104,
                541,
                1507,
                4938,
                6,
                4191
            ];
            const M = [
                509,
                0,
                227,
                0,
                150,
                4,
                294,
                9,
                1368,
                2,
                2,
                1,
                6,
                3,
                41,
                2,
                5,
                0,
                166,
                1,
                574,
                3,
                9,
                9,
                370,
                1,
                81,
                2,
                71,
                10,
                50,
                3,
                123,
                2,
                54,
                14,
                32,
                10,
                3,
                1,
                11,
                3,
                46,
                10,
                8,
                0,
                46,
                9,
                7,
                2,
                37,
                13,
                2,
                9,
                6,
                1,
                45,
                0,
                13,
                2,
                49,
                13,
                9,
                3,
                2,
                11,
                83,
                11,
                7,
                0,
                3,
                0,
                158,
                11,
                6,
                9,
                7,
                3,
                56,
                1,
                2,
                6,
                3,
                1,
                3,
                2,
                10,
                0,
                11,
                1,
                3,
                6,
                4,
                4,
                193,
                17,
                10,
                9,
                5,
                0,
                82,
                19,
                13,
                9,
                214,
                6,
                3,
                8,
                28,
                1,
                83,
                16,
                16,
                9,
                82,
                12,
                9,
                9,
                84,
                14,
                5,
                9,
                243,
                14,
                166,
                9,
                71,
                5,
                2,
                1,
                3,
                3,
                2,
                0,
                2,
                1,
                13,
                9,
                120,
                6,
                3,
                6,
                4,
                0,
                29,
                9,
                41,
                6,
                2,
                3,
                9,
                0,
                10,
                10,
                47,
                15,
                406,
                7,
                2,
                7,
                17,
                9,
                57,
                21,
                2,
                13,
                123,
                5,
                4,
                0,
                2,
                1,
                2,
                6,
                2,
                0,
                9,
                9,
                49,
                4,
                2,
                1,
                2,
                4,
                9,
                9,
                330,
                3,
                10,
                1,
                2,
                0,
                49,
                6,
                4,
                4,
                14,
                9,
                5351,
                0,
                7,
                14,
                13835,
                9,
                87,
                9,
                39,
                4,
                60,
                6,
                26,
                9,
                1014,
                0,
                2,
                54,
                8,
                3,
                82,
                0,
                12,
                1,
                19628,
                1,
                4706,
                45,
                3,
                22,
                543,
                4,
                4,
                5,
                9,
                7,
                3,
                6,
                31,
                3,
                149,
                2,
                1418,
                49,
                513,
                54,
                5,
                49,
                9,
                0,
                15,
                0,
                23,
                4,
                2,
                14,
                1361,
                6,
                2,
                16,
                3,
                6,
                2,
                1,
                2,
                4,
                101,
                0,
                161,
                6,
                10,
                9,
                357,
                0,
                62,
                13,
                499,
                13,
                983,
                6,
                110,
                6,
                6,
                9,
                4759,
                9,
                787719,
                239
            ];
            function isInAstralSet(e1, t) {
                let r = 65536;
                for(let n = 0, s = t.length; n < s; n += 2){
                    r += t[n];
                    if (r > e1) return false;
                    r += t[n + 1];
                    if (r >= e1) return true;
                }
                return false;
            }
            function isIdentifierStart(e1) {
                if (e1 < 65) return e1 === 36;
                if (e1 <= 90) return true;
                if (e1 < 97) return e1 === 95;
                if (e1 <= 122) return true;
                if (e1 <= 65535) {
                    return e1 >= 170 && N.test(String.fromCharCode(e1));
                }
                return isInAstralSet(e1, D);
            }
            function isIdentifierChar(e1) {
                if (e1 < 48) return e1 === 36;
                if (e1 < 58) return true;
                if (e1 < 65) return false;
                if (e1 <= 90) return true;
                if (e1 < 97) return e1 === 95;
                if (e1 <= 122) return true;
                if (e1 <= 65535) {
                    return e1 >= 170 && _.test(String.fromCharCode(e1));
                }
                return isInAstralSet(e1, D) || isInAstralSet(e1, M);
            }
            const L = {
                keyword: [
                    "break",
                    "case",
                    "catch",
                    "continue",
                    "debugger",
                    "default",
                    "do",
                    "else",
                    "finally",
                    "for",
                    "function",
                    "if",
                    "return",
                    "switch",
                    "throw",
                    "try",
                    "var",
                    "const",
                    "while",
                    "with",
                    "new",
                    "this",
                    "super",
                    "class",
                    "extends",
                    "export",
                    "import",
                    "null",
                    "true",
                    "false",
                    "in",
                    "instanceof",
                    "typeof",
                    "void",
                    "delete"
                ],
                strict: [
                    "implements",
                    "interface",
                    "let",
                    "package",
                    "private",
                    "protected",
                    "public",
                    "static",
                    "yield"
                ],
                strictBind: [
                    "eval",
                    "arguments"
                ]
            };
            const j = new Set(L.keyword);
            const F = new Set(L.strict);
            const R = new Set(L.strictBind);
            function isReservedWord(e1, t) {
                return t && e1 === "await" || e1 === "enum";
            }
            function isStrictReservedWord(e1, t) {
                return isReservedWord(e1, t) || F.has(e1);
            }
            function isStrictBindOnlyReservedWord(e1) {
                return R.has(e1);
            }
            function isStrictBindReservedWord(e1, t) {
                return isStrictReservedWord(e1, t) || isStrictBindOnlyReservedWord(e1);
            }
            function isKeyword(e1) {
                return j.has(e1);
            }
            function isIteratorStart(e1, t, r) {
                return e1 === 64 && t === 64 && isIdentifierStart(r);
            }
            const B = new Set([
                "break",
                "case",
                "catch",
                "continue",
                "debugger",
                "default",
                "do",
                "else",
                "finally",
                "for",
                "function",
                "if",
                "return",
                "switch",
                "throw",
                "try",
                "var",
                "const",
                "while",
                "with",
                "new",
                "this",
                "super",
                "class",
                "extends",
                "export",
                "import",
                "null",
                "true",
                "false",
                "in",
                "instanceof",
                "typeof",
                "void",
                "delete",
                "implements",
                "interface",
                "let",
                "package",
                "private",
                "protected",
                "public",
                "static",
                "yield",
                "eval",
                "arguments",
                "enum",
                "await"
            ]);
            function canBeReservedWord(e1) {
                return B.has(e1);
            }
            const U = 0, K = 1, V = 2, W = 4, $ = 8, q = 16, H = 32, G = 64, J = 128, X = 256, z = K | V | J | X;
            const Y = 1, Q = 2, Z = 4, ee = 8, te = 16, re = 64, ne = 128, se = 256, ie = 512, ae = 1024, oe = 2048, le = 4096, ce = 8192;
            const ue = Y | Q | ee | ne | ce, pe = Y | 0 | ee | ce, fe = Y | 0 | ee | 0, de = Y | 0 | Z | 0, he = Y | 0 | te | 0, me = 0 | Q | 0 | ne, ye = 0 | Q | 0 | 0, ge = Y | Q | ee | se | ce, be = 0 | 0 | 0 | ae, Te = 0 | 0 | 0 | re, Se = Y | 0 | 0 | re, Ee = ge | ie, ve = 0 | 0 | 0 | ae, xe = 0 | Q | 0 | le, Pe = oe;
            const we = 4, Ae = 2, Ce = 1, Ie = Ae | Ce;
            const Oe = Ae | we, ke = Ce | we, Ne = Ae, _e = Ce, De = 0;
            class Scope {
                constructor(e1){
                    this.var = new Set;
                    this.lexical = new Set;
                    this.functions = new Set;
                    this.flags = e1;
                }
            }
            class ScopeHandler {
                constructor(e1, t){
                    this.parser = void 0;
                    this.scopeStack = [];
                    this.inModule = void 0;
                    this.undefinedExports = new Map;
                    this.parser = e1;
                    this.inModule = t;
                }
                get inTopLevel() {
                    return (this.currentScope().flags & K) > 0;
                }
                get inFunction() {
                    return (this.currentVarScopeFlags() & V) > 0;
                }
                get allowSuper() {
                    return (this.currentThisScopeFlags() & q) > 0;
                }
                get allowDirectSuper() {
                    return (this.currentThisScopeFlags() & H) > 0;
                }
                get inClass() {
                    return (this.currentThisScopeFlags() & G) > 0;
                }
                get inClassAndNotInNonArrowFunction() {
                    const e1 = this.currentThisScopeFlags();
                    return (e1 & G) > 0 && (e1 & V) === 0;
                }
                get inStaticBlock() {
                    for(let e1 = this.scopeStack.length - 1;; e1--){
                        const { flags: t } = this.scopeStack[e1];
                        if (t & J) {
                            return true;
                        }
                        if (t & (z | G)) {
                            return false;
                        }
                    }
                }
                get inNonArrowFunction() {
                    return (this.currentThisScopeFlags() & V) > 0;
                }
                get treatFunctionsAsVar() {
                    return this.treatFunctionsAsVarInScope(this.currentScope());
                }
                createScope(e1) {
                    return new Scope(e1);
                }
                enter(e1) {
                    this.scopeStack.push(this.createScope(e1));
                }
                exit() {
                    const e1 = this.scopeStack.pop();
                    return e1.flags;
                }
                treatFunctionsAsVarInScope(e1) {
                    return !!(e1.flags & (V | J) || !this.parser.inModule && e1.flags & K);
                }
                declareName(e1, t, r) {
                    let n = this.currentScope();
                    if (t & ee || t & te) {
                        this.checkRedeclarationInScope(n, e1, t, r);
                        if (t & te) {
                            n.functions.add(e1);
                        } else {
                            n.lexical.add(e1);
                        }
                        if (t & ee) {
                            this.maybeExportDefined(n, e1);
                        }
                    } else if (t & Z) {
                        for(let s = this.scopeStack.length - 1; s >= 0; --s){
                            n = this.scopeStack[s];
                            this.checkRedeclarationInScope(n, e1, t, r);
                            n.var.add(e1);
                            this.maybeExportDefined(n, e1);
                            if (n.flags & z) break;
                        }
                    }
                    if (this.parser.inModule && n.flags & K) {
                        this.undefinedExports.delete(e1);
                    }
                }
                maybeExportDefined(e1, t) {
                    if (this.parser.inModule && e1.flags & K) {
                        this.undefinedExports.delete(t);
                    }
                }
                checkRedeclarationInScope(e1, t, r, n) {
                    if (this.isRedeclaredInScope(e1, t, r)) {
                        this.parser.raise(p.VarRedeclaration, {
                            at: n,
                            identifierName: t
                        });
                    }
                }
                isRedeclaredInScope(e1, t, r) {
                    if (!(r & Y)) return false;
                    if (r & ee) {
                        return e1.lexical.has(t) || e1.functions.has(t) || e1.var.has(t);
                    }
                    if (r & te) {
                        return e1.lexical.has(t) || !this.treatFunctionsAsVarInScope(e1) && e1.var.has(t);
                    }
                    return e1.lexical.has(t) && !(e1.flags & $ && e1.lexical.values().next().value === t) || !this.treatFunctionsAsVarInScope(e1) && e1.functions.has(t);
                }
                checkLocalExport(e1) {
                    const { name: t } = e1;
                    const r = this.scopeStack[0];
                    if (!r.lexical.has(t) && !r.var.has(t) && !r.functions.has(t)) {
                        this.undefinedExports.set(t, e1.loc.start);
                    }
                }
                currentScope() {
                    return this.scopeStack[this.scopeStack.length - 1];
                }
                currentVarScopeFlags() {
                    for(let e1 = this.scopeStack.length - 1;; e1--){
                        const { flags: t } = this.scopeStack[e1];
                        if (t & z) {
                            return t;
                        }
                    }
                }
                currentThisScopeFlags() {
                    for(let e1 = this.scopeStack.length - 1;; e1--){
                        const { flags: t } = this.scopeStack[e1];
                        if (t & (z | G) && !(t & W)) {
                            return t;
                        }
                    }
                }
            }
            class FlowScope extends Scope {
                constructor(...e1){
                    super(...e1);
                    this.declareFunctions = new Set;
                }
            }
            class FlowScopeHandler extends ScopeHandler {
                createScope(e1) {
                    return new FlowScope(e1);
                }
                declareName(e1, t, r) {
                    const n = this.currentScope();
                    if (t & oe) {
                        this.checkRedeclarationInScope(n, e1, t, r);
                        this.maybeExportDefined(n, e1);
                        n.declareFunctions.add(e1);
                        return;
                    }
                    super.declareName(e1, t, r);
                }
                isRedeclaredInScope(e1, t, r) {
                    if (super.isRedeclaredInScope(e1, t, r)) return true;
                    if (r & oe) {
                        return !e1.declareFunctions.has(t) && (e1.lexical.has(t) || e1.functions.has(t));
                    }
                    return false;
                }
                checkLocalExport(e1) {
                    if (!this.scopeStack[0].declareFunctions.has(e1.name)) {
                        super.checkLocalExport(e1);
                    }
                }
            }
            class BaseParser {
                constructor(){
                    this.sawUnambiguousESM = false;
                    this.ambiguousScriptDifferentAst = false;
                }
                hasPlugin(e1) {
                    if (typeof e1 === "string") {
                        return this.plugins.has(e1);
                    } else {
                        const [t, r] = e1;
                        if (!this.hasPlugin(t)) {
                            return false;
                        }
                        const n = this.plugins.get(t);
                        for (const e1 of Object.keys(r)){
                            if ((n == null ? void 0 : n[e1]) !== r[e1]) {
                                return false;
                            }
                        }
                        return true;
                    }
                }
                getPluginOption(e1, t) {
                    var r;
                    return (r = this.plugins.get(e1)) == null ? void 0 : r[t];
                }
            }
            function setTrailingComments(e1, t) {
                if (e1.trailingComments === undefined) {
                    e1.trailingComments = t;
                } else {
                    e1.trailingComments.unshift(...t);
                }
            }
            function setLeadingComments(e1, t) {
                if (e1.leadingComments === undefined) {
                    e1.leadingComments = t;
                } else {
                    e1.leadingComments.unshift(...t);
                }
            }
            function setInnerComments(e1, t) {
                if (e1.innerComments === undefined) {
                    e1.innerComments = t;
                } else {
                    e1.innerComments.unshift(...t);
                }
            }
            function adjustInnerComments(e1, t, r) {
                let n = null;
                let s = t.length;
                while(n === null && s > 0){
                    n = t[--s];
                }
                if (n === null || n.start > r.start) {
                    setInnerComments(e1, r.comments);
                } else {
                    setTrailingComments(n, r.comments);
                }
            }
            class CommentsParser extends BaseParser {
                addComment(e1) {
                    if (this.filename) e1.loc.filename = this.filename;
                    this.state.comments.push(e1);
                }
                processComment(e1) {
                    const { commentStack: t } = this.state;
                    const r = t.length;
                    if (r === 0) return;
                    let n = r - 1;
                    const s = t[n];
                    if (s.start === e1.end) {
                        s.leadingNode = e1;
                        n--;
                    }
                    const { start: i } = e1;
                    for(; n >= 0; n--){
                        const r = t[n];
                        const s = r.end;
                        if (s > i) {
                            r.containingNode = e1;
                            this.finalizeComment(r);
                            t.splice(n, 1);
                        } else {
                            if (s === i) {
                                r.trailingNode = e1;
                            }
                            break;
                        }
                    }
                }
                finalizeComment(e1) {
                    const { comments: t } = e1;
                    if (e1.leadingNode !== null || e1.trailingNode !== null) {
                        if (e1.leadingNode !== null) {
                            setTrailingComments(e1.leadingNode, t);
                        }
                        if (e1.trailingNode !== null) {
                            setLeadingComments(e1.trailingNode, t);
                        }
                    } else {
                        const { containingNode: r, start: n } = e1;
                        if (this.input.charCodeAt(n - 1) === 44) {
                            switch(r.type){
                                case "ObjectExpression":
                                case "ObjectPattern":
                                case "RecordExpression":
                                    adjustInnerComments(r, r.properties, e1);
                                    break;
                                case "CallExpression":
                                case "OptionalCallExpression":
                                    adjustInnerComments(r, r.arguments, e1);
                                    break;
                                case "FunctionDeclaration":
                                case "FunctionExpression":
                                case "ArrowFunctionExpression":
                                case "ObjectMethod":
                                case "ClassMethod":
                                case "ClassPrivateMethod":
                                    adjustInnerComments(r, r.params, e1);
                                    break;
                                case "ArrayExpression":
                                case "ArrayPattern":
                                case "TupleExpression":
                                    adjustInnerComments(r, r.elements, e1);
                                    break;
                                case "ExportNamedDeclaration":
                                case "ImportDeclaration":
                                    adjustInnerComments(r, r.specifiers, e1);
                                    break;
                                default:
                                    {
                                        setInnerComments(r, t);
                                    }
                            }
                        } else {
                            setInnerComments(r, t);
                        }
                    }
                }
                finalizeRemainingComments() {
                    const { commentStack: e1 } = this.state;
                    for(let t = e1.length - 1; t >= 0; t--){
                        this.finalizeComment(e1[t]);
                    }
                    this.state.commentStack = [];
                }
                resetPreviousNodeTrailingComments(e1) {
                    const { commentStack: t } = this.state;
                    const { length: r } = t;
                    if (r === 0) return;
                    const n = t[r - 1];
                    if (n.leadingNode === e1) {
                        n.leadingNode = null;
                    }
                }
                resetPreviousIdentifierLeadingComments(e1) {
                    const { commentStack: t } = this.state;
                    const { length: r } = t;
                    if (r === 0) return;
                    if (t[r - 1].trailingNode === e1) {
                        t[r - 1].trailingNode = null;
                    } else if (r >= 2 && t[r - 2].trailingNode === e1) {
                        t[r - 2].trailingNode = null;
                    }
                }
                takeSurroundingComments(e1, t, r) {
                    const { commentStack: n } = this.state;
                    const s = n.length;
                    if (s === 0) return;
                    let i = s - 1;
                    for(; i >= 0; i--){
                        const s = n[i];
                        const a = s.end;
                        const o = s.start;
                        if (o === r) {
                            s.leadingNode = e1;
                        } else if (a === t) {
                            s.trailingNode = e1;
                        } else if (a < t) {
                            break;
                        }
                    }
                }
            }
            const Me = /\r\n?|[\n\u2028\u2029]/;
            const Le = new RegExp(Me.source, "g");
            function isNewLine(e1) {
                switch(e1){
                    case 10:
                    case 13:
                    case 8232:
                    case 8233:
                        return true;
                    default:
                        return false;
                }
            }
            const je = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
            const Fe = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
            const Re = new RegExp("(?=(" + Fe.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
            function isWhitespace(e1) {
                switch(e1){
                    case 9:
                    case 11:
                    case 12:
                    case 32:
                    case 160:
                    case 5760:
                    case 8192:
                    case 8193:
                    case 8194:
                    case 8195:
                    case 8196:
                    case 8197:
                    case 8198:
                    case 8199:
                    case 8200:
                    case 8201:
                    case 8202:
                    case 8239:
                    case 8287:
                    case 12288:
                    case 65279:
                        return true;
                    default:
                        return false;
                }
            }
            class State {
                constructor(){
                    this.strict = void 0;
                    this.curLine = void 0;
                    this.lineStart = void 0;
                    this.startLoc = void 0;
                    this.endLoc = void 0;
                    this.errors = [];
                    this.potentialArrowAt = -1;
                    this.noArrowAt = [];
                    this.noArrowParamsConversionAt = [];
                    this.maybeInArrowParameters = false;
                    this.inType = false;
                    this.noAnonFunctionType = false;
                    this.hasFlowComment = false;
                    this.isAmbientContext = false;
                    this.inAbstractClass = false;
                    this.inDisallowConditionalTypesContext = false;
                    this.topicContext = {
                        maxNumOfResolvableTopics: 0,
                        maxTopicIndex: null
                    };
                    this.soloAwait = false;
                    this.inFSharpPipelineDirectBody = false;
                    this.labels = [];
                    this.comments = [];
                    this.commentStack = [];
                    this.pos = 0;
                    this.type = 137;
                    this.value = null;
                    this.start = 0;
                    this.end = 0;
                    this.lastTokEndLoc = null;
                    this.lastTokStartLoc = null;
                    this.lastTokStart = 0;
                    this.context = [
                        d.brace
                    ];
                    this.canStartJSXElement = true;
                    this.containsEsc = false;
                    this.firstInvalidTemplateEscapePos = null;
                    this.strictErrors = new Map;
                    this.tokensLength = 0;
                }
                init({ strictMode: e1, sourceType: t, startLine: r, startColumn: n }) {
                    this.strict = e1 === false ? false : e1 === true ? true : t === "module";
                    this.curLine = r;
                    this.lineStart = -n;
                    this.startLoc = this.endLoc = new Position(r, n, 0);
                }
                curPosition() {
                    return new Position(this.curLine, this.pos - this.lineStart, this.pos);
                }
                clone(e1) {
                    const t = new State;
                    const r = Object.keys(this);
                    for(let n = 0, s = r.length; n < s; n++){
                        const s = r[n];
                        let i = this[s];
                        if (!e1 && Array.isArray(i)) {
                            i = i.slice();
                        }
                        t[s] = i;
                    }
                    return t;
                }
            }
            var Be = function isDigit(e1) {
                return e1 >= 48 && e1 <= 57;
            };
            const Ue = {
                decBinOct: new Set([
                    46,
                    66,
                    69,
                    79,
                    95,
                    98,
                    101,
                    111
                ]),
                hex: new Set([
                    46,
                    88,
                    95,
                    120
                ])
            };
            const Ke = {
                bin: (e1)=>e1 === 48 || e1 === 49,
                oct: (e1)=>e1 >= 48 && e1 <= 55,
                dec: (e1)=>e1 >= 48 && e1 <= 57,
                hex: (e1)=>e1 >= 48 && e1 <= 57 || e1 >= 65 && e1 <= 70 || e1 >= 97 && e1 <= 102
            };
            function readStringContents(e1, t, r, n, s, i) {
                const a = r;
                const o = n;
                const l = s;
                let c = "";
                let u = null;
                let p = r;
                const { length: f } = t;
                for(;;){
                    if (r >= f) {
                        i.unterminated(a, o, l);
                        c += t.slice(p, r);
                        break;
                    }
                    const d = t.charCodeAt(r);
                    if (isStringEnd(e1, d, t, r)) {
                        c += t.slice(p, r);
                        break;
                    }
                    if (d === 92) {
                        c += t.slice(p, r);
                        const a = readEscapedChar(t, r, n, s, e1 === "template", i);
                        if (a.ch === null && !u) {
                            u = {
                                pos: r,
                                lineStart: n,
                                curLine: s
                            };
                        } else {
                            c += a.ch;
                        }
                        ({ pos: r, lineStart: n, curLine: s } = a);
                        p = r;
                    } else if (d === 8232 || d === 8233) {
                        ++r;
                        ++s;
                        n = r;
                    } else if (d === 10 || d === 13) {
                        if (e1 === "template") {
                            c += t.slice(p, r) + "\n";
                            ++r;
                            if (d === 13 && t.charCodeAt(r) === 10) {
                                ++r;
                            }
                            ++s;
                            p = n = r;
                        } else {
                            i.unterminated(a, o, l);
                        }
                    } else {
                        ++r;
                    }
                }
                return {
                    pos: r,
                    str: c,
                    firstInvalidLoc: u,
                    lineStart: n,
                    curLine: s,
                    containsInvalid: !!u
                };
            }
            function isStringEnd(e1, t, r, n) {
                if (e1 === "template") {
                    return t === 96 || t === 36 && r.charCodeAt(n + 1) === 123;
                }
                return t === (e1 === "double" ? 34 : 39);
            }
            function readEscapedChar(e1, t, r, n, s, i) {
                const a = !s;
                t++;
                const res = (e1)=>({
                        pos: t,
                        ch: e1,
                        lineStart: r,
                        curLine: n
                    });
                const o = e1.charCodeAt(t++);
                switch(o){
                    case 110:
                        return res("\n");
                    case 114:
                        return res("\r");
                    case 120:
                        {
                            let s;
                            ({ code: s, pos: t } = readHexChar(e1, t, r, n, 2, false, a, i));
                            return res(s === null ? null : String.fromCharCode(s));
                        }
                    case 117:
                        {
                            let s;
                            ({ code: s, pos: t } = readCodePoint(e1, t, r, n, a, i));
                            return res(s === null ? null : String.fromCodePoint(s));
                        }
                    case 116:
                        return res("\t");
                    case 98:
                        return res("\b");
                    case 118:
                        return res("\v");
                    case 102:
                        return res("\f");
                    case 13:
                        if (e1.charCodeAt(t) === 10) {
                            ++t;
                        }
                    case 10:
                        r = t;
                        ++n;
                    case 8232:
                    case 8233:
                        return res("");
                    case 56:
                    case 57:
                        if (s) {
                            return res(null);
                        } else {
                            i.strictNumericEscape(t - 1, r, n);
                        }
                    default:
                        if (o >= 48 && o <= 55) {
                            const a = t - 1;
                            const o = e1.slice(a, t + 2).match(/^[0-7]+/);
                            let l = o[0];
                            let c = parseInt(l, 8);
                            if (c > 255) {
                                l = l.slice(0, -1);
                                c = parseInt(l, 8);
                            }
                            t += l.length - 1;
                            const u = e1.charCodeAt(t);
                            if (l !== "0" || u === 56 || u === 57) {
                                if (s) {
                                    return res(null);
                                } else {
                                    i.strictNumericEscape(a, r, n);
                                }
                            }
                            return res(String.fromCharCode(c));
                        }
                        return res(String.fromCharCode(o));
                }
            }
            function readHexChar(e1, t, r, n, s, i, a, o) {
                const l = t;
                let c;
                ({ n: c, pos: t } = readInt(e1, t, r, n, 16, s, i, false, o, !a));
                if (c === null) {
                    if (a) {
                        o.invalidEscapeSequence(l, r, n);
                    } else {
                        t = l - 1;
                    }
                }
                return {
                    code: c,
                    pos: t
                };
            }
            function readInt(e1, t, r, n, s, i, a, o, l, c) {
                const u = t;
                const p = s === 16 ? Ue.hex : Ue.decBinOct;
                const f = s === 16 ? Ke.hex : s === 10 ? Ke.dec : s === 8 ? Ke.oct : Ke.bin;
                let d = false;
                let h = 0;
                for(let u = 0, m = i == null ? Infinity : i; u < m; ++u){
                    const i = e1.charCodeAt(t);
                    let u;
                    if (i === 95 && o !== "bail") {
                        const s = e1.charCodeAt(t - 1);
                        const i = e1.charCodeAt(t + 1);
                        if (!o) {
                            if (c) return {
                                n: null,
                                pos: t
                            };
                            l.numericSeparatorInEscapeSequence(t, r, n);
                        } else if (Number.isNaN(i) || !f(i) || p.has(s) || p.has(i)) {
                            if (c) return {
                                n: null,
                                pos: t
                            };
                            l.unexpectedNumericSeparator(t, r, n);
                        }
                        ++t;
                        continue;
                    }
                    if (i >= 97) {
                        u = i - 97 + 10;
                    } else if (i >= 65) {
                        u = i - 65 + 10;
                    } else if (Be(i)) {
                        u = i - 48;
                    } else {
                        u = Infinity;
                    }
                    if (u >= s) {
                        if (u <= 9 && c) {
                            return {
                                n: null,
                                pos: t
                            };
                        } else if (u <= 9 && l.invalidDigit(t, r, n, s)) {
                            u = 0;
                        } else if (a) {
                            u = 0;
                            d = true;
                        } else {
                            break;
                        }
                    }
                    ++t;
                    h = h * s + u;
                }
                if (t === u || i != null && t - u !== i || d) {
                    return {
                        n: null,
                        pos: t
                    };
                }
                return {
                    n: h,
                    pos: t
                };
            }
            function readCodePoint(e1, t, r, n, s, i) {
                const a = e1.charCodeAt(t);
                let o;
                if (a === 123) {
                    ++t;
                    ({ code: o, pos: t } = readHexChar(e1, t, r, n, e1.indexOf("}", t) - t, true, s, i));
                    ++t;
                    if (o !== null && o > 1114111) {
                        if (s) {
                            i.invalidCodePoint(t, r, n);
                        } else {
                            return {
                                code: null,
                                pos: t
                            };
                        }
                    }
                } else {
                    ({ code: o, pos: t } = readHexChar(e1, t, r, n, 4, false, s, i));
                }
                return {
                    code: o,
                    pos: t
                };
            }
            const Ve = [
                "at"
            ], We = [
                "at"
            ];
            function buildPosition(e1, t, r) {
                return new Position(r, e1 - t, e1);
            }
            const $e = new Set([
                103,
                109,
                115,
                105,
                121,
                117,
                100,
                118
            ]);
            class Token {
                constructor(e1){
                    this.type = e1.type;
                    this.value = e1.value;
                    this.start = e1.start;
                    this.end = e1.end;
                    this.loc = new SourceLocation(e1.startLoc, e1.endLoc);
                }
            }
            class Tokenizer extends CommentsParser {
                constructor(e1, t){
                    super();
                    this.isLookahead = void 0;
                    this.tokens = [];
                    this.errorHandlers_readInt = {
                        invalidDigit: (e1, t, r, n)=>{
                            if (!this.options.errorRecovery) return false;
                            this.raise(p.InvalidDigit, {
                                at: buildPosition(e1, t, r),
                                radix: n
                            });
                            return true;
                        },
                        numericSeparatorInEscapeSequence: this.errorBuilder(p.NumericSeparatorInEscapeSequence),
                        unexpectedNumericSeparator: this.errorBuilder(p.UnexpectedNumericSeparator)
                    };
                    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
                        invalidEscapeSequence: this.errorBuilder(p.InvalidEscapeSequence),
                        invalidCodePoint: this.errorBuilder(p.InvalidCodePoint)
                    });
                    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
                        strictNumericEscape: (e1, t, r)=>{
                            this.recordStrictModeErrors(p.StrictNumericEscape, {
                                at: buildPosition(e1, t, r)
                            });
                        },
                        unterminated: (e1, t, r)=>{
                            throw this.raise(p.UnterminatedString, {
                                at: buildPosition(e1 - 1, t, r)
                            });
                        }
                    });
                    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
                        strictNumericEscape: this.errorBuilder(p.StrictNumericEscape),
                        unterminated: (e1, t, r)=>{
                            throw this.raise(p.UnterminatedTemplate, {
                                at: buildPosition(e1, t, r)
                            });
                        }
                    });
                    this.state = new State;
                    this.state.init(e1);
                    this.input = t;
                    this.length = t.length;
                    this.isLookahead = false;
                }
                pushToken(e1) {
                    this.tokens.length = this.state.tokensLength;
                    this.tokens.push(e1);
                    ++this.state.tokensLength;
                }
                next() {
                    this.checkKeywordEscapes();
                    if (this.options.tokens) {
                        this.pushToken(new Token(this.state));
                    }
                    this.state.lastTokStart = this.state.start;
                    this.state.lastTokEndLoc = this.state.endLoc;
                    this.state.lastTokStartLoc = this.state.startLoc;
                    this.nextToken();
                }
                eat(e1) {
                    if (this.match(e1)) {
                        this.next();
                        return true;
                    } else {
                        return false;
                    }
                }
                match(e1) {
                    return this.state.type === e1;
                }
                createLookaheadState(e1) {
                    return {
                        pos: e1.pos,
                        value: null,
                        type: e1.type,
                        start: e1.start,
                        end: e1.end,
                        context: [
                            this.curContext()
                        ],
                        inType: e1.inType,
                        startLoc: e1.startLoc,
                        lastTokEndLoc: e1.lastTokEndLoc,
                        curLine: e1.curLine,
                        lineStart: e1.lineStart,
                        curPosition: e1.curPosition
                    };
                }
                lookahead() {
                    const e1 = this.state;
                    this.state = this.createLookaheadState(e1);
                    this.isLookahead = true;
                    this.nextToken();
                    this.isLookahead = false;
                    const t = this.state;
                    this.state = e1;
                    return t;
                }
                nextTokenStart() {
                    return this.nextTokenStartSince(this.state.pos);
                }
                nextTokenStartSince(e1) {
                    je.lastIndex = e1;
                    return je.test(this.input) ? je.lastIndex : e1;
                }
                lookaheadCharCode() {
                    return this.input.charCodeAt(this.nextTokenStart());
                }
                nextTokenInLineStart() {
                    return this.nextTokenInLineStartSince(this.state.pos);
                }
                nextTokenInLineStartSince(e1) {
                    Fe.lastIndex = e1;
                    return Fe.test(this.input) ? Fe.lastIndex : e1;
                }
                lookaheadInLineCharCode() {
                    return this.input.charCodeAt(this.nextTokenInLineStart());
                }
                codePointAtPos(e1) {
                    let t = this.input.charCodeAt(e1);
                    if ((t & 64512) === 55296 && ++e1 < this.input.length) {
                        const r = this.input.charCodeAt(e1);
                        if ((r & 64512) === 56320) {
                            t = 65536 + ((t & 1023) << 10) + (r & 1023);
                        }
                    }
                    return t;
                }
                setStrict(e1) {
                    this.state.strict = e1;
                    if (e1) {
                        this.state.strictErrors.forEach(([e1, t])=>this.raise(e1, {
                                at: t
                            }));
                        this.state.strictErrors.clear();
                    }
                }
                curContext() {
                    return this.state.context[this.state.context.length - 1];
                }
                nextToken() {
                    this.skipSpace();
                    this.state.start = this.state.pos;
                    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
                    if (this.state.pos >= this.length) {
                        this.finishToken(137);
                        return;
                    }
                    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
                }
                skipBlockComment(e1) {
                    let t;
                    if (!this.isLookahead) t = this.state.curPosition();
                    const r = this.state.pos;
                    const n = this.input.indexOf(e1, r + 2);
                    if (n === -1) {
                        throw this.raise(p.UnterminatedComment, {
                            at: this.state.curPosition()
                        });
                    }
                    this.state.pos = n + e1.length;
                    Le.lastIndex = r + 2;
                    while(Le.test(this.input) && Le.lastIndex <= n){
                        ++this.state.curLine;
                        this.state.lineStart = Le.lastIndex;
                    }
                    if (this.isLookahead) return;
                    const s = {
                        type: "CommentBlock",
                        value: this.input.slice(r + 2, n),
                        start: r,
                        end: n + e1.length,
                        loc: new SourceLocation(t, this.state.curPosition())
                    };
                    if (this.options.tokens) this.pushToken(s);
                    return s;
                }
                skipLineComment(e1) {
                    const t = this.state.pos;
                    let r;
                    if (!this.isLookahead) r = this.state.curPosition();
                    let n = this.input.charCodeAt(this.state.pos += e1);
                    if (this.state.pos < this.length) {
                        while(!isNewLine(n) && ++this.state.pos < this.length){
                            n = this.input.charCodeAt(this.state.pos);
                        }
                    }
                    if (this.isLookahead) return;
                    const s = this.state.pos;
                    const i = this.input.slice(t + e1, s);
                    const a = {
                        type: "CommentLine",
                        value: i,
                        start: t,
                        end: s,
                        loc: new SourceLocation(r, this.state.curPosition())
                    };
                    if (this.options.tokens) this.pushToken(a);
                    return a;
                }
                skipSpace() {
                    const e1 = this.state.pos;
                    const t = [];
                    e1: while(this.state.pos < this.length){
                        const r = this.input.charCodeAt(this.state.pos);
                        switch(r){
                            case 32:
                            case 160:
                            case 9:
                                ++this.state.pos;
                                break;
                            case 13:
                                if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                                    ++this.state.pos;
                                }
                            case 10:
                            case 8232:
                            case 8233:
                                ++this.state.pos;
                                ++this.state.curLine;
                                this.state.lineStart = this.state.pos;
                                break;
                            case 47:
                                switch(this.input.charCodeAt(this.state.pos + 1)){
                                    case 42:
                                        {
                                            const e1 = this.skipBlockComment("*/");
                                            if (e1 !== undefined) {
                                                this.addComment(e1);
                                                if (this.options.attachComment) t.push(e1);
                                            }
                                            break;
                                        }
                                    case 47:
                                        {
                                            const e1 = this.skipLineComment(2);
                                            if (e1 !== undefined) {
                                                this.addComment(e1);
                                                if (this.options.attachComment) t.push(e1);
                                            }
                                            break;
                                        }
                                    default:
                                        break e1;
                                }
                                break;
                            default:
                                if (isWhitespace(r)) {
                                    ++this.state.pos;
                                } else if (r === 45 && !this.inModule && this.options.annexB) {
                                    const r = this.state.pos;
                                    if (this.input.charCodeAt(r + 1) === 45 && this.input.charCodeAt(r + 2) === 62 && (e1 === 0 || this.state.lineStart > e1)) {
                                        const e1 = this.skipLineComment(3);
                                        if (e1 !== undefined) {
                                            this.addComment(e1);
                                            if (this.options.attachComment) t.push(e1);
                                        }
                                    } else {
                                        break e1;
                                    }
                                } else if (r === 60 && !this.inModule && this.options.annexB) {
                                    const e1 = this.state.pos;
                                    if (this.input.charCodeAt(e1 + 1) === 33 && this.input.charCodeAt(e1 + 2) === 45 && this.input.charCodeAt(e1 + 3) === 45) {
                                        const e1 = this.skipLineComment(4);
                                        if (e1 !== undefined) {
                                            this.addComment(e1);
                                            if (this.options.attachComment) t.push(e1);
                                        }
                                    } else {
                                        break e1;
                                    }
                                } else {
                                    break e1;
                                }
                        }
                    }
                    if (t.length > 0) {
                        const r = this.state.pos;
                        const n = {
                            start: e1,
                            end: r,
                            comments: t,
                            leadingNode: null,
                            trailingNode: null,
                            containingNode: null
                        };
                        this.state.commentStack.push(n);
                    }
                }
                finishToken(e1, t) {
                    this.state.end = this.state.pos;
                    this.state.endLoc = this.state.curPosition();
                    const r = this.state.type;
                    this.state.type = e1;
                    this.state.value = t;
                    if (!this.isLookahead) {
                        this.updateContext(r);
                    }
                }
                replaceToken(e1) {
                    this.state.type = e1;
                    this.updateContext();
                }
                readToken_numberSign() {
                    if (this.state.pos === 0 && this.readToken_interpreter()) {
                        return;
                    }
                    const e1 = this.state.pos + 1;
                    const t = this.codePointAtPos(e1);
                    if (t >= 48 && t <= 57) {
                        throw this.raise(p.UnexpectedDigitAfterHash, {
                            at: this.state.curPosition()
                        });
                    }
                    if (t === 123 || t === 91 && this.hasPlugin("recordAndTuple")) {
                        this.expectPlugin("recordAndTuple");
                        if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
                            throw this.raise(t === 123 ? p.RecordExpressionHashIncorrectStartSyntaxType : p.TupleExpressionHashIncorrectStartSyntaxType, {
                                at: this.state.curPosition()
                            });
                        }
                        this.state.pos += 2;
                        if (t === 123) {
                            this.finishToken(7);
                        } else {
                            this.finishToken(1);
                        }
                    } else if (isIdentifierStart(t)) {
                        ++this.state.pos;
                        this.finishToken(136, this.readWord1(t));
                    } else if (t === 92) {
                        ++this.state.pos;
                        this.finishToken(136, this.readWord1());
                    } else {
                        this.finishOp(27, 1);
                    }
                }
                readToken_dot() {
                    const e1 = this.input.charCodeAt(this.state.pos + 1);
                    if (e1 >= 48 && e1 <= 57) {
                        this.readNumber(true);
                        return;
                    }
                    if (e1 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
                        this.state.pos += 3;
                        this.finishToken(21);
                    } else {
                        ++this.state.pos;
                        this.finishToken(16);
                    }
                }
                readToken_slash() {
                    const e1 = this.input.charCodeAt(this.state.pos + 1);
                    if (e1 === 61) {
                        this.finishOp(31, 2);
                    } else {
                        this.finishOp(56, 1);
                    }
                }
                readToken_interpreter() {
                    if (this.state.pos !== 0 || this.length < 2) return false;
                    let e1 = this.input.charCodeAt(this.state.pos + 1);
                    if (e1 !== 33) return false;
                    const t = this.state.pos;
                    this.state.pos += 1;
                    while(!isNewLine(e1) && ++this.state.pos < this.length){
                        e1 = this.input.charCodeAt(this.state.pos);
                    }
                    const r = this.input.slice(t + 2, this.state.pos);
                    this.finishToken(28, r);
                    return true;
                }
                readToken_mult_modulo(e1) {
                    let t = e1 === 42 ? 55 : 54;
                    let r = 1;
                    let n = this.input.charCodeAt(this.state.pos + 1);
                    if (e1 === 42 && n === 42) {
                        r++;
                        n = this.input.charCodeAt(this.state.pos + 2);
                        t = 57;
                    }
                    if (n === 61 && !this.state.inType) {
                        r++;
                        t = e1 === 37 ? 33 : 30;
                    }
                    this.finishOp(t, r);
                }
                readToken_pipe_amp(e1) {
                    const t = this.input.charCodeAt(this.state.pos + 1);
                    if (t === e1) {
                        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
                            this.finishOp(30, 3);
                        } else {
                            this.finishOp(e1 === 124 ? 41 : 42, 2);
                        }
                        return;
                    }
                    if (e1 === 124) {
                        if (t === 62) {
                            this.finishOp(39, 2);
                            return;
                        }
                        if (this.hasPlugin("recordAndTuple") && t === 125) {
                            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                throw this.raise(p.RecordExpressionBarIncorrectEndSyntaxType, {
                                    at: this.state.curPosition()
                                });
                            }
                            this.state.pos += 2;
                            this.finishToken(9);
                            return;
                        }
                        if (this.hasPlugin("recordAndTuple") && t === 93) {
                            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                throw this.raise(p.TupleExpressionBarIncorrectEndSyntaxType, {
                                    at: this.state.curPosition()
                                });
                            }
                            this.state.pos += 2;
                            this.finishToken(4);
                            return;
                        }
                    }
                    if (t === 61) {
                        this.finishOp(30, 2);
                        return;
                    }
                    this.finishOp(e1 === 124 ? 43 : 45, 1);
                }
                readToken_caret() {
                    const e1 = this.input.charCodeAt(this.state.pos + 1);
                    if (e1 === 61 && !this.state.inType) {
                        this.finishOp(32, 2);
                    } else if (e1 === 94 && this.hasPlugin([
                        "pipelineOperator",
                        {
                            proposal: "hack",
                            topicToken: "^^"
                        }
                    ])) {
                        this.finishOp(37, 2);
                        const e1 = this.input.codePointAt(this.state.pos);
                        if (e1 === 94) {
                            this.unexpected();
                        }
                    } else {
                        this.finishOp(44, 1);
                    }
                }
                readToken_atSign() {
                    const e1 = this.input.charCodeAt(this.state.pos + 1);
                    if (e1 === 64 && this.hasPlugin([
                        "pipelineOperator",
                        {
                            proposal: "hack",
                            topicToken: "@@"
                        }
                    ])) {
                        this.finishOp(38, 2);
                    } else {
                        this.finishOp(26, 1);
                    }
                }
                readToken_plus_min(e1) {
                    const t = this.input.charCodeAt(this.state.pos + 1);
                    if (t === e1) {
                        this.finishOp(34, 2);
                        return;
                    }
                    if (t === 61) {
                        this.finishOp(30, 2);
                    } else {
                        this.finishOp(53, 1);
                    }
                }
                readToken_lt() {
                    const { pos: e1 } = this.state;
                    const t = this.input.charCodeAt(e1 + 1);
                    if (t === 60) {
                        if (this.input.charCodeAt(e1 + 2) === 61) {
                            this.finishOp(30, 3);
                            return;
                        }
                        this.finishOp(51, 2);
                        return;
                    }
                    if (t === 61) {
                        this.finishOp(49, 2);
                        return;
                    }
                    this.finishOp(47, 1);
                }
                readToken_gt() {
                    const { pos: e1 } = this.state;
                    const t = this.input.charCodeAt(e1 + 1);
                    if (t === 62) {
                        const t = this.input.charCodeAt(e1 + 2) === 62 ? 3 : 2;
                        if (this.input.charCodeAt(e1 + t) === 61) {
                            this.finishOp(30, t + 1);
                            return;
                        }
                        this.finishOp(52, t);
                        return;
                    }
                    if (t === 61) {
                        this.finishOp(49, 2);
                        return;
                    }
                    this.finishOp(48, 1);
                }
                readToken_eq_excl(e1) {
                    const t = this.input.charCodeAt(this.state.pos + 1);
                    if (t === 61) {
                        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
                        return;
                    }
                    if (e1 === 61 && t === 62) {
                        this.state.pos += 2;
                        this.finishToken(19);
                        return;
                    }
                    this.finishOp(e1 === 61 ? 29 : 35, 1);
                }
                readToken_question() {
                    const e1 = this.input.charCodeAt(this.state.pos + 1);
                    const t = this.input.charCodeAt(this.state.pos + 2);
                    if (e1 === 63) {
                        if (t === 61) {
                            this.finishOp(30, 3);
                        } else {
                            this.finishOp(40, 2);
                        }
                    } else if (e1 === 46 && !(t >= 48 && t <= 57)) {
                        this.state.pos += 2;
                        this.finishToken(18);
                    } else {
                        ++this.state.pos;
                        this.finishToken(17);
                    }
                }
                getTokenFromCode(e1) {
                    switch(e1){
                        case 46:
                            this.readToken_dot();
                            return;
                        case 40:
                            ++this.state.pos;
                            this.finishToken(10);
                            return;
                        case 41:
                            ++this.state.pos;
                            this.finishToken(11);
                            return;
                        case 59:
                            ++this.state.pos;
                            this.finishToken(13);
                            return;
                        case 44:
                            ++this.state.pos;
                            this.finishToken(12);
                            return;
                        case 91:
                            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                    throw this.raise(p.TupleExpressionBarIncorrectStartSyntaxType, {
                                        at: this.state.curPosition()
                                    });
                                }
                                this.state.pos += 2;
                                this.finishToken(2);
                            } else {
                                ++this.state.pos;
                                this.finishToken(0);
                            }
                            return;
                        case 93:
                            ++this.state.pos;
                            this.finishToken(3);
                            return;
                        case 123:
                            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                                    throw this.raise(p.RecordExpressionBarIncorrectStartSyntaxType, {
                                        at: this.state.curPosition()
                                    });
                                }
                                this.state.pos += 2;
                                this.finishToken(6);
                            } else {
                                ++this.state.pos;
                                this.finishToken(5);
                            }
                            return;
                        case 125:
                            ++this.state.pos;
                            this.finishToken(8);
                            return;
                        case 58:
                            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
                                this.finishOp(15, 2);
                            } else {
                                ++this.state.pos;
                                this.finishToken(14);
                            }
                            return;
                        case 63:
                            this.readToken_question();
                            return;
                        case 96:
                            this.readTemplateToken();
                            return;
                        case 48:
                            {
                                const e1 = this.input.charCodeAt(this.state.pos + 1);
                                if (e1 === 120 || e1 === 88) {
                                    this.readRadixNumber(16);
                                    return;
                                }
                                if (e1 === 111 || e1 === 79) {
                                    this.readRadixNumber(8);
                                    return;
                                }
                                if (e1 === 98 || e1 === 66) {
                                    this.readRadixNumber(2);
                                    return;
                                }
                            }
                        case 49:
                        case 50:
                        case 51:
                        case 52:
                        case 53:
                        case 54:
                        case 55:
                        case 56:
                        case 57:
                            this.readNumber(false);
                            return;
                        case 34:
                        case 39:
                            this.readString(e1);
                            return;
                        case 47:
                            this.readToken_slash();
                            return;
                        case 37:
                        case 42:
                            this.readToken_mult_modulo(e1);
                            return;
                        case 124:
                        case 38:
                            this.readToken_pipe_amp(e1);
                            return;
                        case 94:
                            this.readToken_caret();
                            return;
                        case 43:
                        case 45:
                            this.readToken_plus_min(e1);
                            return;
                        case 60:
                            this.readToken_lt();
                            return;
                        case 62:
                            this.readToken_gt();
                            return;
                        case 61:
                        case 33:
                            this.readToken_eq_excl(e1);
                            return;
                        case 126:
                            this.finishOp(36, 1);
                            return;
                        case 64:
                            this.readToken_atSign();
                            return;
                        case 35:
                            this.readToken_numberSign();
                            return;
                        case 92:
                            this.readWord();
                            return;
                        default:
                            if (isIdentifierStart(e1)) {
                                this.readWord(e1);
                                return;
                            }
                    }
                    throw this.raise(p.InvalidOrUnexpectedToken, {
                        at: this.state.curPosition(),
                        unexpected: String.fromCodePoint(e1)
                    });
                }
                finishOp(e1, t) {
                    const r = this.input.slice(this.state.pos, this.state.pos + t);
                    this.state.pos += t;
                    this.finishToken(e1, r);
                }
                readRegexp() {
                    const e1 = this.state.startLoc;
                    const t = this.state.start + 1;
                    let r, n;
                    let { pos: s } = this.state;
                    for(;; ++s){
                        if (s >= this.length) {
                            throw this.raise(p.UnterminatedRegExp, {
                                at: createPositionWithColumnOffset(e1, 1)
                            });
                        }
                        const t = this.input.charCodeAt(s);
                        if (isNewLine(t)) {
                            throw this.raise(p.UnterminatedRegExp, {
                                at: createPositionWithColumnOffset(e1, 1)
                            });
                        }
                        if (r) {
                            r = false;
                        } else {
                            if (t === 91) {
                                n = true;
                            } else if (t === 93 && n) {
                                n = false;
                            } else if (t === 47 && !n) {
                                break;
                            }
                            r = t === 92;
                        }
                    }
                    const i = this.input.slice(t, s);
                    ++s;
                    let a = "";
                    const nextPos = ()=>createPositionWithColumnOffset(e1, s + 2 - t);
                    while(s < this.length){
                        const e1 = this.codePointAtPos(s);
                        const t = String.fromCharCode(e1);
                        if ($e.has(e1)) {
                            if (e1 === 118) {
                                if (a.includes("u")) {
                                    this.raise(p.IncompatibleRegExpUVFlags, {
                                        at: nextPos()
                                    });
                                }
                            } else if (e1 === 117) {
                                if (a.includes("v")) {
                                    this.raise(p.IncompatibleRegExpUVFlags, {
                                        at: nextPos()
                                    });
                                }
                            }
                            if (a.includes(t)) {
                                this.raise(p.DuplicateRegExpFlags, {
                                    at: nextPos()
                                });
                            }
                        } else if (isIdentifierChar(e1) || e1 === 92) {
                            this.raise(p.MalformedRegExpFlags, {
                                at: nextPos()
                            });
                        } else {
                            break;
                        }
                        ++s;
                        a += t;
                    }
                    this.state.pos = s;
                    this.finishToken(135, {
                        pattern: i,
                        flags: a
                    });
                }
                readInt(e1, t, r = false, n = true) {
                    const { n: s, pos: i } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e1, t, r, n, this.errorHandlers_readInt, false);
                    this.state.pos = i;
                    return s;
                }
                readRadixNumber(e1) {
                    const t = this.state.curPosition();
                    let r = false;
                    this.state.pos += 2;
                    const n = this.readInt(e1);
                    if (n == null) {
                        this.raise(p.InvalidDigit, {
                            at: createPositionWithColumnOffset(t, 2),
                            radix: e1
                        });
                    }
                    const s = this.input.charCodeAt(this.state.pos);
                    if (s === 110) {
                        ++this.state.pos;
                        r = true;
                    } else if (s === 109) {
                        throw this.raise(p.InvalidDecimal, {
                            at: t
                        });
                    }
                    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
                        throw this.raise(p.NumberIdentifier, {
                            at: this.state.curPosition()
                        });
                    }
                    if (r) {
                        const e1 = this.input.slice(t.index, this.state.pos).replace(/[_n]/g, "");
                        this.finishToken(133, e1);
                        return;
                    }
                    this.finishToken(132, n);
                }
                readNumber(e1) {
                    const t = this.state.pos;
                    const r = this.state.curPosition();
                    let n = false;
                    let s = false;
                    let i = false;
                    let a = false;
                    let o = false;
                    if (!e1 && this.readInt(10) === null) {
                        this.raise(p.InvalidNumber, {
                            at: this.state.curPosition()
                        });
                    }
                    const l = this.state.pos - t >= 2 && this.input.charCodeAt(t) === 48;
                    if (l) {
                        const e1 = this.input.slice(t, this.state.pos);
                        this.recordStrictModeErrors(p.StrictOctalLiteral, {
                            at: r
                        });
                        if (!this.state.strict) {
                            const t = e1.indexOf("_");
                            if (t > 0) {
                                this.raise(p.ZeroDigitNumericSeparator, {
                                    at: createPositionWithColumnOffset(r, t)
                                });
                            }
                        }
                        o = l && !/[89]/.test(e1);
                    }
                    let c = this.input.charCodeAt(this.state.pos);
                    if (c === 46 && !o) {
                        ++this.state.pos;
                        this.readInt(10);
                        n = true;
                        c = this.input.charCodeAt(this.state.pos);
                    }
                    if ((c === 69 || c === 101) && !o) {
                        c = this.input.charCodeAt(++this.state.pos);
                        if (c === 43 || c === 45) {
                            ++this.state.pos;
                        }
                        if (this.readInt(10) === null) {
                            this.raise(p.InvalidOrMissingExponent, {
                                at: r
                            });
                        }
                        n = true;
                        a = true;
                        c = this.input.charCodeAt(this.state.pos);
                    }
                    if (c === 110) {
                        if (n || l) {
                            this.raise(p.InvalidBigIntLiteral, {
                                at: r
                            });
                        }
                        ++this.state.pos;
                        s = true;
                    }
                    if (c === 109) {
                        this.expectPlugin("decimal", this.state.curPosition());
                        if (a || l) {
                            this.raise(p.InvalidDecimal, {
                                at: r
                            });
                        }
                        ++this.state.pos;
                        i = true;
                    }
                    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
                        throw this.raise(p.NumberIdentifier, {
                            at: this.state.curPosition()
                        });
                    }
                    const u = this.input.slice(t, this.state.pos).replace(/[_mn]/g, "");
                    if (s) {
                        this.finishToken(133, u);
                        return;
                    }
                    if (i) {
                        this.finishToken(134, u);
                        return;
                    }
                    const f = o ? parseInt(u, 8) : parseFloat(u);
                    this.finishToken(132, f);
                }
                readCodePoint(e1) {
                    const { code: t, pos: r } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e1, this.errorHandlers_readCodePoint);
                    this.state.pos = r;
                    return t;
                }
                readString(e1) {
                    const { str: t, pos: r, curLine: n, lineStart: s } = readStringContents(e1 === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
                    this.state.pos = r + 1;
                    this.state.lineStart = s;
                    this.state.curLine = n;
                    this.finishToken(131, t);
                }
                readTemplateContinuation() {
                    if (!this.match(8)) {
                        this.unexpected(null, 8);
                    }
                    this.state.pos--;
                    this.readTemplateToken();
                }
                readTemplateToken() {
                    const e1 = this.input[this.state.pos];
                    const { str: t, firstInvalidLoc: r, pos: n, curLine: s, lineStart: i } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
                    this.state.pos = n + 1;
                    this.state.lineStart = i;
                    this.state.curLine = s;
                    if (r) {
                        this.state.firstInvalidTemplateEscapePos = new Position(r.curLine, r.pos - r.lineStart, r.pos);
                    }
                    if (this.input.codePointAt(n) === 96) {
                        this.finishToken(24, r ? null : e1 + t + "`");
                    } else {
                        this.state.pos++;
                        this.finishToken(25, r ? null : e1 + t + "${");
                    }
                }
                recordStrictModeErrors(e1, { at: t }) {
                    const r = t.index;
                    if (this.state.strict && !this.state.strictErrors.has(r)) {
                        this.raise(e1, {
                            at: t
                        });
                    } else {
                        this.state.strictErrors.set(r, [
                            e1,
                            t
                        ]);
                    }
                }
                readWord1(e1) {
                    this.state.containsEsc = false;
                    let t = "";
                    const r = this.state.pos;
                    let n = this.state.pos;
                    if (e1 !== undefined) {
                        this.state.pos += e1 <= 65535 ? 1 : 2;
                    }
                    while(this.state.pos < this.length){
                        const e1 = this.codePointAtPos(this.state.pos);
                        if (isIdentifierChar(e1)) {
                            this.state.pos += e1 <= 65535 ? 1 : 2;
                        } else if (e1 === 92) {
                            this.state.containsEsc = true;
                            t += this.input.slice(n, this.state.pos);
                            const e1 = this.state.curPosition();
                            const s = this.state.pos === r ? isIdentifierStart : isIdentifierChar;
                            if (this.input.charCodeAt(++this.state.pos) !== 117) {
                                this.raise(p.MissingUnicodeEscape, {
                                    at: this.state.curPosition()
                                });
                                n = this.state.pos - 1;
                                continue;
                            }
                            ++this.state.pos;
                            const i = this.readCodePoint(true);
                            if (i !== null) {
                                if (!s(i)) {
                                    this.raise(p.EscapedCharNotAnIdentifier, {
                                        at: e1
                                    });
                                }
                                t += String.fromCodePoint(i);
                            }
                            n = this.state.pos;
                        } else {
                            break;
                        }
                    }
                    return t + this.input.slice(n, this.state.pos);
                }
                readWord(e1) {
                    const t = this.readWord1(e1);
                    const r = S.get(t);
                    if (r !== undefined) {
                        this.finishToken(r, tokenLabelName(r));
                    } else {
                        this.finishToken(130, t);
                    }
                }
                checkKeywordEscapes() {
                    const { type: e1 } = this.state;
                    if (tokenIsKeyword(e1) && this.state.containsEsc) {
                        this.raise(p.InvalidEscapedReservedWord, {
                            at: this.state.startLoc,
                            reservedWord: tokenLabelName(e1)
                        });
                    }
                }
                raise(e1, t) {
                    const { at: r } = t, n = _objectWithoutPropertiesLoose(t, Ve);
                    const s = r instanceof Position ? r : r.loc.start;
                    const i = e1({
                        loc: s,
                        details: n
                    });
                    if (!this.options.errorRecovery) throw i;
                    if (!this.isLookahead) this.state.errors.push(i);
                    return i;
                }
                raiseOverwrite(e1, t) {
                    const { at: r } = t, n = _objectWithoutPropertiesLoose(t, We);
                    const s = r instanceof Position ? r : r.loc.start;
                    const i = s.index;
                    const a = this.state.errors;
                    for(let t = a.length - 1; t >= 0; t--){
                        const r = a[t];
                        if (r.loc.index === i) {
                            return a[t] = e1({
                                loc: s,
                                details: n
                            });
                        }
                        if (r.loc.index < i) break;
                    }
                    return this.raise(e1, t);
                }
                updateContext(e1) {}
                unexpected(e1, t) {
                    throw this.raise(p.UnexpectedToken, {
                        expected: t ? tokenLabelName(t) : null,
                        at: e1 != null ? e1 : this.state.startLoc
                    });
                }
                expectPlugin(e1, t) {
                    if (this.hasPlugin(e1)) {
                        return true;
                    }
                    throw this.raise(p.MissingPlugin, {
                        at: t != null ? t : this.state.startLoc,
                        missingPlugin: [
                            e1
                        ]
                    });
                }
                expectOnePlugin(e1) {
                    if (!e1.some((e1)=>this.hasPlugin(e1))) {
                        throw this.raise(p.MissingOneOfPlugins, {
                            at: this.state.startLoc,
                            missingPlugin: e1
                        });
                    }
                }
                errorBuilder(e1) {
                    return (t, r, n)=>{
                        this.raise(e1, {
                            at: buildPosition(t, r, n)
                        });
                    };
                }
            }
            class ClassScope {
                constructor(){
                    this.privateNames = new Set;
                    this.loneAccessors = new Map;
                    this.undefinedPrivateNames = new Map;
                }
            }
            class ClassScopeHandler {
                constructor(e1){
                    this.parser = void 0;
                    this.stack = [];
                    this.undefinedPrivateNames = new Map;
                    this.parser = e1;
                }
                current() {
                    return this.stack[this.stack.length - 1];
                }
                enter() {
                    this.stack.push(new ClassScope);
                }
                exit() {
                    const e1 = this.stack.pop();
                    const t = this.current();
                    for (const [r, n] of Array.from(e1.undefinedPrivateNames)){
                        if (t) {
                            if (!t.undefinedPrivateNames.has(r)) {
                                t.undefinedPrivateNames.set(r, n);
                            }
                        } else {
                            this.parser.raise(p.InvalidPrivateFieldResolution, {
                                at: n,
                                identifierName: r
                            });
                        }
                    }
                }
                declarePrivateName(e1, t, r) {
                    const { privateNames: n, loneAccessors: s, undefinedPrivateNames: i } = this.current();
                    let a = n.has(e1);
                    if (t & Ie) {
                        const r = a && s.get(e1);
                        if (r) {
                            const n = r & we;
                            const i = t & we;
                            const o = r & Ie;
                            const l = t & Ie;
                            a = o === l || n !== i;
                            if (!a) s.delete(e1);
                        } else if (!a) {
                            s.set(e1, t);
                        }
                    }
                    if (a) {
                        this.parser.raise(p.PrivateNameRedeclaration, {
                            at: r,
                            identifierName: e1
                        });
                    }
                    n.add(e1);
                    i.delete(e1);
                }
                usePrivateName(e1, t) {
                    let r;
                    for (r of this.stack){
                        if (r.privateNames.has(e1)) return;
                    }
                    if (r) {
                        r.undefinedPrivateNames.set(e1, t);
                    } else {
                        this.parser.raise(p.InvalidPrivateFieldResolution, {
                            at: t,
                            identifierName: e1
                        });
                    }
                }
            }
            const qe = 0, He = 1, Ge = 2, Je = 3;
            class ExpressionScope {
                constructor(e1 = qe){
                    this.type = void 0;
                    this.type = e1;
                }
                canBeArrowParameterDeclaration() {
                    return this.type === Ge || this.type === He;
                }
                isCertainlyParameterDeclaration() {
                    return this.type === Je;
                }
            }
            class ArrowHeadParsingScope extends ExpressionScope {
                constructor(e1){
                    super(e1);
                    this.declarationErrors = new Map;
                }
                recordDeclarationError(e1, { at: t }) {
                    const r = t.index;
                    this.declarationErrors.set(r, [
                        e1,
                        t
                    ]);
                }
                clearDeclarationError(e1) {
                    this.declarationErrors.delete(e1);
                }
                iterateErrors(e1) {
                    this.declarationErrors.forEach(e1);
                }
            }
            class ExpressionScopeHandler {
                constructor(e1){
                    this.parser = void 0;
                    this.stack = [
                        new ExpressionScope
                    ];
                    this.parser = e1;
                }
                enter(e1) {
                    this.stack.push(e1);
                }
                exit() {
                    this.stack.pop();
                }
                recordParameterInitializerError(e1, { at: t }) {
                    const r = {
                        at: t.loc.start
                    };
                    const { stack: n } = this;
                    let s = n.length - 1;
                    let i = n[s];
                    while(!i.isCertainlyParameterDeclaration()){
                        if (i.canBeArrowParameterDeclaration()) {
                            i.recordDeclarationError(e1, r);
                        } else {
                            return;
                        }
                        i = n[--s];
                    }
                    this.parser.raise(e1, r);
                }
                recordArrowParameterBindingError(e1, { at: t }) {
                    const { stack: r } = this;
                    const n = r[r.length - 1];
                    const s = {
                        at: t.loc.start
                    };
                    if (n.isCertainlyParameterDeclaration()) {
                        this.parser.raise(e1, s);
                    } else if (n.canBeArrowParameterDeclaration()) {
                        n.recordDeclarationError(e1, s);
                    } else {
                        return;
                    }
                }
                recordAsyncArrowParametersError({ at: e1 }) {
                    const { stack: t } = this;
                    let r = t.length - 1;
                    let n = t[r];
                    while(n.canBeArrowParameterDeclaration()){
                        if (n.type === Ge) {
                            n.recordDeclarationError(p.AwaitBindingIdentifier, {
                                at: e1
                            });
                        }
                        n = t[--r];
                    }
                }
                validateAsPattern() {
                    const { stack: e1 } = this;
                    const t = e1[e1.length - 1];
                    if (!t.canBeArrowParameterDeclaration()) return;
                    t.iterateErrors(([t, r])=>{
                        this.parser.raise(t, {
                            at: r
                        });
                        let n = e1.length - 2;
                        let s = e1[n];
                        while(s.canBeArrowParameterDeclaration()){
                            s.clearDeclarationError(r.index);
                            s = e1[--n];
                        }
                    });
                }
            }
            function newParameterDeclarationScope() {
                return new ExpressionScope(Je);
            }
            function newArrowHeadScope() {
                return new ArrowHeadParsingScope(He);
            }
            function newAsyncArrowScope() {
                return new ArrowHeadParsingScope(Ge);
            }
            function newExpressionScope() {
                return new ExpressionScope;
            }
            const Xe = 0, ze = 1, Ye = 2, Qe = 4, Ze = 8;
            class ProductionParameterHandler {
                constructor(){
                    this.stacks = [];
                }
                enter(e1) {
                    this.stacks.push(e1);
                }
                exit() {
                    this.stacks.pop();
                }
                currentFlags() {
                    return this.stacks[this.stacks.length - 1];
                }
                get hasAwait() {
                    return (this.currentFlags() & Ye) > 0;
                }
                get hasYield() {
                    return (this.currentFlags() & ze) > 0;
                }
                get hasReturn() {
                    return (this.currentFlags() & Qe) > 0;
                }
                get hasIn() {
                    return (this.currentFlags() & Ze) > 0;
                }
            }
            function functionFlags(e1, t) {
                return (e1 ? Ye : 0) | (t ? ze : 0);
            }
            class UtilParser extends Tokenizer {
                addExtra(e1, t, r, n = true) {
                    if (!e1) return;
                    const s = e1.extra = e1.extra || {};
                    if (n) {
                        s[t] = r;
                    } else {
                        Object.defineProperty(s, t, {
                            enumerable: n,
                            value: r
                        });
                    }
                }
                isContextual(e1) {
                    return this.state.type === e1 && !this.state.containsEsc;
                }
                isUnparsedContextual(e1, t) {
                    const r = e1 + t.length;
                    if (this.input.slice(e1, r) === t) {
                        const e1 = this.input.charCodeAt(r);
                        return !(isIdentifierChar(e1) || (e1 & 64512) === 55296);
                    }
                    return false;
                }
                isLookaheadContextual(e1) {
                    const t = this.nextTokenStart();
                    return this.isUnparsedContextual(t, e1);
                }
                eatContextual(e1) {
                    if (this.isContextual(e1)) {
                        this.next();
                        return true;
                    }
                    return false;
                }
                expectContextual(e1, t) {
                    if (!this.eatContextual(e1)) {
                        if (t != null) {
                            throw this.raise(t, {
                                at: this.state.startLoc
                            });
                        }
                        this.unexpected(null, e1);
                    }
                }
                canInsertSemicolon() {
                    return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
                }
                hasPrecedingLineBreak() {
                    return Me.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
                }
                hasFollowingLineBreak() {
                    Re.lastIndex = this.state.end;
                    return Re.test(this.input);
                }
                isLineTerminator() {
                    return this.eat(13) || this.canInsertSemicolon();
                }
                semicolon(e1 = true) {
                    if (e1 ? this.isLineTerminator() : this.eat(13)) return;
                    this.raise(p.MissingSemicolon, {
                        at: this.state.lastTokEndLoc
                    });
                }
                expect(e1, t) {
                    this.eat(e1) || this.unexpected(t, e1);
                }
                tryParse(e1, t = this.state.clone()) {
                    const r = {
                        node: null
                    };
                    try {
                        const n = e1((e1 = null)=>{
                            r.node = e1;
                            throw r;
                        });
                        if (this.state.errors.length > t.errors.length) {
                            const e1 = this.state;
                            this.state = t;
                            this.state.tokensLength = e1.tokensLength;
                            return {
                                node: n,
                                error: e1.errors[t.errors.length],
                                thrown: false,
                                aborted: false,
                                failState: e1
                            };
                        }
                        return {
                            node: n,
                            error: null,
                            thrown: false,
                            aborted: false,
                            failState: null
                        };
                    } catch (e1) {
                        const n = this.state;
                        this.state = t;
                        if (e1 instanceof SyntaxError) {
                            return {
                                node: null,
                                error: e1,
                                thrown: true,
                                aborted: false,
                                failState: n
                            };
                        }
                        if (e1 === r) {
                            return {
                                node: r.node,
                                error: null,
                                thrown: false,
                                aborted: true,
                                failState: n
                            };
                        }
                        throw e1;
                    }
                }
                checkExpressionErrors(e1, t) {
                    if (!e1) return false;
                    const { shorthandAssignLoc: r, doubleProtoLoc: n, privateKeyLoc: s, optionalParametersLoc: i } = e1;
                    const a = !!r || !!n || !!i || !!s;
                    if (!t) {
                        return a;
                    }
                    if (r != null) {
                        this.raise(p.InvalidCoverInitializedName, {
                            at: r
                        });
                    }
                    if (n != null) {
                        this.raise(p.DuplicateProto, {
                            at: n
                        });
                    }
                    if (s != null) {
                        this.raise(p.UnexpectedPrivateField, {
                            at: s
                        });
                    }
                    if (i != null) {
                        this.unexpected(i);
                    }
                }
                isLiteralPropertyName() {
                    return tokenIsLiteralPropertyName(this.state.type);
                }
                isPrivateName(e1) {
                    return e1.type === "PrivateName";
                }
                getPrivateNameSV(e1) {
                    return e1.id.name;
                }
                hasPropertyAsPrivateName(e1) {
                    return (e1.type === "MemberExpression" || e1.type === "OptionalMemberExpression") && this.isPrivateName(e1.property);
                }
                isObjectProperty(e1) {
                    return e1.type === "ObjectProperty";
                }
                isObjectMethod(e1) {
                    return e1.type === "ObjectMethod";
                }
                initializeScopes(e1 = this.options.sourceType === "module") {
                    const t = this.state.labels;
                    this.state.labels = [];
                    const r = this.exportedIdentifiers;
                    this.exportedIdentifiers = new Set;
                    const n = this.inModule;
                    this.inModule = e1;
                    const s = this.scope;
                    const i = this.getScopeHandler();
                    this.scope = new i(this, e1);
                    const a = this.prodParam;
                    this.prodParam = new ProductionParameterHandler;
                    const o = this.classScope;
                    this.classScope = new ClassScopeHandler(this);
                    const l = this.expressionScope;
                    this.expressionScope = new ExpressionScopeHandler(this);
                    return ()=>{
                        this.state.labels = t;
                        this.exportedIdentifiers = r;
                        this.inModule = n;
                        this.scope = s;
                        this.prodParam = a;
                        this.classScope = o;
                        this.expressionScope = l;
                    };
                }
                enterInitialScopes() {
                    let e1 = Xe;
                    if (this.inModule) {
                        e1 |= Ye;
                    }
                    this.scope.enter(K);
                    this.prodParam.enter(e1);
                }
                checkDestructuringPrivate(e1) {
                    const { privateKeyLoc: t } = e1;
                    if (t !== null) {
                        this.expectPlugin("destructuringPrivate", t);
                    }
                }
            }
            class ExpressionErrors {
                constructor(){
                    this.shorthandAssignLoc = null;
                    this.doubleProtoLoc = null;
                    this.privateKeyLoc = null;
                    this.optionalParametersLoc = null;
                }
            }
            class Node {
                constructor(e1, t, r){
                    this.type = "";
                    this.start = t;
                    this.end = 0;
                    this.loc = new SourceLocation(r);
                    if (e1 != null && e1.options.ranges) this.range = [
                        t,
                        0
                    ];
                    if (e1 != null && e1.filename) this.loc.filename = e1.filename;
                }
            }
            const et = Node.prototype;
            {
                et.__clone = function() {
                    const e1 = new Node(undefined, this.start, this.loc.start);
                    const t = Object.keys(this);
                    for(let r = 0, n = t.length; r < n; r++){
                        const n = t[r];
                        if (n !== "leadingComments" && n !== "trailingComments" && n !== "innerComments") {
                            e1[n] = this[n];
                        }
                    }
                    return e1;
                };
            }
            function clonePlaceholder(e1) {
                return cloneIdentifier(e1);
            }
            function cloneIdentifier(e1) {
                const { type: t, start: r, end: n, loc: s, range: i, extra: a, name: o } = e1;
                const l = Object.create(et);
                l.type = t;
                l.start = r;
                l.end = n;
                l.loc = s;
                l.range = i;
                l.extra = a;
                l.name = o;
                if (t === "Placeholder") {
                    l.expectedNode = e1.expectedNode;
                }
                return l;
            }
            function cloneStringLiteral(e1) {
                const { type: t, start: r, end: n, loc: s, range: i, extra: a } = e1;
                if (t === "Placeholder") {
                    return clonePlaceholder(e1);
                }
                const o = Object.create(et);
                o.type = t;
                o.start = r;
                o.end = n;
                o.loc = s;
                o.range = i;
                if (e1.raw !== undefined) {
                    o.raw = e1.raw;
                } else {
                    o.extra = a;
                }
                o.value = e1.value;
                return o;
            }
            class NodeUtils extends UtilParser {
                startNode() {
                    return new Node(this, this.state.start, this.state.startLoc);
                }
                startNodeAt(e1) {
                    return new Node(this, e1.index, e1);
                }
                startNodeAtNode(e1) {
                    return this.startNodeAt(e1.loc.start);
                }
                finishNode(e1, t) {
                    return this.finishNodeAt(e1, t, this.state.lastTokEndLoc);
                }
                finishNodeAt(e1, t, r) {
                    e1.type = t;
                    e1.end = r.index;
                    e1.loc.end = r;
                    if (this.options.ranges) e1.range[1] = r.index;
                    if (this.options.attachComment) this.processComment(e1);
                    return e1;
                }
                resetStartLocation(e1, t) {
                    e1.start = t.index;
                    e1.loc.start = t;
                    if (this.options.ranges) e1.range[0] = t.index;
                }
                resetEndLocation(e1, t = this.state.lastTokEndLoc) {
                    e1.end = t.index;
                    e1.loc.end = t;
                    if (this.options.ranges) e1.range[1] = t.index;
                }
                resetStartLocationFromNode(e1, t) {
                    this.resetStartLocation(e1, t.loc.start);
                }
            }
            const tt = new Set([
                "_",
                "any",
                "bool",
                "boolean",
                "empty",
                "extends",
                "false",
                "interface",
                "mixed",
                "null",
                "number",
                "static",
                "string",
                "true",
                "typeof",
                "void"
            ]);
            const rt = ParseErrorEnum`flow`({
                AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
                AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
                AssignReservedType: ({ reservedType: e1 })=>`Cannot overwrite reserved type ${e1}.`,
                DeclareClassElement: "The `declare` modifier can only appear on class fields.",
                DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
                DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
                EnumBooleanMemberNotInitialized: ({ memberName: e1, enumName: t })=>`Boolean enum members need to be initialized. Use either \`${e1} = true,\` or \`${e1} = false,\` in enum \`${t}\`.`,
                EnumDuplicateMemberName: ({ memberName: e1, enumName: t })=>`Enum member names need to be unique, but the name \`${e1}\` has already been used before in enum \`${t}\`.`,
                EnumInconsistentMemberValues: ({ enumName: e1 })=>`Enum \`${e1}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
                EnumInvalidExplicitType: ({ invalidEnumType: e1, enumName: t })=>`Enum type \`${e1}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`,
                EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: e1 })=>`Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e1}\`.`,
                EnumInvalidMemberInitializerPrimaryType: ({ enumName: e1, memberName: t, explicitType: r })=>`Enum \`${e1}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`,
                EnumInvalidMemberInitializerSymbolType: ({ enumName: e1, memberName: t })=>`Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e1}\`.`,
                EnumInvalidMemberInitializerUnknownType: ({ enumName: e1, memberName: t })=>`The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e1}\`.`,
                EnumInvalidMemberName: ({ enumName: e1, memberName: t, suggestion: r })=>`Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e1}\`.`,
                EnumNumberMemberNotInitialized: ({ enumName: e1, memberName: t })=>`Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e1}\`.`,
                EnumStringMemberInconsistentlyInitailized: ({ enumName: e1 })=>`String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e1}\`.`,
                GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
                ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
                ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
                InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
                InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
                InexactVariance: "Explicit inexact syntax cannot have variance.",
                InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
                MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
                NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
                NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
                PatternIsOptional: Object.assign({
                    message: "A binding pattern parameter cannot be optional in an implementation signature."
                }, {
                    reasonCode: "OptionalBindingPattern"
                }),
                SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
                SpreadVariance: "Spread properties cannot have variance.",
                ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
                ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
                ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
                ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
                ThisParamNoDefault: "The `this` parameter may not have a default value.",
                TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
                TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
                UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
                UnexpectedReservedType: ({ reservedType: e1 })=>`Unexpected reserved type ${e1}.`,
                UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
                UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
                UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
                UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
                UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
                UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
                UnsupportedDeclareExportKind: ({ unsupportedExportKind: e1, suggestion: t })=>`\`declare export ${e1}\` is not supported. Use \`${t}\` instead.`,
                UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
                UnterminatedFlowComment: "Unterminated flow-comment."
            });
            function isEsModuleType(e1) {
                return e1.type === "DeclareExportAllDeclaration" || e1.type === "DeclareExportDeclaration" && (!e1.declaration || e1.declaration.type !== "TypeAlias" && e1.declaration.type !== "InterfaceDeclaration");
            }
            function hasTypeImportKind(e1) {
                return e1.importKind === "type" || e1.importKind === "typeof";
            }
            const nt = {
                const: "declare export var",
                let: "declare export var",
                type: "export type",
                interface: "export interface"
            };
            function partition(e1, t) {
                const r = [];
                const n = [];
                for(let s = 0; s < e1.length; s++){
                    (t(e1[s], s, e1) ? r : n).push(e1[s]);
                }
                return [
                    r,
                    n
                ];
            }
            const st = /\*?\s*@((?:no)?flow)\b/;
            var flow = (e1)=>class FlowParserMixin extends e1 {
                    constructor(...e1){
                        super(...e1);
                        this.flowPragma = undefined;
                    }
                    getScopeHandler() {
                        return FlowScopeHandler;
                    }
                    shouldParseTypes() {
                        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
                    }
                    shouldParseEnums() {
                        return !!this.getPluginOption("flow", "enums");
                    }
                    finishToken(e1, t) {
                        if (e1 !== 131 && e1 !== 13 && e1 !== 28) {
                            if (this.flowPragma === undefined) {
                                this.flowPragma = null;
                            }
                        }
                        super.finishToken(e1, t);
                    }
                    addComment(e1) {
                        if (this.flowPragma === undefined) {
                            const t = st.exec(e1.value);
                            if (!t) ;
                            else if (t[1] === "flow") {
                                this.flowPragma = "flow";
                            } else if (t[1] === "noflow") {
                                this.flowPragma = "noflow";
                            } else {
                                throw new Error("Unexpected flow pragma");
                            }
                        }
                        super.addComment(e1);
                    }
                    flowParseTypeInitialiser(e1) {
                        const t = this.state.inType;
                        this.state.inType = true;
                        this.expect(e1 || 14);
                        const r = this.flowParseType();
                        this.state.inType = t;
                        return r;
                    }
                    flowParsePredicate() {
                        const e1 = this.startNode();
                        const t = this.state.startLoc;
                        this.next();
                        this.expectContextual(108);
                        if (this.state.lastTokStart > t.index + 1) {
                            this.raise(rt.UnexpectedSpaceBetweenModuloChecks, {
                                at: t
                            });
                        }
                        if (this.eat(10)) {
                            e1.value = super.parseExpression();
                            this.expect(11);
                            return this.finishNode(e1, "DeclaredPredicate");
                        } else {
                            return this.finishNode(e1, "InferredPredicate");
                        }
                    }
                    flowParseTypeAndPredicateInitialiser() {
                        const e1 = this.state.inType;
                        this.state.inType = true;
                        this.expect(14);
                        let t = null;
                        let r = null;
                        if (this.match(54)) {
                            this.state.inType = e1;
                            r = this.flowParsePredicate();
                        } else {
                            t = this.flowParseType();
                            this.state.inType = e1;
                            if (this.match(54)) {
                                r = this.flowParsePredicate();
                            }
                        }
                        return [
                            t,
                            r
                        ];
                    }
                    flowParseDeclareClass(e1) {
                        this.next();
                        this.flowParseInterfaceish(e1, true);
                        return this.finishNode(e1, "DeclareClass");
                    }
                    flowParseDeclareFunction(e1) {
                        this.next();
                        const t = e1.id = this.parseIdentifier();
                        const r = this.startNode();
                        const n = this.startNode();
                        if (this.match(47)) {
                            r.typeParameters = this.flowParseTypeParameterDeclaration();
                        } else {
                            r.typeParameters = null;
                        }
                        this.expect(10);
                        const s = this.flowParseFunctionTypeParams();
                        r.params = s.params;
                        r.rest = s.rest;
                        r.this = s._this;
                        this.expect(11);
                        [r.returnType, e1.predicate] = this.flowParseTypeAndPredicateInitialiser();
                        n.typeAnnotation = this.finishNode(r, "FunctionTypeAnnotation");
                        t.typeAnnotation = this.finishNode(n, "TypeAnnotation");
                        this.resetEndLocation(t);
                        this.semicolon();
                        this.scope.declareName(e1.id.name, Pe, e1.id.loc.start);
                        return this.finishNode(e1, "DeclareFunction");
                    }
                    flowParseDeclare(e1, t) {
                        if (this.match(80)) {
                            return this.flowParseDeclareClass(e1);
                        } else if (this.match(68)) {
                            return this.flowParseDeclareFunction(e1);
                        } else if (this.match(74)) {
                            return this.flowParseDeclareVariable(e1);
                        } else if (this.eatContextual(125)) {
                            if (this.match(16)) {
                                return this.flowParseDeclareModuleExports(e1);
                            } else {
                                if (t) {
                                    this.raise(rt.NestedDeclareModule, {
                                        at: this.state.lastTokStartLoc
                                    });
                                }
                                return this.flowParseDeclareModule(e1);
                            }
                        } else if (this.isContextual(128)) {
                            return this.flowParseDeclareTypeAlias(e1);
                        } else if (this.isContextual(129)) {
                            return this.flowParseDeclareOpaqueType(e1);
                        } else if (this.isContextual(127)) {
                            return this.flowParseDeclareInterface(e1);
                        } else if (this.match(82)) {
                            return this.flowParseDeclareExportDeclaration(e1, t);
                        } else {
                            this.unexpected();
                        }
                    }
                    flowParseDeclareVariable(e1) {
                        this.next();
                        e1.id = this.flowParseTypeAnnotatableIdentifier(true);
                        this.scope.declareName(e1.id.name, de, e1.id.loc.start);
                        this.semicolon();
                        return this.finishNode(e1, "DeclareVariable");
                    }
                    flowParseDeclareModule(e1) {
                        this.scope.enter(U);
                        if (this.match(131)) {
                            e1.id = super.parseExprAtom();
                        } else {
                            e1.id = this.parseIdentifier();
                        }
                        const t = e1.body = this.startNode();
                        const r = t.body = [];
                        this.expect(5);
                        while(!this.match(8)){
                            let e1 = this.startNode();
                            if (this.match(83)) {
                                this.next();
                                if (!this.isContextual(128) && !this.match(87)) {
                                    this.raise(rt.InvalidNonTypeImportInDeclareModule, {
                                        at: this.state.lastTokStartLoc
                                    });
                                }
                                super.parseImport(e1);
                            } else {
                                this.expectContextual(123, rt.UnsupportedStatementInDeclareModule);
                                e1 = this.flowParseDeclare(e1, true);
                            }
                            r.push(e1);
                        }
                        this.scope.exit();
                        this.expect(8);
                        this.finishNode(t, "BlockStatement");
                        let n = null;
                        let s = false;
                        r.forEach((e1)=>{
                            if (isEsModuleType(e1)) {
                                if (n === "CommonJS") {
                                    this.raise(rt.AmbiguousDeclareModuleKind, {
                                        at: e1
                                    });
                                }
                                n = "ES";
                            } else if (e1.type === "DeclareModuleExports") {
                                if (s) {
                                    this.raise(rt.DuplicateDeclareModuleExports, {
                                        at: e1
                                    });
                                }
                                if (n === "ES") {
                                    this.raise(rt.AmbiguousDeclareModuleKind, {
                                        at: e1
                                    });
                                }
                                n = "CommonJS";
                                s = true;
                            }
                        });
                        e1.kind = n || "CommonJS";
                        return this.finishNode(e1, "DeclareModule");
                    }
                    flowParseDeclareExportDeclaration(e1, t) {
                        this.expect(82);
                        if (this.eat(65)) {
                            if (this.match(68) || this.match(80)) {
                                e1.declaration = this.flowParseDeclare(this.startNode());
                            } else {
                                e1.declaration = this.flowParseType();
                                this.semicolon();
                            }
                            e1.default = true;
                            return this.finishNode(e1, "DeclareExportDeclaration");
                        } else {
                            if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !t) {
                                const e1 = this.state.value;
                                throw this.raise(rt.UnsupportedDeclareExportKind, {
                                    at: this.state.startLoc,
                                    unsupportedExportKind: e1,
                                    suggestion: nt[e1]
                                });
                            }
                            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129)) {
                                e1.declaration = this.flowParseDeclare(this.startNode());
                                e1.default = false;
                                return this.finishNode(e1, "DeclareExportDeclaration");
                            } else if (this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129)) {
                                e1 = this.parseExport(e1, null);
                                if (e1.type === "ExportNamedDeclaration") {
                                    e1.type = "ExportDeclaration";
                                    e1.default = false;
                                    delete e1.exportKind;
                                }
                                e1.type = "Declare" + e1.type;
                                return e1;
                            }
                        }
                        this.unexpected();
                    }
                    flowParseDeclareModuleExports(e1) {
                        this.next();
                        this.expectContextual(109);
                        e1.typeAnnotation = this.flowParseTypeAnnotation();
                        this.semicolon();
                        return this.finishNode(e1, "DeclareModuleExports");
                    }
                    flowParseDeclareTypeAlias(e1) {
                        this.next();
                        const t = this.flowParseTypeAlias(e1);
                        t.type = "DeclareTypeAlias";
                        return t;
                    }
                    flowParseDeclareOpaqueType(e1) {
                        this.next();
                        const t = this.flowParseOpaqueType(e1, true);
                        t.type = "DeclareOpaqueType";
                        return t;
                    }
                    flowParseDeclareInterface(e1) {
                        this.next();
                        this.flowParseInterfaceish(e1, false);
                        return this.finishNode(e1, "DeclareInterface");
                    }
                    flowParseInterfaceish(e1, t) {
                        e1.id = this.flowParseRestrictedIdentifier(!t, true);
                        this.scope.declareName(e1.id.name, t ? he : pe, e1.id.loc.start);
                        if (this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterDeclaration();
                        } else {
                            e1.typeParameters = null;
                        }
                        e1.extends = [];
                        if (this.eat(81)) {
                            do {
                                e1.extends.push(this.flowParseInterfaceExtends());
                            }while (!t && this.eat(12))
                        }
                        if (t) {
                            e1.implements = [];
                            e1.mixins = [];
                            if (this.eatContextual(115)) {
                                do {
                                    e1.mixins.push(this.flowParseInterfaceExtends());
                                }while (this.eat(12))
                            }
                            if (this.eatContextual(111)) {
                                do {
                                    e1.implements.push(this.flowParseInterfaceExtends());
                                }while (this.eat(12))
                            }
                        }
                        e1.body = this.flowParseObjectType({
                            allowStatic: t,
                            allowExact: false,
                            allowSpread: false,
                            allowProto: t,
                            allowInexact: false
                        });
                    }
                    flowParseInterfaceExtends() {
                        const e1 = this.startNode();
                        e1.id = this.flowParseQualifiedTypeIdentifier();
                        if (this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterInstantiation();
                        } else {
                            e1.typeParameters = null;
                        }
                        return this.finishNode(e1, "InterfaceExtends");
                    }
                    flowParseInterface(e1) {
                        this.flowParseInterfaceish(e1, false);
                        return this.finishNode(e1, "InterfaceDeclaration");
                    }
                    checkNotUnderscore(e1) {
                        if (e1 === "_") {
                            this.raise(rt.UnexpectedReservedUnderscore, {
                                at: this.state.startLoc
                            });
                        }
                    }
                    checkReservedType(e1, t, r) {
                        if (!tt.has(e1)) return;
                        this.raise(r ? rt.AssignReservedType : rt.UnexpectedReservedType, {
                            at: t,
                            reservedType: e1
                        });
                    }
                    flowParseRestrictedIdentifier(e1, t) {
                        this.checkReservedType(this.state.value, this.state.startLoc, t);
                        return this.parseIdentifier(e1);
                    }
                    flowParseTypeAlias(e1) {
                        e1.id = this.flowParseRestrictedIdentifier(false, true);
                        this.scope.declareName(e1.id.name, pe, e1.id.loc.start);
                        if (this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterDeclaration();
                        } else {
                            e1.typeParameters = null;
                        }
                        e1.right = this.flowParseTypeInitialiser(29);
                        this.semicolon();
                        return this.finishNode(e1, "TypeAlias");
                    }
                    flowParseOpaqueType(e1, t) {
                        this.expectContextual(128);
                        e1.id = this.flowParseRestrictedIdentifier(true, true);
                        this.scope.declareName(e1.id.name, pe, e1.id.loc.start);
                        if (this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterDeclaration();
                        } else {
                            e1.typeParameters = null;
                        }
                        e1.supertype = null;
                        if (this.match(14)) {
                            e1.supertype = this.flowParseTypeInitialiser(14);
                        }
                        e1.impltype = null;
                        if (!t) {
                            e1.impltype = this.flowParseTypeInitialiser(29);
                        }
                        this.semicolon();
                        return this.finishNode(e1, "OpaqueType");
                    }
                    flowParseTypeParameter(e1 = false) {
                        const t = this.state.startLoc;
                        const r = this.startNode();
                        const n = this.flowParseVariance();
                        const s = this.flowParseTypeAnnotatableIdentifier();
                        r.name = s.name;
                        r.variance = n;
                        r.bound = s.typeAnnotation;
                        if (this.match(29)) {
                            this.eat(29);
                            r.default = this.flowParseType();
                        } else {
                            if (e1) {
                                this.raise(rt.MissingTypeParamDefault, {
                                    at: t
                                });
                            }
                        }
                        return this.finishNode(r, "TypeParameter");
                    }
                    flowParseTypeParameterDeclaration() {
                        const e1 = this.state.inType;
                        const t = this.startNode();
                        t.params = [];
                        this.state.inType = true;
                        if (this.match(47) || this.match(140)) {
                            this.next();
                        } else {
                            this.unexpected();
                        }
                        let r = false;
                        do {
                            const e1 = this.flowParseTypeParameter(r);
                            t.params.push(e1);
                            if (e1.default) {
                                r = true;
                            }
                            if (!this.match(48)) {
                                this.expect(12);
                            }
                        }while (!this.match(48))
                        this.expect(48);
                        this.state.inType = e1;
                        return this.finishNode(t, "TypeParameterDeclaration");
                    }
                    flowParseTypeParameterInstantiation() {
                        const e1 = this.startNode();
                        const t = this.state.inType;
                        e1.params = [];
                        this.state.inType = true;
                        this.expect(47);
                        const r = this.state.noAnonFunctionType;
                        this.state.noAnonFunctionType = false;
                        while(!this.match(48)){
                            e1.params.push(this.flowParseType());
                            if (!this.match(48)) {
                                this.expect(12);
                            }
                        }
                        this.state.noAnonFunctionType = r;
                        this.expect(48);
                        this.state.inType = t;
                        return this.finishNode(e1, "TypeParameterInstantiation");
                    }
                    flowParseTypeParameterInstantiationCallOrNew() {
                        const e1 = this.startNode();
                        const t = this.state.inType;
                        e1.params = [];
                        this.state.inType = true;
                        this.expect(47);
                        while(!this.match(48)){
                            e1.params.push(this.flowParseTypeOrImplicitInstantiation());
                            if (!this.match(48)) {
                                this.expect(12);
                            }
                        }
                        this.expect(48);
                        this.state.inType = t;
                        return this.finishNode(e1, "TypeParameterInstantiation");
                    }
                    flowParseInterfaceType() {
                        const e1 = this.startNode();
                        this.expectContextual(127);
                        e1.extends = [];
                        if (this.eat(81)) {
                            do {
                                e1.extends.push(this.flowParseInterfaceExtends());
                            }while (this.eat(12))
                        }
                        e1.body = this.flowParseObjectType({
                            allowStatic: false,
                            allowExact: false,
                            allowSpread: false,
                            allowProto: false,
                            allowInexact: false
                        });
                        return this.finishNode(e1, "InterfaceTypeAnnotation");
                    }
                    flowParseObjectPropertyKey() {
                        return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);
                    }
                    flowParseObjectTypeIndexer(e1, t, r) {
                        e1.static = t;
                        if (this.lookahead().type === 14) {
                            e1.id = this.flowParseObjectPropertyKey();
                            e1.key = this.flowParseTypeInitialiser();
                        } else {
                            e1.id = null;
                            e1.key = this.flowParseType();
                        }
                        this.expect(3);
                        e1.value = this.flowParseTypeInitialiser();
                        e1.variance = r;
                        return this.finishNode(e1, "ObjectTypeIndexer");
                    }
                    flowParseObjectTypeInternalSlot(e1, t) {
                        e1.static = t;
                        e1.id = this.flowParseObjectPropertyKey();
                        this.expect(3);
                        this.expect(3);
                        if (this.match(47) || this.match(10)) {
                            e1.method = true;
                            e1.optional = false;
                            e1.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e1.loc.start));
                        } else {
                            e1.method = false;
                            if (this.eat(17)) {
                                e1.optional = true;
                            }
                            e1.value = this.flowParseTypeInitialiser();
                        }
                        return this.finishNode(e1, "ObjectTypeInternalSlot");
                    }
                    flowParseObjectTypeMethodish(e1) {
                        e1.params = [];
                        e1.rest = null;
                        e1.typeParameters = null;
                        e1.this = null;
                        if (this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterDeclaration();
                        }
                        this.expect(10);
                        if (this.match(78)) {
                            e1.this = this.flowParseFunctionTypeParam(true);
                            e1.this.name = null;
                            if (!this.match(11)) {
                                this.expect(12);
                            }
                        }
                        while(!this.match(11) && !this.match(21)){
                            e1.params.push(this.flowParseFunctionTypeParam(false));
                            if (!this.match(11)) {
                                this.expect(12);
                            }
                        }
                        if (this.eat(21)) {
                            e1.rest = this.flowParseFunctionTypeParam(false);
                        }
                        this.expect(11);
                        e1.returnType = this.flowParseTypeInitialiser();
                        return this.finishNode(e1, "FunctionTypeAnnotation");
                    }
                    flowParseObjectTypeCallProperty(e1, t) {
                        const r = this.startNode();
                        e1.static = t;
                        e1.value = this.flowParseObjectTypeMethodish(r);
                        return this.finishNode(e1, "ObjectTypeCallProperty");
                    }
                    flowParseObjectType({ allowStatic: e1, allowExact: t, allowSpread: r, allowProto: n, allowInexact: s }) {
                        const i = this.state.inType;
                        this.state.inType = true;
                        const a = this.startNode();
                        a.callProperties = [];
                        a.properties = [];
                        a.indexers = [];
                        a.internalSlots = [];
                        let o;
                        let l;
                        let c = false;
                        if (t && this.match(6)) {
                            this.expect(6);
                            o = 9;
                            l = true;
                        } else {
                            this.expect(5);
                            o = 8;
                            l = false;
                        }
                        a.exact = l;
                        while(!this.match(o)){
                            let t = false;
                            let i = null;
                            let o = null;
                            const u = this.startNode();
                            if (n && this.isContextual(116)) {
                                const t = this.lookahead();
                                if (t.type !== 14 && t.type !== 17) {
                                    this.next();
                                    i = this.state.startLoc;
                                    e1 = false;
                                }
                            }
                            if (e1 && this.isContextual(104)) {
                                const e1 = this.lookahead();
                                if (e1.type !== 14 && e1.type !== 17) {
                                    this.next();
                                    t = true;
                                }
                            }
                            const p = this.flowParseVariance();
                            if (this.eat(0)) {
                                if (i != null) {
                                    this.unexpected(i);
                                }
                                if (this.eat(0)) {
                                    if (p) {
                                        this.unexpected(p.loc.start);
                                    }
                                    a.internalSlots.push(this.flowParseObjectTypeInternalSlot(u, t));
                                } else {
                                    a.indexers.push(this.flowParseObjectTypeIndexer(u, t, p));
                                }
                            } else if (this.match(10) || this.match(47)) {
                                if (i != null) {
                                    this.unexpected(i);
                                }
                                if (p) {
                                    this.unexpected(p.loc.start);
                                }
                                a.callProperties.push(this.flowParseObjectTypeCallProperty(u, t));
                            } else {
                                let e1 = "init";
                                if (this.isContextual(98) || this.isContextual(103)) {
                                    const t = this.lookahead();
                                    if (tokenIsLiteralPropertyName(t.type)) {
                                        e1 = this.state.value;
                                        this.next();
                                    }
                                }
                                const n = this.flowParseObjectTypeProperty(u, t, i, p, e1, r, s != null ? s : !l);
                                if (n === null) {
                                    c = true;
                                    o = this.state.lastTokStartLoc;
                                } else {
                                    a.properties.push(n);
                                }
                            }
                            this.flowObjectTypeSemicolon();
                            if (o && !this.match(8) && !this.match(9)) {
                                this.raise(rt.UnexpectedExplicitInexactInObject, {
                                    at: o
                                });
                            }
                        }
                        this.expect(o);
                        if (r) {
                            a.inexact = c;
                        }
                        const u = this.finishNode(a, "ObjectTypeAnnotation");
                        this.state.inType = i;
                        return u;
                    }
                    flowParseObjectTypeProperty(e1, t, r, n, s, i, a) {
                        if (this.eat(21)) {
                            const t = this.match(12) || this.match(13) || this.match(8) || this.match(9);
                            if (t) {
                                if (!i) {
                                    this.raise(rt.InexactInsideNonObject, {
                                        at: this.state.lastTokStartLoc
                                    });
                                } else if (!a) {
                                    this.raise(rt.InexactInsideExact, {
                                        at: this.state.lastTokStartLoc
                                    });
                                }
                                if (n) {
                                    this.raise(rt.InexactVariance, {
                                        at: n
                                    });
                                }
                                return null;
                            }
                            if (!i) {
                                this.raise(rt.UnexpectedSpreadType, {
                                    at: this.state.lastTokStartLoc
                                });
                            }
                            if (r != null) {
                                this.unexpected(r);
                            }
                            if (n) {
                                this.raise(rt.SpreadVariance, {
                                    at: n
                                });
                            }
                            e1.argument = this.flowParseType();
                            return this.finishNode(e1, "ObjectTypeSpreadProperty");
                        } else {
                            e1.key = this.flowParseObjectPropertyKey();
                            e1.static = t;
                            e1.proto = r != null;
                            e1.kind = s;
                            let a = false;
                            if (this.match(47) || this.match(10)) {
                                e1.method = true;
                                if (r != null) {
                                    this.unexpected(r);
                                }
                                if (n) {
                                    this.unexpected(n.loc.start);
                                }
                                e1.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e1.loc.start));
                                if (s === "get" || s === "set") {
                                    this.flowCheckGetterSetterParams(e1);
                                }
                                if (!i && e1.key.name === "constructor" && e1.value.this) {
                                    this.raise(rt.ThisParamBannedInConstructor, {
                                        at: e1.value.this
                                    });
                                }
                            } else {
                                if (s !== "init") this.unexpected();
                                e1.method = false;
                                if (this.eat(17)) {
                                    a = true;
                                }
                                e1.value = this.flowParseTypeInitialiser();
                                e1.variance = n;
                            }
                            e1.optional = a;
                            return this.finishNode(e1, "ObjectTypeProperty");
                        }
                    }
                    flowCheckGetterSetterParams(e1) {
                        const t = e1.kind === "get" ? 0 : 1;
                        const r = e1.value.params.length + (e1.value.rest ? 1 : 0);
                        if (e1.value.this) {
                            this.raise(e1.kind === "get" ? rt.GetterMayNotHaveThisParam : rt.SetterMayNotHaveThisParam, {
                                at: e1.value.this
                            });
                        }
                        if (r !== t) {
                            this.raise(e1.kind === "get" ? p.BadGetterArity : p.BadSetterArity, {
                                at: e1
                            });
                        }
                        if (e1.kind === "set" && e1.value.rest) {
                            this.raise(p.BadSetterRestParameter, {
                                at: e1
                            });
                        }
                    }
                    flowObjectTypeSemicolon() {
                        if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
                            this.unexpected();
                        }
                    }
                    flowParseQualifiedTypeIdentifier(e1, t) {
                        var r;
                        (r = e1) != null ? r : e1 = this.state.startLoc;
                        let n = t || this.flowParseRestrictedIdentifier(true);
                        while(this.eat(16)){
                            const t = this.startNodeAt(e1);
                            t.qualification = n;
                            t.id = this.flowParseRestrictedIdentifier(true);
                            n = this.finishNode(t, "QualifiedTypeIdentifier");
                        }
                        return n;
                    }
                    flowParseGenericType(e1, t) {
                        const r = this.startNodeAt(e1);
                        r.typeParameters = null;
                        r.id = this.flowParseQualifiedTypeIdentifier(e1, t);
                        if (this.match(47)) {
                            r.typeParameters = this.flowParseTypeParameterInstantiation();
                        }
                        return this.finishNode(r, "GenericTypeAnnotation");
                    }
                    flowParseTypeofType() {
                        const e1 = this.startNode();
                        this.expect(87);
                        e1.argument = this.flowParsePrimaryType();
                        return this.finishNode(e1, "TypeofTypeAnnotation");
                    }
                    flowParseTupleType() {
                        const e1 = this.startNode();
                        e1.types = [];
                        this.expect(0);
                        while(this.state.pos < this.length && !this.match(3)){
                            e1.types.push(this.flowParseType());
                            if (this.match(3)) break;
                            this.expect(12);
                        }
                        this.expect(3);
                        return this.finishNode(e1, "TupleTypeAnnotation");
                    }
                    flowParseFunctionTypeParam(e1) {
                        let t = null;
                        let r = false;
                        let n = null;
                        const s = this.startNode();
                        const i = this.lookahead();
                        const a = this.state.type === 78;
                        if (i.type === 14 || i.type === 17) {
                            if (a && !e1) {
                                this.raise(rt.ThisParamMustBeFirst, {
                                    at: s
                                });
                            }
                            t = this.parseIdentifier(a);
                            if (this.eat(17)) {
                                r = true;
                                if (a) {
                                    this.raise(rt.ThisParamMayNotBeOptional, {
                                        at: s
                                    });
                                }
                            }
                            n = this.flowParseTypeInitialiser();
                        } else {
                            n = this.flowParseType();
                        }
                        s.name = t;
                        s.optional = r;
                        s.typeAnnotation = n;
                        return this.finishNode(s, "FunctionTypeParam");
                    }
                    reinterpretTypeAsFunctionTypeParam(e1) {
                        const t = this.startNodeAt(e1.loc.start);
                        t.name = null;
                        t.optional = false;
                        t.typeAnnotation = e1;
                        return this.finishNode(t, "FunctionTypeParam");
                    }
                    flowParseFunctionTypeParams(e1 = []) {
                        let t = null;
                        let r = null;
                        if (this.match(78)) {
                            r = this.flowParseFunctionTypeParam(true);
                            r.name = null;
                            if (!this.match(11)) {
                                this.expect(12);
                            }
                        }
                        while(!this.match(11) && !this.match(21)){
                            e1.push(this.flowParseFunctionTypeParam(false));
                            if (!this.match(11)) {
                                this.expect(12);
                            }
                        }
                        if (this.eat(21)) {
                            t = this.flowParseFunctionTypeParam(false);
                        }
                        return {
                            params: e1,
                            rest: t,
                            _this: r
                        };
                    }
                    flowIdentToTypeAnnotation(e1, t, r) {
                        switch(r.name){
                            case "any":
                                return this.finishNode(t, "AnyTypeAnnotation");
                            case "bool":
                            case "boolean":
                                return this.finishNode(t, "BooleanTypeAnnotation");
                            case "mixed":
                                return this.finishNode(t, "MixedTypeAnnotation");
                            case "empty":
                                return this.finishNode(t, "EmptyTypeAnnotation");
                            case "number":
                                return this.finishNode(t, "NumberTypeAnnotation");
                            case "string":
                                return this.finishNode(t, "StringTypeAnnotation");
                            case "symbol":
                                return this.finishNode(t, "SymbolTypeAnnotation");
                            default:
                                this.checkNotUnderscore(r.name);
                                return this.flowParseGenericType(e1, r);
                        }
                    }
                    flowParsePrimaryType() {
                        const e1 = this.state.startLoc;
                        const t = this.startNode();
                        let r;
                        let n;
                        let s = false;
                        const i = this.state.noAnonFunctionType;
                        switch(this.state.type){
                            case 5:
                                return this.flowParseObjectType({
                                    allowStatic: false,
                                    allowExact: false,
                                    allowSpread: true,
                                    allowProto: false,
                                    allowInexact: true
                                });
                            case 6:
                                return this.flowParseObjectType({
                                    allowStatic: false,
                                    allowExact: true,
                                    allowSpread: true,
                                    allowProto: false,
                                    allowInexact: false
                                });
                            case 0:
                                this.state.noAnonFunctionType = false;
                                n = this.flowParseTupleType();
                                this.state.noAnonFunctionType = i;
                                return n;
                            case 47:
                                t.typeParameters = this.flowParseTypeParameterDeclaration();
                                this.expect(10);
                                r = this.flowParseFunctionTypeParams();
                                t.params = r.params;
                                t.rest = r.rest;
                                t.this = r._this;
                                this.expect(11);
                                this.expect(19);
                                t.returnType = this.flowParseType();
                                return this.finishNode(t, "FunctionTypeAnnotation");
                            case 10:
                                this.next();
                                if (!this.match(11) && !this.match(21)) {
                                    if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                                        const e1 = this.lookahead().type;
                                        s = e1 !== 17 && e1 !== 14;
                                    } else {
                                        s = true;
                                    }
                                }
                                if (s) {
                                    this.state.noAnonFunctionType = false;
                                    n = this.flowParseType();
                                    this.state.noAnonFunctionType = i;
                                    if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                                        this.expect(11);
                                        return n;
                                    } else {
                                        this.eat(12);
                                    }
                                }
                                if (n) {
                                    r = this.flowParseFunctionTypeParams([
                                        this.reinterpretTypeAsFunctionTypeParam(n)
                                    ]);
                                } else {
                                    r = this.flowParseFunctionTypeParams();
                                }
                                t.params = r.params;
                                t.rest = r.rest;
                                t.this = r._this;
                                this.expect(11);
                                this.expect(19);
                                t.returnType = this.flowParseType();
                                t.typeParameters = null;
                                return this.finishNode(t, "FunctionTypeAnnotation");
                            case 131:
                                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                            case 85:
                            case 86:
                                t.value = this.match(85);
                                this.next();
                                return this.finishNode(t, "BooleanLiteralTypeAnnotation");
                            case 53:
                                if (this.state.value === "-") {
                                    this.next();
                                    if (this.match(132)) {
                                        return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", t);
                                    }
                                    if (this.match(133)) {
                                        return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", t);
                                    }
                                    throw this.raise(rt.UnexpectedSubtractionOperand, {
                                        at: this.state.startLoc
                                    });
                                }
                                this.unexpected();
                                return;
                            case 132:
                                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                            case 133:
                                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                            case 88:
                                this.next();
                                return this.finishNode(t, "VoidTypeAnnotation");
                            case 84:
                                this.next();
                                return this.finishNode(t, "NullLiteralTypeAnnotation");
                            case 78:
                                this.next();
                                return this.finishNode(t, "ThisTypeAnnotation");
                            case 55:
                                this.next();
                                return this.finishNode(t, "ExistsTypeAnnotation");
                            case 87:
                                return this.flowParseTypeofType();
                            default:
                                if (tokenIsKeyword(this.state.type)) {
                                    const e1 = tokenLabelName(this.state.type);
                                    this.next();
                                    return super.createIdentifier(t, e1);
                                } else if (tokenIsIdentifier(this.state.type)) {
                                    if (this.isContextual(127)) {
                                        return this.flowParseInterfaceType();
                                    }
                                    return this.flowIdentToTypeAnnotation(e1, t, this.parseIdentifier());
                                }
                        }
                        this.unexpected();
                    }
                    flowParsePostfixType() {
                        const e1 = this.state.startLoc;
                        let t = this.flowParsePrimaryType();
                        let r = false;
                        while((this.match(0) || this.match(18)) && !this.canInsertSemicolon()){
                            const n = this.startNodeAt(e1);
                            const s = this.eat(18);
                            r = r || s;
                            this.expect(0);
                            if (!s && this.match(3)) {
                                n.elementType = t;
                                this.next();
                                t = this.finishNode(n, "ArrayTypeAnnotation");
                            } else {
                                n.objectType = t;
                                n.indexType = this.flowParseType();
                                this.expect(3);
                                if (r) {
                                    n.optional = s;
                                    t = this.finishNode(n, "OptionalIndexedAccessType");
                                } else {
                                    t = this.finishNode(n, "IndexedAccessType");
                                }
                            }
                        }
                        return t;
                    }
                    flowParsePrefixType() {
                        const e1 = this.startNode();
                        if (this.eat(17)) {
                            e1.typeAnnotation = this.flowParsePrefixType();
                            return this.finishNode(e1, "NullableTypeAnnotation");
                        } else {
                            return this.flowParsePostfixType();
                        }
                    }
                    flowParseAnonFunctionWithoutParens() {
                        const e1 = this.flowParsePrefixType();
                        if (!this.state.noAnonFunctionType && this.eat(19)) {
                            const t = this.startNodeAt(e1.loc.start);
                            t.params = [
                                this.reinterpretTypeAsFunctionTypeParam(e1)
                            ];
                            t.rest = null;
                            t.this = null;
                            t.returnType = this.flowParseType();
                            t.typeParameters = null;
                            return this.finishNode(t, "FunctionTypeAnnotation");
                        }
                        return e1;
                    }
                    flowParseIntersectionType() {
                        const e1 = this.startNode();
                        this.eat(45);
                        const t = this.flowParseAnonFunctionWithoutParens();
                        e1.types = [
                            t
                        ];
                        while(this.eat(45)){
                            e1.types.push(this.flowParseAnonFunctionWithoutParens());
                        }
                        return e1.types.length === 1 ? t : this.finishNode(e1, "IntersectionTypeAnnotation");
                    }
                    flowParseUnionType() {
                        const e1 = this.startNode();
                        this.eat(43);
                        const t = this.flowParseIntersectionType();
                        e1.types = [
                            t
                        ];
                        while(this.eat(43)){
                            e1.types.push(this.flowParseIntersectionType());
                        }
                        return e1.types.length === 1 ? t : this.finishNode(e1, "UnionTypeAnnotation");
                    }
                    flowParseType() {
                        const e1 = this.state.inType;
                        this.state.inType = true;
                        const t = this.flowParseUnionType();
                        this.state.inType = e1;
                        return t;
                    }
                    flowParseTypeOrImplicitInstantiation() {
                        if (this.state.type === 130 && this.state.value === "_") {
                            const e1 = this.state.startLoc;
                            const t = this.parseIdentifier();
                            return this.flowParseGenericType(e1, t);
                        } else {
                            return this.flowParseType();
                        }
                    }
                    flowParseTypeAnnotation() {
                        const e1 = this.startNode();
                        e1.typeAnnotation = this.flowParseTypeInitialiser();
                        return this.finishNode(e1, "TypeAnnotation");
                    }
                    flowParseTypeAnnotatableIdentifier(e1) {
                        const t = e1 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
                        if (this.match(14)) {
                            t.typeAnnotation = this.flowParseTypeAnnotation();
                            this.resetEndLocation(t);
                        }
                        return t;
                    }
                    typeCastToParameter(e1) {
                        e1.expression.typeAnnotation = e1.typeAnnotation;
                        this.resetEndLocation(e1.expression, e1.typeAnnotation.loc.end);
                        return e1.expression;
                    }
                    flowParseVariance() {
                        let e1 = null;
                        if (this.match(53)) {
                            e1 = this.startNode();
                            if (this.state.value === "+") {
                                e1.kind = "plus";
                            } else {
                                e1.kind = "minus";
                            }
                            this.next();
                            return this.finishNode(e1, "Variance");
                        }
                        return e1;
                    }
                    parseFunctionBody(e1, t, r = false) {
                        if (t) {
                            this.forwardNoArrowParamsConversionAt(e1, ()=>super.parseFunctionBody(e1, true, r));
                            return;
                        }
                        super.parseFunctionBody(e1, false, r);
                    }
                    parseFunctionBodyAndFinish(e1, t, r = false) {
                        if (this.match(14)) {
                            const t = this.startNode();
                            [t.typeAnnotation, e1.predicate] = this.flowParseTypeAndPredicateInitialiser();
                            e1.returnType = t.typeAnnotation ? this.finishNode(t, "TypeAnnotation") : null;
                        }
                        return super.parseFunctionBodyAndFinish(e1, t, r);
                    }
                    parseStatementLike(e1) {
                        if (this.state.strict && this.isContextual(127)) {
                            const e1 = this.lookahead();
                            if (tokenIsKeywordOrIdentifier(e1.type)) {
                                const e1 = this.startNode();
                                this.next();
                                return this.flowParseInterface(e1);
                            }
                        } else if (this.shouldParseEnums() && this.isContextual(124)) {
                            const e1 = this.startNode();
                            this.next();
                            return this.flowParseEnumDeclaration(e1);
                        }
                        const t = super.parseStatementLike(e1);
                        if (this.flowPragma === undefined && !this.isValidDirective(t)) {
                            this.flowPragma = null;
                        }
                        return t;
                    }
                    parseExpressionStatement(e1, t, r) {
                        if (t.type === "Identifier") {
                            if (t.name === "declare") {
                                if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
                                    return this.flowParseDeclare(e1);
                                }
                            } else if (tokenIsIdentifier(this.state.type)) {
                                if (t.name === "interface") {
                                    return this.flowParseInterface(e1);
                                } else if (t.name === "type") {
                                    return this.flowParseTypeAlias(e1);
                                } else if (t.name === "opaque") {
                                    return this.flowParseOpaqueType(e1, false);
                                }
                            }
                        }
                        return super.parseExpressionStatement(e1, t, r);
                    }
                    shouldParseExportDeclaration() {
                        const { type: e1 } = this.state;
                        if (tokenIsFlowInterfaceOrTypeOrOpaque(e1) || this.shouldParseEnums() && e1 === 124) {
                            return !this.state.containsEsc;
                        }
                        return super.shouldParseExportDeclaration();
                    }
                    isExportDefaultSpecifier() {
                        const { type: e1 } = this.state;
                        if (tokenIsFlowInterfaceOrTypeOrOpaque(e1) || this.shouldParseEnums() && e1 === 124) {
                            return this.state.containsEsc;
                        }
                        return super.isExportDefaultSpecifier();
                    }
                    parseExportDefaultExpression() {
                        if (this.shouldParseEnums() && this.isContextual(124)) {
                            const e1 = this.startNode();
                            this.next();
                            return this.flowParseEnumDeclaration(e1);
                        }
                        return super.parseExportDefaultExpression();
                    }
                    parseConditional(e1, t, r) {
                        if (!this.match(17)) return e1;
                        if (this.state.maybeInArrowParameters) {
                            const t = this.lookaheadCharCode();
                            if (t === 44 || t === 61 || t === 58 || t === 41) {
                                this.setOptionalParametersError(r);
                                return e1;
                            }
                        }
                        this.expect(17);
                        const n = this.state.clone();
                        const s = this.state.noArrowAt;
                        const i = this.startNodeAt(t);
                        let { consequent: a, failed: o } = this.tryParseConditionalConsequent();
                        let [l, c] = this.getArrowLikeExpressions(a);
                        if (o || c.length > 0) {
                            const e1 = [
                                ...s
                            ];
                            if (c.length > 0) {
                                this.state = n;
                                this.state.noArrowAt = e1;
                                for(let t = 0; t < c.length; t++){
                                    e1.push(c[t].start);
                                }
                                ({ consequent: a, failed: o } = this.tryParseConditionalConsequent());
                                [l, c] = this.getArrowLikeExpressions(a);
                            }
                            if (o && l.length > 1) {
                                this.raise(rt.AmbiguousConditionalArrow, {
                                    at: n.startLoc
                                });
                            }
                            if (o && l.length === 1) {
                                this.state = n;
                                e1.push(l[0].start);
                                this.state.noArrowAt = e1;
                                ({ consequent: a, failed: o } = this.tryParseConditionalConsequent());
                            }
                        }
                        this.getArrowLikeExpressions(a, true);
                        this.state.noArrowAt = s;
                        this.expect(14);
                        i.test = e1;
                        i.consequent = a;
                        i.alternate = this.forwardNoArrowParamsConversionAt(i, ()=>this.parseMaybeAssign(undefined, undefined));
                        return this.finishNode(i, "ConditionalExpression");
                    }
                    tryParseConditionalConsequent() {
                        this.state.noArrowParamsConversionAt.push(this.state.start);
                        const e1 = this.parseMaybeAssignAllowIn();
                        const t = !this.match(14);
                        this.state.noArrowParamsConversionAt.pop();
                        return {
                            consequent: e1,
                            failed: t
                        };
                    }
                    getArrowLikeExpressions(e1, t) {
                        const r = [
                            e1
                        ];
                        const n = [];
                        while(r.length !== 0){
                            const e1 = r.pop();
                            if (e1.type === "ArrowFunctionExpression") {
                                if (e1.typeParameters || !e1.returnType) {
                                    this.finishArrowValidation(e1);
                                } else {
                                    n.push(e1);
                                }
                                r.push(e1.body);
                            } else if (e1.type === "ConditionalExpression") {
                                r.push(e1.consequent);
                                r.push(e1.alternate);
                            }
                        }
                        if (t) {
                            n.forEach((e1)=>this.finishArrowValidation(e1));
                            return [
                                n,
                                []
                            ];
                        }
                        return partition(n, (e1)=>e1.params.every((e1)=>this.isAssignable(e1, true)));
                    }
                    finishArrowValidation(e1) {
                        var t;
                        this.toAssignableList(e1.params, (t = e1.extra) == null ? void 0 : t.trailingCommaLoc, false);
                        this.scope.enter(V | W);
                        super.checkParams(e1, false, true);
                        this.scope.exit();
                    }
                    forwardNoArrowParamsConversionAt(e1, t) {
                        let r;
                        if (this.state.noArrowParamsConversionAt.indexOf(e1.start) !== -1) {
                            this.state.noArrowParamsConversionAt.push(this.state.start);
                            r = t();
                            this.state.noArrowParamsConversionAt.pop();
                        } else {
                            r = t();
                        }
                        return r;
                    }
                    parseParenItem(e1, t) {
                        e1 = super.parseParenItem(e1, t);
                        if (this.eat(17)) {
                            e1.optional = true;
                            this.resetEndLocation(e1);
                        }
                        if (this.match(14)) {
                            const r = this.startNodeAt(t);
                            r.expression = e1;
                            r.typeAnnotation = this.flowParseTypeAnnotation();
                            return this.finishNode(r, "TypeCastExpression");
                        }
                        return e1;
                    }
                    assertModuleNodeAllowed(e1) {
                        if (e1.type === "ImportDeclaration" && (e1.importKind === "type" || e1.importKind === "typeof") || e1.type === "ExportNamedDeclaration" && e1.exportKind === "type" || e1.type === "ExportAllDeclaration" && e1.exportKind === "type") {
                            return;
                        }
                        super.assertModuleNodeAllowed(e1);
                    }
                    parseExportDeclaration(e1) {
                        if (this.isContextual(128)) {
                            e1.exportKind = "type";
                            const t = this.startNode();
                            this.next();
                            if (this.match(5)) {
                                e1.specifiers = this.parseExportSpecifiers(true);
                                super.parseExportFrom(e1);
                                return null;
                            } else {
                                return this.flowParseTypeAlias(t);
                            }
                        } else if (this.isContextual(129)) {
                            e1.exportKind = "type";
                            const t = this.startNode();
                            this.next();
                            return this.flowParseOpaqueType(t, false);
                        } else if (this.isContextual(127)) {
                            e1.exportKind = "type";
                            const t = this.startNode();
                            this.next();
                            return this.flowParseInterface(t);
                        } else if (this.shouldParseEnums() && this.isContextual(124)) {
                            e1.exportKind = "value";
                            const t = this.startNode();
                            this.next();
                            return this.flowParseEnumDeclaration(t);
                        } else {
                            return super.parseExportDeclaration(e1);
                        }
                    }
                    eatExportStar(e1) {
                        if (super.eatExportStar(e1)) return true;
                        if (this.isContextual(128) && this.lookahead().type === 55) {
                            e1.exportKind = "type";
                            this.next();
                            this.next();
                            return true;
                        }
                        return false;
                    }
                    maybeParseExportNamespaceSpecifier(e1) {
                        const { startLoc: t } = this.state;
                        const r = super.maybeParseExportNamespaceSpecifier(e1);
                        if (r && e1.exportKind === "type") {
                            this.unexpected(t);
                        }
                        return r;
                    }
                    parseClassId(e1, t, r) {
                        super.parseClassId(e1, t, r);
                        if (this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterDeclaration();
                        }
                    }
                    parseClassMember(e1, t, r) {
                        const { startLoc: n } = this.state;
                        if (this.isContextual(123)) {
                            if (super.parseClassMemberFromModifier(e1, t)) {
                                return;
                            }
                            t.declare = true;
                        }
                        super.parseClassMember(e1, t, r);
                        if (t.declare) {
                            if (t.type !== "ClassProperty" && t.type !== "ClassPrivateProperty" && t.type !== "PropertyDefinition") {
                                this.raise(rt.DeclareClassElement, {
                                    at: n
                                });
                            } else if (t.value) {
                                this.raise(rt.DeclareClassFieldInitializer, {
                                    at: t.value
                                });
                            }
                        }
                    }
                    isIterator(e1) {
                        return e1 === "iterator" || e1 === "asyncIterator";
                    }
                    readIterator() {
                        const e1 = super.readWord1();
                        const t = "@@" + e1;
                        if (!this.isIterator(e1) || !this.state.inType) {
                            this.raise(p.InvalidIdentifier, {
                                at: this.state.curPosition(),
                                identifierName: t
                            });
                        }
                        this.finishToken(130, t);
                    }
                    getTokenFromCode(e1) {
                        const t = this.input.charCodeAt(this.state.pos + 1);
                        if (e1 === 123 && t === 124) {
                            this.finishOp(6, 2);
                        } else if (this.state.inType && (e1 === 62 || e1 === 60)) {
                            this.finishOp(e1 === 62 ? 48 : 47, 1);
                        } else if (this.state.inType && e1 === 63) {
                            if (t === 46) {
                                this.finishOp(18, 2);
                            } else {
                                this.finishOp(17, 1);
                            }
                        } else if (isIteratorStart(e1, t, this.input.charCodeAt(this.state.pos + 2))) {
                            this.state.pos += 2;
                            this.readIterator();
                        } else {
                            super.getTokenFromCode(e1);
                        }
                    }
                    isAssignable(e1, t) {
                        if (e1.type === "TypeCastExpression") {
                            return this.isAssignable(e1.expression, t);
                        } else {
                            return super.isAssignable(e1, t);
                        }
                    }
                    toAssignable(e1, t = false) {
                        if (!t && e1.type === "AssignmentExpression" && e1.left.type === "TypeCastExpression") {
                            e1.left = this.typeCastToParameter(e1.left);
                        }
                        super.toAssignable(e1, t);
                    }
                    toAssignableList(e1, t, r) {
                        for(let t = 0; t < e1.length; t++){
                            const r = e1[t];
                            if ((r == null ? void 0 : r.type) === "TypeCastExpression") {
                                e1[t] = this.typeCastToParameter(r);
                            }
                        }
                        super.toAssignableList(e1, t, r);
                    }
                    toReferencedList(e1, t) {
                        for(let n = 0; n < e1.length; n++){
                            var r;
                            const s = e1[n];
                            if (s && s.type === "TypeCastExpression" && !((r = s.extra) != null && r.parenthesized) && (e1.length > 1 || !t)) {
                                this.raise(rt.TypeCastInPattern, {
                                    at: s.typeAnnotation
                                });
                            }
                        }
                        return e1;
                    }
                    parseArrayLike(e1, t, r, n) {
                        const s = super.parseArrayLike(e1, t, r, n);
                        if (t && !this.state.maybeInArrowParameters) {
                            this.toReferencedList(s.elements);
                        }
                        return s;
                    }
                    isValidLVal(e1, t, r) {
                        return e1 === "TypeCastExpression" || super.isValidLVal(e1, t, r);
                    }
                    parseClassProperty(e1) {
                        if (this.match(14)) {
                            e1.typeAnnotation = this.flowParseTypeAnnotation();
                        }
                        return super.parseClassProperty(e1);
                    }
                    parseClassPrivateProperty(e1) {
                        if (this.match(14)) {
                            e1.typeAnnotation = this.flowParseTypeAnnotation();
                        }
                        return super.parseClassPrivateProperty(e1);
                    }
                    isClassMethod() {
                        return this.match(47) || super.isClassMethod();
                    }
                    isClassProperty() {
                        return this.match(14) || super.isClassProperty();
                    }
                    isNonstaticConstructor(e1) {
                        return !this.match(14) && super.isNonstaticConstructor(e1);
                    }
                    pushClassMethod(e1, t, r, n, s, i) {
                        if (t.variance) {
                            this.unexpected(t.variance.loc.start);
                        }
                        delete t.variance;
                        if (this.match(47)) {
                            t.typeParameters = this.flowParseTypeParameterDeclaration();
                        }
                        super.pushClassMethod(e1, t, r, n, s, i);
                        if (t.params && s) {
                            const e1 = t.params;
                            if (e1.length > 0 && this.isThisParam(e1[0])) {
                                this.raise(rt.ThisParamBannedInConstructor, {
                                    at: t
                                });
                            }
                        } else if (t.type === "MethodDefinition" && s && t.value.params) {
                            const e1 = t.value.params;
                            if (e1.length > 0 && this.isThisParam(e1[0])) {
                                this.raise(rt.ThisParamBannedInConstructor, {
                                    at: t
                                });
                            }
                        }
                    }
                    pushClassPrivateMethod(e1, t, r, n) {
                        if (t.variance) {
                            this.unexpected(t.variance.loc.start);
                        }
                        delete t.variance;
                        if (this.match(47)) {
                            t.typeParameters = this.flowParseTypeParameterDeclaration();
                        }
                        super.pushClassPrivateMethod(e1, t, r, n);
                    }
                    parseClassSuper(e1) {
                        super.parseClassSuper(e1);
                        if (e1.superClass && this.match(47)) {
                            e1.superTypeParameters = this.flowParseTypeParameterInstantiation();
                        }
                        if (this.isContextual(111)) {
                            this.next();
                            const t = e1.implements = [];
                            do {
                                const e1 = this.startNode();
                                e1.id = this.flowParseRestrictedIdentifier(true);
                                if (this.match(47)) {
                                    e1.typeParameters = this.flowParseTypeParameterInstantiation();
                                } else {
                                    e1.typeParameters = null;
                                }
                                t.push(this.finishNode(e1, "ClassImplements"));
                            }while (this.eat(12))
                        }
                    }
                    checkGetterSetterParams(e1) {
                        super.checkGetterSetterParams(e1);
                        const t = this.getObjectOrClassMethodParams(e1);
                        if (t.length > 0) {
                            const r = t[0];
                            if (this.isThisParam(r) && e1.kind === "get") {
                                this.raise(rt.GetterMayNotHaveThisParam, {
                                    at: r
                                });
                            } else if (this.isThisParam(r)) {
                                this.raise(rt.SetterMayNotHaveThisParam, {
                                    at: r
                                });
                            }
                        }
                    }
                    parsePropertyNamePrefixOperator(e1) {
                        e1.variance = this.flowParseVariance();
                    }
                    parseObjPropValue(e1, t, r, n, s, i, a) {
                        if (e1.variance) {
                            this.unexpected(e1.variance.loc.start);
                        }
                        delete e1.variance;
                        let o;
                        if (this.match(47) && !i) {
                            o = this.flowParseTypeParameterDeclaration();
                            if (!this.match(10)) this.unexpected();
                        }
                        const l = super.parseObjPropValue(e1, t, r, n, s, i, a);
                        if (o) {
                            (l.value || l).typeParameters = o;
                        }
                        return l;
                    }
                    parseAssignableListItemTypes(e1) {
                        if (this.eat(17)) {
                            if (e1.type !== "Identifier") {
                                this.raise(rt.PatternIsOptional, {
                                    at: e1
                                });
                            }
                            if (this.isThisParam(e1)) {
                                this.raise(rt.ThisParamMayNotBeOptional, {
                                    at: e1
                                });
                            }
                            e1.optional = true;
                        }
                        if (this.match(14)) {
                            e1.typeAnnotation = this.flowParseTypeAnnotation();
                        } else if (this.isThisParam(e1)) {
                            this.raise(rt.ThisParamAnnotationRequired, {
                                at: e1
                            });
                        }
                        if (this.match(29) && this.isThisParam(e1)) {
                            this.raise(rt.ThisParamNoDefault, {
                                at: e1
                            });
                        }
                        this.resetEndLocation(e1);
                        return e1;
                    }
                    parseMaybeDefault(e1, t) {
                        const r = super.parseMaybeDefault(e1, t);
                        if (r.type === "AssignmentPattern" && r.typeAnnotation && r.right.start < r.typeAnnotation.start) {
                            this.raise(rt.TypeBeforeInitializer, {
                                at: r.typeAnnotation
                            });
                        }
                        return r;
                    }
                    checkImportReflection(e1) {
                        super.checkImportReflection(e1);
                        if (e1.module && e1.importKind !== "value") {
                            this.raise(rt.ImportReflectionHasImportType, {
                                at: e1.specifiers[0].loc.start
                            });
                        }
                    }
                    parseImportSpecifierLocal(e1, t, r) {
                        t.local = hasTypeImportKind(e1) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
                        e1.specifiers.push(this.finishImportSpecifier(t, r));
                    }
                    isPotentialImportPhase(e1) {
                        if (super.isPotentialImportPhase(e1)) return true;
                        if (this.isContextual(128)) {
                            if (!e1) return true;
                            const t = this.lookaheadCharCode();
                            return t === 123 || t === 42;
                        }
                        return !e1 && this.isContextual(87);
                    }
                    applyImportPhase(e1, t, r, n) {
                        super.applyImportPhase(e1, t, r, n);
                        if (t) {
                            if (!r && this.match(65)) {
                                return;
                            }
                            e1.exportKind = r === "type" ? r : "value";
                        } else {
                            if (r === "type" && this.match(55)) this.unexpected();
                            e1.importKind = r === "type" || r === "typeof" ? r : "value";
                        }
                    }
                    parseImportSpecifier(e1, t, r, n, s) {
                        const i = e1.imported;
                        let a = null;
                        if (i.type === "Identifier") {
                            if (i.name === "type") {
                                a = "type";
                            } else if (i.name === "typeof") {
                                a = "typeof";
                            }
                        }
                        let o = false;
                        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
                            const t = this.parseIdentifier(true);
                            if (a !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
                                e1.imported = t;
                                e1.importKind = a;
                                e1.local = cloneIdentifier(t);
                            } else {
                                e1.imported = i;
                                e1.importKind = null;
                                e1.local = this.parseIdentifier();
                            }
                        } else {
                            if (a !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
                                e1.imported = this.parseIdentifier(true);
                                e1.importKind = a;
                            } else {
                                if (t) {
                                    throw this.raise(p.ImportBindingIsString, {
                                        at: e1,
                                        importName: i.value
                                    });
                                }
                                e1.imported = i;
                                e1.importKind = null;
                            }
                            if (this.eatContextual(93)) {
                                e1.local = this.parseIdentifier();
                            } else {
                                o = true;
                                e1.local = cloneIdentifier(e1.imported);
                            }
                        }
                        const l = hasTypeImportKind(e1);
                        if (r && l) {
                            this.raise(rt.ImportTypeShorthandOnlyInPureImport, {
                                at: e1
                            });
                        }
                        if (r || l) {
                            this.checkReservedType(e1.local.name, e1.local.loc.start, true);
                        }
                        if (o && !r && !l) {
                            this.checkReservedWord(e1.local.name, e1.loc.start, true, true);
                        }
                        return this.finishImportSpecifier(e1, "ImportSpecifier");
                    }
                    parseBindingAtom() {
                        switch(this.state.type){
                            case 78:
                                return this.parseIdentifier(true);
                            default:
                                return super.parseBindingAtom();
                        }
                    }
                    parseFunctionParams(e1, t) {
                        const r = e1.kind;
                        if (r !== "get" && r !== "set" && this.match(47)) {
                            e1.typeParameters = this.flowParseTypeParameterDeclaration();
                        }
                        super.parseFunctionParams(e1, t);
                    }
                    parseVarId(e1, t) {
                        super.parseVarId(e1, t);
                        if (this.match(14)) {
                            e1.id.typeAnnotation = this.flowParseTypeAnnotation();
                            this.resetEndLocation(e1.id);
                        }
                    }
                    parseAsyncArrowFromCallExpression(e1, t) {
                        if (this.match(14)) {
                            const t = this.state.noAnonFunctionType;
                            this.state.noAnonFunctionType = true;
                            e1.returnType = this.flowParseTypeAnnotation();
                            this.state.noAnonFunctionType = t;
                        }
                        return super.parseAsyncArrowFromCallExpression(e1, t);
                    }
                    shouldParseAsyncArrow() {
                        return this.match(14) || super.shouldParseAsyncArrow();
                    }
                    parseMaybeAssign(e1, t) {
                        var r;
                        let n = null;
                        let s;
                        if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                            n = this.state.clone();
                            s = this.tryParse(()=>super.parseMaybeAssign(e1, t), n);
                            if (!s.error) return s.node;
                            const { context: r } = this.state;
                            const i = r[r.length - 1];
                            if (i === d.j_oTag || i === d.j_expr) {
                                r.pop();
                            }
                        }
                        if ((r = s) != null && r.error || this.match(47)) {
                            var i, a;
                            n = n || this.state.clone();
                            let r;
                            const o = this.tryParse((n)=>{
                                var s;
                                r = this.flowParseTypeParameterDeclaration();
                                const i = this.forwardNoArrowParamsConversionAt(r, ()=>{
                                    const n = super.parseMaybeAssign(e1, t);
                                    this.resetStartLocationFromNode(n, r);
                                    return n;
                                });
                                if ((s = i.extra) != null && s.parenthesized) n();
                                const a = this.maybeUnwrapTypeCastExpression(i);
                                if (a.type !== "ArrowFunctionExpression") n();
                                a.typeParameters = r;
                                this.resetStartLocationFromNode(a, r);
                                return i;
                            }, n);
                            let l = null;
                            if (o.node && this.maybeUnwrapTypeCastExpression(o.node).type === "ArrowFunctionExpression") {
                                if (!o.error && !o.aborted) {
                                    if (o.node.async) {
                                        this.raise(rt.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                                            at: r
                                        });
                                    }
                                    return o.node;
                                }
                                l = o.node;
                            }
                            if ((i = s) != null && i.node) {
                                this.state = s.failState;
                                return s.node;
                            }
                            if (l) {
                                this.state = o.failState;
                                return l;
                            }
                            if ((a = s) != null && a.thrown) throw s.error;
                            if (o.thrown) throw o.error;
                            throw this.raise(rt.UnexpectedTokenAfterTypeParameter, {
                                at: r
                            });
                        }
                        return super.parseMaybeAssign(e1, t);
                    }
                    parseArrow(e1) {
                        if (this.match(14)) {
                            const t = this.tryParse(()=>{
                                const t = this.state.noAnonFunctionType;
                                this.state.noAnonFunctionType = true;
                                const r = this.startNode();
                                [r.typeAnnotation, e1.predicate] = this.flowParseTypeAndPredicateInitialiser();
                                this.state.noAnonFunctionType = t;
                                if (this.canInsertSemicolon()) this.unexpected();
                                if (!this.match(19)) this.unexpected();
                                return r;
                            });
                            if (t.thrown) return null;
                            if (t.error) this.state = t.failState;
                            e1.returnType = t.node.typeAnnotation ? this.finishNode(t.node, "TypeAnnotation") : null;
                        }
                        return super.parseArrow(e1);
                    }
                    shouldParseArrow(e1) {
                        return this.match(14) || super.shouldParseArrow(e1);
                    }
                    setArrowFunctionParameters(e1, t) {
                        if (this.state.noArrowParamsConversionAt.indexOf(e1.start) !== -1) {
                            e1.params = t;
                        } else {
                            super.setArrowFunctionParameters(e1, t);
                        }
                    }
                    checkParams(e1, t, r, n = true) {
                        if (r && this.state.noArrowParamsConversionAt.indexOf(e1.start) !== -1) {
                            return;
                        }
                        for(let t = 0; t < e1.params.length; t++){
                            if (this.isThisParam(e1.params[t]) && t > 0) {
                                this.raise(rt.ThisParamMustBeFirst, {
                                    at: e1.params[t]
                                });
                            }
                        }
                        super.checkParams(e1, t, r, n);
                    }
                    parseParenAndDistinguishExpression(e1) {
                        return super.parseParenAndDistinguishExpression(e1 && this.state.noArrowAt.indexOf(this.state.start) === -1);
                    }
                    parseSubscripts(e1, t, r) {
                        if (e1.type === "Identifier" && e1.name === "async" && this.state.noArrowAt.indexOf(t.index) !== -1) {
                            this.next();
                            const r = this.startNodeAt(t);
                            r.callee = e1;
                            r.arguments = super.parseCallExpressionArguments(11, false);
                            e1 = this.finishNode(r, "CallExpression");
                        } else if (e1.type === "Identifier" && e1.name === "async" && this.match(47)) {
                            const n = this.state.clone();
                            const s = this.tryParse((e1)=>this.parseAsyncArrowWithTypeParameters(t) || e1(), n);
                            if (!s.error && !s.aborted) return s.node;
                            const i = this.tryParse(()=>super.parseSubscripts(e1, t, r), n);
                            if (i.node && !i.error) return i.node;
                            if (s.node) {
                                this.state = s.failState;
                                return s.node;
                            }
                            if (i.node) {
                                this.state = i.failState;
                                return i.node;
                            }
                            throw s.error || i.error;
                        }
                        return super.parseSubscripts(e1, t, r);
                    }
                    parseSubscript(e1, t, r, n) {
                        if (this.match(18) && this.isLookaheadToken_lt()) {
                            n.optionalChainMember = true;
                            if (r) {
                                n.stop = true;
                                return e1;
                            }
                            this.next();
                            const s = this.startNodeAt(t);
                            s.callee = e1;
                            s.typeArguments = this.flowParseTypeParameterInstantiation();
                            this.expect(10);
                            s.arguments = this.parseCallExpressionArguments(11, false);
                            s.optional = true;
                            return this.finishCallExpression(s, true);
                        } else if (!r && this.shouldParseTypes() && this.match(47)) {
                            const r = this.startNodeAt(t);
                            r.callee = e1;
                            const s = this.tryParse(()=>{
                                r.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
                                this.expect(10);
                                r.arguments = super.parseCallExpressionArguments(11, false);
                                if (n.optionalChainMember) {
                                    r.optional = false;
                                }
                                return this.finishCallExpression(r, n.optionalChainMember);
                            });
                            if (s.node) {
                                if (s.error) this.state = s.failState;
                                return s.node;
                            }
                        }
                        return super.parseSubscript(e1, t, r, n);
                    }
                    parseNewCallee(e1) {
                        super.parseNewCallee(e1);
                        let t = null;
                        if (this.shouldParseTypes() && this.match(47)) {
                            t = this.tryParse(()=>this.flowParseTypeParameterInstantiationCallOrNew()).node;
                        }
                        e1.typeArguments = t;
                    }
                    parseAsyncArrowWithTypeParameters(e1) {
                        const t = this.startNodeAt(e1);
                        this.parseFunctionParams(t, false);
                        if (!this.parseArrow(t)) return;
                        return super.parseArrowExpression(t, undefined, true);
                    }
                    readToken_mult_modulo(e1) {
                        const t = this.input.charCodeAt(this.state.pos + 1);
                        if (e1 === 42 && t === 47 && this.state.hasFlowComment) {
                            this.state.hasFlowComment = false;
                            this.state.pos += 2;
                            this.nextToken();
                            return;
                        }
                        super.readToken_mult_modulo(e1);
                    }
                    readToken_pipe_amp(e1) {
                        const t = this.input.charCodeAt(this.state.pos + 1);
                        if (e1 === 124 && t === 125) {
                            this.finishOp(9, 2);
                            return;
                        }
                        super.readToken_pipe_amp(e1);
                    }
                    parseTopLevel(e1, t) {
                        const r = super.parseTopLevel(e1, t);
                        if (this.state.hasFlowComment) {
                            this.raise(rt.UnterminatedFlowComment, {
                                at: this.state.curPosition()
                            });
                        }
                        return r;
                    }
                    skipBlockComment() {
                        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                            if (this.state.hasFlowComment) {
                                throw this.raise(rt.NestedFlowComment, {
                                    at: this.state.startLoc
                                });
                            }
                            this.hasFlowCommentCompletion();
                            const e1 = this.skipFlowComment();
                            if (e1) {
                                this.state.pos += e1;
                                this.state.hasFlowComment = true;
                            }
                            return;
                        }
                        return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
                    }
                    skipFlowComment() {
                        const { pos: e1 } = this.state;
                        let t = 2;
                        while([
                            32,
                            9
                        ].includes(this.input.charCodeAt(e1 + t))){
                            t++;
                        }
                        const r = this.input.charCodeAt(t + e1);
                        const n = this.input.charCodeAt(t + e1 + 1);
                        if (r === 58 && n === 58) {
                            return t + 2;
                        }
                        if (this.input.slice(t + e1, t + e1 + 12) === "flow-include") {
                            return t + 12;
                        }
                        if (r === 58 && n !== 58) {
                            return t;
                        }
                        return false;
                    }
                    hasFlowCommentCompletion() {
                        const e1 = this.input.indexOf("*/", this.state.pos);
                        if (e1 === -1) {
                            throw this.raise(p.UnterminatedComment, {
                                at: this.state.curPosition()
                            });
                        }
                    }
                    flowEnumErrorBooleanMemberNotInitialized(e1, { enumName: t, memberName: r }) {
                        this.raise(rt.EnumBooleanMemberNotInitialized, {
                            at: e1,
                            memberName: r,
                            enumName: t
                        });
                    }
                    flowEnumErrorInvalidMemberInitializer(e1, t) {
                        return this.raise(!t.explicitType ? rt.EnumInvalidMemberInitializerUnknownType : t.explicitType === "symbol" ? rt.EnumInvalidMemberInitializerSymbolType : rt.EnumInvalidMemberInitializerPrimaryType, Object.assign({
                            at: e1
                        }, t));
                    }
                    flowEnumErrorNumberMemberNotInitialized(e1, { enumName: t, memberName: r }) {
                        this.raise(rt.EnumNumberMemberNotInitialized, {
                            at: e1,
                            enumName: t,
                            memberName: r
                        });
                    }
                    flowEnumErrorStringMemberInconsistentlyInitailized(e1, { enumName: t }) {
                        this.raise(rt.EnumStringMemberInconsistentlyInitailized, {
                            at: e1,
                            enumName: t
                        });
                    }
                    flowEnumMemberInit() {
                        const e1 = this.state.startLoc;
                        const endOfInit = ()=>this.match(12) || this.match(8);
                        switch(this.state.type){
                            case 132:
                                {
                                    const t = this.parseNumericLiteral(this.state.value);
                                    if (endOfInit()) {
                                        return {
                                            type: "number",
                                            loc: t.loc.start,
                                            value: t
                                        };
                                    }
                                    return {
                                        type: "invalid",
                                        loc: e1
                                    };
                                }
                            case 131:
                                {
                                    const t = this.parseStringLiteral(this.state.value);
                                    if (endOfInit()) {
                                        return {
                                            type: "string",
                                            loc: t.loc.start,
                                            value: t
                                        };
                                    }
                                    return {
                                        type: "invalid",
                                        loc: e1
                                    };
                                }
                            case 85:
                            case 86:
                                {
                                    const t = this.parseBooleanLiteral(this.match(85));
                                    if (endOfInit()) {
                                        return {
                                            type: "boolean",
                                            loc: t.loc.start,
                                            value: t
                                        };
                                    }
                                    return {
                                        type: "invalid",
                                        loc: e1
                                    };
                                }
                            default:
                                return {
                                    type: "invalid",
                                    loc: e1
                                };
                        }
                    }
                    flowEnumMemberRaw() {
                        const e1 = this.state.startLoc;
                        const t = this.parseIdentifier(true);
                        const r = this.eat(29) ? this.flowEnumMemberInit() : {
                            type: "none",
                            loc: e1
                        };
                        return {
                            id: t,
                            init: r
                        };
                    }
                    flowEnumCheckExplicitTypeMismatch(e1, t, r) {
                        const { explicitType: n } = t;
                        if (n === null) {
                            return;
                        }
                        if (n !== r) {
                            this.flowEnumErrorInvalidMemberInitializer(e1, t);
                        }
                    }
                    flowEnumMembers({ enumName: e1, explicitType: t }) {
                        const r = new Set;
                        const n = {
                            booleanMembers: [],
                            numberMembers: [],
                            stringMembers: [],
                            defaultedMembers: []
                        };
                        let s = false;
                        while(!this.match(8)){
                            if (this.eat(21)) {
                                s = true;
                                break;
                            }
                            const i = this.startNode();
                            const { id: a, init: o } = this.flowEnumMemberRaw();
                            const l = a.name;
                            if (l === "") {
                                continue;
                            }
                            if (/^[a-z]/.test(l)) {
                                this.raise(rt.EnumInvalidMemberName, {
                                    at: a,
                                    memberName: l,
                                    suggestion: l[0].toUpperCase() + l.slice(1),
                                    enumName: e1
                                });
                            }
                            if (r.has(l)) {
                                this.raise(rt.EnumDuplicateMemberName, {
                                    at: a,
                                    memberName: l,
                                    enumName: e1
                                });
                            }
                            r.add(l);
                            const c = {
                                enumName: e1,
                                explicitType: t,
                                memberName: l
                            };
                            i.id = a;
                            switch(o.type){
                                case "boolean":
                                    {
                                        this.flowEnumCheckExplicitTypeMismatch(o.loc, c, "boolean");
                                        i.init = o.value;
                                        n.booleanMembers.push(this.finishNode(i, "EnumBooleanMember"));
                                        break;
                                    }
                                case "number":
                                    {
                                        this.flowEnumCheckExplicitTypeMismatch(o.loc, c, "number");
                                        i.init = o.value;
                                        n.numberMembers.push(this.finishNode(i, "EnumNumberMember"));
                                        break;
                                    }
                                case "string":
                                    {
                                        this.flowEnumCheckExplicitTypeMismatch(o.loc, c, "string");
                                        i.init = o.value;
                                        n.stringMembers.push(this.finishNode(i, "EnumStringMember"));
                                        break;
                                    }
                                case "invalid":
                                    {
                                        throw this.flowEnumErrorInvalidMemberInitializer(o.loc, c);
                                    }
                                case "none":
                                    {
                                        switch(t){
                                            case "boolean":
                                                this.flowEnumErrorBooleanMemberNotInitialized(o.loc, c);
                                                break;
                                            case "number":
                                                this.flowEnumErrorNumberMemberNotInitialized(o.loc, c);
                                                break;
                                            default:
                                                n.defaultedMembers.push(this.finishNode(i, "EnumDefaultedMember"));
                                        }
                                    }
                            }
                            if (!this.match(8)) {
                                this.expect(12);
                            }
                        }
                        return {
                            members: n,
                            hasUnknownMembers: s
                        };
                    }
                    flowEnumStringMembers(e1, t, { enumName: r }) {
                        if (e1.length === 0) {
                            return t;
                        } else if (t.length === 0) {
                            return e1;
                        } else if (t.length > e1.length) {
                            for (const t of e1){
                                this.flowEnumErrorStringMemberInconsistentlyInitailized(t, {
                                    enumName: r
                                });
                            }
                            return t;
                        } else {
                            for (const e1 of t){
                                this.flowEnumErrorStringMemberInconsistentlyInitailized(e1, {
                                    enumName: r
                                });
                            }
                            return e1;
                        }
                    }
                    flowEnumParseExplicitType({ enumName: e1 }) {
                        if (!this.eatContextual(101)) return null;
                        if (!tokenIsIdentifier(this.state.type)) {
                            throw this.raise(rt.EnumInvalidExplicitTypeUnknownSupplied, {
                                at: this.state.startLoc,
                                enumName: e1
                            });
                        }
                        const { value: t } = this.state;
                        this.next();
                        if (t !== "boolean" && t !== "number" && t !== "string" && t !== "symbol") {
                            this.raise(rt.EnumInvalidExplicitType, {
                                at: this.state.startLoc,
                                enumName: e1,
                                invalidEnumType: t
                            });
                        }
                        return t;
                    }
                    flowEnumBody(e1, t) {
                        const r = t.name;
                        const n = t.loc.start;
                        const s = this.flowEnumParseExplicitType({
                            enumName: r
                        });
                        this.expect(5);
                        const { members: i, hasUnknownMembers: a } = this.flowEnumMembers({
                            enumName: r,
                            explicitType: s
                        });
                        e1.hasUnknownMembers = a;
                        switch(s){
                            case "boolean":
                                e1.explicitType = true;
                                e1.members = i.booleanMembers;
                                this.expect(8);
                                return this.finishNode(e1, "EnumBooleanBody");
                            case "number":
                                e1.explicitType = true;
                                e1.members = i.numberMembers;
                                this.expect(8);
                                return this.finishNode(e1, "EnumNumberBody");
                            case "string":
                                e1.explicitType = true;
                                e1.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, {
                                    enumName: r
                                });
                                this.expect(8);
                                return this.finishNode(e1, "EnumStringBody");
                            case "symbol":
                                e1.members = i.defaultedMembers;
                                this.expect(8);
                                return this.finishNode(e1, "EnumSymbolBody");
                            default:
                                {
                                    const empty = ()=>{
                                        e1.members = [];
                                        this.expect(8);
                                        return this.finishNode(e1, "EnumStringBody");
                                    };
                                    e1.explicitType = false;
                                    const t = i.booleanMembers.length;
                                    const s = i.numberMembers.length;
                                    const a = i.stringMembers.length;
                                    const o = i.defaultedMembers.length;
                                    if (!t && !s && !a && !o) {
                                        return empty();
                                    } else if (!t && !s) {
                                        e1.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, {
                                            enumName: r
                                        });
                                        this.expect(8);
                                        return this.finishNode(e1, "EnumStringBody");
                                    } else if (!s && !a && t >= o) {
                                        for (const e1 of i.defaultedMembers){
                                            this.flowEnumErrorBooleanMemberNotInitialized(e1.loc.start, {
                                                enumName: r,
                                                memberName: e1.id.name
                                            });
                                        }
                                        e1.members = i.booleanMembers;
                                        this.expect(8);
                                        return this.finishNode(e1, "EnumBooleanBody");
                                    } else if (!t && !a && s >= o) {
                                        for (const e1 of i.defaultedMembers){
                                            this.flowEnumErrorNumberMemberNotInitialized(e1.loc.start, {
                                                enumName: r,
                                                memberName: e1.id.name
                                            });
                                        }
                                        e1.members = i.numberMembers;
                                        this.expect(8);
                                        return this.finishNode(e1, "EnumNumberBody");
                                    } else {
                                        this.raise(rt.EnumInconsistentMemberValues, {
                                            at: n,
                                            enumName: r
                                        });
                                        return empty();
                                    }
                                }
                        }
                    }
                    flowParseEnumDeclaration(e1) {
                        const t = this.parseIdentifier();
                        e1.id = t;
                        e1.body = this.flowEnumBody(this.startNode(), t);
                        return this.finishNode(e1, "EnumDeclaration");
                    }
                    isLookaheadToken_lt() {
                        const e1 = this.nextTokenStart();
                        if (this.input.charCodeAt(e1) === 60) {
                            const t = this.input.charCodeAt(e1 + 1);
                            return t !== 60 && t !== 61;
                        }
                        return false;
                    }
                    maybeUnwrapTypeCastExpression(e1) {
                        return e1.type === "TypeCastExpression" ? e1.expression : e1;
                    }
                };
            const it = {
                __proto__: null,
                quot: '"',
                amp: "&",
                apos: "'",
                lt: "<",
                gt: ">",
                nbsp: "",
                iexcl: "",
                cent: "",
                pound: "",
                curren: "",
                yen: "",
                brvbar: "",
                sect: "",
                uml: "",
                copy: "",
                ordf: "",
                laquo: "",
                not: "",
                shy: "",
                reg: "",
                macr: "",
                deg: "",
                plusmn: "",
                sup2: "",
                sup3: "",
                acute: "",
                micro: "",
                para: "",
                middot: "",
                cedil: "",
                sup1: "",
                ordm: "",
                raquo: "",
                frac14: "",
                frac12: "",
                frac34: "",
                iquest: "",
                Agrave: "",
                Aacute: "",
                Acirc: "",
                Atilde: "",
                Auml: "",
                Aring: "",
                AElig: "",
                Ccedil: "",
                Egrave: "",
                Eacute: "",
                Ecirc: "",
                Euml: "",
                Igrave: "",
                Iacute: "",
                Icirc: "",
                Iuml: "",
                ETH: "",
                Ntilde: "",
                Ograve: "",
                Oacute: "",
                Ocirc: "",
                Otilde: "",
                Ouml: "",
                times: "",
                Oslash: "",
                Ugrave: "",
                Uacute: "",
                Ucirc: "",
                Uuml: "",
                Yacute: "",
                THORN: "",
                szlig: "",
                agrave: "",
                aacute: "",
                acirc: "",
                atilde: "",
                auml: "",
                aring: "",
                aelig: "",
                ccedil: "",
                egrave: "",
                eacute: "",
                ecirc: "",
                euml: "",
                igrave: "",
                iacute: "",
                icirc: "",
                iuml: "",
                eth: "",
                ntilde: "",
                ograve: "",
                oacute: "",
                ocirc: "",
                otilde: "",
                ouml: "",
                divide: "",
                oslash: "",
                ugrave: "",
                uacute: "",
                ucirc: "",
                uuml: "",
                yacute: "",
                thorn: "",
                yuml: "",
                OElig: "",
                oelig: "",
                Scaron: "",
                scaron: "",
                Yuml: "",
                fnof: "",
                circ: "",
                tilde: "",
                Alpha: "",
                Beta: "",
                Gamma: "",
                Delta: "",
                Epsilon: "",
                Zeta: "",
                Eta: "",
                Theta: "",
                Iota: "",
                Kappa: "",
                Lambda: "",
                Mu: "",
                Nu: "",
                Xi: "",
                Omicron: "",
                Pi: "",
                Rho: "",
                Sigma: "",
                Tau: "",
                Upsilon: "",
                Phi: "",
                Chi: "",
                Psi: "",
                Omega: "",
                alpha: "",
                beta: "",
                gamma: "",
                delta: "",
                epsilon: "",
                zeta: "",
                eta: "",
                theta: "",
                iota: "",
                kappa: "",
                lambda: "",
                mu: "",
                nu: "",
                xi: "",
                omicron: "",
                pi: "",
                rho: "",
                sigmaf: "",
                sigma: "",
                tau: "",
                upsilon: "",
                phi: "",
                chi: "",
                psi: "",
                omega: "",
                thetasym: "",
                upsih: "",
                piv: "",
                ensp: "",
                emsp: "",
                thinsp: "",
                zwnj: "",
                zwj: "",
                lrm: "",
                rlm: "",
                ndash: "",
                mdash: "",
                lsquo: "",
                rsquo: "",
                sbquo: "",
                ldquo: "",
                rdquo: "",
                bdquo: "",
                dagger: "",
                Dagger: "",
                bull: "",
                hellip: "",
                permil: "",
                prime: "",
                Prime: "",
                lsaquo: "",
                rsaquo: "",
                oline: "",
                frasl: "",
                euro: "",
                image: "",
                weierp: "",
                real: "",
                trade: "",
                alefsym: "",
                larr: "",
                uarr: "",
                rarr: "",
                darr: "",
                harr: "",
                crarr: "",
                lArr: "",
                uArr: "",
                rArr: "",
                dArr: "",
                hArr: "",
                forall: "",
                part: "",
                exist: "",
                empty: "",
                nabla: "",
                isin: "",
                notin: "",
                ni: "",
                prod: "",
                sum: "",
                minus: "",
                lowast: "",
                radic: "",
                prop: "",
                infin: "",
                ang: "",
                and: "",
                or: "",
                cap: "",
                cup: "",
                int: "",
                there4: "",
                sim: "",
                cong: "",
                asymp: "",
                ne: "",
                equiv: "",
                le: "",
                ge: "",
                sub: "",
                sup: "",
                nsub: "",
                sube: "",
                supe: "",
                oplus: "",
                otimes: "",
                perp: "",
                sdot: "",
                lceil: "",
                rceil: "",
                lfloor: "",
                rfloor: "",
                lang: "",
                rang: "",
                loz: "",
                spades: "",
                clubs: "",
                hearts: "",
                diams: ""
            };
            const at = ParseErrorEnum`jsx`({
                AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
                MissingClosingTagElement: ({ openingTagName: e1 })=>`Expected corresponding JSX closing tag for <${e1}>.`,
                MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
                UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
                UnexpectedToken: ({ unexpected: e1, HTMLEntity: t })=>`Unexpected token \`${e1}\`. Did you mean \`${t}\` or \`{'${e1}'}\`?`,
                UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
                UnterminatedJsxContent: "Unterminated JSX contents.",
                UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
            });
            function isFragment(e1) {
                return e1 ? e1.type === "JSXOpeningFragment" || e1.type === "JSXClosingFragment" : false;
            }
            function getQualifiedJSXName(e1) {
                if (e1.type === "JSXIdentifier") {
                    return e1.name;
                }
                if (e1.type === "JSXNamespacedName") {
                    return e1.namespace.name + ":" + e1.name.name;
                }
                if (e1.type === "JSXMemberExpression") {
                    return getQualifiedJSXName(e1.object) + "." + getQualifiedJSXName(e1.property);
                }
                throw new Error("Node had unexpected type: " + e1.type);
            }
            var jsx = (e1)=>class JSXParserMixin extends e1 {
                    jsxReadToken() {
                        let e1 = "";
                        let t = this.state.pos;
                        for(;;){
                            if (this.state.pos >= this.length) {
                                throw this.raise(at.UnterminatedJsxContent, {
                                    at: this.state.startLoc
                                });
                            }
                            const r = this.input.charCodeAt(this.state.pos);
                            switch(r){
                                case 60:
                                case 123:
                                    if (this.state.pos === this.state.start) {
                                        if (r === 60 && this.state.canStartJSXElement) {
                                            ++this.state.pos;
                                            this.finishToken(140);
                                        } else {
                                            super.getTokenFromCode(r);
                                        }
                                        return;
                                    }
                                    e1 += this.input.slice(t, this.state.pos);
                                    this.finishToken(139, e1);
                                    return;
                                case 38:
                                    e1 += this.input.slice(t, this.state.pos);
                                    e1 += this.jsxReadEntity();
                                    t = this.state.pos;
                                    break;
                                case 62:
                                case 125:
                                default:
                                    if (isNewLine(r)) {
                                        e1 += this.input.slice(t, this.state.pos);
                                        e1 += this.jsxReadNewLine(true);
                                        t = this.state.pos;
                                    } else {
                                        ++this.state.pos;
                                    }
                            }
                        }
                    }
                    jsxReadNewLine(e1) {
                        const t = this.input.charCodeAt(this.state.pos);
                        let r;
                        ++this.state.pos;
                        if (t === 13 && this.input.charCodeAt(this.state.pos) === 10) {
                            ++this.state.pos;
                            r = e1 ? "\n" : "\r\n";
                        } else {
                            r = String.fromCharCode(t);
                        }
                        ++this.state.curLine;
                        this.state.lineStart = this.state.pos;
                        return r;
                    }
                    jsxReadString(e1) {
                        let t = "";
                        let r = ++this.state.pos;
                        for(;;){
                            if (this.state.pos >= this.length) {
                                throw this.raise(p.UnterminatedString, {
                                    at: this.state.startLoc
                                });
                            }
                            const n = this.input.charCodeAt(this.state.pos);
                            if (n === e1) break;
                            if (n === 38) {
                                t += this.input.slice(r, this.state.pos);
                                t += this.jsxReadEntity();
                                r = this.state.pos;
                            } else if (isNewLine(n)) {
                                t += this.input.slice(r, this.state.pos);
                                t += this.jsxReadNewLine(false);
                                r = this.state.pos;
                            } else {
                                ++this.state.pos;
                            }
                        }
                        t += this.input.slice(r, this.state.pos++);
                        this.finishToken(131, t);
                    }
                    jsxReadEntity() {
                        const e1 = ++this.state.pos;
                        if (this.codePointAtPos(this.state.pos) === 35) {
                            ++this.state.pos;
                            let e1 = 10;
                            if (this.codePointAtPos(this.state.pos) === 120) {
                                e1 = 16;
                                ++this.state.pos;
                            }
                            const t = this.readInt(e1, undefined, false, "bail");
                            if (t !== null && this.codePointAtPos(this.state.pos) === 59) {
                                ++this.state.pos;
                                return String.fromCodePoint(t);
                            }
                        } else {
                            let t = 0;
                            let r = false;
                            while(t++ < 10 && this.state.pos < this.length && !(r = this.codePointAtPos(this.state.pos) == 59)){
                                ++this.state.pos;
                            }
                            if (r) {
                                const t = this.input.slice(e1, this.state.pos);
                                const r = it[t];
                                ++this.state.pos;
                                if (r) {
                                    return r;
                                }
                            }
                        }
                        this.state.pos = e1;
                        return "&";
                    }
                    jsxReadWord() {
                        let e1;
                        const t = this.state.pos;
                        do {
                            e1 = this.input.charCodeAt(++this.state.pos);
                        }while (isIdentifierChar(e1) || e1 === 45)
                        this.finishToken(138, this.input.slice(t, this.state.pos));
                    }
                    jsxParseIdentifier() {
                        const e1 = this.startNode();
                        if (this.match(138)) {
                            e1.name = this.state.value;
                        } else if (tokenIsKeyword(this.state.type)) {
                            e1.name = tokenLabelName(this.state.type);
                        } else {
                            this.unexpected();
                        }
                        this.next();
                        return this.finishNode(e1, "JSXIdentifier");
                    }
                    jsxParseNamespacedName() {
                        const e1 = this.state.startLoc;
                        const t = this.jsxParseIdentifier();
                        if (!this.eat(14)) return t;
                        const r = this.startNodeAt(e1);
                        r.namespace = t;
                        r.name = this.jsxParseIdentifier();
                        return this.finishNode(r, "JSXNamespacedName");
                    }
                    jsxParseElementName() {
                        const e1 = this.state.startLoc;
                        let t = this.jsxParseNamespacedName();
                        if (t.type === "JSXNamespacedName") {
                            return t;
                        }
                        while(this.eat(16)){
                            const r = this.startNodeAt(e1);
                            r.object = t;
                            r.property = this.jsxParseIdentifier();
                            t = this.finishNode(r, "JSXMemberExpression");
                        }
                        return t;
                    }
                    jsxParseAttributeValue() {
                        let e1;
                        switch(this.state.type){
                            case 5:
                                e1 = this.startNode();
                                this.setContext(d.brace);
                                this.next();
                                e1 = this.jsxParseExpressionContainer(e1, d.j_oTag);
                                if (e1.expression.type === "JSXEmptyExpression") {
                                    this.raise(at.AttributeIsEmpty, {
                                        at: e1
                                    });
                                }
                                return e1;
                            case 140:
                            case 131:
                                return this.parseExprAtom();
                            default:
                                throw this.raise(at.UnsupportedJsxValue, {
                                    at: this.state.startLoc
                                });
                        }
                    }
                    jsxParseEmptyExpression() {
                        const e1 = this.startNodeAt(this.state.lastTokEndLoc);
                        return this.finishNodeAt(e1, "JSXEmptyExpression", this.state.startLoc);
                    }
                    jsxParseSpreadChild(e1) {
                        this.next();
                        e1.expression = this.parseExpression();
                        this.setContext(d.j_expr);
                        this.state.canStartJSXElement = true;
                        this.expect(8);
                        return this.finishNode(e1, "JSXSpreadChild");
                    }
                    jsxParseExpressionContainer(e1, t) {
                        if (this.match(8)) {
                            e1.expression = this.jsxParseEmptyExpression();
                        } else {
                            const t = this.parseExpression();
                            e1.expression = t;
                        }
                        this.setContext(t);
                        this.state.canStartJSXElement = true;
                        this.expect(8);
                        return this.finishNode(e1, "JSXExpressionContainer");
                    }
                    jsxParseAttribute() {
                        const e1 = this.startNode();
                        if (this.match(5)) {
                            this.setContext(d.brace);
                            this.next();
                            this.expect(21);
                            e1.argument = this.parseMaybeAssignAllowIn();
                            this.setContext(d.j_oTag);
                            this.state.canStartJSXElement = true;
                            this.expect(8);
                            return this.finishNode(e1, "JSXSpreadAttribute");
                        }
                        e1.name = this.jsxParseNamespacedName();
                        e1.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
                        return this.finishNode(e1, "JSXAttribute");
                    }
                    jsxParseOpeningElementAt(e1) {
                        const t = this.startNodeAt(e1);
                        if (this.eat(141)) {
                            return this.finishNode(t, "JSXOpeningFragment");
                        }
                        t.name = this.jsxParseElementName();
                        return this.jsxParseOpeningElementAfterName(t);
                    }
                    jsxParseOpeningElementAfterName(e1) {
                        const t = [];
                        while(!this.match(56) && !this.match(141)){
                            t.push(this.jsxParseAttribute());
                        }
                        e1.attributes = t;
                        e1.selfClosing = this.eat(56);
                        this.expect(141);
                        return this.finishNode(e1, "JSXOpeningElement");
                    }
                    jsxParseClosingElementAt(e1) {
                        const t = this.startNodeAt(e1);
                        if (this.eat(141)) {
                            return this.finishNode(t, "JSXClosingFragment");
                        }
                        t.name = this.jsxParseElementName();
                        this.expect(141);
                        return this.finishNode(t, "JSXClosingElement");
                    }
                    jsxParseElementAt(e1) {
                        const t = this.startNodeAt(e1);
                        const r = [];
                        const n = this.jsxParseOpeningElementAt(e1);
                        let s = null;
                        if (!n.selfClosing) {
                            e1: for(;;){
                                switch(this.state.type){
                                    case 140:
                                        e1 = this.state.startLoc;
                                        this.next();
                                        if (this.eat(56)) {
                                            s = this.jsxParseClosingElementAt(e1);
                                            break e1;
                                        }
                                        r.push(this.jsxParseElementAt(e1));
                                        break;
                                    case 139:
                                        r.push(this.parseExprAtom());
                                        break;
                                    case 5:
                                        {
                                            const e1 = this.startNode();
                                            this.setContext(d.brace);
                                            this.next();
                                            if (this.match(21)) {
                                                r.push(this.jsxParseSpreadChild(e1));
                                            } else {
                                                r.push(this.jsxParseExpressionContainer(e1, d.j_expr));
                                            }
                                            break;
                                        }
                                    default:
                                        this.unexpected();
                                }
                            }
                            if (isFragment(n) && !isFragment(s) && s !== null) {
                                this.raise(at.MissingClosingTagFragment, {
                                    at: s
                                });
                            } else if (!isFragment(n) && isFragment(s)) {
                                this.raise(at.MissingClosingTagElement, {
                                    at: s,
                                    openingTagName: getQualifiedJSXName(n.name)
                                });
                            } else if (!isFragment(n) && !isFragment(s)) {
                                if (getQualifiedJSXName(s.name) !== getQualifiedJSXName(n.name)) {
                                    this.raise(at.MissingClosingTagElement, {
                                        at: s,
                                        openingTagName: getQualifiedJSXName(n.name)
                                    });
                                }
                            }
                        }
                        if (isFragment(n)) {
                            t.openingFragment = n;
                            t.closingFragment = s;
                        } else {
                            t.openingElement = n;
                            t.closingElement = s;
                        }
                        t.children = r;
                        if (this.match(47)) {
                            throw this.raise(at.UnwrappedAdjacentJSXElements, {
                                at: this.state.startLoc
                            });
                        }
                        return isFragment(n) ? this.finishNode(t, "JSXFragment") : this.finishNode(t, "JSXElement");
                    }
                    jsxParseElement() {
                        const e1 = this.state.startLoc;
                        this.next();
                        return this.jsxParseElementAt(e1);
                    }
                    setContext(e1) {
                        const { context: t } = this.state;
                        t[t.length - 1] = e1;
                    }
                    parseExprAtom(e1) {
                        if (this.match(139)) {
                            return this.parseLiteral(this.state.value, "JSXText");
                        } else if (this.match(140)) {
                            return this.jsxParseElement();
                        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
                            this.replaceToken(140);
                            return this.jsxParseElement();
                        } else {
                            return super.parseExprAtom(e1);
                        }
                    }
                    skipSpace() {
                        const e1 = this.curContext();
                        if (!e1.preserveSpace) super.skipSpace();
                    }
                    getTokenFromCode(e1) {
                        const t = this.curContext();
                        if (t === d.j_expr) {
                            this.jsxReadToken();
                            return;
                        }
                        if (t === d.j_oTag || t === d.j_cTag) {
                            if (isIdentifierStart(e1)) {
                                this.jsxReadWord();
                                return;
                            }
                            if (e1 === 62) {
                                ++this.state.pos;
                                this.finishToken(141);
                                return;
                            }
                            if ((e1 === 34 || e1 === 39) && t === d.j_oTag) {
                                this.jsxReadString(e1);
                                return;
                            }
                        }
                        if (e1 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
                            ++this.state.pos;
                            this.finishToken(140);
                            return;
                        }
                        super.getTokenFromCode(e1);
                    }
                    updateContext(e1) {
                        const { context: t, type: r } = this.state;
                        if (r === 56 && e1 === 140) {
                            t.splice(-2, 2, d.j_cTag);
                            this.state.canStartJSXElement = false;
                        } else if (r === 140) {
                            t.push(d.j_oTag);
                        } else if (r === 141) {
                            const r = t[t.length - 1];
                            if (r === d.j_oTag && e1 === 56 || r === d.j_cTag) {
                                t.pop();
                                this.state.canStartJSXElement = t[t.length - 1] === d.j_expr;
                            } else {
                                this.setContext(d.j_expr);
                                this.state.canStartJSXElement = true;
                            }
                        } else {
                            this.state.canStartJSXElement = tokenComesBeforeExpression(r);
                        }
                    }
                };
            class TypeScriptScope extends Scope {
                constructor(...e1){
                    super(...e1);
                    this.types = new Set;
                    this.enums = new Set;
                    this.constEnums = new Set;
                    this.classes = new Set;
                    this.exportOnlyBindings = new Set;
                }
            }
            class TypeScriptScopeHandler extends ScopeHandler {
                constructor(...e1){
                    super(...e1);
                    this.importsStack = [];
                }
                createScope(e1) {
                    this.importsStack.push(new Set);
                    return new TypeScriptScope(e1);
                }
                enter(e1) {
                    if (e1 == X) {
                        this.importsStack.push(new Set);
                    }
                    super.enter(e1);
                }
                exit() {
                    const e1 = super.exit();
                    if (e1 == X) {
                        this.importsStack.pop();
                    }
                    return e1;
                }
                hasImport(e1, t) {
                    const r = this.importsStack.length;
                    if (this.importsStack[r - 1].has(e1)) {
                        return true;
                    }
                    if (!t && r > 1) {
                        for(let t = 0; t < r - 1; t++){
                            if (this.importsStack[t].has(e1)) return true;
                        }
                    }
                    return false;
                }
                declareName(e1, t, r) {
                    if (t & le) {
                        if (this.hasImport(e1, true)) {
                            this.parser.raise(p.VarRedeclaration, {
                                at: r,
                                identifierName: e1
                            });
                        }
                        this.importsStack[this.importsStack.length - 1].add(e1);
                        return;
                    }
                    const n = this.currentScope();
                    if (t & ae) {
                        this.maybeExportDefined(n, e1);
                        n.exportOnlyBindings.add(e1);
                        return;
                    }
                    super.declareName(e1, t, r);
                    if (t & Q) {
                        if (!(t & Y)) {
                            this.checkRedeclarationInScope(n, e1, t, r);
                            this.maybeExportDefined(n, e1);
                        }
                        n.types.add(e1);
                    }
                    if (t & se) n.enums.add(e1);
                    if (t & ie) n.constEnums.add(e1);
                    if (t & ne) n.classes.add(e1);
                }
                isRedeclaredInScope(e1, t, r) {
                    if (e1.enums.has(t)) {
                        if (r & se) {
                            const n = !!(r & ie);
                            const s = e1.constEnums.has(t);
                            return n !== s;
                        }
                        return true;
                    }
                    if (r & ne && e1.classes.has(t)) {
                        if (e1.lexical.has(t)) {
                            return !!(r & Y);
                        } else {
                            return false;
                        }
                    }
                    if (r & Q && e1.types.has(t)) {
                        return true;
                    }
                    return super.isRedeclaredInScope(e1, t, r);
                }
                checkLocalExport(e1) {
                    const { name: t } = e1;
                    if (this.hasImport(t)) return;
                    const r = this.scopeStack.length;
                    for(let e1 = r - 1; e1 >= 0; e1--){
                        const r = this.scopeStack[e1];
                        if (r.types.has(t) || r.exportOnlyBindings.has(t)) return;
                    }
                    super.checkLocalExport(e1);
                }
            }
            const getOwn$1 = (e1, t)=>Object.hasOwnProperty.call(e1, t) && e1[t];
            const unwrapParenthesizedExpression = (e1)=>e1.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(e1.expression) : e1;
            class LValParser extends NodeUtils {
                toAssignable(e1, t = false) {
                    var r, n;
                    let s = undefined;
                    if (e1.type === "ParenthesizedExpression" || (r = e1.extra) != null && r.parenthesized) {
                        s = unwrapParenthesizedExpression(e1);
                        if (t) {
                            if (s.type === "Identifier") {
                                this.expressionScope.recordArrowParameterBindingError(p.InvalidParenthesizedAssignment, {
                                    at: e1
                                });
                            } else if (s.type !== "MemberExpression") {
                                this.raise(p.InvalidParenthesizedAssignment, {
                                    at: e1
                                });
                            }
                        } else {
                            this.raise(p.InvalidParenthesizedAssignment, {
                                at: e1
                            });
                        }
                    }
                    switch(e1.type){
                        case "Identifier":
                        case "ObjectPattern":
                        case "ArrayPattern":
                        case "AssignmentPattern":
                        case "RestElement":
                            break;
                        case "ObjectExpression":
                            e1.type = "ObjectPattern";
                            for(let r = 0, n = e1.properties.length, s = n - 1; r < n; r++){
                                var i;
                                const n = e1.properties[r];
                                const a = r === s;
                                this.toAssignableObjectExpressionProp(n, a, t);
                                if (a && n.type === "RestElement" && (i = e1.extra) != null && i.trailingCommaLoc) {
                                    this.raise(p.RestTrailingComma, {
                                        at: e1.extra.trailingCommaLoc
                                    });
                                }
                            }
                            break;
                        case "ObjectProperty":
                            {
                                const { key: r, value: n } = e1;
                                if (this.isPrivateName(r)) {
                                    this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start);
                                }
                                this.toAssignable(n, t);
                                break;
                            }
                        case "SpreadElement":
                            {
                                throw new Error("Internal @babel/parser error (this is a bug, please report it)." + " SpreadElement should be converted by .toAssignable's caller.");
                            }
                        case "ArrayExpression":
                            e1.type = "ArrayPattern";
                            this.toAssignableList(e1.elements, (n = e1.extra) == null ? void 0 : n.trailingCommaLoc, t);
                            break;
                        case "AssignmentExpression":
                            if (e1.operator !== "=") {
                                this.raise(p.MissingEqInAssignment, {
                                    at: e1.left.loc.end
                                });
                            }
                            e1.type = "AssignmentPattern";
                            delete e1.operator;
                            this.toAssignable(e1.left, t);
                            break;
                        case "ParenthesizedExpression":
                            this.toAssignable(s, t);
                            break;
                    }
                }
                toAssignableObjectExpressionProp(e1, t, r) {
                    if (e1.type === "ObjectMethod") {
                        this.raise(e1.kind === "get" || e1.kind === "set" ? p.PatternHasAccessor : p.PatternHasMethod, {
                            at: e1.key
                        });
                    } else if (e1.type === "SpreadElement") {
                        e1.type = "RestElement";
                        const n = e1.argument;
                        this.checkToRestConversion(n, false);
                        this.toAssignable(n, r);
                        if (!t) {
                            this.raise(p.RestTrailingComma, {
                                at: e1
                            });
                        }
                    } else {
                        this.toAssignable(e1, r);
                    }
                }
                toAssignableList(e1, t, r) {
                    const n = e1.length - 1;
                    for(let s = 0; s <= n; s++){
                        const i = e1[s];
                        if (!i) continue;
                        if (i.type === "SpreadElement") {
                            i.type = "RestElement";
                            const e1 = i.argument;
                            this.checkToRestConversion(e1, true);
                            this.toAssignable(e1, r);
                        } else {
                            this.toAssignable(i, r);
                        }
                        if (i.type === "RestElement") {
                            if (s < n) {
                                this.raise(p.RestTrailingComma, {
                                    at: i
                                });
                            } else if (t) {
                                this.raise(p.RestTrailingComma, {
                                    at: t
                                });
                            }
                        }
                    }
                }
                isAssignable(e1, t) {
                    switch(e1.type){
                        case "Identifier":
                        case "ObjectPattern":
                        case "ArrayPattern":
                        case "AssignmentPattern":
                        case "RestElement":
                            return true;
                        case "ObjectExpression":
                            {
                                const t = e1.properties.length - 1;
                                return e1.properties.every((e1, r)=>e1.type !== "ObjectMethod" && (r === t || e1.type !== "SpreadElement") && this.isAssignable(e1));
                            }
                        case "ObjectProperty":
                            return this.isAssignable(e1.value);
                        case "SpreadElement":
                            return this.isAssignable(e1.argument);
                        case "ArrayExpression":
                            return e1.elements.every((e1)=>e1 === null || this.isAssignable(e1));
                        case "AssignmentExpression":
                            return e1.operator === "=";
                        case "ParenthesizedExpression":
                            return this.isAssignable(e1.expression);
                        case "MemberExpression":
                        case "OptionalMemberExpression":
                            return !t;
                        default:
                            return false;
                    }
                }
                toReferencedList(e1, t) {
                    return e1;
                }
                toReferencedListDeep(e1, t) {
                    this.toReferencedList(e1, t);
                    for (const t of e1){
                        if ((t == null ? void 0 : t.type) === "ArrayExpression") {
                            this.toReferencedListDeep(t.elements);
                        }
                    }
                }
                parseSpread(e1) {
                    const t = this.startNode();
                    this.next();
                    t.argument = this.parseMaybeAssignAllowIn(e1, undefined);
                    return this.finishNode(t, "SpreadElement");
                }
                parseRestBinding() {
                    const e1 = this.startNode();
                    this.next();
                    e1.argument = this.parseBindingAtom();
                    return this.finishNode(e1, "RestElement");
                }
                parseBindingAtom() {
                    switch(this.state.type){
                        case 0:
                            {
                                const e1 = this.startNode();
                                this.next();
                                e1.elements = this.parseBindingList(3, 93, 1);
                                return this.finishNode(e1, "ArrayPattern");
                            }
                        case 5:
                            return this.parseObjectLike(8, true);
                    }
                    return this.parseIdentifier();
                }
                parseBindingList(e1, t, r) {
                    const n = r & 1;
                    const s = [];
                    let i = true;
                    while(!this.eat(e1)){
                        if (i) {
                            i = false;
                        } else {
                            this.expect(12);
                        }
                        if (n && this.match(12)) {
                            s.push(null);
                        } else if (this.eat(e1)) {
                            break;
                        } else if (this.match(21)) {
                            s.push(this.parseAssignableListItemTypes(this.parseRestBinding(), r));
                            if (!this.checkCommaAfterRest(t)) {
                                this.expect(e1);
                                break;
                            }
                        } else {
                            const e1 = [];
                            if (this.match(26) && this.hasPlugin("decorators")) {
                                this.raise(p.UnsupportedParameterDecorator, {
                                    at: this.state.startLoc
                                });
                            }
                            while(this.match(26)){
                                e1.push(this.parseDecorator());
                            }
                            s.push(this.parseAssignableListItem(r, e1));
                        }
                    }
                    return s;
                }
                parseBindingRestProperty(e1) {
                    this.next();
                    e1.argument = this.parseIdentifier();
                    this.checkCommaAfterRest(125);
                    return this.finishNode(e1, "RestElement");
                }
                parseBindingProperty() {
                    const e1 = this.startNode();
                    const { type: t, startLoc: r } = this.state;
                    if (t === 21) {
                        return this.parseBindingRestProperty(e1);
                    } else if (t === 136) {
                        this.expectPlugin("destructuringPrivate", r);
                        this.classScope.usePrivateName(this.state.value, r);
                        e1.key = this.parsePrivateName();
                    } else {
                        this.parsePropertyName(e1);
                    }
                    e1.method = false;
                    return this.parseObjPropValue(e1, r, false, false, true, false);
                }
                parseAssignableListItem(e1, t) {
                    const r = this.parseMaybeDefault();
                    this.parseAssignableListItemTypes(r, e1);
                    const n = this.parseMaybeDefault(r.loc.start, r);
                    if (t.length) {
                        r.decorators = t;
                    }
                    return n;
                }
                parseAssignableListItemTypes(e1, t) {
                    return e1;
                }
                parseMaybeDefault(e1, t) {
                    var r, n;
                    (r = e1) != null ? r : e1 = this.state.startLoc;
                    t = (n = t) != null ? n : this.parseBindingAtom();
                    if (!this.eat(29)) return t;
                    const s = this.startNodeAt(e1);
                    s.left = t;
                    s.right = this.parseMaybeAssignAllowIn();
                    return this.finishNode(s, "AssignmentPattern");
                }
                isValidLVal(e1, t, r) {
                    return getOwn$1({
                        AssignmentPattern: "left",
                        RestElement: "argument",
                        ObjectProperty: "value",
                        ParenthesizedExpression: "expression",
                        ArrayPattern: "elements",
                        ObjectPattern: "properties"
                    }, e1);
                }
                checkLVal(e1, { in: t, binding: r = Te, checkClashes: n = false, strictModeChanged: s = false, hasParenthesizedAncestor: i = false }) {
                    var a;
                    const o = e1.type;
                    if (this.isObjectMethod(e1)) return;
                    if (o === "MemberExpression") {
                        if (r !== Te) {
                            this.raise(p.InvalidPropertyBindingPattern, {
                                at: e1
                            });
                        }
                        return;
                    }
                    if (o === "Identifier") {
                        this.checkIdentifier(e1, r, s);
                        const { name: t } = e1;
                        if (n) {
                            if (n.has(t)) {
                                this.raise(p.ParamDupe, {
                                    at: e1
                                });
                            } else {
                                n.add(t);
                            }
                        }
                        return;
                    }
                    const l = this.isValidLVal(o, !(i || (a = e1.extra) != null && a.parenthesized) && t.type === "AssignmentExpression", r);
                    if (l === true) return;
                    if (l === false) {
                        const n = r === Te ? p.InvalidLhs : p.InvalidLhsBinding;
                        this.raise(n, {
                            at: e1,
                            ancestor: t
                        });
                        return;
                    }
                    const [c, u] = Array.isArray(l) ? l : [
                        l,
                        o === "ParenthesizedExpression"
                    ];
                    const f = o === "ArrayPattern" || o === "ObjectPattern" || o === "ParenthesizedExpression" ? {
                        type: o
                    } : t;
                    for (const t of [].concat(e1[c])){
                        if (t) {
                            this.checkLVal(t, {
                                in: f,
                                binding: r,
                                checkClashes: n,
                                strictModeChanged: s,
                                hasParenthesizedAncestor: u
                            });
                        }
                    }
                }
                checkIdentifier(e1, t, r = false) {
                    if (this.state.strict && (r ? isStrictBindReservedWord(e1.name, this.inModule) : isStrictBindOnlyReservedWord(e1.name))) {
                        if (t === Te) {
                            this.raise(p.StrictEvalArguments, {
                                at: e1,
                                referenceName: e1.name
                            });
                        } else {
                            this.raise(p.StrictEvalArgumentsBinding, {
                                at: e1,
                                bindingName: e1.name
                            });
                        }
                    }
                    if (t & ce && e1.name === "let") {
                        this.raise(p.LetInLexicalBinding, {
                            at: e1
                        });
                    }
                    if (!(t & Te)) {
                        this.declareNameFromIdentifier(e1, t);
                    }
                }
                declareNameFromIdentifier(e1, t) {
                    this.scope.declareName(e1.name, t, e1.loc.start);
                }
                checkToRestConversion(e1, t) {
                    switch(e1.type){
                        case "ParenthesizedExpression":
                            this.checkToRestConversion(e1.expression, t);
                            break;
                        case "Identifier":
                        case "MemberExpression":
                            break;
                        case "ArrayExpression":
                        case "ObjectExpression":
                            if (t) break;
                        default:
                            this.raise(p.InvalidRestAssignmentPattern, {
                                at: e1
                            });
                    }
                }
                checkCommaAfterRest(e1) {
                    if (!this.match(12)) {
                        return false;
                    }
                    this.raise(this.lookaheadCharCode() === e1 ? p.RestTrailingComma : p.ElementAfterRest, {
                        at: this.state.startLoc
                    });
                    return true;
                }
            }
            const getOwn = (e1, t)=>Object.hasOwnProperty.call(e1, t) && e1[t];
            function nonNull(e1) {
                if (e1 == null) {
                    throw new Error(`Unexpected ${e1} value.`);
                }
                return e1;
            }
            function assert(e1) {
                if (!e1) {
                    throw new Error("Assert fail");
                }
            }
            const ot = ParseErrorEnum`typescript`({
                AbstractMethodHasImplementation: ({ methodName: e1 })=>`Method '${e1}' cannot have an implementation because it is marked abstract.`,
                AbstractPropertyHasInitializer: ({ propertyName: e1 })=>`Property '${e1}' cannot have an initializer because it is marked abstract.`,
                AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
                AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
                AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
                ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
                ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
                ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
                ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
                DeclareAccessor: ({ kind: e1 })=>`'declare' is not allowed in ${e1}ters.`,
                DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
                DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
                DuplicateAccessibilityModifier: ({ modifier: e1 })=>`Accessibility modifier already seen.`,
                DuplicateModifier: ({ modifier: e1 })=>`Duplicate modifier: '${e1}'.`,
                EmptyHeritageClauseType: ({ token: e1 })=>`'${e1}' list cannot be empty.`,
                EmptyTypeArguments: "Type argument list cannot be empty.",
                EmptyTypeParameters: "Type parameter list cannot be empty.",
                ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
                ImportAliasHasImportType: "An import alias can not use 'import type'.",
                ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
                IncompatibleModifiers: ({ modifiers: e1 })=>`'${e1[0]}' modifier cannot be used with '${e1[1]}' modifier.`,
                IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
                IndexSignatureHasAccessibility: ({ modifier: e1 })=>`Index signatures cannot have an accessibility modifier ('${e1}').`,
                IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
                IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
                IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
                InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
                InvalidModifierOnTypeMember: ({ modifier: e1 })=>`'${e1}' modifier cannot appear on a type member.`,
                InvalidModifierOnTypeParameter: ({ modifier: e1 })=>`'${e1}' modifier cannot appear on a type parameter.`,
                InvalidModifierOnTypeParameterPositions: ({ modifier: e1 })=>`'${e1}' modifier can only appear on a type parameter of a class, interface or type alias.`,
                InvalidModifiersOrder: ({ orderedModifiers: e1 })=>`'${e1[0]}' modifier must precede '${e1[1]}' modifier.`,
                InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. " + "You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
                InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
                MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
                MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
                NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
                NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
                OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
                OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
                PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
                PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
                PrivateElementHasAccessibility: ({ modifier: e1 })=>`Private elements cannot have an accessibility modifier ('${e1}').`,
                ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
                ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
                ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
                SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
                SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
                SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
                SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: e1 })=>`Single type parameter ${e1} should have a trailing comma. Example usage: <${e1},>.`,
                StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
                TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
                TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
                TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
                TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
                TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
                UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
                UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
                UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
                UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
                UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
                UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
                UnsupportedSignatureParameterKind: ({ type: e1 })=>`Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e1}.`
            });
            function keywordTypeFromName(e1) {
                switch(e1){
                    case "any":
                        return "TSAnyKeyword";
                    case "boolean":
                        return "TSBooleanKeyword";
                    case "bigint":
                        return "TSBigIntKeyword";
                    case "never":
                        return "TSNeverKeyword";
                    case "number":
                        return "TSNumberKeyword";
                    case "object":
                        return "TSObjectKeyword";
                    case "string":
                        return "TSStringKeyword";
                    case "symbol":
                        return "TSSymbolKeyword";
                    case "undefined":
                        return "TSUndefinedKeyword";
                    case "unknown":
                        return "TSUnknownKeyword";
                    default:
                        return undefined;
                }
            }
            function tsIsAccessModifier(e1) {
                return e1 === "private" || e1 === "public" || e1 === "protected";
            }
            function tsIsVarianceAnnotations(e1) {
                return e1 === "in" || e1 === "out";
            }
            var typescript = (e1)=>class TypeScriptParserMixin extends e1 {
                    constructor(...e1){
                        super(...e1);
                        this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
                            allowedModifiers: [
                                "in",
                                "out"
                            ],
                            disallowedModifiers: [
                                "const",
                                "public",
                                "private",
                                "protected",
                                "readonly",
                                "declare",
                                "abstract",
                                "override"
                            ],
                            errorTemplate: ot.InvalidModifierOnTypeParameter
                        });
                        this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
                            allowedModifiers: [
                                "const"
                            ],
                            disallowedModifiers: [
                                "in",
                                "out"
                            ],
                            errorTemplate: ot.InvalidModifierOnTypeParameterPositions
                        });
                        this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
                            allowedModifiers: [
                                "in",
                                "out",
                                "const"
                            ],
                            disallowedModifiers: [
                                "public",
                                "private",
                                "protected",
                                "readonly",
                                "declare",
                                "abstract",
                                "override"
                            ],
                            errorTemplate: ot.InvalidModifierOnTypeParameter
                        });
                    }
                    getScopeHandler() {
                        return TypeScriptScopeHandler;
                    }
                    tsIsIdentifier() {
                        return tokenIsIdentifier(this.state.type);
                    }
                    tsTokenCanFollowModifier() {
                        return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
                    }
                    tsNextTokenCanFollowModifier() {
                        this.next();
                        return this.tsTokenCanFollowModifier();
                    }
                    tsParseModifier(e1, t) {
                        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
                            return undefined;
                        }
                        const r = this.state.value;
                        if (e1.indexOf(r) !== -1) {
                            if (t && this.tsIsStartOfStaticBlocks()) {
                                return undefined;
                            }
                            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
                                return r;
                            }
                        }
                        return undefined;
                    }
                    tsParseModifiers({ allowedModifiers: e1, disallowedModifiers: t, stopOnStartOfClassStaticBlock: r, errorTemplate: n = ot.InvalidModifierOnTypeMember }, s) {
                        const enforceOrder = (e1, t, r, n)=>{
                            if (t === r && s[n]) {
                                this.raise(ot.InvalidModifiersOrder, {
                                    at: e1,
                                    orderedModifiers: [
                                        r,
                                        n
                                    ]
                                });
                            }
                        };
                        const incompatible = (e1, t, r, n)=>{
                            if (s[r] && t === n || s[n] && t === r) {
                                this.raise(ot.IncompatibleModifiers, {
                                    at: e1,
                                    modifiers: [
                                        r,
                                        n
                                    ]
                                });
                            }
                        };
                        for(;;){
                            const { startLoc: i } = this.state;
                            const a = this.tsParseModifier(e1.concat(t != null ? t : []), r);
                            if (!a) break;
                            if (tsIsAccessModifier(a)) {
                                if (s.accessibility) {
                                    this.raise(ot.DuplicateAccessibilityModifier, {
                                        at: i,
                                        modifier: a
                                    });
                                } else {
                                    enforceOrder(i, a, a, "override");
                                    enforceOrder(i, a, a, "static");
                                    enforceOrder(i, a, a, "readonly");
                                    s.accessibility = a;
                                }
                            } else if (tsIsVarianceAnnotations(a)) {
                                if (s[a]) {
                                    this.raise(ot.DuplicateModifier, {
                                        at: i,
                                        modifier: a
                                    });
                                }
                                s[a] = true;
                                enforceOrder(i, a, "in", "out");
                            } else {
                                if (Object.hasOwnProperty.call(s, a)) {
                                    this.raise(ot.DuplicateModifier, {
                                        at: i,
                                        modifier: a
                                    });
                                } else {
                                    enforceOrder(i, a, "static", "readonly");
                                    enforceOrder(i, a, "static", "override");
                                    enforceOrder(i, a, "override", "readonly");
                                    enforceOrder(i, a, "abstract", "override");
                                    incompatible(i, a, "declare", "override");
                                    incompatible(i, a, "static", "abstract");
                                }
                                s[a] = true;
                            }
                            if (t != null && t.includes(a)) {
                                this.raise(n, {
                                    at: i,
                                    modifier: a
                                });
                            }
                        }
                    }
                    tsIsListTerminator(e1) {
                        switch(e1){
                            case "EnumMembers":
                            case "TypeMembers":
                                return this.match(8);
                            case "HeritageClauseElement":
                                return this.match(5);
                            case "TupleElementTypes":
                                return this.match(3);
                            case "TypeParametersOrArguments":
                                return this.match(48);
                        }
                    }
                    tsParseList(e1, t) {
                        const r = [];
                        while(!this.tsIsListTerminator(e1)){
                            r.push(t());
                        }
                        return r;
                    }
                    tsParseDelimitedList(e1, t, r) {
                        return nonNull(this.tsParseDelimitedListWorker(e1, t, true, r));
                    }
                    tsParseDelimitedListWorker(e1, t, r, n) {
                        const s = [];
                        let i = -1;
                        for(;;){
                            if (this.tsIsListTerminator(e1)) {
                                break;
                            }
                            i = -1;
                            const n = t();
                            if (n == null) {
                                return undefined;
                            }
                            s.push(n);
                            if (this.eat(12)) {
                                i = this.state.lastTokStart;
                                continue;
                            }
                            if (this.tsIsListTerminator(e1)) {
                                break;
                            }
                            if (r) {
                                this.expect(12);
                            }
                            return undefined;
                        }
                        if (n) {
                            n.value = i;
                        }
                        return s;
                    }
                    tsParseBracketedList(e1, t, r, n, s) {
                        if (!n) {
                            if (r) {
                                this.expect(0);
                            } else {
                                this.expect(47);
                            }
                        }
                        const i = this.tsParseDelimitedList(e1, t, s);
                        if (r) {
                            this.expect(3);
                        } else {
                            this.expect(48);
                        }
                        return i;
                    }
                    tsParseImportType() {
                        const e1 = this.startNode();
                        this.expect(83);
                        this.expect(10);
                        if (!this.match(131)) {
                            this.raise(ot.UnsupportedImportTypeArgument, {
                                at: this.state.startLoc
                            });
                        }
                        e1.argument = super.parseExprAtom();
                        this.expect(11);
                        if (this.eat(16)) {
                            e1.qualifier = this.tsParseEntityName();
                        }
                        if (this.match(47)) {
                            e1.typeParameters = this.tsParseTypeArguments();
                        }
                        return this.finishNode(e1, "TSImportType");
                    }
                    tsParseEntityName(e1 = true) {
                        let t = this.parseIdentifier(e1);
                        while(this.eat(16)){
                            const r = this.startNodeAtNode(t);
                            r.left = t;
                            r.right = this.parseIdentifier(e1);
                            t = this.finishNode(r, "TSQualifiedName");
                        }
                        return t;
                    }
                    tsParseTypeReference() {
                        const e1 = this.startNode();
                        e1.typeName = this.tsParseEntityName();
                        if (!this.hasPrecedingLineBreak() && this.match(47)) {
                            e1.typeParameters = this.tsParseTypeArguments();
                        }
                        return this.finishNode(e1, "TSTypeReference");
                    }
                    tsParseThisTypePredicate(e1) {
                        this.next();
                        const t = this.startNodeAtNode(e1);
                        t.parameterName = e1;
                        t.typeAnnotation = this.tsParseTypeAnnotation(false);
                        t.asserts = false;
                        return this.finishNode(t, "TSTypePredicate");
                    }
                    tsParseThisTypeNode() {
                        const e1 = this.startNode();
                        this.next();
                        return this.finishNode(e1, "TSThisType");
                    }
                    tsParseTypeQuery() {
                        const e1 = this.startNode();
                        this.expect(87);
                        if (this.match(83)) {
                            e1.exprName = this.tsParseImportType();
                        } else {
                            e1.exprName = this.tsParseEntityName();
                        }
                        if (!this.hasPrecedingLineBreak() && this.match(47)) {
                            e1.typeParameters = this.tsParseTypeArguments();
                        }
                        return this.finishNode(e1, "TSTypeQuery");
                    }
                    tsParseTypeParameter(e1) {
                        const t = this.startNode();
                        e1(t);
                        t.name = this.tsParseTypeParameterName();
                        t.constraint = this.tsEatThenParseType(81);
                        t.default = this.tsEatThenParseType(29);
                        return this.finishNode(t, "TSTypeParameter");
                    }
                    tsTryParseTypeParameters(e1) {
                        if (this.match(47)) {
                            return this.tsParseTypeParameters(e1);
                        }
                    }
                    tsParseTypeParameters(e1) {
                        const t = this.startNode();
                        if (this.match(47) || this.match(140)) {
                            this.next();
                        } else {
                            this.unexpected();
                        }
                        const r = {
                            value: -1
                        };
                        t.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e1), false, true, r);
                        if (t.params.length === 0) {
                            this.raise(ot.EmptyTypeParameters, {
                                at: t
                            });
                        }
                        if (r.value !== -1) {
                            this.addExtra(t, "trailingComma", r.value);
                        }
                        return this.finishNode(t, "TSTypeParameterDeclaration");
                    }
                    tsFillSignature(e1, t) {
                        const r = e1 === 19;
                        const n = "parameters";
                        const s = "typeAnnotation";
                        t.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                        this.expect(10);
                        t[n] = this.tsParseBindingListForSignature();
                        if (r) {
                            t[s] = this.tsParseTypeOrTypePredicateAnnotation(e1);
                        } else if (this.match(e1)) {
                            t[s] = this.tsParseTypeOrTypePredicateAnnotation(e1);
                        }
                    }
                    tsParseBindingListForSignature() {
                        const e1 = super.parseBindingList(11, 41, 2);
                        for (const t of e1){
                            const { type: e1 } = t;
                            if (e1 === "AssignmentPattern" || e1 === "TSParameterProperty") {
                                this.raise(ot.UnsupportedSignatureParameterKind, {
                                    at: t,
                                    type: e1
                                });
                            }
                        }
                        return e1;
                    }
                    tsParseTypeMemberSemicolon() {
                        if (!this.eat(12) && !this.isLineTerminator()) {
                            this.expect(13);
                        }
                    }
                    tsParseSignatureMember(e1, t) {
                        this.tsFillSignature(14, t);
                        this.tsParseTypeMemberSemicolon();
                        return this.finishNode(t, e1);
                    }
                    tsIsUnambiguouslyIndexSignature() {
                        this.next();
                        if (tokenIsIdentifier(this.state.type)) {
                            this.next();
                            return this.match(14);
                        }
                        return false;
                    }
                    tsTryParseIndexSignature(e1) {
                        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
                            return;
                        }
                        this.expect(0);
                        const t = this.parseIdentifier();
                        t.typeAnnotation = this.tsParseTypeAnnotation();
                        this.resetEndLocation(t);
                        this.expect(3);
                        e1.parameters = [
                            t
                        ];
                        const r = this.tsTryParseTypeAnnotation();
                        if (r) e1.typeAnnotation = r;
                        this.tsParseTypeMemberSemicolon();
                        return this.finishNode(e1, "TSIndexSignature");
                    }
                    tsParsePropertyOrMethodSignature(e1, t) {
                        if (this.eat(17)) e1.optional = true;
                        const r = e1;
                        if (this.match(10) || this.match(47)) {
                            if (t) {
                                this.raise(ot.ReadonlyForMethodSignature, {
                                    at: e1
                                });
                            }
                            const n = r;
                            if (n.kind && this.match(47)) {
                                this.raise(ot.AccesorCannotHaveTypeParameters, {
                                    at: this.state.curPosition()
                                });
                            }
                            this.tsFillSignature(14, n);
                            this.tsParseTypeMemberSemicolon();
                            const s = "parameters";
                            const i = "typeAnnotation";
                            if (n.kind === "get") {
                                if (n[s].length > 0) {
                                    this.raise(p.BadGetterArity, {
                                        at: this.state.curPosition()
                                    });
                                    if (this.isThisParam(n[s][0])) {
                                        this.raise(ot.AccesorCannotDeclareThisParameter, {
                                            at: this.state.curPosition()
                                        });
                                    }
                                }
                            } else if (n.kind === "set") {
                                if (n[s].length !== 1) {
                                    this.raise(p.BadSetterArity, {
                                        at: this.state.curPosition()
                                    });
                                } else {
                                    const e1 = n[s][0];
                                    if (this.isThisParam(e1)) {
                                        this.raise(ot.AccesorCannotDeclareThisParameter, {
                                            at: this.state.curPosition()
                                        });
                                    }
                                    if (e1.type === "Identifier" && e1.optional) {
                                        this.raise(ot.SetAccesorCannotHaveOptionalParameter, {
                                            at: this.state.curPosition()
                                        });
                                    }
                                    if (e1.type === "RestElement") {
                                        this.raise(ot.SetAccesorCannotHaveRestParameter, {
                                            at: this.state.curPosition()
                                        });
                                    }
                                }
                                if (n[i]) {
                                    this.raise(ot.SetAccesorCannotHaveReturnType, {
                                        at: n[i]
                                    });
                                }
                            } else {
                                n.kind = "method";
                            }
                            return this.finishNode(n, "TSMethodSignature");
                        } else {
                            const e1 = r;
                            if (t) e1.readonly = true;
                            const n = this.tsTryParseTypeAnnotation();
                            if (n) e1.typeAnnotation = n;
                            this.tsParseTypeMemberSemicolon();
                            return this.finishNode(e1, "TSPropertySignature");
                        }
                    }
                    tsParseTypeMember() {
                        const e1 = this.startNode();
                        if (this.match(10) || this.match(47)) {
                            return this.tsParseSignatureMember("TSCallSignatureDeclaration", e1);
                        }
                        if (this.match(77)) {
                            const t = this.startNode();
                            this.next();
                            if (this.match(10) || this.match(47)) {
                                return this.tsParseSignatureMember("TSConstructSignatureDeclaration", e1);
                            } else {
                                e1.key = this.createIdentifier(t, "new");
                                return this.tsParsePropertyOrMethodSignature(e1, false);
                            }
                        }
                        this.tsParseModifiers({
                            allowedModifiers: [
                                "readonly"
                            ],
                            disallowedModifiers: [
                                "declare",
                                "abstract",
                                "private",
                                "protected",
                                "public",
                                "static",
                                "override"
                            ]
                        }, e1);
                        const t = this.tsTryParseIndexSignature(e1);
                        if (t) {
                            return t;
                        }
                        super.parsePropertyName(e1);
                        if (!e1.computed && e1.key.type === "Identifier" && (e1.key.name === "get" || e1.key.name === "set") && this.tsTokenCanFollowModifier()) {
                            e1.kind = e1.key.name;
                            super.parsePropertyName(e1);
                        }
                        return this.tsParsePropertyOrMethodSignature(e1, !!e1.readonly);
                    }
                    tsParseTypeLiteral() {
                        const e1 = this.startNode();
                        e1.members = this.tsParseObjectTypeMembers();
                        return this.finishNode(e1, "TSTypeLiteral");
                    }
                    tsParseObjectTypeMembers() {
                        this.expect(5);
                        const e1 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
                        this.expect(8);
                        return e1;
                    }
                    tsIsStartOfMappedType() {
                        this.next();
                        if (this.eat(53)) {
                            return this.isContextual(120);
                        }
                        if (this.isContextual(120)) {
                            this.next();
                        }
                        if (!this.match(0)) {
                            return false;
                        }
                        this.next();
                        if (!this.tsIsIdentifier()) {
                            return false;
                        }
                        this.next();
                        return this.match(58);
                    }
                    tsParseMappedTypeParameter() {
                        const e1 = this.startNode();
                        e1.name = this.tsParseTypeParameterName();
                        e1.constraint = this.tsExpectThenParseType(58);
                        return this.finishNode(e1, "TSTypeParameter");
                    }
                    tsParseMappedType() {
                        const e1 = this.startNode();
                        this.expect(5);
                        if (this.match(53)) {
                            e1.readonly = this.state.value;
                            this.next();
                            this.expectContextual(120);
                        } else if (this.eatContextual(120)) {
                            e1.readonly = true;
                        }
                        this.expect(0);
                        e1.typeParameter = this.tsParseMappedTypeParameter();
                        e1.nameType = this.eatContextual(93) ? this.tsParseType() : null;
                        this.expect(3);
                        if (this.match(53)) {
                            e1.optional = this.state.value;
                            this.next();
                            this.expect(17);
                        } else if (this.eat(17)) {
                            e1.optional = true;
                        }
                        e1.typeAnnotation = this.tsTryParseType();
                        this.semicolon();
                        this.expect(8);
                        return this.finishNode(e1, "TSMappedType");
                    }
                    tsParseTupleType() {
                        const e1 = this.startNode();
                        e1.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
                        let t = false;
                        let r = null;
                        e1.elementTypes.forEach((e1)=>{
                            var n;
                            const { type: s } = e1;
                            if (t && s !== "TSRestType" && s !== "TSOptionalType" && !(s === "TSNamedTupleMember" && e1.optional)) {
                                this.raise(ot.OptionalTypeBeforeRequired, {
                                    at: e1
                                });
                            }
                            t || (t = s === "TSNamedTupleMember" && e1.optional || s === "TSOptionalType");
                            let i = s;
                            if (s === "TSRestType") {
                                e1 = e1.typeAnnotation;
                                i = e1.type;
                            }
                            const a = i === "TSNamedTupleMember";
                            (n = r) != null ? n : r = a;
                            if (r !== a) {
                                this.raise(ot.MixedLabeledAndUnlabeledElements, {
                                    at: e1
                                });
                            }
                        });
                        return this.finishNode(e1, "TSTupleType");
                    }
                    tsParseTupleElementType() {
                        const { startLoc: e1 } = this.state;
                        const t = this.eat(21);
                        let r;
                        let n;
                        let s;
                        let i;
                        const a = tokenIsKeywordOrIdentifier(this.state.type);
                        const o = a ? this.lookaheadCharCode() : null;
                        if (o === 58) {
                            r = true;
                            s = false;
                            n = this.parseIdentifier(true);
                            this.expect(14);
                            i = this.tsParseType();
                        } else if (o === 63) {
                            s = true;
                            const e1 = this.state.startLoc;
                            const t = this.state.value;
                            const a = this.tsParseNonArrayType();
                            if (this.lookaheadCharCode() === 58) {
                                r = true;
                                n = this.createIdentifier(this.startNodeAt(e1), t);
                                this.expect(17);
                                this.expect(14);
                                i = this.tsParseType();
                            } else {
                                r = false;
                                i = a;
                                this.expect(17);
                            }
                        } else {
                            i = this.tsParseType();
                            s = this.eat(17);
                            r = this.eat(14);
                        }
                        if (r) {
                            let e1;
                            if (n) {
                                e1 = this.startNodeAtNode(n);
                                e1.optional = s;
                                e1.label = n;
                                e1.elementType = i;
                                if (this.eat(17)) {
                                    e1.optional = true;
                                    this.raise(ot.TupleOptionalAfterType, {
                                        at: this.state.lastTokStartLoc
                                    });
                                }
                            } else {
                                e1 = this.startNodeAtNode(i);
                                e1.optional = s;
                                this.raise(ot.InvalidTupleMemberLabel, {
                                    at: i
                                });
                                e1.label = i;
                                e1.elementType = this.tsParseType();
                            }
                            i = this.finishNode(e1, "TSNamedTupleMember");
                        } else if (s) {
                            const e1 = this.startNodeAtNode(i);
                            e1.typeAnnotation = i;
                            i = this.finishNode(e1, "TSOptionalType");
                        }
                        if (t) {
                            const t = this.startNodeAt(e1);
                            t.typeAnnotation = i;
                            i = this.finishNode(t, "TSRestType");
                        }
                        return i;
                    }
                    tsParseParenthesizedType() {
                        const e1 = this.startNode();
                        this.expect(10);
                        e1.typeAnnotation = this.tsParseType();
                        this.expect(11);
                        return this.finishNode(e1, "TSParenthesizedType");
                    }
                    tsParseFunctionOrConstructorType(e1, t) {
                        const r = this.startNode();
                        if (e1 === "TSConstructorType") {
                            r.abstract = !!t;
                            if (t) this.next();
                            this.next();
                        }
                        this.tsInAllowConditionalTypesContext(()=>this.tsFillSignature(19, r));
                        return this.finishNode(r, e1);
                    }
                    tsParseLiteralTypeNode() {
                        const e1 = this.startNode();
                        switch(this.state.type){
                            case 132:
                            case 133:
                            case 131:
                            case 85:
                            case 86:
                                e1.literal = super.parseExprAtom();
                                break;
                            default:
                                this.unexpected();
                        }
                        return this.finishNode(e1, "TSLiteralType");
                    }
                    tsParseTemplateLiteralType() {
                        const e1 = this.startNode();
                        e1.literal = super.parseTemplate(false);
                        return this.finishNode(e1, "TSLiteralType");
                    }
                    parseTemplateSubstitution() {
                        if (this.state.inType) return this.tsParseType();
                        return super.parseTemplateSubstitution();
                    }
                    tsParseThisTypeOrThisTypePredicate() {
                        const e1 = this.tsParseThisTypeNode();
                        if (this.isContextual(114) && !this.hasPrecedingLineBreak()) {
                            return this.tsParseThisTypePredicate(e1);
                        } else {
                            return e1;
                        }
                    }
                    tsParseNonArrayType() {
                        switch(this.state.type){
                            case 131:
                            case 132:
                            case 133:
                            case 85:
                            case 86:
                                return this.tsParseLiteralTypeNode();
                            case 53:
                                if (this.state.value === "-") {
                                    const e1 = this.startNode();
                                    const t = this.lookahead();
                                    if (t.type !== 132 && t.type !== 133) {
                                        this.unexpected();
                                    }
                                    e1.literal = this.parseMaybeUnary();
                                    return this.finishNode(e1, "TSLiteralType");
                                }
                                break;
                            case 78:
                                return this.tsParseThisTypeOrThisTypePredicate();
                            case 87:
                                return this.tsParseTypeQuery();
                            case 83:
                                return this.tsParseImportType();
                            case 5:
                                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                            case 0:
                                return this.tsParseTupleType();
                            case 10:
                                return this.tsParseParenthesizedType();
                            case 25:
                            case 24:
                                return this.tsParseTemplateLiteralType();
                            default:
                                {
                                    const { type: e1 } = this.state;
                                    if (tokenIsIdentifier(e1) || e1 === 88 || e1 === 84) {
                                        const t = e1 === 88 ? "TSVoidKeyword" : e1 === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
                                        if (t !== undefined && this.lookaheadCharCode() !== 46) {
                                            const e1 = this.startNode();
                                            this.next();
                                            return this.finishNode(e1, t);
                                        }
                                        return this.tsParseTypeReference();
                                    }
                                }
                        }
                        this.unexpected();
                    }
                    tsParseArrayTypeOrHigher() {
                        let e1 = this.tsParseNonArrayType();
                        while(!this.hasPrecedingLineBreak() && this.eat(0)){
                            if (this.match(3)) {
                                const t = this.startNodeAtNode(e1);
                                t.elementType = e1;
                                this.expect(3);
                                e1 = this.finishNode(t, "TSArrayType");
                            } else {
                                const t = this.startNodeAtNode(e1);
                                t.objectType = e1;
                                t.indexType = this.tsParseType();
                                this.expect(3);
                                e1 = this.finishNode(t, "TSIndexedAccessType");
                            }
                        }
                        return e1;
                    }
                    tsParseTypeOperator() {
                        const e1 = this.startNode();
                        const t = this.state.value;
                        this.next();
                        e1.operator = t;
                        e1.typeAnnotation = this.tsParseTypeOperatorOrHigher();
                        if (t === "readonly") {
                            this.tsCheckTypeAnnotationForReadOnly(e1);
                        }
                        return this.finishNode(e1, "TSTypeOperator");
                    }
                    tsCheckTypeAnnotationForReadOnly(e1) {
                        switch(e1.typeAnnotation.type){
                            case "TSTupleType":
                            case "TSArrayType":
                                return;
                            default:
                                this.raise(ot.UnexpectedReadonly, {
                                    at: e1
                                });
                        }
                    }
                    tsParseInferType() {
                        const e1 = this.startNode();
                        this.expectContextual(113);
                        const t = this.startNode();
                        t.name = this.tsParseTypeParameterName();
                        t.constraint = this.tsTryParse(()=>this.tsParseConstraintForInferType());
                        e1.typeParameter = this.finishNode(t, "TSTypeParameter");
                        return this.finishNode(e1, "TSInferType");
                    }
                    tsParseConstraintForInferType() {
                        if (this.eat(81)) {
                            const e1 = this.tsInDisallowConditionalTypesContext(()=>this.tsParseType());
                            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
                                return e1;
                            }
                        }
                    }
                    tsParseTypeOperatorOrHigher() {
                        const e1 = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
                        return e1 ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(()=>this.tsParseArrayTypeOrHigher());
                    }
                    tsParseUnionOrIntersectionType(e1, t, r) {
                        const n = this.startNode();
                        const s = this.eat(r);
                        const i = [];
                        do {
                            i.push(t());
                        }while (this.eat(r))
                        if (i.length === 1 && !s) {
                            return i[0];
                        }
                        n.types = i;
                        return this.finishNode(n, e1);
                    }
                    tsParseIntersectionTypeOrHigher() {
                        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
                    }
                    tsParseUnionTypeOrHigher() {
                        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
                    }
                    tsIsStartOfFunctionType() {
                        if (this.match(47)) {
                            return true;
                        }
                        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
                    }
                    tsSkipParameterStart() {
                        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                            this.next();
                            return true;
                        }
                        if (this.match(5)) {
                            const { errors: e1 } = this.state;
                            const t = e1.length;
                            try {
                                this.parseObjectLike(8, true);
                                return e1.length === t;
                            } catch (e1) {
                                return false;
                            }
                        }
                        if (this.match(0)) {
                            this.next();
                            const { errors: e1 } = this.state;
                            const t = e1.length;
                            try {
                                super.parseBindingList(3, 93, 1);
                                return e1.length === t;
                            } catch (e1) {
                                return false;
                            }
                        }
                        return false;
                    }
                    tsIsUnambiguouslyStartOfFunctionType() {
                        this.next();
                        if (this.match(11) || this.match(21)) {
                            return true;
                        }
                        if (this.tsSkipParameterStart()) {
                            if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
                                return true;
                            }
                            if (this.match(11)) {
                                this.next();
                                if (this.match(19)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                    tsParseTypeOrTypePredicateAnnotation(e1) {
                        return this.tsInType(()=>{
                            const t = this.startNode();
                            this.expect(e1);
                            const r = this.startNode();
                            const n = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                            if (n && this.match(78)) {
                                let e1 = this.tsParseThisTypeOrThisTypePredicate();
                                if (e1.type === "TSThisType") {
                                    r.parameterName = e1;
                                    r.asserts = true;
                                    r.typeAnnotation = null;
                                    e1 = this.finishNode(r, "TSTypePredicate");
                                } else {
                                    this.resetStartLocationFromNode(e1, r);
                                    e1.asserts = true;
                                }
                                t.typeAnnotation = e1;
                                return this.finishNode(t, "TSTypeAnnotation");
                            }
                            const s = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                            if (!s) {
                                if (!n) {
                                    return this.tsParseTypeAnnotation(false, t);
                                }
                                r.parameterName = this.parseIdentifier();
                                r.asserts = n;
                                r.typeAnnotation = null;
                                t.typeAnnotation = this.finishNode(r, "TSTypePredicate");
                                return this.finishNode(t, "TSTypeAnnotation");
                            }
                            const i = this.tsParseTypeAnnotation(false);
                            r.parameterName = s;
                            r.typeAnnotation = i;
                            r.asserts = n;
                            t.typeAnnotation = this.finishNode(r, "TSTypePredicate");
                            return this.finishNode(t, "TSTypeAnnotation");
                        });
                    }
                    tsTryParseTypeOrTypePredicateAnnotation() {
                        if (this.match(14)) {
                            return this.tsParseTypeOrTypePredicateAnnotation(14);
                        }
                    }
                    tsTryParseTypeAnnotation() {
                        if (this.match(14)) {
                            return this.tsParseTypeAnnotation();
                        }
                    }
                    tsTryParseType() {
                        return this.tsEatThenParseType(14);
                    }
                    tsParseTypePredicatePrefix() {
                        const e1 = this.parseIdentifier();
                        if (this.isContextual(114) && !this.hasPrecedingLineBreak()) {
                            this.next();
                            return e1;
                        }
                    }
                    tsParseTypePredicateAsserts() {
                        if (this.state.type !== 107) {
                            return false;
                        }
                        const e1 = this.state.containsEsc;
                        this.next();
                        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
                            return false;
                        }
                        if (e1) {
                            this.raise(p.InvalidEscapedReservedWord, {
                                at: this.state.lastTokStartLoc,
                                reservedWord: "asserts"
                            });
                        }
                        return true;
                    }
                    tsParseTypeAnnotation(e1 = true, t = this.startNode()) {
                        this.tsInType(()=>{
                            if (e1) this.expect(14);
                            t.typeAnnotation = this.tsParseType();
                        });
                        return this.finishNode(t, "TSTypeAnnotation");
                    }
                    tsParseType() {
                        assert(this.state.inType);
                        const e1 = this.tsParseNonConditionalType();
                        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
                            return e1;
                        }
                        const t = this.startNodeAtNode(e1);
                        t.checkType = e1;
                        t.extendsType = this.tsInDisallowConditionalTypesContext(()=>this.tsParseNonConditionalType());
                        this.expect(17);
                        t.trueType = this.tsInAllowConditionalTypesContext(()=>this.tsParseType());
                        this.expect(14);
                        t.falseType = this.tsInAllowConditionalTypesContext(()=>this.tsParseType());
                        return this.finishNode(t, "TSConditionalType");
                    }
                    isAbstractConstructorSignature() {
                        return this.isContextual(122) && this.lookahead().type === 77;
                    }
                    tsParseNonConditionalType() {
                        if (this.tsIsStartOfFunctionType()) {
                            return this.tsParseFunctionOrConstructorType("TSFunctionType");
                        }
                        if (this.match(77)) {
                            return this.tsParseFunctionOrConstructorType("TSConstructorType");
                        } else if (this.isAbstractConstructorSignature()) {
                            return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
                        }
                        return this.tsParseUnionTypeOrHigher();
                    }
                    tsParseTypeAssertion() {
                        if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
                            this.raise(ot.ReservedTypeAssertion, {
                                at: this.state.startLoc
                            });
                        }
                        const e1 = this.startNode();
                        e1.typeAnnotation = this.tsInType(()=>{
                            this.next();
                            return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
                        });
                        this.expect(48);
                        e1.expression = this.parseMaybeUnary();
                        return this.finishNode(e1, "TSTypeAssertion");
                    }
                    tsParseHeritageClause(e1) {
                        const t = this.state.startLoc;
                        const r = this.tsParseDelimitedList("HeritageClauseElement", ()=>{
                            const e1 = this.startNode();
                            e1.expression = this.tsParseEntityName();
                            if (this.match(47)) {
                                e1.typeParameters = this.tsParseTypeArguments();
                            }
                            return this.finishNode(e1, "TSExpressionWithTypeArguments");
                        });
                        if (!r.length) {
                            this.raise(ot.EmptyHeritageClauseType, {
                                at: t,
                                token: e1
                            });
                        }
                        return r;
                    }
                    tsParseInterfaceDeclaration(e1, t = {}) {
                        if (this.hasFollowingLineBreak()) return null;
                        this.expectContextual(127);
                        if (t.declare) e1.declare = true;
                        if (tokenIsIdentifier(this.state.type)) {
                            e1.id = this.parseIdentifier();
                            this.checkIdentifier(e1.id, me);
                        } else {
                            e1.id = null;
                            this.raise(ot.MissingInterfaceName, {
                                at: this.state.startLoc
                            });
                        }
                        e1.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
                        if (this.eat(81)) {
                            e1.extends = this.tsParseHeritageClause("extends");
                        }
                        const r = this.startNode();
                        r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
                        e1.body = this.finishNode(r, "TSInterfaceBody");
                        return this.finishNode(e1, "TSInterfaceDeclaration");
                    }
                    tsParseTypeAliasDeclaration(e1) {
                        e1.id = this.parseIdentifier();
                        this.checkIdentifier(e1.id, ye);
                        e1.typeAnnotation = this.tsInType(()=>{
                            e1.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
                            this.expect(29);
                            if (this.isContextual(112) && this.lookahead().type !== 16) {
                                const e1 = this.startNode();
                                this.next();
                                return this.finishNode(e1, "TSIntrinsicKeyword");
                            }
                            return this.tsParseType();
                        });
                        this.semicolon();
                        return this.finishNode(e1, "TSTypeAliasDeclaration");
                    }
                    tsInNoContext(e1) {
                        const t = this.state.context;
                        this.state.context = [
                            t[0]
                        ];
                        try {
                            return e1();
                        } finally{
                            this.state.context = t;
                        }
                    }
                    tsInType(e1) {
                        const t = this.state.inType;
                        this.state.inType = true;
                        try {
                            return e1();
                        } finally{
                            this.state.inType = t;
                        }
                    }
                    tsInDisallowConditionalTypesContext(e1) {
                        const t = this.state.inDisallowConditionalTypesContext;
                        this.state.inDisallowConditionalTypesContext = true;
                        try {
                            return e1();
                        } finally{
                            this.state.inDisallowConditionalTypesContext = t;
                        }
                    }
                    tsInAllowConditionalTypesContext(e1) {
                        const t = this.state.inDisallowConditionalTypesContext;
                        this.state.inDisallowConditionalTypesContext = false;
                        try {
                            return e1();
                        } finally{
                            this.state.inDisallowConditionalTypesContext = t;
                        }
                    }
                    tsEatThenParseType(e1) {
                        if (this.match(e1)) {
                            return this.tsNextThenParseType();
                        }
                    }
                    tsExpectThenParseType(e1) {
                        return this.tsInType(()=>{
                            this.expect(e1);
                            return this.tsParseType();
                        });
                    }
                    tsNextThenParseType() {
                        return this.tsInType(()=>{
                            this.next();
                            return this.tsParseType();
                        });
                    }
                    tsParseEnumMember() {
                        const e1 = this.startNode();
                        e1.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
                        if (this.eat(29)) {
                            e1.initializer = super.parseMaybeAssignAllowIn();
                        }
                        return this.finishNode(e1, "TSEnumMember");
                    }
                    tsParseEnumDeclaration(e1, t = {}) {
                        if (t.const) e1.const = true;
                        if (t.declare) e1.declare = true;
                        this.expectContextual(124);
                        e1.id = this.parseIdentifier();
                        this.checkIdentifier(e1.id, e1.const ? Ee : ge);
                        this.expect(5);
                        e1.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
                        this.expect(8);
                        return this.finishNode(e1, "TSEnumDeclaration");
                    }
                    tsParseModuleBlock() {
                        const e1 = this.startNode();
                        this.scope.enter(U);
                        this.expect(5);
                        super.parseBlockOrModuleBlockBody(e1.body = [], undefined, true, 8);
                        this.scope.exit();
                        return this.finishNode(e1, "TSModuleBlock");
                    }
                    tsParseModuleOrNamespaceDeclaration(e1, t = false) {
                        e1.id = this.parseIdentifier();
                        if (!t) {
                            this.checkIdentifier(e1.id, ve);
                        }
                        if (this.eat(16)) {
                            const t = this.startNode();
                            this.tsParseModuleOrNamespaceDeclaration(t, true);
                            e1.body = t;
                        } else {
                            this.scope.enter(X);
                            this.prodParam.enter(Xe);
                            e1.body = this.tsParseModuleBlock();
                            this.prodParam.exit();
                            this.scope.exit();
                        }
                        return this.finishNode(e1, "TSModuleDeclaration");
                    }
                    tsParseAmbientExternalModuleDeclaration(e1) {
                        if (this.isContextual(110)) {
                            e1.global = true;
                            e1.id = this.parseIdentifier();
                        } else if (this.match(131)) {
                            e1.id = super.parseStringLiteral(this.state.value);
                        } else {
                            this.unexpected();
                        }
                        if (this.match(5)) {
                            this.scope.enter(X);
                            this.prodParam.enter(Xe);
                            e1.body = this.tsParseModuleBlock();
                            this.prodParam.exit();
                            this.scope.exit();
                        } else {
                            this.semicolon();
                        }
                        return this.finishNode(e1, "TSModuleDeclaration");
                    }
                    tsParseImportEqualsDeclaration(e1, t, r) {
                        e1.isExport = r || false;
                        e1.id = t || this.parseIdentifier();
                        this.checkIdentifier(e1.id, le);
                        this.expect(29);
                        const n = this.tsParseModuleReference();
                        if (e1.importKind === "type" && n.type !== "TSExternalModuleReference") {
                            this.raise(ot.ImportAliasHasImportType, {
                                at: n
                            });
                        }
                        e1.moduleReference = n;
                        this.semicolon();
                        return this.finishNode(e1, "TSImportEqualsDeclaration");
                    }
                    tsIsExternalModuleReference() {
                        return this.isContextual(117) && this.lookaheadCharCode() === 40;
                    }
                    tsParseModuleReference() {
                        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
                    }
                    tsParseExternalModuleReference() {
                        const e1 = this.startNode();
                        this.expectContextual(117);
                        this.expect(10);
                        if (!this.match(131)) {
                            this.unexpected();
                        }
                        e1.expression = super.parseExprAtom();
                        this.expect(11);
                        this.sawUnambiguousESM = true;
                        return this.finishNode(e1, "TSExternalModuleReference");
                    }
                    tsLookAhead(e1) {
                        const t = this.state.clone();
                        const r = e1();
                        this.state = t;
                        return r;
                    }
                    tsTryParseAndCatch(e1) {
                        const t = this.tryParse((t)=>e1() || t());
                        if (t.aborted || !t.node) return;
                        if (t.error) this.state = t.failState;
                        return t.node;
                    }
                    tsTryParse(e1) {
                        const t = this.state.clone();
                        const r = e1();
                        if (r !== undefined && r !== false) {
                            return r;
                        }
                        this.state = t;
                    }
                    tsTryParseDeclare(e1) {
                        if (this.isLineTerminator()) {
                            return;
                        }
                        let t = this.state.type;
                        let r;
                        if (this.isContextual(99)) {
                            t = 74;
                            r = "let";
                        }
                        return this.tsInAmbientContext(()=>{
                            switch(t){
                                case 68:
                                    e1.declare = true;
                                    return super.parseFunctionStatement(e1, false, false);
                                case 80:
                                    e1.declare = true;
                                    return this.parseClass(e1, true, false);
                                case 124:
                                    return this.tsParseEnumDeclaration(e1, {
                                        declare: true
                                    });
                                case 110:
                                    return this.tsParseAmbientExternalModuleDeclaration(e1);
                                case 75:
                                case 74:
                                    if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                                        e1.declare = true;
                                        return this.parseVarStatement(e1, r || this.state.value, true);
                                    }
                                    this.expect(75);
                                    return this.tsParseEnumDeclaration(e1, {
                                        const: true,
                                        declare: true
                                    });
                                case 127:
                                    {
                                        const t = this.tsParseInterfaceDeclaration(e1, {
                                            declare: true
                                        });
                                        if (t) return t;
                                    }
                                default:
                                    if (tokenIsIdentifier(t)) {
                                        return this.tsParseDeclaration(e1, this.state.value, true, null);
                                    }
                            }
                        });
                    }
                    tsTryParseExportDeclaration() {
                        return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
                    }
                    tsParseExpressionStatement(e1, t, r) {
                        switch(t.name){
                            case "declare":
                                {
                                    const t = this.tsTryParseDeclare(e1);
                                    if (t) {
                                        t.declare = true;
                                    }
                                    return t;
                                }
                            case "global":
                                if (this.match(5)) {
                                    this.scope.enter(X);
                                    this.prodParam.enter(Xe);
                                    const r = e1;
                                    r.global = true;
                                    r.id = t;
                                    r.body = this.tsParseModuleBlock();
                                    this.scope.exit();
                                    this.prodParam.exit();
                                    return this.finishNode(r, "TSModuleDeclaration");
                                }
                                break;
                            default:
                                return this.tsParseDeclaration(e1, t.name, false, r);
                        }
                    }
                    tsParseDeclaration(e1, t, r, n) {
                        switch(t){
                            case "abstract":
                                if (this.tsCheckLineTerminator(r) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
                                    return this.tsParseAbstractDeclaration(e1, n);
                                }
                                break;
                            case "module":
                                if (this.tsCheckLineTerminator(r)) {
                                    if (this.match(131)) {
                                        return this.tsParseAmbientExternalModuleDeclaration(e1);
                                    } else if (tokenIsIdentifier(this.state.type)) {
                                        return this.tsParseModuleOrNamespaceDeclaration(e1);
                                    }
                                }
                                break;
                            case "namespace":
                                if (this.tsCheckLineTerminator(r) && tokenIsIdentifier(this.state.type)) {
                                    return this.tsParseModuleOrNamespaceDeclaration(e1);
                                }
                                break;
                            case "type":
                                if (this.tsCheckLineTerminator(r) && tokenIsIdentifier(this.state.type)) {
                                    return this.tsParseTypeAliasDeclaration(e1);
                                }
                                break;
                        }
                    }
                    tsCheckLineTerminator(e1) {
                        if (e1) {
                            if (this.hasFollowingLineBreak()) return false;
                            this.next();
                            return true;
                        }
                        return !this.isLineTerminator();
                    }
                    tsTryParseGenericAsyncArrowFunction(e1) {
                        if (!this.match(47)) return;
                        const t = this.state.maybeInArrowParameters;
                        this.state.maybeInArrowParameters = true;
                        const r = this.tsTryParseAndCatch(()=>{
                            const t = this.startNodeAt(e1);
                            t.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
                            super.parseFunctionParams(t);
                            t.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
                            this.expect(19);
                            return t;
                        });
                        this.state.maybeInArrowParameters = t;
                        if (!r) return;
                        return super.parseArrowExpression(r, null, true);
                    }
                    tsParseTypeArgumentsInExpression() {
                        if (this.reScan_lt() !== 47) return;
                        return this.tsParseTypeArguments();
                    }
                    tsParseTypeArguments() {
                        const e1 = this.startNode();
                        e1.params = this.tsInType(()=>this.tsInNoContext(()=>{
                                this.expect(47);
                                return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
                            }));
                        if (e1.params.length === 0) {
                            this.raise(ot.EmptyTypeArguments, {
                                at: e1
                            });
                        } else if (!this.state.inType && this.curContext() === d.brace) {
                            this.reScan_lt_gt();
                        }
                        this.expect(48);
                        return this.finishNode(e1, "TSTypeParameterInstantiation");
                    }
                    tsIsDeclarationStart() {
                        return tokenIsTSDeclarationStart(this.state.type);
                    }
                    isExportDefaultSpecifier() {
                        if (this.tsIsDeclarationStart()) return false;
                        return super.isExportDefaultSpecifier();
                    }
                    parseAssignableListItem(e1, t) {
                        const r = this.state.startLoc;
                        const n = {};
                        this.tsParseModifiers({
                            allowedModifiers: [
                                "public",
                                "private",
                                "protected",
                                "override",
                                "readonly"
                            ]
                        }, n);
                        const s = n.accessibility;
                        const i = n.override;
                        const a = n.readonly;
                        if (!(e1 & 4) && (s || a || i)) {
                            this.raise(ot.UnexpectedParameterModifier, {
                                at: r
                            });
                        }
                        const o = this.parseMaybeDefault();
                        this.parseAssignableListItemTypes(o, e1);
                        const l = this.parseMaybeDefault(o.loc.start, o);
                        if (s || a || i) {
                            const e1 = this.startNodeAt(r);
                            if (t.length) {
                                e1.decorators = t;
                            }
                            if (s) e1.accessibility = s;
                            if (a) e1.readonly = a;
                            if (i) e1.override = i;
                            if (l.type !== "Identifier" && l.type !== "AssignmentPattern") {
                                this.raise(ot.UnsupportedParameterPropertyKind, {
                                    at: e1
                                });
                            }
                            e1.parameter = l;
                            return this.finishNode(e1, "TSParameterProperty");
                        }
                        if (t.length) {
                            o.decorators = t;
                        }
                        return l;
                    }
                    isSimpleParameter(e1) {
                        return e1.type === "TSParameterProperty" && super.isSimpleParameter(e1.parameter) || super.isSimpleParameter(e1);
                    }
                    tsDisallowOptionalPattern(e1) {
                        for (const t of e1.params){
                            if (t.type !== "Identifier" && t.optional && !this.state.isAmbientContext) {
                                this.raise(ot.PatternIsOptional, {
                                    at: t
                                });
                            }
                        }
                    }
                    setArrowFunctionParameters(e1, t, r) {
                        super.setArrowFunctionParameters(e1, t, r);
                        this.tsDisallowOptionalPattern(e1);
                    }
                    parseFunctionBodyAndFinish(e1, t, r = false) {
                        if (this.match(14)) {
                            e1.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
                        }
                        const n = t === "FunctionDeclaration" ? "TSDeclareFunction" : t === "ClassMethod" || t === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;
                        if (n && !this.match(5) && this.isLineTerminator()) {
                            return this.finishNode(e1, n);
                        }
                        if (n === "TSDeclareFunction" && this.state.isAmbientContext) {
                            this.raise(ot.DeclareFunctionHasImplementation, {
                                at: e1
                            });
                            if (e1.declare) {
                                return super.parseFunctionBodyAndFinish(e1, n, r);
                            }
                        }
                        this.tsDisallowOptionalPattern(e1);
                        return super.parseFunctionBodyAndFinish(e1, t, r);
                    }
                    registerFunctionStatementId(e1) {
                        if (!e1.body && e1.id) {
                            this.checkIdentifier(e1.id, be);
                        } else {
                            super.registerFunctionStatementId(e1);
                        }
                    }
                    tsCheckForInvalidTypeCasts(e1) {
                        e1.forEach((e1)=>{
                            if ((e1 == null ? void 0 : e1.type) === "TSTypeCastExpression") {
                                this.raise(ot.UnexpectedTypeAnnotation, {
                                    at: e1.typeAnnotation
                                });
                            }
                        });
                    }
                    toReferencedList(e1, t) {
                        this.tsCheckForInvalidTypeCasts(e1);
                        return e1;
                    }
                    parseArrayLike(e1, t, r, n) {
                        const s = super.parseArrayLike(e1, t, r, n);
                        if (s.type === "ArrayExpression") {
                            this.tsCheckForInvalidTypeCasts(s.elements);
                        }
                        return s;
                    }
                    parseSubscript(e1, t, r, n) {
                        if (!this.hasPrecedingLineBreak() && this.match(35)) {
                            this.state.canStartJSXElement = false;
                            this.next();
                            const r = this.startNodeAt(t);
                            r.expression = e1;
                            return this.finishNode(r, "TSNonNullExpression");
                        }
                        let s = false;
                        if (this.match(18) && this.lookaheadCharCode() === 60) {
                            if (r) {
                                n.stop = true;
                                return e1;
                            }
                            n.optionalChainMember = s = true;
                            this.next();
                        }
                        if (this.match(47) || this.match(51)) {
                            let i;
                            const a = this.tsTryParseAndCatch(()=>{
                                if (!r && this.atPossibleAsyncArrow(e1)) {
                                    const e1 = this.tsTryParseGenericAsyncArrowFunction(t);
                                    if (e1) {
                                        return e1;
                                    }
                                }
                                const a = this.tsParseTypeArgumentsInExpression();
                                if (!a) return;
                                if (s && !this.match(10)) {
                                    i = this.state.curPosition();
                                    return;
                                }
                                if (tokenIsTemplate(this.state.type)) {
                                    const r = super.parseTaggedTemplateExpression(e1, t, n);
                                    r.typeParameters = a;
                                    return r;
                                }
                                if (!r && this.eat(10)) {
                                    const r = this.startNodeAt(t);
                                    r.callee = e1;
                                    r.arguments = this.parseCallExpressionArguments(11, false);
                                    this.tsCheckForInvalidTypeCasts(r.arguments);
                                    r.typeParameters = a;
                                    if (n.optionalChainMember) {
                                        r.optional = s;
                                    }
                                    return this.finishCallExpression(r, n.optionalChainMember);
                                }
                                const o = this.state.type;
                                if (o === 48 || o === 52 || o !== 10 && tokenCanStartExpression(o) && !this.hasPrecedingLineBreak()) {
                                    return;
                                }
                                const l = this.startNodeAt(t);
                                l.expression = e1;
                                l.typeParameters = a;
                                return this.finishNode(l, "TSInstantiationExpression");
                            });
                            if (i) {
                                this.unexpected(i, 10);
                            }
                            if (a) {
                                if (a.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
                                    this.raise(ot.InvalidPropertyAccessAfterInstantiationExpression, {
                                        at: this.state.startLoc
                                    });
                                }
                                return a;
                            }
                        }
                        return super.parseSubscript(e1, t, r, n);
                    }
                    parseNewCallee(e1) {
                        var t;
                        super.parseNewCallee(e1);
                        const { callee: r } = e1;
                        if (r.type === "TSInstantiationExpression" && !((t = r.extra) != null && t.parenthesized)) {
                            e1.typeParameters = r.typeParameters;
                            e1.callee = r.expression;
                        }
                    }
                    parseExprOp(e1, t, r) {
                        let n;
                        if (tokenOperatorPrecedence(58) > r && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n = this.isContextual(118)))) {
                            const s = this.startNodeAt(t);
                            s.expression = e1;
                            s.typeAnnotation = this.tsInType(()=>{
                                this.next();
                                if (this.match(75)) {
                                    if (n) {
                                        this.raise(p.UnexpectedKeyword, {
                                            at: this.state.startLoc,
                                            keyword: "const"
                                        });
                                    }
                                    return this.tsParseTypeReference();
                                }
                                return this.tsParseType();
                            });
                            this.finishNode(s, n ? "TSSatisfiesExpression" : "TSAsExpression");
                            this.reScan_lt_gt();
                            return this.parseExprOp(s, t, r);
                        }
                        return super.parseExprOp(e1, t, r);
                    }
                    checkReservedWord(e1, t, r, n) {
                        if (!this.state.isAmbientContext) {
                            super.checkReservedWord(e1, t, r, n);
                        }
                    }
                    checkImportReflection(e1) {
                        super.checkImportReflection(e1);
                        if (e1.module && e1.importKind !== "value") {
                            this.raise(ot.ImportReflectionHasImportType, {
                                at: e1.specifiers[0].loc.start
                            });
                        }
                    }
                    checkDuplicateExports() {}
                    isPotentialImportPhase(e1) {
                        if (super.isPotentialImportPhase(e1)) return true;
                        if (this.isContextual(128)) {
                            const t = this.lookaheadCharCode();
                            return e1 ? t === 123 || t === 42 : t !== 61;
                        }
                        return !e1 && this.isContextual(87);
                    }
                    applyImportPhase(e1, t, r, n) {
                        super.applyImportPhase(e1, t, r, n);
                        if (t) {
                            e1.exportKind = r === "type" ? "type" : "value";
                        } else {
                            e1.importKind = r === "type" || r === "typeof" ? r : "value";
                        }
                    }
                    parseImport(e1) {
                        if (this.match(131)) {
                            e1.importKind = "value";
                            return super.parseImport(e1);
                        }
                        let t;
                        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
                            e1.importKind = "value";
                            return this.tsParseImportEqualsDeclaration(e1);
                        } else if (this.isContextual(128)) {
                            const r = this.parseMaybeImportPhase(e1, false);
                            if (this.lookaheadCharCode() === 61) {
                                return this.tsParseImportEqualsDeclaration(e1, r);
                            } else {
                                t = super.parseImportSpecifiersAndAfter(e1, r);
                            }
                        } else {
                            t = super.parseImport(e1);
                        }
                        if (t.importKind === "type" && t.specifiers.length > 1 && t.specifiers[0].type === "ImportDefaultSpecifier") {
                            this.raise(ot.TypeImportCannotSpecifyDefaultAndNamed, {
                                at: t
                            });
                        }
                        return t;
                    }
                    parseExport(e1, t) {
                        if (this.match(83)) {
                            this.next();
                            let t = null;
                            if (this.isContextual(128) && this.isPotentialImportPhase(false)) {
                                t = this.parseMaybeImportPhase(e1, false);
                            } else {
                                e1.importKind = "value";
                            }
                            return this.tsParseImportEqualsDeclaration(e1, t, true);
                        } else if (this.eat(29)) {
                            const t = e1;
                            t.expression = super.parseExpression();
                            this.semicolon();
                            this.sawUnambiguousESM = true;
                            return this.finishNode(t, "TSExportAssignment");
                        } else if (this.eatContextual(93)) {
                            const t = e1;
                            this.expectContextual(126);
                            t.id = this.parseIdentifier();
                            this.semicolon();
                            return this.finishNode(t, "TSNamespaceExportDeclaration");
                        } else {
                            return super.parseExport(e1, t);
                        }
                    }
                    isAbstractClass() {
                        return this.isContextual(122) && this.lookahead().type === 80;
                    }
                    parseExportDefaultExpression() {
                        if (this.isAbstractClass()) {
                            const e1 = this.startNode();
                            this.next();
                            e1.abstract = true;
                            return this.parseClass(e1, true, true);
                        }
                        if (this.match(127)) {
                            const e1 = this.tsParseInterfaceDeclaration(this.startNode());
                            if (e1) return e1;
                        }
                        return super.parseExportDefaultExpression();
                    }
                    parseVarStatement(e1, t, r = false) {
                        const { isAmbientContext: n } = this.state;
                        const s = super.parseVarStatement(e1, t, r || n);
                        if (!n) return s;
                        for (const { id: e1, init: r } of s.declarations){
                            if (!r) continue;
                            if (t !== "const" || !!e1.typeAnnotation) {
                                this.raise(ot.InitializerNotAllowedInAmbientContext, {
                                    at: r
                                });
                            } else if (!isValidAmbientConstInitializer(r, this.hasPlugin("estree"))) {
                                this.raise(ot.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
                                    at: r
                                });
                            }
                        }
                        return s;
                    }
                    parseStatementContent(e1, t) {
                        if (this.match(75) && this.isLookaheadContextual("enum")) {
                            const e1 = this.startNode();
                            this.expect(75);
                            return this.tsParseEnumDeclaration(e1, {
                                const: true
                            });
                        }
                        if (this.isContextual(124)) {
                            return this.tsParseEnumDeclaration(this.startNode());
                        }
                        if (this.isContextual(127)) {
                            const e1 = this.tsParseInterfaceDeclaration(this.startNode());
                            if (e1) return e1;
                        }
                        return super.parseStatementContent(e1, t);
                    }
                    parseAccessModifier() {
                        return this.tsParseModifier([
                            "public",
                            "protected",
                            "private"
                        ]);
                    }
                    tsHasSomeModifiers(e1, t) {
                        return t.some((t)=>{
                            if (tsIsAccessModifier(t)) {
                                return e1.accessibility === t;
                            }
                            return !!e1[t];
                        });
                    }
                    tsIsStartOfStaticBlocks() {
                        return this.isContextual(104) && this.lookaheadCharCode() === 123;
                    }
                    parseClassMember(e1, t, r) {
                        const n = [
                            "declare",
                            "private",
                            "public",
                            "protected",
                            "override",
                            "abstract",
                            "readonly",
                            "static"
                        ];
                        this.tsParseModifiers({
                            allowedModifiers: n,
                            disallowedModifiers: [
                                "in",
                                "out"
                            ],
                            stopOnStartOfClassStaticBlock: true,
                            errorTemplate: ot.InvalidModifierOnTypeParameterPositions
                        }, t);
                        const callParseClassMemberWithIsStatic = ()=>{
                            if (this.tsIsStartOfStaticBlocks()) {
                                this.next();
                                this.next();
                                if (this.tsHasSomeModifiers(t, n)) {
                                    this.raise(ot.StaticBlockCannotHaveModifier, {
                                        at: this.state.curPosition()
                                    });
                                }
                                super.parseClassStaticBlock(e1, t);
                            } else {
                                this.parseClassMemberWithIsStatic(e1, t, r, !!t.static);
                            }
                        };
                        if (t.declare) {
                            this.tsInAmbientContext(callParseClassMemberWithIsStatic);
                        } else {
                            callParseClassMemberWithIsStatic();
                        }
                    }
                    parseClassMemberWithIsStatic(e1, t, r, n) {
                        const s = this.tsTryParseIndexSignature(t);
                        if (s) {
                            e1.body.push(s);
                            if (t.abstract) {
                                this.raise(ot.IndexSignatureHasAbstract, {
                                    at: t
                                });
                            }
                            if (t.accessibility) {
                                this.raise(ot.IndexSignatureHasAccessibility, {
                                    at: t,
                                    modifier: t.accessibility
                                });
                            }
                            if (t.declare) {
                                this.raise(ot.IndexSignatureHasDeclare, {
                                    at: t
                                });
                            }
                            if (t.override) {
                                this.raise(ot.IndexSignatureHasOverride, {
                                    at: t
                                });
                            }
                            return;
                        }
                        if (!this.state.inAbstractClass && t.abstract) {
                            this.raise(ot.NonAbstractClassHasAbstractMethod, {
                                at: t
                            });
                        }
                        if (t.override) {
                            if (!r.hadSuperClass) {
                                this.raise(ot.OverrideNotInSubClass, {
                                    at: t
                                });
                            }
                        }
                        super.parseClassMemberWithIsStatic(e1, t, r, n);
                    }
                    parsePostMemberNameModifiers(e1) {
                        const t = this.eat(17);
                        if (t) e1.optional = true;
                        if (e1.readonly && this.match(10)) {
                            this.raise(ot.ClassMethodHasReadonly, {
                                at: e1
                            });
                        }
                        if (e1.declare && this.match(10)) {
                            this.raise(ot.ClassMethodHasDeclare, {
                                at: e1
                            });
                        }
                    }
                    parseExpressionStatement(e1, t, r) {
                        const n = t.type === "Identifier" ? this.tsParseExpressionStatement(e1, t, r) : undefined;
                        return n || super.parseExpressionStatement(e1, t, r);
                    }
                    shouldParseExportDeclaration() {
                        if (this.tsIsDeclarationStart()) return true;
                        return super.shouldParseExportDeclaration();
                    }
                    parseConditional(e1, t, r) {
                        if (!this.state.maybeInArrowParameters || !this.match(17)) {
                            return super.parseConditional(e1, t, r);
                        }
                        const n = this.tryParse(()=>super.parseConditional(e1, t));
                        if (!n.node) {
                            if (n.error) {
                                super.setOptionalParametersError(r, n.error);
                            }
                            return e1;
                        }
                        if (n.error) this.state = n.failState;
                        return n.node;
                    }
                    parseParenItem(e1, t) {
                        e1 = super.parseParenItem(e1, t);
                        if (this.eat(17)) {
                            e1.optional = true;
                            this.resetEndLocation(e1);
                        }
                        if (this.match(14)) {
                            const r = this.startNodeAt(t);
                            r.expression = e1;
                            r.typeAnnotation = this.tsParseTypeAnnotation();
                            return this.finishNode(r, "TSTypeCastExpression");
                        }
                        return e1;
                    }
                    parseExportDeclaration(e1) {
                        if (!this.state.isAmbientContext && this.isContextual(123)) {
                            return this.tsInAmbientContext(()=>this.parseExportDeclaration(e1));
                        }
                        const t = this.state.startLoc;
                        const r = this.eatContextual(123);
                        if (r && (this.isContextual(123) || !this.shouldParseExportDeclaration())) {
                            throw this.raise(ot.ExpectedAmbientAfterExportDeclare, {
                                at: this.state.startLoc
                            });
                        }
                        const n = tokenIsIdentifier(this.state.type);
                        const s = n && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e1);
                        if (!s) return null;
                        if (s.type === "TSInterfaceDeclaration" || s.type === "TSTypeAliasDeclaration" || r) {
                            e1.exportKind = "type";
                        }
                        if (r) {
                            this.resetStartLocation(s, t);
                            s.declare = true;
                        }
                        return s;
                    }
                    parseClassId(e1, t, r, n) {
                        if ((!t || r) && this.isContextual(111)) {
                            return;
                        }
                        super.parseClassId(e1, t, r, e1.declare ? be : ue);
                        const s = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
                        if (s) e1.typeParameters = s;
                    }
                    parseClassPropertyAnnotation(e1) {
                        if (!e1.optional) {
                            if (this.eat(35)) {
                                e1.definite = true;
                            } else if (this.eat(17)) {
                                e1.optional = true;
                            }
                        }
                        const t = this.tsTryParseTypeAnnotation();
                        if (t) e1.typeAnnotation = t;
                    }
                    parseClassProperty(e1) {
                        this.parseClassPropertyAnnotation(e1);
                        if (this.state.isAmbientContext && !(e1.readonly && !e1.typeAnnotation) && this.match(29)) {
                            this.raise(ot.DeclareClassFieldHasInitializer, {
                                at: this.state.startLoc
                            });
                        }
                        if (e1.abstract && this.match(29)) {
                            const { key: t } = e1;
                            this.raise(ot.AbstractPropertyHasInitializer, {
                                at: this.state.startLoc,
                                propertyName: t.type === "Identifier" && !e1.computed ? t.name : `[${this.input.slice(t.start, t.end)}]`
                            });
                        }
                        return super.parseClassProperty(e1);
                    }
                    parseClassPrivateProperty(e1) {
                        if (e1.abstract) {
                            this.raise(ot.PrivateElementHasAbstract, {
                                at: e1
                            });
                        }
                        if (e1.accessibility) {
                            this.raise(ot.PrivateElementHasAccessibility, {
                                at: e1,
                                modifier: e1.accessibility
                            });
                        }
                        this.parseClassPropertyAnnotation(e1);
                        return super.parseClassPrivateProperty(e1);
                    }
                    parseClassAccessorProperty(e1) {
                        this.parseClassPropertyAnnotation(e1);
                        if (e1.optional) {
                            this.raise(ot.AccessorCannotBeOptional, {
                                at: e1
                            });
                        }
                        return super.parseClassAccessorProperty(e1);
                    }
                    pushClassMethod(e1, t, r, n, s, i) {
                        const a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                        if (a && s) {
                            this.raise(ot.ConstructorHasTypeParameters, {
                                at: a
                            });
                        }
                        const { declare: o = false, kind: l } = t;
                        if (o && (l === "get" || l === "set")) {
                            this.raise(ot.DeclareAccessor, {
                                at: t,
                                kind: l
                            });
                        }
                        if (a) t.typeParameters = a;
                        super.pushClassMethod(e1, t, r, n, s, i);
                    }
                    pushClassPrivateMethod(e1, t, r, n) {
                        const s = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                        if (s) t.typeParameters = s;
                        super.pushClassPrivateMethod(e1, t, r, n);
                    }
                    declareClassPrivateMethodInScope(e1, t) {
                        if (e1.type === "TSDeclareMethod") return;
                        if (e1.type === "MethodDefinition" && !e1.value.body) return;
                        super.declareClassPrivateMethodInScope(e1, t);
                    }
                    parseClassSuper(e1) {
                        super.parseClassSuper(e1);
                        if (e1.superClass && (this.match(47) || this.match(51))) {
                            e1.superTypeParameters = this.tsParseTypeArgumentsInExpression();
                        }
                        if (this.eatContextual(111)) {
                            e1.implements = this.tsParseHeritageClause("implements");
                        }
                    }
                    parseObjPropValue(e1, t, r, n, s, i, a) {
                        const o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                        if (o) e1.typeParameters = o;
                        return super.parseObjPropValue(e1, t, r, n, s, i, a);
                    }
                    parseFunctionParams(e1, t) {
                        const r = this.tsTryParseTypeParameters(this.tsParseConstModifier);
                        if (r) e1.typeParameters = r;
                        super.parseFunctionParams(e1, t);
                    }
                    parseVarId(e1, t) {
                        super.parseVarId(e1, t);
                        if (e1.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
                            e1.definite = true;
                        }
                        const r = this.tsTryParseTypeAnnotation();
                        if (r) {
                            e1.id.typeAnnotation = r;
                            this.resetEndLocation(e1.id);
                        }
                    }
                    parseAsyncArrowFromCallExpression(e1, t) {
                        if (this.match(14)) {
                            e1.returnType = this.tsParseTypeAnnotation();
                        }
                        return super.parseAsyncArrowFromCallExpression(e1, t);
                    }
                    parseMaybeAssign(e1, t) {
                        var r, n, s, i, a;
                        let o;
                        let l;
                        let c;
                        if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                            o = this.state.clone();
                            l = this.tryParse(()=>super.parseMaybeAssign(e1, t), o);
                            if (!l.error) return l.node;
                            const { context: r } = this.state;
                            const n = r[r.length - 1];
                            if (n === d.j_oTag || n === d.j_expr) {
                                r.pop();
                            }
                        }
                        if (!((r = l) != null && r.error) && !this.match(47)) {
                            return super.parseMaybeAssign(e1, t);
                        }
                        if (!o || o === this.state) o = this.state.clone();
                        let u;
                        const p = this.tryParse((r)=>{
                            var n, s;
                            u = this.tsParseTypeParameters(this.tsParseConstModifier);
                            const i = super.parseMaybeAssign(e1, t);
                            if (i.type !== "ArrowFunctionExpression" || (n = i.extra) != null && n.parenthesized) {
                                r();
                            }
                            if (((s = u) == null ? void 0 : s.params.length) !== 0) {
                                this.resetStartLocationFromNode(i, u);
                            }
                            i.typeParameters = u;
                            return i;
                        }, o);
                        if (!p.error && !p.aborted) {
                            if (u) this.reportReservedArrowTypeParam(u);
                            return p.node;
                        }
                        if (!l) {
                            assert(!this.hasPlugin("jsx"));
                            c = this.tryParse(()=>super.parseMaybeAssign(e1, t), o);
                            if (!c.error) return c.node;
                        }
                        if ((n = l) != null && n.node) {
                            this.state = l.failState;
                            return l.node;
                        }
                        if (p.node) {
                            this.state = p.failState;
                            if (u) this.reportReservedArrowTypeParam(u);
                            return p.node;
                        }
                        if ((s = c) != null && s.node) {
                            this.state = c.failState;
                            return c.node;
                        }
                        throw ((i = l) == null ? void 0 : i.error) || p.error || ((a = c) == null ? void 0 : a.error);
                    }
                    reportReservedArrowTypeParam(e1) {
                        var t;
                        if (e1.params.length === 1 && !e1.params[0].constraint && !((t = e1.extra) != null && t.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
                            this.raise(ot.ReservedArrowTypeParam, {
                                at: e1
                            });
                        }
                    }
                    parseMaybeUnary(e1, t) {
                        if (!this.hasPlugin("jsx") && this.match(47)) {
                            return this.tsParseTypeAssertion();
                        }
                        return super.parseMaybeUnary(e1, t);
                    }
                    parseArrow(e1) {
                        if (this.match(14)) {
                            const t = this.tryParse((e1)=>{
                                const t = this.tsParseTypeOrTypePredicateAnnotation(14);
                                if (this.canInsertSemicolon() || !this.match(19)) e1();
                                return t;
                            });
                            if (t.aborted) return;
                            if (!t.thrown) {
                                if (t.error) this.state = t.failState;
                                e1.returnType = t.node;
                            }
                        }
                        return super.parseArrow(e1);
                    }
                    parseAssignableListItemTypes(e1, t) {
                        if (!(t & 2)) return e1;
                        if (this.eat(17)) {
                            e1.optional = true;
                        }
                        const r = this.tsTryParseTypeAnnotation();
                        if (r) e1.typeAnnotation = r;
                        this.resetEndLocation(e1);
                        return e1;
                    }
                    isAssignable(e1, t) {
                        switch(e1.type){
                            case "TSTypeCastExpression":
                                return this.isAssignable(e1.expression, t);
                            case "TSParameterProperty":
                                return true;
                            default:
                                return super.isAssignable(e1, t);
                        }
                    }
                    toAssignable(e1, t = false) {
                        switch(e1.type){
                            case "ParenthesizedExpression":
                                this.toAssignableParenthesizedExpression(e1, t);
                                break;
                            case "TSAsExpression":
                            case "TSSatisfiesExpression":
                            case "TSNonNullExpression":
                            case "TSTypeAssertion":
                                if (t) {
                                    this.expressionScope.recordArrowParameterBindingError(ot.UnexpectedTypeCastInParameter, {
                                        at: e1
                                    });
                                } else {
                                    this.raise(ot.UnexpectedTypeCastInParameter, {
                                        at: e1
                                    });
                                }
                                this.toAssignable(e1.expression, t);
                                break;
                            case "AssignmentExpression":
                                if (!t && e1.left.type === "TSTypeCastExpression") {
                                    e1.left = this.typeCastToParameter(e1.left);
                                }
                            default:
                                super.toAssignable(e1, t);
                        }
                    }
                    toAssignableParenthesizedExpression(e1, t) {
                        switch(e1.expression.type){
                            case "TSAsExpression":
                            case "TSSatisfiesExpression":
                            case "TSNonNullExpression":
                            case "TSTypeAssertion":
                            case "ParenthesizedExpression":
                                this.toAssignable(e1.expression, t);
                                break;
                            default:
                                super.toAssignable(e1, t);
                        }
                    }
                    checkToRestConversion(e1, t) {
                        switch(e1.type){
                            case "TSAsExpression":
                            case "TSSatisfiesExpression":
                            case "TSTypeAssertion":
                            case "TSNonNullExpression":
                                this.checkToRestConversion(e1.expression, false);
                                break;
                            default:
                                super.checkToRestConversion(e1, t);
                        }
                    }
                    isValidLVal(e1, t, r) {
                        return getOwn({
                            TSTypeCastExpression: true,
                            TSParameterProperty: "parameter",
                            TSNonNullExpression: "expression",
                            TSAsExpression: (r !== Te || !t) && [
                                "expression",
                                true
                            ],
                            TSSatisfiesExpression: (r !== Te || !t) && [
                                "expression",
                                true
                            ],
                            TSTypeAssertion: (r !== Te || !t) && [
                                "expression",
                                true
                            ]
                        }, e1) || super.isValidLVal(e1, t, r);
                    }
                    parseBindingAtom() {
                        if (this.state.type === 78) {
                            return this.parseIdentifier(true);
                        }
                        return super.parseBindingAtom();
                    }
                    parseMaybeDecoratorArguments(e1) {
                        if (this.match(47) || this.match(51)) {
                            const t = this.tsParseTypeArgumentsInExpression();
                            if (this.match(10)) {
                                const r = super.parseMaybeDecoratorArguments(e1);
                                r.typeParameters = t;
                                return r;
                            }
                            this.unexpected(null, 10);
                        }
                        return super.parseMaybeDecoratorArguments(e1);
                    }
                    checkCommaAfterRest(e1) {
                        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e1) {
                            this.next();
                            return false;
                        }
                        return super.checkCommaAfterRest(e1);
                    }
                    isClassMethod() {
                        return this.match(47) || super.isClassMethod();
                    }
                    isClassProperty() {
                        return this.match(35) || this.match(14) || super.isClassProperty();
                    }
                    parseMaybeDefault(e1, t) {
                        const r = super.parseMaybeDefault(e1, t);
                        if (r.type === "AssignmentPattern" && r.typeAnnotation && r.right.start < r.typeAnnotation.start) {
                            this.raise(ot.TypeAnnotationAfterAssign, {
                                at: r.typeAnnotation
                            });
                        }
                        return r;
                    }
                    getTokenFromCode(e1) {
                        if (this.state.inType) {
                            if (e1 === 62) {
                                this.finishOp(48, 1);
                                return;
                            }
                            if (e1 === 60) {
                                this.finishOp(47, 1);
                                return;
                            }
                        }
                        super.getTokenFromCode(e1);
                    }
                    reScan_lt_gt() {
                        const { type: e1 } = this.state;
                        if (e1 === 47) {
                            this.state.pos -= 1;
                            this.readToken_lt();
                        } else if (e1 === 48) {
                            this.state.pos -= 1;
                            this.readToken_gt();
                        }
                    }
                    reScan_lt() {
                        const { type: e1 } = this.state;
                        if (e1 === 51) {
                            this.state.pos -= 2;
                            this.finishOp(47, 1);
                            return 47;
                        }
                        return e1;
                    }
                    toAssignableList(e1, t, r) {
                        for(let t = 0; t < e1.length; t++){
                            const r = e1[t];
                            if ((r == null ? void 0 : r.type) === "TSTypeCastExpression") {
                                e1[t] = this.typeCastToParameter(r);
                            }
                        }
                        super.toAssignableList(e1, t, r);
                    }
                    typeCastToParameter(e1) {
                        e1.expression.typeAnnotation = e1.typeAnnotation;
                        this.resetEndLocation(e1.expression, e1.typeAnnotation.loc.end);
                        return e1.expression;
                    }
                    shouldParseArrow(e1) {
                        if (this.match(14)) {
                            return e1.every((e1)=>this.isAssignable(e1, true));
                        }
                        return super.shouldParseArrow(e1);
                    }
                    shouldParseAsyncArrow() {
                        return this.match(14) || super.shouldParseAsyncArrow();
                    }
                    canHaveLeadingDecorator() {
                        return super.canHaveLeadingDecorator() || this.isAbstractClass();
                    }
                    jsxParseOpeningElementAfterName(e1) {
                        if (this.match(47) || this.match(51)) {
                            const t = this.tsTryParseAndCatch(()=>this.tsParseTypeArgumentsInExpression());
                            if (t) e1.typeParameters = t;
                        }
                        return super.jsxParseOpeningElementAfterName(e1);
                    }
                    getGetterSetterExpectedParamCount(e1) {
                        const t = super.getGetterSetterExpectedParamCount(e1);
                        const r = this.getObjectOrClassMethodParams(e1);
                        const n = r[0];
                        const s = n && this.isThisParam(n);
                        return s ? t + 1 : t;
                    }
                    parseCatchClauseParam() {
                        const e1 = super.parseCatchClauseParam();
                        const t = this.tsTryParseTypeAnnotation();
                        if (t) {
                            e1.typeAnnotation = t;
                            this.resetEndLocation(e1);
                        }
                        return e1;
                    }
                    tsInAmbientContext(e1) {
                        const t = this.state.isAmbientContext;
                        this.state.isAmbientContext = true;
                        try {
                            return e1();
                        } finally{
                            this.state.isAmbientContext = t;
                        }
                    }
                    parseClass(e1, t, r) {
                        const n = this.state.inAbstractClass;
                        this.state.inAbstractClass = !!e1.abstract;
                        try {
                            return super.parseClass(e1, t, r);
                        } finally{
                            this.state.inAbstractClass = n;
                        }
                    }
                    tsParseAbstractDeclaration(e1, t) {
                        if (this.match(80)) {
                            e1.abstract = true;
                            return this.maybeTakeDecorators(t, this.parseClass(e1, true, false));
                        } else if (this.isContextual(127)) {
                            if (!this.hasFollowingLineBreak()) {
                                e1.abstract = true;
                                this.raise(ot.NonClassMethodPropertyHasAbstractModifer, {
                                    at: e1
                                });
                                return this.tsParseInterfaceDeclaration(e1);
                            }
                        } else {
                            this.unexpected(null, 80);
                        }
                    }
                    parseMethod(e1, t, r, n, s, i, a) {
                        const o = super.parseMethod(e1, t, r, n, s, i, a);
                        if (o.abstract) {
                            const e1 = this.hasPlugin("estree") ? !!o.value.body : !!o.body;
                            if (e1) {
                                const { key: e1 } = o;
                                this.raise(ot.AbstractMethodHasImplementation, {
                                    at: o,
                                    methodName: e1.type === "Identifier" && !o.computed ? e1.name : `[${this.input.slice(e1.start, e1.end)}]`
                                });
                            }
                        }
                        return o;
                    }
                    tsParseTypeParameterName() {
                        const e1 = this.parseIdentifier();
                        return e1.name;
                    }
                    shouldParseAsAmbientContext() {
                        return !!this.getPluginOption("typescript", "dts");
                    }
                    parse() {
                        if (this.shouldParseAsAmbientContext()) {
                            this.state.isAmbientContext = true;
                        }
                        return super.parse();
                    }
                    getExpression() {
                        if (this.shouldParseAsAmbientContext()) {
                            this.state.isAmbientContext = true;
                        }
                        return super.getExpression();
                    }
                    parseExportSpecifier(e1, t, r, n) {
                        if (!t && n) {
                            this.parseTypeOnlyImportExportSpecifier(e1, false, r);
                            return this.finishNode(e1, "ExportSpecifier");
                        }
                        e1.exportKind = "value";
                        return super.parseExportSpecifier(e1, t, r, n);
                    }
                    parseImportSpecifier(e1, t, r, n, s) {
                        if (!t && n) {
                            this.parseTypeOnlyImportExportSpecifier(e1, true, r);
                            return this.finishNode(e1, "ImportSpecifier");
                        }
                        e1.importKind = "value";
                        return super.parseImportSpecifier(e1, t, r, n, r ? xe : le);
                    }
                    parseTypeOnlyImportExportSpecifier(e1, t, r) {
                        const n = t ? "imported" : "local";
                        const s = t ? "local" : "exported";
                        let i = e1[n];
                        let a;
                        let o = false;
                        let l = true;
                        const c = i.loc.start;
                        if (this.isContextual(93)) {
                            const e1 = this.parseIdentifier();
                            if (this.isContextual(93)) {
                                const r = this.parseIdentifier();
                                if (tokenIsKeywordOrIdentifier(this.state.type)) {
                                    o = true;
                                    i = e1;
                                    a = t ? this.parseIdentifier() : this.parseModuleExportName();
                                    l = false;
                                } else {
                                    a = r;
                                    l = false;
                                }
                            } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                                l = false;
                                a = t ? this.parseIdentifier() : this.parseModuleExportName();
                            } else {
                                o = true;
                                i = e1;
                            }
                        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                            o = true;
                            if (t) {
                                i = this.parseIdentifier(true);
                                if (!this.isContextual(93)) {
                                    this.checkReservedWord(i.name, i.loc.start, true, true);
                                }
                            } else {
                                i = this.parseModuleExportName();
                            }
                        }
                        if (o && r) {
                            this.raise(t ? ot.TypeModifierIsUsedInTypeImports : ot.TypeModifierIsUsedInTypeExports, {
                                at: c
                            });
                        }
                        e1[n] = i;
                        e1[s] = a;
                        const u = t ? "importKind" : "exportKind";
                        e1[u] = o ? "type" : "value";
                        if (l && this.eatContextual(93)) {
                            e1[s] = t ? this.parseIdentifier() : this.parseModuleExportName();
                        }
                        if (!e1[s]) {
                            e1[s] = cloneIdentifier(e1[n]);
                        }
                        if (t) {
                            this.checkIdentifier(e1[s], o ? xe : le);
                        }
                    }
                };
            function isPossiblyLiteralEnum(e1) {
                if (e1.type !== "MemberExpression") return false;
                const { computed: t, property: r } = e1;
                if (t && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0)) {
                    return false;
                }
                return isUncomputedMemberExpressionChain(e1.object);
            }
            function isValidAmbientConstInitializer(e1, t) {
                var r;
                const { type: n } = e1;
                if ((r = e1.extra) != null && r.parenthesized) {
                    return false;
                }
                if (t) {
                    if (n === "Literal") {
                        const { value: t } = e1;
                        if (typeof t === "string" || typeof t === "boolean") {
                            return true;
                        }
                    }
                } else {
                    if (n === "StringLiteral" || n === "BooleanLiteral") {
                        return true;
                    }
                }
                if (isNumber(e1, t) || isNegativeNumber(e1, t)) {
                    return true;
                }
                if (n === "TemplateLiteral" && e1.expressions.length === 0) {
                    return true;
                }
                if (isPossiblyLiteralEnum(e1)) {
                    return true;
                }
                return false;
            }
            function isNumber(e1, t) {
                if (t) {
                    return e1.type === "Literal" && (typeof e1.value === "number" || "bigint" in e1);
                }
                return e1.type === "NumericLiteral" || e1.type === "BigIntLiteral";
            }
            function isNegativeNumber(e1, t) {
                if (e1.type === "UnaryExpression") {
                    const { operator: r, argument: n } = e1;
                    if (r === "-" && isNumber(n, t)) {
                        return true;
                    }
                }
                return false;
            }
            function isUncomputedMemberExpressionChain(e1) {
                if (e1.type === "Identifier") return true;
                if (e1.type !== "MemberExpression" || e1.computed) {
                    return false;
                }
                return isUncomputedMemberExpressionChain(e1.object);
            }
            const lt = ParseErrorEnum`placeholders`({
                ClassNameIsRequired: "A class name is required.",
                UnexpectedSpace: "Unexpected space in placeholder."
            });
            var placeholders = (e1)=>class PlaceholdersParserMixin extends e1 {
                    parsePlaceholder(e1) {
                        if (this.match(142)) {
                            const t = this.startNode();
                            this.next();
                            this.assertNoSpace();
                            t.name = super.parseIdentifier(true);
                            this.assertNoSpace();
                            this.expect(142);
                            return this.finishPlaceholder(t, e1);
                        }
                    }
                    finishPlaceholder(e1, t) {
                        const r = !!(e1.expectedNode && e1.type === "Placeholder");
                        e1.expectedNode = t;
                        return r ? e1 : this.finishNode(e1, "Placeholder");
                    }
                    getTokenFromCode(e1) {
                        if (e1 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
                            this.finishOp(142, 2);
                        } else {
                            super.getTokenFromCode(e1);
                        }
                    }
                    parseExprAtom(e1) {
                        return this.parsePlaceholder("Expression") || super.parseExprAtom(e1);
                    }
                    parseIdentifier(e1) {
                        return this.parsePlaceholder("Identifier") || super.parseIdentifier(e1);
                    }
                    checkReservedWord(e1, t, r, n) {
                        if (e1 !== undefined) {
                            super.checkReservedWord(e1, t, r, n);
                        }
                    }
                    parseBindingAtom() {
                        return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
                    }
                    isValidLVal(e1, t, r) {
                        return e1 === "Placeholder" || super.isValidLVal(e1, t, r);
                    }
                    toAssignable(e1, t) {
                        if (e1 && e1.type === "Placeholder" && e1.expectedNode === "Expression") {
                            e1.expectedNode = "Pattern";
                        } else {
                            super.toAssignable(e1, t);
                        }
                    }
                    chStartsBindingIdentifier(e1, t) {
                        if (super.chStartsBindingIdentifier(e1, t)) {
                            return true;
                        }
                        const r = this.lookahead();
                        if (r.type === 142) {
                            return true;
                        }
                        return false;
                    }
                    verifyBreakContinue(e1, t) {
                        if (e1.label && e1.label.type === "Placeholder") return;
                        super.verifyBreakContinue(e1, t);
                    }
                    parseExpressionStatement(e1, t) {
                        if (t.type !== "Placeholder" || t.extra && t.extra.parenthesized) {
                            return super.parseExpressionStatement(e1, t);
                        }
                        if (this.match(14)) {
                            const r = e1;
                            r.label = this.finishPlaceholder(t, "Identifier");
                            this.next();
                            r.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
                            return this.finishNode(r, "LabeledStatement");
                        }
                        this.semicolon();
                        e1.name = t.name;
                        return this.finishPlaceholder(e1, "Statement");
                    }
                    parseBlock(e1, t, r) {
                        return this.parsePlaceholder("BlockStatement") || super.parseBlock(e1, t, r);
                    }
                    parseFunctionId(e1) {
                        return this.parsePlaceholder("Identifier") || super.parseFunctionId(e1);
                    }
                    parseClass(e1, t, r) {
                        const n = t ? "ClassDeclaration" : "ClassExpression";
                        this.next();
                        const s = this.state.strict;
                        const i = this.parsePlaceholder("Identifier");
                        if (i) {
                            if (this.match(81) || this.match(142) || this.match(5)) {
                                e1.id = i;
                            } else if (r || !t) {
                                e1.id = null;
                                e1.body = this.finishPlaceholder(i, "ClassBody");
                                return this.finishNode(e1, n);
                            } else {
                                throw this.raise(lt.ClassNameIsRequired, {
                                    at: this.state.startLoc
                                });
                            }
                        } else {
                            this.parseClassId(e1, t, r);
                        }
                        super.parseClassSuper(e1);
                        e1.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e1.superClass, s);
                        return this.finishNode(e1, n);
                    }
                    parseExport(e1, t) {
                        const r = this.parsePlaceholder("Identifier");
                        if (!r) return super.parseExport(e1, t);
                        if (!this.isContextual(97) && !this.match(12)) {
                            e1.specifiers = [];
                            e1.source = null;
                            e1.declaration = this.finishPlaceholder(r, "Declaration");
                            return this.finishNode(e1, "ExportNamedDeclaration");
                        }
                        this.expectPlugin("exportDefaultFrom");
                        const n = this.startNode();
                        n.exported = r;
                        e1.specifiers = [
                            this.finishNode(n, "ExportDefaultSpecifier")
                        ];
                        return super.parseExport(e1, t);
                    }
                    isExportDefaultSpecifier() {
                        if (this.match(65)) {
                            const e1 = this.nextTokenStart();
                            if (this.isUnparsedContextual(e1, "from")) {
                                if (this.input.startsWith(tokenLabelName(142), this.nextTokenStartSince(e1 + 4))) {
                                    return true;
                                }
                            }
                        }
                        return super.isExportDefaultSpecifier();
                    }
                    maybeParseExportDefaultSpecifier(e1, t) {
                        var r;
                        if ((r = e1.specifiers) != null && r.length) {
                            return true;
                        }
                        return super.maybeParseExportDefaultSpecifier(e1, t);
                    }
                    checkExport(e1) {
                        const { specifiers: t } = e1;
                        if (t != null && t.length) {
                            e1.specifiers = t.filter((e1)=>e1.exported.type === "Placeholder");
                        }
                        super.checkExport(e1);
                        e1.specifiers = t;
                    }
                    parseImport(e1) {
                        const t = this.parsePlaceholder("Identifier");
                        if (!t) return super.parseImport(e1);
                        e1.specifiers = [];
                        if (!this.isContextual(97) && !this.match(12)) {
                            e1.source = this.finishPlaceholder(t, "StringLiteral");
                            this.semicolon();
                            return this.finishNode(e1, "ImportDeclaration");
                        }
                        const r = this.startNodeAtNode(t);
                        r.local = t;
                        e1.specifiers.push(this.finishNode(r, "ImportDefaultSpecifier"));
                        if (this.eat(12)) {
                            const t = this.maybeParseStarImportSpecifier(e1);
                            if (!t) this.parseNamedImportSpecifiers(e1);
                        }
                        this.expectContextual(97);
                        e1.source = this.parseImportSource();
                        this.semicolon();
                        return this.finishNode(e1, "ImportDeclaration");
                    }
                    parseImportSource() {
                        return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
                    }
                    assertNoSpace() {
                        if (this.state.start > this.state.lastTokEndLoc.index) {
                            this.raise(lt.UnexpectedSpace, {
                                at: this.state.lastTokEndLoc
                            });
                        }
                    }
                };
            var v8intrinsic = (e1)=>class V8IntrinsicMixin extends e1 {
                    parseV8Intrinsic() {
                        if (this.match(54)) {
                            const e1 = this.state.startLoc;
                            const t = this.startNode();
                            this.next();
                            if (tokenIsIdentifier(this.state.type)) {
                                const e1 = this.parseIdentifierName();
                                const r = this.createIdentifier(t, e1);
                                r.type = "V8IntrinsicIdentifier";
                                if (this.match(10)) {
                                    return r;
                                }
                            }
                            this.unexpected(e1);
                        }
                    }
                    parseExprAtom(e1) {
                        return this.parseV8Intrinsic() || super.parseExprAtom(e1);
                    }
                };
            function hasPlugin(e1, t) {
                const [r, n] = typeof t === "string" ? [
                    t,
                    {}
                ] : t;
                const s = Object.keys(n);
                const i = s.length === 0;
                return e1.some((e1)=>{
                    if (typeof e1 === "string") {
                        return i && e1 === r;
                    } else {
                        const [t, i] = e1;
                        if (t !== r) {
                            return false;
                        }
                        for (const e1 of s){
                            if (i[e1] !== n[e1]) {
                                return false;
                            }
                        }
                        return true;
                    }
                });
            }
            function getPluginOption(e1, t, r) {
                const n = e1.find((e1)=>{
                    if (Array.isArray(e1)) {
                        return e1[0] === t;
                    } else {
                        return e1 === t;
                    }
                });
                if (n && Array.isArray(n) && n.length > 1) {
                    return n[1][r];
                }
                return null;
            }
            const ct = [
                "minimal",
                "fsharp",
                "hack",
                "smart"
            ];
            const ut = [
                "^^",
                "@@",
                "^",
                "%",
                "#"
            ];
            const pt = [
                "hash",
                "bar"
            ];
            function validatePlugins(e1) {
                if (hasPlugin(e1, "decorators")) {
                    if (hasPlugin(e1, "decorators-legacy")) {
                        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
                    }
                    const t = getPluginOption(e1, "decorators", "decoratorsBeforeExport");
                    if (t != null && typeof t !== "boolean") {
                        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
                    }
                    const r = getPluginOption(e1, "decorators", "allowCallParenthesized");
                    if (r != null && typeof r !== "boolean") {
                        throw new Error("'allowCallParenthesized' must be a boolean.");
                    }
                }
                if (hasPlugin(e1, "flow") && hasPlugin(e1, "typescript")) {
                    throw new Error("Cannot combine flow and typescript plugins.");
                }
                if (hasPlugin(e1, "placeholders") && hasPlugin(e1, "v8intrinsic")) {
                    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
                }
                if (hasPlugin(e1, "pipelineOperator")) {
                    const t = getPluginOption(e1, "pipelineOperator", "proposal");
                    if (!ct.includes(t)) {
                        const e1 = ct.map((e1)=>`"${e1}"`).join(", ");
                        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e1}.`);
                    }
                    const r = hasPlugin(e1, [
                        "recordAndTuple",
                        {
                            syntaxType: "hash"
                        }
                    ]);
                    if (t === "hack") {
                        if (hasPlugin(e1, "placeholders")) {
                            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                        }
                        if (hasPlugin(e1, "v8intrinsic")) {
                            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                        }
                        const t = getPluginOption(e1, "pipelineOperator", "topicToken");
                        if (!ut.includes(t)) {
                            const e1 = ut.map((e1)=>`"${e1}"`).join(", ");
                            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e1}.`);
                        }
                        if (t === "#" && r) {
                            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
                        }
                    } else if (t === "smart" && r) {
                        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
                    }
                }
                if (hasPlugin(e1, "moduleAttributes")) {
                    {
                        if (hasPlugin(e1, "importAssertions") || hasPlugin(e1, "importAttributes")) {
                            throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
                        }
                        const t = getPluginOption(e1, "moduleAttributes", "version");
                        if (t !== "may-2020") {
                            throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
                        }
                    }
                }
                if (hasPlugin(e1, "importAssertions") && hasPlugin(e1, "importAttributes")) {
                    throw new Error("Cannot combine importAssertions and importAttributes plugins.");
                }
                if (hasPlugin(e1, "recordAndTuple") && getPluginOption(e1, "recordAndTuple", "syntaxType") != null && !pt.includes(getPluginOption(e1, "recordAndTuple", "syntaxType"))) {
                    throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + pt.map((e1)=>`'${e1}'`).join(", "));
                }
                if (hasPlugin(e1, "asyncDoExpressions") && !hasPlugin(e1, "doExpressions")) {
                    const e1 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
                    e1.missingPlugins = "doExpressions";
                    throw e1;
                }
            }
            const ft = {
                estree: estree,
                jsx: jsx,
                flow: flow,
                typescript: typescript,
                v8intrinsic: v8intrinsic,
                placeholders: placeholders
            };
            const dt = Object.keys(ft);
            const ht = {
                sourceType: "script",
                sourceFilename: undefined,
                startColumn: 0,
                startLine: 1,
                allowAwaitOutsideFunction: false,
                allowReturnOutsideFunction: false,
                allowNewTargetOutsideFunction: false,
                allowImportExportEverywhere: false,
                allowSuperOutsideMethod: false,
                allowUndeclaredExports: false,
                plugins: [],
                strictMode: null,
                ranges: false,
                tokens: false,
                createParenthesizedExpressions: false,
                errorRecovery: false,
                attachComment: true,
                annexB: true
            };
            function getOptions(e1) {
                if (e1 && e1.annexB != null && e1.annexB !== false) {
                    throw new Error("The `annexB` option can only be set to `false`.");
                }
                const t = {};
                for (const r of Object.keys(ht)){
                    t[r] = e1 && e1[r] != null ? e1[r] : ht[r];
                }
                return t;
            }
            class ExpressionParser extends LValParser {
                checkProto(e1, t, r, n) {
                    if (e1.type === "SpreadElement" || this.isObjectMethod(e1) || e1.computed || e1.shorthand) {
                        return;
                    }
                    const s = e1.key;
                    const i = s.type === "Identifier" ? s.name : s.value;
                    if (i === "__proto__") {
                        if (t) {
                            this.raise(p.RecordNoProto, {
                                at: s
                            });
                            return;
                        }
                        if (r.used) {
                            if (n) {
                                if (n.doubleProtoLoc === null) {
                                    n.doubleProtoLoc = s.loc.start;
                                }
                            } else {
                                this.raise(p.DuplicateProto, {
                                    at: s
                                });
                            }
                        }
                        r.used = true;
                    }
                }
                shouldExitDescending(e1, t) {
                    return e1.type === "ArrowFunctionExpression" && e1.start === t;
                }
                getExpression() {
                    this.enterInitialScopes();
                    this.nextToken();
                    const e1 = this.parseExpression();
                    if (!this.match(137)) {
                        this.unexpected();
                    }
                    this.finalizeRemainingComments();
                    e1.comments = this.state.comments;
                    e1.errors = this.state.errors;
                    if (this.options.tokens) {
                        e1.tokens = this.tokens;
                    }
                    return e1;
                }
                parseExpression(e1, t) {
                    if (e1) {
                        return this.disallowInAnd(()=>this.parseExpressionBase(t));
                    }
                    return this.allowInAnd(()=>this.parseExpressionBase(t));
                }
                parseExpressionBase(e1) {
                    const t = this.state.startLoc;
                    const r = this.parseMaybeAssign(e1);
                    if (this.match(12)) {
                        const n = this.startNodeAt(t);
                        n.expressions = [
                            r
                        ];
                        while(this.eat(12)){
                            n.expressions.push(this.parseMaybeAssign(e1));
                        }
                        this.toReferencedList(n.expressions);
                        return this.finishNode(n, "SequenceExpression");
                    }
                    return r;
                }
                parseMaybeAssignDisallowIn(e1, t) {
                    return this.disallowInAnd(()=>this.parseMaybeAssign(e1, t));
                }
                parseMaybeAssignAllowIn(e1, t) {
                    return this.allowInAnd(()=>this.parseMaybeAssign(e1, t));
                }
                setOptionalParametersError(e1, t) {
                    var r;
                    e1.optionalParametersLoc = (r = t == null ? void 0 : t.loc) != null ? r : this.state.startLoc;
                }
                parseMaybeAssign(e1, t) {
                    const r = this.state.startLoc;
                    if (this.isContextual(106)) {
                        if (this.prodParam.hasYield) {
                            let e1 = this.parseYield();
                            if (t) {
                                e1 = t.call(this, e1, r);
                            }
                            return e1;
                        }
                    }
                    let n;
                    if (e1) {
                        n = false;
                    } else {
                        e1 = new ExpressionErrors;
                        n = true;
                    }
                    const { type: s } = this.state;
                    if (s === 10 || tokenIsIdentifier(s)) {
                        this.state.potentialArrowAt = this.state.start;
                    }
                    let i = this.parseMaybeConditional(e1);
                    if (t) {
                        i = t.call(this, i, r);
                    }
                    if (tokenIsAssignment(this.state.type)) {
                        const t = this.startNodeAt(r);
                        const n = this.state.value;
                        t.operator = n;
                        if (this.match(29)) {
                            this.toAssignable(i, true);
                            t.left = i;
                            const n = r.index;
                            if (e1.doubleProtoLoc != null && e1.doubleProtoLoc.index >= n) {
                                e1.doubleProtoLoc = null;
                            }
                            if (e1.shorthandAssignLoc != null && e1.shorthandAssignLoc.index >= n) {
                                e1.shorthandAssignLoc = null;
                            }
                            if (e1.privateKeyLoc != null && e1.privateKeyLoc.index >= n) {
                                this.checkDestructuringPrivate(e1);
                                e1.privateKeyLoc = null;
                            }
                        } else {
                            t.left = i;
                        }
                        this.next();
                        t.right = this.parseMaybeAssign();
                        this.checkLVal(i, {
                            in: this.finishNode(t, "AssignmentExpression")
                        });
                        return t;
                    } else if (n) {
                        this.checkExpressionErrors(e1, true);
                    }
                    return i;
                }
                parseMaybeConditional(e1) {
                    const t = this.state.startLoc;
                    const r = this.state.potentialArrowAt;
                    const n = this.parseExprOps(e1);
                    if (this.shouldExitDescending(n, r)) {
                        return n;
                    }
                    return this.parseConditional(n, t, e1);
                }
                parseConditional(e1, t, r) {
                    if (this.eat(17)) {
                        const r = this.startNodeAt(t);
                        r.test = e1;
                        r.consequent = this.parseMaybeAssignAllowIn();
                        this.expect(14);
                        r.alternate = this.parseMaybeAssign();
                        return this.finishNode(r, "ConditionalExpression");
                    }
                    return e1;
                }
                parseMaybeUnaryOrPrivate(e1) {
                    return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(e1);
                }
                parseExprOps(e1) {
                    const t = this.state.startLoc;
                    const r = this.state.potentialArrowAt;
                    const n = this.parseMaybeUnaryOrPrivate(e1);
                    if (this.shouldExitDescending(n, r)) {
                        return n;
                    }
                    return this.parseExprOp(n, t, -1);
                }
                parseExprOp(e1, t, r) {
                    if (this.isPrivateName(e1)) {
                        const t = this.getPrivateNameSV(e1);
                        if (r >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
                            this.raise(p.PrivateInExpectedIn, {
                                at: e1,
                                identifierName: t
                            });
                        }
                        this.classScope.usePrivateName(t, e1.loc.start);
                    }
                    const n = this.state.type;
                    if (tokenIsOperator(n) && (this.prodParam.hasIn || !this.match(58))) {
                        let s = tokenOperatorPrecedence(n);
                        if (s > r) {
                            if (n === 39) {
                                this.expectPlugin("pipelineOperator");
                                if (this.state.inFSharpPipelineDirectBody) {
                                    return e1;
                                }
                                this.checkPipelineAtInfixOperator(e1, t);
                            }
                            const i = this.startNodeAt(t);
                            i.left = e1;
                            i.operator = this.state.value;
                            const a = n === 41 || n === 42;
                            const o = n === 40;
                            if (o) {
                                s = tokenOperatorPrecedence(42);
                            }
                            this.next();
                            if (n === 39 && this.hasPlugin([
                                "pipelineOperator",
                                {
                                    proposal: "minimal"
                                }
                            ])) {
                                if (this.state.type === 96 && this.prodParam.hasAwait) {
                                    throw this.raise(p.UnexpectedAwaitAfterPipelineBody, {
                                        at: this.state.startLoc
                                    });
                                }
                            }
                            i.right = this.parseExprOpRightExpr(n, s);
                            const l = this.finishNode(i, a || o ? "LogicalExpression" : "BinaryExpression");
                            const c = this.state.type;
                            if (o && (c === 41 || c === 42) || a && c === 40) {
                                throw this.raise(p.MixingCoalesceWithLogical, {
                                    at: this.state.startLoc
                                });
                            }
                            return this.parseExprOp(l, t, r);
                        }
                    }
                    return e1;
                }
                parseExprOpRightExpr(e1, t) {
                    const r = this.state.startLoc;
                    switch(e1){
                        case 39:
                            switch(this.getPluginOption("pipelineOperator", "proposal")){
                                case "hack":
                                    return this.withTopicBindingContext(()=>this.parseHackPipeBody());
                                case "smart":
                                    return this.withTopicBindingContext(()=>{
                                        if (this.prodParam.hasYield && this.isContextual(106)) {
                                            throw this.raise(p.PipeBodyIsTighter, {
                                                at: this.state.startLoc
                                            });
                                        }
                                        return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e1, t), r);
                                    });
                                case "fsharp":
                                    return this.withSoloAwaitPermittingContext(()=>this.parseFSharpPipelineBody(t));
                            }
                        default:
                            return this.parseExprOpBaseRightExpr(e1, t);
                    }
                }
                parseExprOpBaseRightExpr(e1, t) {
                    const r = this.state.startLoc;
                    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, tokenIsRightAssociative(e1) ? t - 1 : t);
                }
                parseHackPipeBody() {
                    var e1;
                    const { startLoc: t } = this.state;
                    const r = this.parseMaybeAssign();
                    const n = o.has(r.type);
                    if (n && !((e1 = r.extra) != null && e1.parenthesized)) {
                        this.raise(p.PipeUnparenthesizedBody, {
                            at: t,
                            type: r.type
                        });
                    }
                    if (!this.topicReferenceWasUsedInCurrentContext()) {
                        this.raise(p.PipeTopicUnused, {
                            at: t
                        });
                    }
                    return r;
                }
                checkExponentialAfterUnary(e1) {
                    if (this.match(57)) {
                        this.raise(p.UnexpectedTokenUnaryExponentiation, {
                            at: e1.argument
                        });
                    }
                }
                parseMaybeUnary(e1, t) {
                    const r = this.state.startLoc;
                    const n = this.isContextual(96);
                    if (n && this.isAwaitAllowed()) {
                        this.next();
                        const e1 = this.parseAwait(r);
                        if (!t) this.checkExponentialAfterUnary(e1);
                        return e1;
                    }
                    const s = this.match(34);
                    const i = this.startNode();
                    if (tokenIsPrefix(this.state.type)) {
                        i.operator = this.state.value;
                        i.prefix = true;
                        if (this.match(72)) {
                            this.expectPlugin("throwExpressions");
                        }
                        const r = this.match(89);
                        this.next();
                        i.argument = this.parseMaybeUnary(null, true);
                        this.checkExpressionErrors(e1, true);
                        if (this.state.strict && r) {
                            const e1 = i.argument;
                            if (e1.type === "Identifier") {
                                this.raise(p.StrictDelete, {
                                    at: i
                                });
                            } else if (this.hasPropertyAsPrivateName(e1)) {
                                this.raise(p.DeletePrivateField, {
                                    at: i
                                });
                            }
                        }
                        if (!s) {
                            if (!t) {
                                this.checkExponentialAfterUnary(i);
                            }
                            return this.finishNode(i, "UnaryExpression");
                        }
                    }
                    const a = this.parseUpdate(i, s, e1);
                    if (n) {
                        const { type: e1 } = this.state;
                        const t = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(e1) : tokenCanStartExpression(e1) && !this.match(54);
                        if (t && !this.isAmbiguousAwait()) {
                            this.raiseOverwrite(p.AwaitNotInAsyncContext, {
                                at: r
                            });
                            return this.parseAwait(r);
                        }
                    }
                    return a;
                }
                parseUpdate(e1, t, r) {
                    if (t) {
                        const t = e1;
                        this.checkLVal(t.argument, {
                            in: this.finishNode(t, "UpdateExpression")
                        });
                        return e1;
                    }
                    const n = this.state.startLoc;
                    let s = this.parseExprSubscripts(r);
                    if (this.checkExpressionErrors(r, false)) return s;
                    while(tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()){
                        const e1 = this.startNodeAt(n);
                        e1.operator = this.state.value;
                        e1.prefix = false;
                        e1.argument = s;
                        this.next();
                        this.checkLVal(s, {
                            in: s = this.finishNode(e1, "UpdateExpression")
                        });
                    }
                    return s;
                }
                parseExprSubscripts(e1) {
                    const t = this.state.startLoc;
                    const r = this.state.potentialArrowAt;
                    const n = this.parseExprAtom(e1);
                    if (this.shouldExitDescending(n, r)) {
                        return n;
                    }
                    return this.parseSubscripts(n, t);
                }
                parseSubscripts(e1, t, r) {
                    const n = {
                        optionalChainMember: false,
                        maybeAsyncArrow: this.atPossibleAsyncArrow(e1),
                        stop: false
                    };
                    do {
                        e1 = this.parseSubscript(e1, t, r, n);
                        n.maybeAsyncArrow = false;
                    }while (!n.stop)
                    return e1;
                }
                parseSubscript(e1, t, r, n) {
                    const { type: s } = this.state;
                    if (!r && s === 15) {
                        return this.parseBind(e1, t, r, n);
                    } else if (tokenIsTemplate(s)) {
                        return this.parseTaggedTemplateExpression(e1, t, n);
                    }
                    let i = false;
                    if (s === 18) {
                        if (r) {
                            this.raise(p.OptionalChainingNoNew, {
                                at: this.state.startLoc
                            });
                            if (this.lookaheadCharCode() === 40) {
                                n.stop = true;
                                return e1;
                            }
                        }
                        n.optionalChainMember = i = true;
                        this.next();
                    }
                    if (!r && this.match(10)) {
                        return this.parseCoverCallAndAsyncArrowHead(e1, t, n, i);
                    } else {
                        const r = this.eat(0);
                        if (r || i || this.eat(16)) {
                            return this.parseMember(e1, t, n, r, i);
                        } else {
                            n.stop = true;
                            return e1;
                        }
                    }
                }
                parseMember(e1, t, r, n, s) {
                    const i = this.startNodeAt(t);
                    i.object = e1;
                    i.computed = n;
                    if (n) {
                        i.property = this.parseExpression();
                        this.expect(3);
                    } else if (this.match(136)) {
                        if (e1.type === "Super") {
                            this.raise(p.SuperPrivateField, {
                                at: t
                            });
                        }
                        this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                        i.property = this.parsePrivateName();
                    } else {
                        i.property = this.parseIdentifier(true);
                    }
                    if (r.optionalChainMember) {
                        i.optional = s;
                        return this.finishNode(i, "OptionalMemberExpression");
                    } else {
                        return this.finishNode(i, "MemberExpression");
                    }
                }
                parseBind(e1, t, r, n) {
                    const s = this.startNodeAt(t);
                    s.object = e1;
                    this.next();
                    s.callee = this.parseNoCallExpr();
                    n.stop = true;
                    return this.parseSubscripts(this.finishNode(s, "BindExpression"), t, r);
                }
                parseCoverCallAndAsyncArrowHead(e1, t, r, n) {
                    const s = this.state.maybeInArrowParameters;
                    let i = null;
                    this.state.maybeInArrowParameters = true;
                    this.next();
                    const a = this.startNodeAt(t);
                    a.callee = e1;
                    const { maybeAsyncArrow: o, optionalChainMember: l } = r;
                    if (o) {
                        this.expressionScope.enter(newAsyncArrowScope());
                        i = new ExpressionErrors;
                    }
                    if (l) {
                        a.optional = n;
                    }
                    if (n) {
                        a.arguments = this.parseCallExpressionArguments(11);
                    } else {
                        a.arguments = this.parseCallExpressionArguments(11, e1.type === "Import", e1.type !== "Super", a, i);
                    }
                    let c = this.finishCallExpression(a, l);
                    if (o && this.shouldParseAsyncArrow() && !n) {
                        r.stop = true;
                        this.checkDestructuringPrivate(i);
                        this.expressionScope.validateAsPattern();
                        this.expressionScope.exit();
                        c = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t), c);
                    } else {
                        if (o) {
                            this.checkExpressionErrors(i, true);
                            this.expressionScope.exit();
                        }
                        this.toReferencedArguments(c);
                    }
                    this.state.maybeInArrowParameters = s;
                    return c;
                }
                toReferencedArguments(e1, t) {
                    this.toReferencedListDeep(e1.arguments, t);
                }
                parseTaggedTemplateExpression(e1, t, r) {
                    const n = this.startNodeAt(t);
                    n.tag = e1;
                    n.quasi = this.parseTemplate(true);
                    if (r.optionalChainMember) {
                        this.raise(p.OptionalChainingNoTemplate, {
                            at: t
                        });
                    }
                    return this.finishNode(n, "TaggedTemplateExpression");
                }
                atPossibleAsyncArrow(e1) {
                    return e1.type === "Identifier" && e1.name === "async" && this.state.lastTokEndLoc.index === e1.end && !this.canInsertSemicolon() && e1.end - e1.start === 5 && e1.start === this.state.potentialArrowAt;
                }
                expectImportAttributesPlugin() {
                    if (!this.hasPlugin("importAssertions")) {
                        this.expectPlugin("importAttributes");
                    }
                }
                finishCallExpression(e1, t) {
                    if (e1.callee.type === "Import") {
                        if (e1.arguments.length === 2) {
                            {
                                if (!this.hasPlugin("moduleAttributes")) {
                                    this.expectImportAttributesPlugin();
                                }
                            }
                        }
                        if (e1.arguments.length === 0 || e1.arguments.length > 2) {
                            this.raise(p.ImportCallArity, {
                                at: e1,
                                maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
                            });
                        } else {
                            for (const t of e1.arguments){
                                if (t.type === "SpreadElement") {
                                    this.raise(p.ImportCallSpreadArgument, {
                                        at: t
                                    });
                                }
                            }
                        }
                    }
                    return this.finishNode(e1, t ? "OptionalCallExpression" : "CallExpression");
                }
                parseCallExpressionArguments(e1, t, r, n, s) {
                    const i = [];
                    let a = true;
                    const o = this.state.inFSharpPipelineDirectBody;
                    this.state.inFSharpPipelineDirectBody = false;
                    while(!this.eat(e1)){
                        if (a) {
                            a = false;
                        } else {
                            this.expect(12);
                            if (this.match(e1)) {
                                if (t && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                                    this.raise(p.ImportCallArgumentTrailingComma, {
                                        at: this.state.lastTokStartLoc
                                    });
                                }
                                if (n) {
                                    this.addTrailingCommaExtraToNode(n);
                                }
                                this.next();
                                break;
                            }
                        }
                        i.push(this.parseExprListItem(false, s, r));
                    }
                    this.state.inFSharpPipelineDirectBody = o;
                    return i;
                }
                shouldParseAsyncArrow() {
                    return this.match(19) && !this.canInsertSemicolon();
                }
                parseAsyncArrowFromCallExpression(e1, t) {
                    var r;
                    this.resetPreviousNodeTrailingComments(t);
                    this.expect(19);
                    this.parseArrowExpression(e1, t.arguments, true, (r = t.extra) == null ? void 0 : r.trailingCommaLoc);
                    if (t.innerComments) {
                        setInnerComments(e1, t.innerComments);
                    }
                    if (t.callee.trailingComments) {
                        setInnerComments(e1, t.callee.trailingComments);
                    }
                    return e1;
                }
                parseNoCallExpr() {
                    const e1 = this.state.startLoc;
                    return this.parseSubscripts(this.parseExprAtom(), e1, true);
                }
                parseExprAtom(e1) {
                    let t;
                    let r = null;
                    const { type: n } = this.state;
                    switch(n){
                        case 79:
                            return this.parseSuper();
                        case 83:
                            t = this.startNode();
                            this.next();
                            if (this.match(16)) {
                                return this.parseImportMetaProperty(t);
                            }
                            if (!this.match(10)) {
                                this.raise(p.UnsupportedImport, {
                                    at: this.state.lastTokStartLoc
                                });
                            }
                            return this.finishNode(t, "Import");
                        case 78:
                            t = this.startNode();
                            this.next();
                            return this.finishNode(t, "ThisExpression");
                        case 90:
                            {
                                return this.parseDo(this.startNode(), false);
                            }
                        case 56:
                        case 31:
                            {
                                this.readRegexp();
                                return this.parseRegExpLiteral(this.state.value);
                            }
                        case 132:
                            return this.parseNumericLiteral(this.state.value);
                        case 133:
                            return this.parseBigIntLiteral(this.state.value);
                        case 134:
                            return this.parseDecimalLiteral(this.state.value);
                        case 131:
                            return this.parseStringLiteral(this.state.value);
                        case 84:
                            return this.parseNullLiteral();
                        case 85:
                            return this.parseBooleanLiteral(true);
                        case 86:
                            return this.parseBooleanLiteral(false);
                        case 10:
                            {
                                const e1 = this.state.potentialArrowAt === this.state.start;
                                return this.parseParenAndDistinguishExpression(e1);
                            }
                        case 2:
                        case 1:
                            {
                                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
                            }
                        case 0:
                            {
                                return this.parseArrayLike(3, true, false, e1);
                            }
                        case 6:
                        case 7:
                            {
                                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
                            }
                        case 5:
                            {
                                return this.parseObjectLike(8, false, false, e1);
                            }
                        case 68:
                            return this.parseFunctionOrFunctionSent();
                        case 26:
                            r = this.parseDecorators();
                        case 80:
                            return this.parseClass(this.maybeTakeDecorators(r, this.startNode()), false);
                        case 77:
                            return this.parseNewOrNewTarget();
                        case 25:
                        case 24:
                            return this.parseTemplate(false);
                        case 15:
                            {
                                t = this.startNode();
                                this.next();
                                t.object = null;
                                const e1 = t.callee = this.parseNoCallExpr();
                                if (e1.type === "MemberExpression") {
                                    return this.finishNode(t, "BindExpression");
                                } else {
                                    throw this.raise(p.UnsupportedBind, {
                                        at: e1
                                    });
                                }
                            }
                        case 136:
                            {
                                this.raise(p.PrivateInExpectedIn, {
                                    at: this.state.startLoc,
                                    identifierName: this.state.value
                                });
                                return this.parsePrivateName();
                            }
                        case 33:
                            {
                                return this.parseTopicReferenceThenEqualsSign(54, "%");
                            }
                        case 32:
                            {
                                return this.parseTopicReferenceThenEqualsSign(44, "^");
                            }
                        case 37:
                        case 38:
                            {
                                return this.parseTopicReference("hack");
                            }
                        case 44:
                        case 54:
                        case 27:
                            {
                                const e1 = this.getPluginOption("pipelineOperator", "proposal");
                                if (e1) {
                                    return this.parseTopicReference(e1);
                                }
                                this.unexpected();
                                break;
                            }
                        case 47:
                            {
                                const e1 = this.input.codePointAt(this.nextTokenStart());
                                if (isIdentifierStart(e1) || e1 === 62) {
                                    this.expectOnePlugin([
                                        "jsx",
                                        "flow",
                                        "typescript"
                                    ]);
                                } else {
                                    this.unexpected();
                                }
                                break;
                            }
                        default:
                            if (tokenIsIdentifier(n)) {
                                if (this.isContextual(125) && this.lookaheadInLineCharCode() === 123) {
                                    return this.parseModuleExpression();
                                }
                                const e1 = this.state.potentialArrowAt === this.state.start;
                                const t = this.state.containsEsc;
                                const r = this.parseIdentifier();
                                if (!t && r.name === "async" && !this.canInsertSemicolon()) {
                                    const { type: e1 } = this.state;
                                    if (e1 === 68) {
                                        this.resetPreviousNodeTrailingComments(r);
                                        this.next();
                                        return this.parseAsyncFunctionExpression(this.startNodeAtNode(r));
                                    } else if (tokenIsIdentifier(e1)) {
                                        if (this.lookaheadCharCode() === 61) {
                                            return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(r));
                                        } else {
                                            return r;
                                        }
                                    } else if (e1 === 90) {
                                        this.resetPreviousNodeTrailingComments(r);
                                        return this.parseDo(this.startNodeAtNode(r), true);
                                    }
                                }
                                if (e1 && this.match(19) && !this.canInsertSemicolon()) {
                                    this.next();
                                    return this.parseArrowExpression(this.startNodeAtNode(r), [
                                        r
                                    ], false);
                                }
                                return r;
                            } else {
                                this.unexpected();
                            }
                    }
                }
                parseTopicReferenceThenEqualsSign(e1, t) {
                    const r = this.getPluginOption("pipelineOperator", "proposal");
                    if (r) {
                        this.state.type = e1;
                        this.state.value = t;
                        this.state.pos--;
                        this.state.end--;
                        this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
                        return this.parseTopicReference(r);
                    } else {
                        this.unexpected();
                    }
                }
                parseTopicReference(e1) {
                    const t = this.startNode();
                    const r = this.state.startLoc;
                    const n = this.state.type;
                    this.next();
                    return this.finishTopicReference(t, r, e1, n);
                }
                finishTopicReference(e1, t, r, n) {
                    if (this.testTopicReferenceConfiguration(r, t, n)) {
                        const n = r === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
                        if (!this.topicReferenceIsAllowedInCurrentContext()) {
                            this.raise(r === "smart" ? p.PrimaryTopicNotAllowed : p.PipeTopicUnbound, {
                                at: t
                            });
                        }
                        this.registerTopicReference();
                        return this.finishNode(e1, n);
                    } else {
                        throw this.raise(p.PipeTopicUnconfiguredToken, {
                            at: t,
                            token: tokenLabelName(n)
                        });
                    }
                }
                testTopicReferenceConfiguration(e1, t, r) {
                    switch(e1){
                        case "hack":
                            {
                                return this.hasPlugin([
                                    "pipelineOperator",
                                    {
                                        topicToken: tokenLabelName(r)
                                    }
                                ]);
                            }
                        case "smart":
                            return r === 27;
                        default:
                            throw this.raise(p.PipeTopicRequiresHackPipes, {
                                at: t
                            });
                    }
                }
                parseAsyncArrowUnaryFunction(e1) {
                    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
                    const t = [
                        this.parseIdentifier()
                    ];
                    this.prodParam.exit();
                    if (this.hasPrecedingLineBreak()) {
                        this.raise(p.LineTerminatorBeforeArrow, {
                            at: this.state.curPosition()
                        });
                    }
                    this.expect(19);
                    return this.parseArrowExpression(e1, t, true);
                }
                parseDo(e1, t) {
                    this.expectPlugin("doExpressions");
                    if (t) {
                        this.expectPlugin("asyncDoExpressions");
                    }
                    e1.async = t;
                    this.next();
                    const r = this.state.labels;
                    this.state.labels = [];
                    if (t) {
                        this.prodParam.enter(Ye);
                        e1.body = this.parseBlock();
                        this.prodParam.exit();
                    } else {
                        e1.body = this.parseBlock();
                    }
                    this.state.labels = r;
                    return this.finishNode(e1, "DoExpression");
                }
                parseSuper() {
                    const e1 = this.startNode();
                    this.next();
                    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
                        this.raise(p.SuperNotAllowed, {
                            at: e1
                        });
                    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
                        this.raise(p.UnexpectedSuper, {
                            at: e1
                        });
                    }
                    if (!this.match(10) && !this.match(0) && !this.match(16)) {
                        this.raise(p.UnsupportedSuper, {
                            at: e1
                        });
                    }
                    return this.finishNode(e1, "Super");
                }
                parsePrivateName() {
                    const e1 = this.startNode();
                    const t = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
                    const r = this.state.value;
                    this.next();
                    e1.id = this.createIdentifier(t, r);
                    return this.finishNode(e1, "PrivateName");
                }
                parseFunctionOrFunctionSent() {
                    const e1 = this.startNode();
                    this.next();
                    if (this.prodParam.hasYield && this.match(16)) {
                        const t = this.createIdentifier(this.startNodeAtNode(e1), "function");
                        this.next();
                        if (this.match(102)) {
                            this.expectPlugin("functionSent");
                        } else if (!this.hasPlugin("functionSent")) {
                            this.unexpected();
                        }
                        return this.parseMetaProperty(e1, t, "sent");
                    }
                    return this.parseFunction(e1);
                }
                parseMetaProperty(e1, t, r) {
                    e1.meta = t;
                    const n = this.state.containsEsc;
                    e1.property = this.parseIdentifier(true);
                    if (e1.property.name !== r || n) {
                        this.raise(p.UnsupportedMetaProperty, {
                            at: e1.property,
                            target: t.name,
                            onlyValidPropertyName: r
                        });
                    }
                    return this.finishNode(e1, "MetaProperty");
                }
                parseImportMetaProperty(e1) {
                    const t = this.createIdentifier(this.startNodeAtNode(e1), "import");
                    this.next();
                    if (this.isContextual(100)) {
                        if (!this.inModule) {
                            this.raise(p.ImportMetaOutsideModule, {
                                at: t
                            });
                        }
                        this.sawUnambiguousESM = true;
                    }
                    return this.parseMetaProperty(e1, t, "meta");
                }
                parseLiteralAtNode(e1, t, r) {
                    this.addExtra(r, "rawValue", e1);
                    this.addExtra(r, "raw", this.input.slice(r.start, this.state.end));
                    r.value = e1;
                    this.next();
                    return this.finishNode(r, t);
                }
                parseLiteral(e1, t) {
                    const r = this.startNode();
                    return this.parseLiteralAtNode(e1, t, r);
                }
                parseStringLiteral(e1) {
                    return this.parseLiteral(e1, "StringLiteral");
                }
                parseNumericLiteral(e1) {
                    return this.parseLiteral(e1, "NumericLiteral");
                }
                parseBigIntLiteral(e1) {
                    return this.parseLiteral(e1, "BigIntLiteral");
                }
                parseDecimalLiteral(e1) {
                    return this.parseLiteral(e1, "DecimalLiteral");
                }
                parseRegExpLiteral(e1) {
                    const t = this.parseLiteral(e1.value, "RegExpLiteral");
                    t.pattern = e1.pattern;
                    t.flags = e1.flags;
                    return t;
                }
                parseBooleanLiteral(e1) {
                    const t = this.startNode();
                    t.value = e1;
                    this.next();
                    return this.finishNode(t, "BooleanLiteral");
                }
                parseNullLiteral() {
                    const e1 = this.startNode();
                    this.next();
                    return this.finishNode(e1, "NullLiteral");
                }
                parseParenAndDistinguishExpression(e1) {
                    const t = this.state.startLoc;
                    let r;
                    this.next();
                    this.expressionScope.enter(newArrowHeadScope());
                    const n = this.state.maybeInArrowParameters;
                    const s = this.state.inFSharpPipelineDirectBody;
                    this.state.maybeInArrowParameters = true;
                    this.state.inFSharpPipelineDirectBody = false;
                    const i = this.state.startLoc;
                    const a = [];
                    const o = new ExpressionErrors;
                    let l = true;
                    let c;
                    let u;
                    while(!this.match(11)){
                        if (l) {
                            l = false;
                        } else {
                            this.expect(12, o.optionalParametersLoc === null ? null : o.optionalParametersLoc);
                            if (this.match(11)) {
                                u = this.state.startLoc;
                                break;
                            }
                        }
                        if (this.match(21)) {
                            const e1 = this.state.startLoc;
                            c = this.state.startLoc;
                            a.push(this.parseParenItem(this.parseRestBinding(), e1));
                            if (!this.checkCommaAfterRest(41)) {
                                break;
                            }
                        } else {
                            a.push(this.parseMaybeAssignAllowIn(o, this.parseParenItem));
                        }
                    }
                    const p = this.state.lastTokEndLoc;
                    this.expect(11);
                    this.state.maybeInArrowParameters = n;
                    this.state.inFSharpPipelineDirectBody = s;
                    let f = this.startNodeAt(t);
                    if (e1 && this.shouldParseArrow(a) && (f = this.parseArrow(f))) {
                        this.checkDestructuringPrivate(o);
                        this.expressionScope.validateAsPattern();
                        this.expressionScope.exit();
                        this.parseArrowExpression(f, a, false);
                        return f;
                    }
                    this.expressionScope.exit();
                    if (!a.length) {
                        this.unexpected(this.state.lastTokStartLoc);
                    }
                    if (u) this.unexpected(u);
                    if (c) this.unexpected(c);
                    this.checkExpressionErrors(o, true);
                    this.toReferencedListDeep(a, true);
                    if (a.length > 1) {
                        r = this.startNodeAt(i);
                        r.expressions = a;
                        this.finishNode(r, "SequenceExpression");
                        this.resetEndLocation(r, p);
                    } else {
                        r = a[0];
                    }
                    return this.wrapParenthesis(t, r);
                }
                wrapParenthesis(e1, t) {
                    if (!this.options.createParenthesizedExpressions) {
                        this.addExtra(t, "parenthesized", true);
                        this.addExtra(t, "parenStart", e1.index);
                        this.takeSurroundingComments(t, e1.index, this.state.lastTokEndLoc.index);
                        return t;
                    }
                    const r = this.startNodeAt(e1);
                    r.expression = t;
                    return this.finishNode(r, "ParenthesizedExpression");
                }
                shouldParseArrow(e1) {
                    return !this.canInsertSemicolon();
                }
                parseArrow(e1) {
                    if (this.eat(19)) {
                        return e1;
                    }
                }
                parseParenItem(e1, t) {
                    return e1;
                }
                parseNewOrNewTarget() {
                    const e1 = this.startNode();
                    this.next();
                    if (this.match(16)) {
                        const t = this.createIdentifier(this.startNodeAtNode(e1), "new");
                        this.next();
                        const r = this.parseMetaProperty(e1, t, "target");
                        if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {
                            this.raise(p.UnexpectedNewTarget, {
                                at: r
                            });
                        }
                        return r;
                    }
                    return this.parseNew(e1);
                }
                parseNew(e1) {
                    this.parseNewCallee(e1);
                    if (this.eat(10)) {
                        const t = this.parseExprList(11);
                        this.toReferencedList(t);
                        e1.arguments = t;
                    } else {
                        e1.arguments = [];
                    }
                    return this.finishNode(e1, "NewExpression");
                }
                parseNewCallee(e1) {
                    e1.callee = this.parseNoCallExpr();
                    if (e1.callee.type === "Import") {
                        this.raise(p.ImportCallNotNewExpression, {
                            at: e1.callee
                        });
                    }
                }
                parseTemplateElement(e1) {
                    const { start: t, startLoc: r, end: n, value: s } = this.state;
                    const i = t + 1;
                    const a = this.startNodeAt(createPositionWithColumnOffset(r, 1));
                    if (s === null) {
                        if (!e1) {
                            this.raise(p.InvalidEscapeSequenceTemplate, {
                                at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)
                            });
                        }
                    }
                    const o = this.match(24);
                    const l = o ? -1 : -2;
                    const c = n + l;
                    a.value = {
                        raw: this.input.slice(i, c).replace(/\r\n?/g, "\n"),
                        cooked: s === null ? null : s.slice(1, l)
                    };
                    a.tail = o;
                    this.next();
                    const u = this.finishNode(a, "TemplateElement");
                    this.resetEndLocation(u, createPositionWithColumnOffset(this.state.lastTokEndLoc, l));
                    return u;
                }
                parseTemplate(e1) {
                    const t = this.startNode();
                    t.expressions = [];
                    let r = this.parseTemplateElement(e1);
                    t.quasis = [
                        r
                    ];
                    while(!r.tail){
                        t.expressions.push(this.parseTemplateSubstitution());
                        this.readTemplateContinuation();
                        t.quasis.push(r = this.parseTemplateElement(e1));
                    }
                    return this.finishNode(t, "TemplateLiteral");
                }
                parseTemplateSubstitution() {
                    return this.parseExpression();
                }
                parseObjectLike(e1, t, r, n) {
                    if (r) {
                        this.expectPlugin("recordAndTuple");
                    }
                    const s = this.state.inFSharpPipelineDirectBody;
                    this.state.inFSharpPipelineDirectBody = false;
                    const i = Object.create(null);
                    let a = true;
                    const o = this.startNode();
                    o.properties = [];
                    this.next();
                    while(!this.match(e1)){
                        if (a) {
                            a = false;
                        } else {
                            this.expect(12);
                            if (this.match(e1)) {
                                this.addTrailingCommaExtraToNode(o);
                                break;
                            }
                        }
                        let s;
                        if (t) {
                            s = this.parseBindingProperty();
                        } else {
                            s = this.parsePropertyDefinition(n);
                            this.checkProto(s, r, i, n);
                        }
                        if (r && !this.isObjectProperty(s) && s.type !== "SpreadElement") {
                            this.raise(p.InvalidRecordProperty, {
                                at: s
                            });
                        }
                        if (s.shorthand) {
                            this.addExtra(s, "shorthand", true);
                        }
                        o.properties.push(s);
                    }
                    this.next();
                    this.state.inFSharpPipelineDirectBody = s;
                    let l = "ObjectExpression";
                    if (t) {
                        l = "ObjectPattern";
                    } else if (r) {
                        l = "RecordExpression";
                    }
                    return this.finishNode(o, l);
                }
                addTrailingCommaExtraToNode(e1) {
                    this.addExtra(e1, "trailingComma", this.state.lastTokStart);
                    this.addExtra(e1, "trailingCommaLoc", this.state.lastTokStartLoc, false);
                }
                maybeAsyncOrAccessorProp(e1) {
                    return !e1.computed && e1.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
                }
                parsePropertyDefinition(e1) {
                    let t = [];
                    if (this.match(26)) {
                        if (this.hasPlugin("decorators")) {
                            this.raise(p.UnsupportedPropertyDecorator, {
                                at: this.state.startLoc
                            });
                        }
                        while(this.match(26)){
                            t.push(this.parseDecorator());
                        }
                    }
                    const r = this.startNode();
                    let n = false;
                    let s = false;
                    let i;
                    if (this.match(21)) {
                        if (t.length) this.unexpected();
                        return this.parseSpread();
                    }
                    if (t.length) {
                        r.decorators = t;
                        t = [];
                    }
                    r.method = false;
                    if (e1) {
                        i = this.state.startLoc;
                    }
                    let a = this.eat(55);
                    this.parsePropertyNamePrefixOperator(r);
                    const o = this.state.containsEsc;
                    const l = this.parsePropertyName(r, e1);
                    if (!a && !o && this.maybeAsyncOrAccessorProp(r)) {
                        const e1 = l.name;
                        if (e1 === "async" && !this.hasPrecedingLineBreak()) {
                            n = true;
                            this.resetPreviousNodeTrailingComments(l);
                            a = this.eat(55);
                            this.parsePropertyName(r);
                        }
                        if (e1 === "get" || e1 === "set") {
                            s = true;
                            this.resetPreviousNodeTrailingComments(l);
                            r.kind = e1;
                            if (this.match(55)) {
                                a = true;
                                this.raise(p.AccessorIsGenerator, {
                                    at: this.state.curPosition(),
                                    kind: e1
                                });
                                this.next();
                            }
                            this.parsePropertyName(r);
                        }
                    }
                    return this.parseObjPropValue(r, i, a, n, false, s, e1);
                }
                getGetterSetterExpectedParamCount(e1) {
                    return e1.kind === "get" ? 0 : 1;
                }
                getObjectOrClassMethodParams(e1) {
                    return e1.params;
                }
                checkGetterSetterParams(e1) {
                    var t;
                    const r = this.getGetterSetterExpectedParamCount(e1);
                    const n = this.getObjectOrClassMethodParams(e1);
                    if (n.length !== r) {
                        this.raise(e1.kind === "get" ? p.BadGetterArity : p.BadSetterArity, {
                            at: e1
                        });
                    }
                    if (e1.kind === "set" && ((t = n[n.length - 1]) == null ? void 0 : t.type) === "RestElement") {
                        this.raise(p.BadSetterRestParameter, {
                            at: e1
                        });
                    }
                }
                parseObjectMethod(e1, t, r, n, s) {
                    if (s) {
                        const r = this.parseMethod(e1, t, false, false, false, "ObjectMethod");
                        this.checkGetterSetterParams(r);
                        return r;
                    }
                    if (r || t || this.match(10)) {
                        if (n) this.unexpected();
                        e1.kind = "method";
                        e1.method = true;
                        return this.parseMethod(e1, t, r, false, false, "ObjectMethod");
                    }
                }
                parseObjectProperty(e1, t, r, n) {
                    e1.shorthand = false;
                    if (this.eat(14)) {
                        e1.value = r ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n);
                        return this.finishNode(e1, "ObjectProperty");
                    }
                    if (!e1.computed && e1.key.type === "Identifier") {
                        this.checkReservedWord(e1.key.name, e1.key.loc.start, true, false);
                        if (r) {
                            e1.value = this.parseMaybeDefault(t, cloneIdentifier(e1.key));
                        } else if (this.match(29)) {
                            const r = this.state.startLoc;
                            if (n != null) {
                                if (n.shorthandAssignLoc === null) {
                                    n.shorthandAssignLoc = r;
                                }
                            } else {
                                this.raise(p.InvalidCoverInitializedName, {
                                    at: r
                                });
                            }
                            e1.value = this.parseMaybeDefault(t, cloneIdentifier(e1.key));
                        } else {
                            e1.value = cloneIdentifier(e1.key);
                        }
                        e1.shorthand = true;
                        return this.finishNode(e1, "ObjectProperty");
                    }
                }
                parseObjPropValue(e1, t, r, n, s, i, a) {
                    const o = this.parseObjectMethod(e1, r, n, s, i) || this.parseObjectProperty(e1, t, s, a);
                    if (!o) this.unexpected();
                    return o;
                }
                parsePropertyName(e1, t) {
                    if (this.eat(0)) {
                        e1.computed = true;
                        e1.key = this.parseMaybeAssignAllowIn();
                        this.expect(3);
                    } else {
                        const { type: r, value: n } = this.state;
                        let s;
                        if (tokenIsKeywordOrIdentifier(r)) {
                            s = this.parseIdentifier(true);
                        } else {
                            switch(r){
                                case 132:
                                    s = this.parseNumericLiteral(n);
                                    break;
                                case 131:
                                    s = this.parseStringLiteral(n);
                                    break;
                                case 133:
                                    s = this.parseBigIntLiteral(n);
                                    break;
                                case 134:
                                    s = this.parseDecimalLiteral(n);
                                    break;
                                case 136:
                                    {
                                        const e1 = this.state.startLoc;
                                        if (t != null) {
                                            if (t.privateKeyLoc === null) {
                                                t.privateKeyLoc = e1;
                                            }
                                        } else {
                                            this.raise(p.UnexpectedPrivateField, {
                                                at: e1
                                            });
                                        }
                                        s = this.parsePrivateName();
                                        break;
                                    }
                                default:
                                    this.unexpected();
                            }
                        }
                        e1.key = s;
                        if (r !== 136) {
                            e1.computed = false;
                        }
                    }
                    return e1.key;
                }
                initFunction(e1, t) {
                    e1.id = null;
                    e1.generator = false;
                    e1.async = t;
                }
                parseMethod(e1, t, r, n, s, i, a = false) {
                    this.initFunction(e1, r);
                    e1.generator = t;
                    this.scope.enter(V | q | (a ? G : 0) | (s ? H : 0));
                    this.prodParam.enter(functionFlags(r, e1.generator));
                    this.parseFunctionParams(e1, n);
                    const o = this.parseFunctionBodyAndFinish(e1, i, true);
                    this.prodParam.exit();
                    this.scope.exit();
                    return o;
                }
                parseArrayLike(e1, t, r, n) {
                    if (r) {
                        this.expectPlugin("recordAndTuple");
                    }
                    const s = this.state.inFSharpPipelineDirectBody;
                    this.state.inFSharpPipelineDirectBody = false;
                    const i = this.startNode();
                    this.next();
                    i.elements = this.parseExprList(e1, !r, n, i);
                    this.state.inFSharpPipelineDirectBody = s;
                    return this.finishNode(i, r ? "TupleExpression" : "ArrayExpression");
                }
                parseArrowExpression(e1, t, r, n) {
                    this.scope.enter(V | W);
                    let s = functionFlags(r, false);
                    if (!this.match(5) && this.prodParam.hasIn) {
                        s |= Ze;
                    }
                    this.prodParam.enter(s);
                    this.initFunction(e1, r);
                    const i = this.state.maybeInArrowParameters;
                    if (t) {
                        this.state.maybeInArrowParameters = true;
                        this.setArrowFunctionParameters(e1, t, n);
                    }
                    this.state.maybeInArrowParameters = false;
                    this.parseFunctionBody(e1, true);
                    this.prodParam.exit();
                    this.scope.exit();
                    this.state.maybeInArrowParameters = i;
                    return this.finishNode(e1, "ArrowFunctionExpression");
                }
                setArrowFunctionParameters(e1, t, r) {
                    this.toAssignableList(t, r, false);
                    e1.params = t;
                }
                parseFunctionBodyAndFinish(e1, t, r = false) {
                    this.parseFunctionBody(e1, false, r);
                    return this.finishNode(e1, t);
                }
                parseFunctionBody(e1, t, r = false) {
                    const n = t && !this.match(5);
                    this.expressionScope.enter(newExpressionScope());
                    if (n) {
                        e1.body = this.parseMaybeAssign();
                        this.checkParams(e1, false, t, false);
                    } else {
                        const n = this.state.strict;
                        const s = this.state.labels;
                        this.state.labels = [];
                        this.prodParam.enter(this.prodParam.currentFlags() | Qe);
                        e1.body = this.parseBlock(true, false, (s)=>{
                            const i = !this.isSimpleParamList(e1.params);
                            if (s && i) {
                                this.raise(p.IllegalLanguageModeDirective, {
                                    at: (e1.kind === "method" || e1.kind === "constructor") && !!e1.key ? e1.key.loc.end : e1
                                });
                            }
                            const a = !n && this.state.strict;
                            this.checkParams(e1, !this.state.strict && !t && !r && !i, t, a);
                            if (this.state.strict && e1.id) {
                                this.checkIdentifier(e1.id, Se, a);
                            }
                        });
                        this.prodParam.exit();
                        this.state.labels = s;
                    }
                    this.expressionScope.exit();
                }
                isSimpleParameter(e1) {
                    return e1.type === "Identifier";
                }
                isSimpleParamList(e1) {
                    for(let t = 0, r = e1.length; t < r; t++){
                        if (!this.isSimpleParameter(e1[t])) return false;
                    }
                    return true;
                }
                checkParams(e1, t, r, n = true) {
                    const s = !t && new Set;
                    const i = {
                        type: "FormalParameters"
                    };
                    for (const t of e1.params){
                        this.checkLVal(t, {
                            in: i,
                            binding: de,
                            checkClashes: s,
                            strictModeChanged: n
                        });
                    }
                }
                parseExprList(e1, t, r, n) {
                    const s = [];
                    let i = true;
                    while(!this.eat(e1)){
                        if (i) {
                            i = false;
                        } else {
                            this.expect(12);
                            if (this.match(e1)) {
                                if (n) {
                                    this.addTrailingCommaExtraToNode(n);
                                }
                                this.next();
                                break;
                            }
                        }
                        s.push(this.parseExprListItem(t, r));
                    }
                    return s;
                }
                parseExprListItem(e1, t, r) {
                    let n;
                    if (this.match(12)) {
                        if (!e1) {
                            this.raise(p.UnexpectedToken, {
                                at: this.state.curPosition(),
                                unexpected: ","
                            });
                        }
                        n = null;
                    } else if (this.match(21)) {
                        const e1 = this.state.startLoc;
                        n = this.parseParenItem(this.parseSpread(t), e1);
                    } else if (this.match(17)) {
                        this.expectPlugin("partialApplication");
                        if (!r) {
                            this.raise(p.UnexpectedArgumentPlaceholder, {
                                at: this.state.startLoc
                            });
                        }
                        const e1 = this.startNode();
                        this.next();
                        n = this.finishNode(e1, "ArgumentPlaceholder");
                    } else {
                        n = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
                    }
                    return n;
                }
                parseIdentifier(e1) {
                    const t = this.startNode();
                    const r = this.parseIdentifierName(e1);
                    return this.createIdentifier(t, r);
                }
                createIdentifier(e1, t) {
                    e1.name = t;
                    e1.loc.identifierName = t;
                    return this.finishNode(e1, "Identifier");
                }
                parseIdentifierName(e1) {
                    let t;
                    const { startLoc: r, type: n } = this.state;
                    if (tokenIsKeywordOrIdentifier(n)) {
                        t = this.state.value;
                    } else {
                        this.unexpected();
                    }
                    const s = tokenKeywordOrIdentifierIsKeyword(n);
                    if (e1) {
                        if (s) {
                            this.replaceToken(130);
                        }
                    } else {
                        this.checkReservedWord(t, r, s, false);
                    }
                    this.next();
                    return t;
                }
                checkReservedWord(e1, t, r, n) {
                    if (e1.length > 10) {
                        return;
                    }
                    if (!canBeReservedWord(e1)) {
                        return;
                    }
                    if (r && isKeyword(e1)) {
                        this.raise(p.UnexpectedKeyword, {
                            at: t,
                            keyword: e1
                        });
                        return;
                    }
                    const s = !this.state.strict ? isReservedWord : n ? isStrictBindReservedWord : isStrictReservedWord;
                    if (s(e1, this.inModule)) {
                        this.raise(p.UnexpectedReservedWord, {
                            at: t,
                            reservedWord: e1
                        });
                        return;
                    } else if (e1 === "yield") {
                        if (this.prodParam.hasYield) {
                            this.raise(p.YieldBindingIdentifier, {
                                at: t
                            });
                            return;
                        }
                    } else if (e1 === "await") {
                        if (this.prodParam.hasAwait) {
                            this.raise(p.AwaitBindingIdentifier, {
                                at: t
                            });
                            return;
                        }
                        if (this.scope.inStaticBlock) {
                            this.raise(p.AwaitBindingIdentifierInStaticBlock, {
                                at: t
                            });
                            return;
                        }
                        this.expressionScope.recordAsyncArrowParametersError({
                            at: t
                        });
                    } else if (e1 === "arguments") {
                        if (this.scope.inClassAndNotInNonArrowFunction) {
                            this.raise(p.ArgumentsInClass, {
                                at: t
                            });
                            return;
                        }
                    }
                }
                isAwaitAllowed() {
                    if (this.prodParam.hasAwait) return true;
                    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
                        return true;
                    }
                    return false;
                }
                parseAwait(e1) {
                    const t = this.startNodeAt(e1);
                    this.expressionScope.recordParameterInitializerError(p.AwaitExpressionFormalParameter, {
                        at: t
                    });
                    if (this.eat(55)) {
                        this.raise(p.ObsoleteAwaitStar, {
                            at: t
                        });
                    }
                    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
                        if (this.isAmbiguousAwait()) {
                            this.ambiguousScriptDifferentAst = true;
                        } else {
                            this.sawUnambiguousESM = true;
                        }
                    }
                    if (!this.state.soloAwait) {
                        t.argument = this.parseMaybeUnary(null, true);
                    }
                    return this.finishNode(t, "AwaitExpression");
                }
                isAmbiguousAwait() {
                    if (this.hasPrecedingLineBreak()) return true;
                    const { type: e1 } = this.state;
                    return e1 === 53 || e1 === 10 || e1 === 0 || tokenIsTemplate(e1) || e1 === 101 && !this.state.containsEsc || e1 === 135 || e1 === 56 || this.hasPlugin("v8intrinsic") && e1 === 54;
                }
                parseYield() {
                    const e1 = this.startNode();
                    this.expressionScope.recordParameterInitializerError(p.YieldInParameter, {
                        at: e1
                    });
                    this.next();
                    let t = false;
                    let r = null;
                    if (!this.hasPrecedingLineBreak()) {
                        t = this.eat(55);
                        switch(this.state.type){
                            case 13:
                            case 137:
                            case 8:
                            case 11:
                            case 3:
                            case 9:
                            case 14:
                            case 12:
                                if (!t) break;
                            default:
                                r = this.parseMaybeAssign();
                        }
                    }
                    e1.delegate = t;
                    e1.argument = r;
                    return this.finishNode(e1, "YieldExpression");
                }
                checkPipelineAtInfixOperator(e1, t) {
                    if (this.hasPlugin([
                        "pipelineOperator",
                        {
                            proposal: "smart"
                        }
                    ])) {
                        if (e1.type === "SequenceExpression") {
                            this.raise(p.PipelineHeadSequenceExpression, {
                                at: t
                            });
                        }
                    }
                }
                parseSmartPipelineBodyInStyle(e1, t) {
                    if (this.isSimpleReference(e1)) {
                        const r = this.startNodeAt(t);
                        r.callee = e1;
                        return this.finishNode(r, "PipelineBareFunction");
                    } else {
                        const r = this.startNodeAt(t);
                        this.checkSmartPipeTopicBodyEarlyErrors(t);
                        r.expression = e1;
                        return this.finishNode(r, "PipelineTopicExpression");
                    }
                }
                isSimpleReference(e1) {
                    switch(e1.type){
                        case "MemberExpression":
                            return !e1.computed && this.isSimpleReference(e1.object);
                        case "Identifier":
                            return true;
                        default:
                            return false;
                    }
                }
                checkSmartPipeTopicBodyEarlyErrors(e1) {
                    if (this.match(19)) {
                        throw this.raise(p.PipelineBodyNoArrow, {
                            at: this.state.startLoc
                        });
                    }
                    if (!this.topicReferenceWasUsedInCurrentContext()) {
                        this.raise(p.PipelineTopicUnused, {
                            at: e1
                        });
                    }
                }
                withTopicBindingContext(e1) {
                    const t = this.state.topicContext;
                    this.state.topicContext = {
                        maxNumOfResolvableTopics: 1,
                        maxTopicIndex: null
                    };
                    try {
                        return e1();
                    } finally{
                        this.state.topicContext = t;
                    }
                }
                withSmartMixTopicForbiddingContext(e1) {
                    if (this.hasPlugin([
                        "pipelineOperator",
                        {
                            proposal: "smart"
                        }
                    ])) {
                        const t = this.state.topicContext;
                        this.state.topicContext = {
                            maxNumOfResolvableTopics: 0,
                            maxTopicIndex: null
                        };
                        try {
                            return e1();
                        } finally{
                            this.state.topicContext = t;
                        }
                    } else {
                        return e1();
                    }
                }
                withSoloAwaitPermittingContext(e1) {
                    const t = this.state.soloAwait;
                    this.state.soloAwait = true;
                    try {
                        return e1();
                    } finally{
                        this.state.soloAwait = t;
                    }
                }
                allowInAnd(e1) {
                    const t = this.prodParam.currentFlags();
                    const r = Ze & ~t;
                    if (r) {
                        this.prodParam.enter(t | Ze);
                        try {
                            return e1();
                        } finally{
                            this.prodParam.exit();
                        }
                    }
                    return e1();
                }
                disallowInAnd(e1) {
                    const t = this.prodParam.currentFlags();
                    const r = Ze & t;
                    if (r) {
                        this.prodParam.enter(t & ~Ze);
                        try {
                            return e1();
                        } finally{
                            this.prodParam.exit();
                        }
                    }
                    return e1();
                }
                registerTopicReference() {
                    this.state.topicContext.maxTopicIndex = 0;
                }
                topicReferenceIsAllowedInCurrentContext() {
                    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
                }
                topicReferenceWasUsedInCurrentContext() {
                    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
                }
                parseFSharpPipelineBody(e1) {
                    const t = this.state.startLoc;
                    this.state.potentialArrowAt = this.state.start;
                    const r = this.state.inFSharpPipelineDirectBody;
                    this.state.inFSharpPipelineDirectBody = true;
                    const n = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, e1);
                    this.state.inFSharpPipelineDirectBody = r;
                    return n;
                }
                parseModuleExpression() {
                    this.expectPlugin("moduleBlocks");
                    const e1 = this.startNode();
                    this.next();
                    if (!this.match(5)) {
                        this.unexpected(null, 5);
                    }
                    const t = this.startNodeAt(this.state.endLoc);
                    this.next();
                    const r = this.initializeScopes(true);
                    this.enterInitialScopes();
                    try {
                        e1.body = this.parseProgram(t, 8, "module");
                    } finally{
                        r();
                    }
                    return this.finishNode(e1, "ModuleExpression");
                }
                parsePropertyNamePrefixOperator(e1) {}
            }
            const mt = {
                kind: "loop"
            }, yt = {
                kind: "switch"
            };
            const gt = /[\uD800-\uDFFF]/u;
            const bt = /in(?:stanceof)?/y;
            function babel7CompatTokens(e1, t) {
                for(let r = 0; r < e1.length; r++){
                    const n = e1[r];
                    const { type: s } = n;
                    if (typeof s === "number") {
                        {
                            if (s === 136) {
                                const { loc: t, start: s, value: i, end: a } = n;
                                const o = s + 1;
                                const l = createPositionWithColumnOffset(t.start, 1);
                                e1.splice(r, 1, new Token({
                                    type: getExportedToken(27),
                                    value: "#",
                                    start: s,
                                    end: o,
                                    startLoc: t.start,
                                    endLoc: l
                                }), new Token({
                                    type: getExportedToken(130),
                                    value: i,
                                    start: o,
                                    end: a,
                                    startLoc: l,
                                    endLoc: t.end
                                }));
                                r++;
                                continue;
                            }
                            if (tokenIsTemplate(s)) {
                                const { loc: i, start: a, value: o, end: l } = n;
                                const c = a + 1;
                                const u = createPositionWithColumnOffset(i.start, 1);
                                let p;
                                if (t.charCodeAt(a) === 96) {
                                    p = new Token({
                                        type: getExportedToken(22),
                                        value: "`",
                                        start: a,
                                        end: c,
                                        startLoc: i.start,
                                        endLoc: u
                                    });
                                } else {
                                    p = new Token({
                                        type: getExportedToken(8),
                                        value: "}",
                                        start: a,
                                        end: c,
                                        startLoc: i.start,
                                        endLoc: u
                                    });
                                }
                                let f, d, h, m;
                                if (s === 24) {
                                    d = l - 1;
                                    h = createPositionWithColumnOffset(i.end, -1);
                                    f = o === null ? null : o.slice(1, -1);
                                    m = new Token({
                                        type: getExportedToken(22),
                                        value: "`",
                                        start: d,
                                        end: l,
                                        startLoc: h,
                                        endLoc: i.end
                                    });
                                } else {
                                    d = l - 2;
                                    h = createPositionWithColumnOffset(i.end, -2);
                                    f = o === null ? null : o.slice(1, -2);
                                    m = new Token({
                                        type: getExportedToken(23),
                                        value: "${",
                                        start: d,
                                        end: l,
                                        startLoc: h,
                                        endLoc: i.end
                                    });
                                }
                                e1.splice(r, 1, p, new Token({
                                    type: getExportedToken(20),
                                    value: f,
                                    start: c,
                                    end: d,
                                    startLoc: u,
                                    endLoc: h
                                }), m);
                                r += 2;
                                continue;
                            }
                        }
                        n.type = getExportedToken(s);
                    }
                }
                return e1;
            }
            class StatementParser extends ExpressionParser {
                parseTopLevel(e1, t) {
                    e1.program = this.parseProgram(t);
                    e1.comments = this.state.comments;
                    if (this.options.tokens) {
                        e1.tokens = babel7CompatTokens(this.tokens, this.input);
                    }
                    return this.finishNode(e1, "File");
                }
                parseProgram(e1, t = 137, r = this.options.sourceType) {
                    e1.sourceType = r;
                    e1.interpreter = this.parseInterpreterDirective();
                    this.parseBlockBody(e1, true, true, t);
                    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
                        for (const [e1, t] of Array.from(this.scope.undefinedExports)){
                            this.raise(p.ModuleExportUndefined, {
                                at: t,
                                localName: e1
                            });
                        }
                    }
                    let n;
                    if (t === 137) {
                        n = this.finishNode(e1, "Program");
                    } else {
                        n = this.finishNodeAt(e1, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
                    }
                    return n;
                }
                stmtToDirective(e1) {
                    const t = e1;
                    t.type = "Directive";
                    t.value = t.expression;
                    delete t.expression;
                    const r = t.value;
                    const n = r.value;
                    const s = this.input.slice(r.start, r.end);
                    const i = r.value = s.slice(1, -1);
                    this.addExtra(r, "raw", s);
                    this.addExtra(r, "rawValue", i);
                    this.addExtra(r, "expressionValue", n);
                    r.type = "DirectiveLiteral";
                    return t;
                }
                parseInterpreterDirective() {
                    if (!this.match(28)) {
                        return null;
                    }
                    const e1 = this.startNode();
                    e1.value = this.state.value;
                    this.next();
                    return this.finishNode(e1, "InterpreterDirective");
                }
                isLet() {
                    if (!this.isContextual(99)) {
                        return false;
                    }
                    return this.hasFollowingBindingAtom();
                }
                chStartsBindingIdentifier(e1, t) {
                    if (isIdentifierStart(e1)) {
                        bt.lastIndex = t;
                        if (bt.test(this.input)) {
                            const e1 = this.codePointAtPos(bt.lastIndex);
                            if (!isIdentifierChar(e1) && e1 !== 92) {
                                return false;
                            }
                        }
                        return true;
                    } else if (e1 === 92) {
                        return true;
                    } else {
                        return false;
                    }
                }
                chStartsBindingPattern(e1) {
                    return e1 === 91 || e1 === 123;
                }
                hasFollowingBindingAtom() {
                    const e1 = this.nextTokenStart();
                    const t = this.codePointAtPos(e1);
                    return this.chStartsBindingPattern(t) || this.chStartsBindingIdentifier(t, e1);
                }
                hasInLineFollowingBindingIdentifier() {
                    const e1 = this.nextTokenInLineStart();
                    const t = this.codePointAtPos(e1);
                    return this.chStartsBindingIdentifier(t, e1);
                }
                startsUsingForOf() {
                    const { type: e1, containsEsc: t } = this.lookahead();
                    if (e1 === 101 && !t) {
                        return false;
                    } else if (tokenIsIdentifier(e1) && !this.hasFollowingLineBreak()) {
                        this.expectPlugin("explicitResourceManagement");
                        return true;
                    }
                }
                startsAwaitUsing() {
                    let e1 = this.nextTokenInLineStart();
                    if (this.isUnparsedContextual(e1, "using")) {
                        e1 = this.nextTokenInLineStartSince(e1 + 5);
                        const t = this.codePointAtPos(e1);
                        if (this.chStartsBindingIdentifier(t, e1)) {
                            this.expectPlugin("explicitResourceManagement");
                            return true;
                        }
                    }
                    return false;
                }
                parseModuleItem() {
                    return this.parseStatementLike(1 | 2 | 4 | 8);
                }
                parseStatementListItem() {
                    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
                }
                parseStatementOrSloppyAnnexBFunctionDeclaration(e1 = false) {
                    let t = 0;
                    if (this.options.annexB && !this.state.strict) {
                        t |= 4;
                        if (e1) {
                            t |= 8;
                        }
                    }
                    return this.parseStatementLike(t);
                }
                parseStatement() {
                    return this.parseStatementLike(0);
                }
                parseStatementLike(e1) {
                    let t = null;
                    if (this.match(26)) {
                        t = this.parseDecorators(true);
                    }
                    return this.parseStatementContent(e1, t);
                }
                parseStatementContent(e1, t) {
                    const r = this.state.type;
                    const n = this.startNode();
                    const s = !!(e1 & 2);
                    const i = !!(e1 & 4);
                    const a = e1 & 1;
                    switch(r){
                        case 60:
                            return this.parseBreakContinueStatement(n, true);
                        case 63:
                            return this.parseBreakContinueStatement(n, false);
                        case 64:
                            return this.parseDebuggerStatement(n);
                        case 90:
                            return this.parseDoWhileStatement(n);
                        case 91:
                            return this.parseForStatement(n);
                        case 68:
                            if (this.lookaheadCharCode() === 46) break;
                            if (!i) {
                                this.raise(this.state.strict ? p.StrictFunction : this.options.annexB ? p.SloppyFunctionAnnexB : p.SloppyFunction, {
                                    at: this.state.startLoc
                                });
                            }
                            return this.parseFunctionStatement(n, false, !s && i);
                        case 80:
                            if (!s) this.unexpected();
                            return this.parseClass(this.maybeTakeDecorators(t, n), true);
                        case 69:
                            return this.parseIfStatement(n);
                        case 70:
                            return this.parseReturnStatement(n);
                        case 71:
                            return this.parseSwitchStatement(n);
                        case 72:
                            return this.parseThrowStatement(n);
                        case 73:
                            return this.parseTryStatement(n);
                        case 96:
                            if (!this.state.containsEsc && this.startsAwaitUsing()) {
                                if (!this.isAwaitAllowed()) {
                                    this.raise(p.AwaitUsingNotInAsyncContext, {
                                        at: n
                                    });
                                } else if (!s) {
                                    this.raise(p.UnexpectedLexicalDeclaration, {
                                        at: n
                                    });
                                }
                                this.next();
                                return this.parseVarStatement(n, "await using");
                            }
                            break;
                        case 105:
                            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier()) {
                                break;
                            }
                            this.expectPlugin("explicitResourceManagement");
                            if (!this.scope.inModule && this.scope.inTopLevel) {
                                this.raise(p.UnexpectedUsingDeclaration, {
                                    at: this.state.startLoc
                                });
                            } else if (!s) {
                                this.raise(p.UnexpectedLexicalDeclaration, {
                                    at: this.state.startLoc
                                });
                            }
                            return this.parseVarStatement(n, "using");
                        case 99:
                            {
                                if (this.state.containsEsc) {
                                    break;
                                }
                                const e1 = this.nextTokenStart();
                                const t = this.codePointAtPos(e1);
                                if (t !== 91) {
                                    if (!s && this.hasFollowingLineBreak()) break;
                                    if (!this.chStartsBindingIdentifier(t, e1) && t !== 123) {
                                        break;
                                    }
                                }
                            }
                        case 75:
                            {
                                if (!s) {
                                    this.raise(p.UnexpectedLexicalDeclaration, {
                                        at: this.state.startLoc
                                    });
                                }
                            }
                        case 74:
                            {
                                const e1 = this.state.value;
                                return this.parseVarStatement(n, e1);
                            }
                        case 92:
                            return this.parseWhileStatement(n);
                        case 76:
                            return this.parseWithStatement(n);
                        case 5:
                            return this.parseBlock();
                        case 13:
                            return this.parseEmptyStatement(n);
                        case 83:
                            {
                                const e1 = this.lookaheadCharCode();
                                if (e1 === 40 || e1 === 46) {
                                    break;
                                }
                            }
                        case 82:
                            {
                                if (!this.options.allowImportExportEverywhere && !a) {
                                    this.raise(p.UnexpectedImportExport, {
                                        at: this.state.startLoc
                                    });
                                }
                                this.next();
                                let e1;
                                if (r === 83) {
                                    e1 = this.parseImport(n);
                                    if (e1.type === "ImportDeclaration" && (!e1.importKind || e1.importKind === "value")) {
                                        this.sawUnambiguousESM = true;
                                    }
                                } else {
                                    e1 = this.parseExport(n, t);
                                    if (e1.type === "ExportNamedDeclaration" && (!e1.exportKind || e1.exportKind === "value") || e1.type === "ExportAllDeclaration" && (!e1.exportKind || e1.exportKind === "value") || e1.type === "ExportDefaultDeclaration") {
                                        this.sawUnambiguousESM = true;
                                    }
                                }
                                this.assertModuleNodeAllowed(e1);
                                return e1;
                            }
                        default:
                            {
                                if (this.isAsyncFunction()) {
                                    if (!s) {
                                        this.raise(p.AsyncFunctionInSingleStatementContext, {
                                            at: this.state.startLoc
                                        });
                                    }
                                    this.next();
                                    return this.parseFunctionStatement(n, true, !s && i);
                                }
                            }
                    }
                    const o = this.state.value;
                    const l = this.parseExpression();
                    if (tokenIsIdentifier(r) && l.type === "Identifier" && this.eat(14)) {
                        return this.parseLabeledStatement(n, o, l, e1);
                    } else {
                        return this.parseExpressionStatement(n, l, t);
                    }
                }
                assertModuleNodeAllowed(e1) {
                    if (!this.options.allowImportExportEverywhere && !this.inModule) {
                        this.raise(p.ImportOutsideModule, {
                            at: e1
                        });
                    }
                }
                decoratorsEnabledBeforeExport() {
                    if (this.hasPlugin("decorators-legacy")) return true;
                    return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
                }
                maybeTakeDecorators(e1, t, r) {
                    if (e1) {
                        if (t.decorators && t.decorators.length > 0) {
                            if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
                                this.raise(p.DecoratorsBeforeAfterExport, {
                                    at: t.decorators[0]
                                });
                            }
                            t.decorators.unshift(...e1);
                        } else {
                            t.decorators = e1;
                        }
                        this.resetStartLocationFromNode(t, e1[0]);
                        if (r) this.resetStartLocationFromNode(r, t);
                    }
                    return t;
                }
                canHaveLeadingDecorator() {
                    return this.match(80);
                }
                parseDecorators(e1) {
                    const t = [];
                    do {
                        t.push(this.parseDecorator());
                    }while (this.match(26))
                    if (this.match(82)) {
                        if (!e1) {
                            this.unexpected();
                        }
                        if (!this.decoratorsEnabledBeforeExport()) {
                            this.raise(p.DecoratorExportClass, {
                                at: this.state.startLoc
                            });
                        }
                    } else if (!this.canHaveLeadingDecorator()) {
                        throw this.raise(p.UnexpectedLeadingDecorator, {
                            at: this.state.startLoc
                        });
                    }
                    return t;
                }
                parseDecorator() {
                    this.expectOnePlugin([
                        "decorators",
                        "decorators-legacy"
                    ]);
                    const e1 = this.startNode();
                    this.next();
                    if (this.hasPlugin("decorators")) {
                        const t = this.state.startLoc;
                        let r;
                        if (this.match(10)) {
                            const t = this.state.startLoc;
                            this.next();
                            r = this.parseExpression();
                            this.expect(11);
                            r = this.wrapParenthesis(t, r);
                            const n = this.state.startLoc;
                            e1.expression = this.parseMaybeDecoratorArguments(r);
                            if (this.getPluginOption("decorators", "allowCallParenthesized") === false && e1.expression !== r) {
                                this.raise(p.DecoratorArgumentsOutsideParentheses, {
                                    at: n
                                });
                            }
                        } else {
                            r = this.parseIdentifier(false);
                            while(this.eat(16)){
                                const e1 = this.startNodeAt(t);
                                e1.object = r;
                                if (this.match(136)) {
                                    this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                                    e1.property = this.parsePrivateName();
                                } else {
                                    e1.property = this.parseIdentifier(true);
                                }
                                e1.computed = false;
                                r = this.finishNode(e1, "MemberExpression");
                            }
                            e1.expression = this.parseMaybeDecoratorArguments(r);
                        }
                    } else {
                        e1.expression = this.parseExprSubscripts();
                    }
                    return this.finishNode(e1, "Decorator");
                }
                parseMaybeDecoratorArguments(e1) {
                    if (this.eat(10)) {
                        const t = this.startNodeAtNode(e1);
                        t.callee = e1;
                        t.arguments = this.parseCallExpressionArguments(11, false);
                        this.toReferencedList(t.arguments);
                        return this.finishNode(t, "CallExpression");
                    }
                    return e1;
                }
                parseBreakContinueStatement(e1, t) {
                    this.next();
                    if (this.isLineTerminator()) {
                        e1.label = null;
                    } else {
                        e1.label = this.parseIdentifier();
                        this.semicolon();
                    }
                    this.verifyBreakContinue(e1, t);
                    return this.finishNode(e1, t ? "BreakStatement" : "ContinueStatement");
                }
                verifyBreakContinue(e1, t) {
                    let r;
                    for(r = 0; r < this.state.labels.length; ++r){
                        const n = this.state.labels[r];
                        if (e1.label == null || n.name === e1.label.name) {
                            if (n.kind != null && (t || n.kind === "loop")) break;
                            if (e1.label && t) break;
                        }
                    }
                    if (r === this.state.labels.length) {
                        const r = t ? "BreakStatement" : "ContinueStatement";
                        this.raise(p.IllegalBreakContinue, {
                            at: e1,
                            type: r
                        });
                    }
                }
                parseDebuggerStatement(e1) {
                    this.next();
                    this.semicolon();
                    return this.finishNode(e1, "DebuggerStatement");
                }
                parseHeaderExpression() {
                    this.expect(10);
                    const e1 = this.parseExpression();
                    this.expect(11);
                    return e1;
                }
                parseDoWhileStatement(e1) {
                    this.next();
                    this.state.labels.push(mt);
                    e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
                    this.state.labels.pop();
                    this.expect(92);
                    e1.test = this.parseHeaderExpression();
                    this.eat(13);
                    return this.finishNode(e1, "DoWhileStatement");
                }
                parseForStatement(e1) {
                    this.next();
                    this.state.labels.push(mt);
                    let t = null;
                    if (this.isAwaitAllowed() && this.eatContextual(96)) {
                        t = this.state.lastTokStartLoc;
                    }
                    this.scope.enter(U);
                    this.expect(10);
                    if (this.match(13)) {
                        if (t !== null) {
                            this.unexpected(t);
                        }
                        return this.parseFor(e1, null);
                    }
                    const r = this.isContextual(99);
                    {
                        const n = this.isContextual(96) && this.startsAwaitUsing();
                        const s = n || this.isContextual(105) && this.startsUsingForOf();
                        const i = r && this.hasFollowingBindingAtom() || s;
                        if (this.match(74) || this.match(75) || i) {
                            const r = this.startNode();
                            let i;
                            if (n) {
                                i = "await using";
                                if (!this.isAwaitAllowed()) {
                                    this.raise(p.AwaitUsingNotInAsyncContext, {
                                        at: this.state.startLoc
                                    });
                                }
                                this.next();
                            } else {
                                i = this.state.value;
                            }
                            this.next();
                            this.parseVar(r, true, i);
                            const a = this.finishNode(r, "VariableDeclaration");
                            const o = this.match(58);
                            if (o && s) {
                                this.raise(p.ForInUsing, {
                                    at: a
                                });
                            }
                            if ((o || this.isContextual(101)) && a.declarations.length === 1) {
                                return this.parseForIn(e1, a, t);
                            }
                            if (t !== null) {
                                this.unexpected(t);
                            }
                            return this.parseFor(e1, a);
                        }
                    }
                    const n = this.isContextual(95);
                    const s = new ExpressionErrors;
                    const i = this.parseExpression(true, s);
                    const a = this.isContextual(101);
                    if (a) {
                        if (r) {
                            this.raise(p.ForOfLet, {
                                at: i
                            });
                        }
                        if (t === null && n && i.type === "Identifier") {
                            this.raise(p.ForOfAsync, {
                                at: i
                            });
                        }
                    }
                    if (a || this.match(58)) {
                        this.checkDestructuringPrivate(s);
                        this.toAssignable(i, true);
                        const r = a ? "ForOfStatement" : "ForInStatement";
                        this.checkLVal(i, {
                            in: {
                                type: r
                            }
                        });
                        return this.parseForIn(e1, i, t);
                    } else {
                        this.checkExpressionErrors(s, true);
                    }
                    if (t !== null) {
                        this.unexpected(t);
                    }
                    return this.parseFor(e1, i);
                }
                parseFunctionStatement(e1, t, r) {
                    this.next();
                    return this.parseFunction(e1, 1 | (r ? 2 : 0) | (t ? 8 : 0));
                }
                parseIfStatement(e1) {
                    this.next();
                    e1.test = this.parseHeaderExpression();
                    e1.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
                    e1.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
                    return this.finishNode(e1, "IfStatement");
                }
                parseReturnStatement(e1) {
                    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
                        this.raise(p.IllegalReturn, {
                            at: this.state.startLoc
                        });
                    }
                    this.next();
                    if (this.isLineTerminator()) {
                        e1.argument = null;
                    } else {
                        e1.argument = this.parseExpression();
                        this.semicolon();
                    }
                    return this.finishNode(e1, "ReturnStatement");
                }
                parseSwitchStatement(e1) {
                    this.next();
                    e1.discriminant = this.parseHeaderExpression();
                    const t = e1.cases = [];
                    this.expect(5);
                    this.state.labels.push(yt);
                    this.scope.enter(U);
                    let r;
                    for(let e1; !this.match(8);){
                        if (this.match(61) || this.match(65)) {
                            const n = this.match(61);
                            if (r) this.finishNode(r, "SwitchCase");
                            t.push(r = this.startNode());
                            r.consequent = [];
                            this.next();
                            if (n) {
                                r.test = this.parseExpression();
                            } else {
                                if (e1) {
                                    this.raise(p.MultipleDefaultsInSwitch, {
                                        at: this.state.lastTokStartLoc
                                    });
                                }
                                e1 = true;
                                r.test = null;
                            }
                            this.expect(14);
                        } else {
                            if (r) {
                                r.consequent.push(this.parseStatementListItem());
                            } else {
                                this.unexpected();
                            }
                        }
                    }
                    this.scope.exit();
                    if (r) this.finishNode(r, "SwitchCase");
                    this.next();
                    this.state.labels.pop();
                    return this.finishNode(e1, "SwitchStatement");
                }
                parseThrowStatement(e1) {
                    this.next();
                    if (this.hasPrecedingLineBreak()) {
                        this.raise(p.NewlineAfterThrow, {
                            at: this.state.lastTokEndLoc
                        });
                    }
                    e1.argument = this.parseExpression();
                    this.semicolon();
                    return this.finishNode(e1, "ThrowStatement");
                }
                parseCatchClauseParam() {
                    const e1 = this.parseBindingAtom();
                    this.scope.enter(this.options.annexB && e1.type === "Identifier" ? $ : 0);
                    this.checkLVal(e1, {
                        in: {
                            type: "CatchClause"
                        },
                        binding: fe
                    });
                    return e1;
                }
                parseTryStatement(e1) {
                    this.next();
                    e1.block = this.parseBlock();
                    e1.handler = null;
                    if (this.match(62)) {
                        const t = this.startNode();
                        this.next();
                        if (this.match(10)) {
                            this.expect(10);
                            t.param = this.parseCatchClauseParam();
                            this.expect(11);
                        } else {
                            t.param = null;
                            this.scope.enter(U);
                        }
                        t.body = this.withSmartMixTopicForbiddingContext(()=>this.parseBlock(false, false));
                        this.scope.exit();
                        e1.handler = this.finishNode(t, "CatchClause");
                    }
                    e1.finalizer = this.eat(67) ? this.parseBlock() : null;
                    if (!e1.handler && !e1.finalizer) {
                        this.raise(p.NoCatchOrFinally, {
                            at: e1
                        });
                    }
                    return this.finishNode(e1, "TryStatement");
                }
                parseVarStatement(e1, t, r = false) {
                    this.next();
                    this.parseVar(e1, false, t, r);
                    this.semicolon();
                    return this.finishNode(e1, "VariableDeclaration");
                }
                parseWhileStatement(e1) {
                    this.next();
                    e1.test = this.parseHeaderExpression();
                    this.state.labels.push(mt);
                    e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
                    this.state.labels.pop();
                    return this.finishNode(e1, "WhileStatement");
                }
                parseWithStatement(e1) {
                    if (this.state.strict) {
                        this.raise(p.StrictWith, {
                            at: this.state.startLoc
                        });
                    }
                    this.next();
                    e1.object = this.parseHeaderExpression();
                    e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
                    return this.finishNode(e1, "WithStatement");
                }
                parseEmptyStatement(e1) {
                    this.next();
                    return this.finishNode(e1, "EmptyStatement");
                }
                parseLabeledStatement(e1, t, r, n) {
                    for (const e1 of this.state.labels){
                        if (e1.name === t) {
                            this.raise(p.LabelRedeclaration, {
                                at: r,
                                labelName: t
                            });
                        }
                    }
                    const s = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
                    for(let t = this.state.labels.length - 1; t >= 0; t--){
                        const r = this.state.labels[t];
                        if (r.statementStart === e1.start) {
                            r.statementStart = this.state.start;
                            r.kind = s;
                        } else {
                            break;
                        }
                    }
                    this.state.labels.push({
                        name: t,
                        kind: s,
                        statementStart: this.state.start
                    });
                    e1.body = n & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
                    this.state.labels.pop();
                    e1.label = r;
                    return this.finishNode(e1, "LabeledStatement");
                }
                parseExpressionStatement(e1, t, r) {
                    e1.expression = t;
                    this.semicolon();
                    return this.finishNode(e1, "ExpressionStatement");
                }
                parseBlock(e1 = false, t = true, r) {
                    const n = this.startNode();
                    if (e1) {
                        this.state.strictErrors.clear();
                    }
                    this.expect(5);
                    if (t) {
                        this.scope.enter(U);
                    }
                    this.parseBlockBody(n, e1, false, 8, r);
                    if (t) {
                        this.scope.exit();
                    }
                    return this.finishNode(n, "BlockStatement");
                }
                isValidDirective(e1) {
                    return e1.type === "ExpressionStatement" && e1.expression.type === "StringLiteral" && !e1.expression.extra.parenthesized;
                }
                parseBlockBody(e1, t, r, n, s) {
                    const i = e1.body = [];
                    const a = e1.directives = [];
                    this.parseBlockOrModuleBlockBody(i, t ? a : undefined, r, n, s);
                }
                parseBlockOrModuleBlockBody(e1, t, r, n, s) {
                    const i = this.state.strict;
                    let a = false;
                    let o = false;
                    while(!this.match(n)){
                        const n = r ? this.parseModuleItem() : this.parseStatementListItem();
                        if (t && !o) {
                            if (this.isValidDirective(n)) {
                                const e1 = this.stmtToDirective(n);
                                t.push(e1);
                                if (!a && e1.value.value === "use strict") {
                                    a = true;
                                    this.setStrict(true);
                                }
                                continue;
                            }
                            o = true;
                            this.state.strictErrors.clear();
                        }
                        e1.push(n);
                    }
                    if (s) {
                        s.call(this, a);
                    }
                    if (!i) {
                        this.setStrict(false);
                    }
                    this.next();
                }
                parseFor(e1, t) {
                    e1.init = t;
                    this.semicolon(false);
                    e1.test = this.match(13) ? null : this.parseExpression();
                    this.semicolon(false);
                    e1.update = this.match(11) ? null : this.parseExpression();
                    this.expect(11);
                    e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
                    this.scope.exit();
                    this.state.labels.pop();
                    return this.finishNode(e1, "ForStatement");
                }
                parseForIn(e1, t, r) {
                    const n = this.match(58);
                    this.next();
                    if (n) {
                        if (r !== null) this.unexpected(r);
                    } else {
                        e1.await = r !== null;
                    }
                    if (t.type === "VariableDeclaration" && t.declarations[0].init != null && (!n || !this.options.annexB || this.state.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier")) {
                        this.raise(p.ForInOfLoopInitializer, {
                            at: t,
                            type: n ? "ForInStatement" : "ForOfStatement"
                        });
                    }
                    if (t.type === "AssignmentPattern") {
                        this.raise(p.InvalidLhs, {
                            at: t,
                            ancestor: {
                                type: "ForStatement"
                            }
                        });
                    }
                    e1.left = t;
                    e1.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn();
                    this.expect(11);
                    e1.body = this.withSmartMixTopicForbiddingContext(()=>this.parseStatement());
                    this.scope.exit();
                    this.state.labels.pop();
                    return this.finishNode(e1, n ? "ForInStatement" : "ForOfStatement");
                }
                parseVar(e1, t, r, n = false) {
                    const s = e1.declarations = [];
                    e1.kind = r;
                    for(;;){
                        const e1 = this.startNode();
                        this.parseVarId(e1, r);
                        e1.init = !this.eat(29) ? null : t ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
                        if (e1.init === null && !n) {
                            if (e1.id.type !== "Identifier" && !(t && (this.match(58) || this.isContextual(101)))) {
                                this.raise(p.DeclarationMissingInitializer, {
                                    at: this.state.lastTokEndLoc,
                                    kind: "destructuring"
                                });
                            } else if (r === "const" && !(this.match(58) || this.isContextual(101))) {
                                this.raise(p.DeclarationMissingInitializer, {
                                    at: this.state.lastTokEndLoc,
                                    kind: "const"
                                });
                            }
                        }
                        s.push(this.finishNode(e1, "VariableDeclarator"));
                        if (!this.eat(12)) break;
                    }
                    return e1;
                }
                parseVarId(e1, t) {
                    const r = this.parseBindingAtom();
                    this.checkLVal(r, {
                        in: {
                            type: "VariableDeclarator"
                        },
                        binding: t === "var" ? de : pe
                    });
                    e1.id = r;
                }
                parseAsyncFunctionExpression(e1) {
                    return this.parseFunction(e1, 8);
                }
                parseFunction(e1, t = 0) {
                    const r = t & 2;
                    const n = !!(t & 1);
                    const s = n && !(t & 4);
                    const i = !!(t & 8);
                    this.initFunction(e1, i);
                    if (this.match(55)) {
                        if (r) {
                            this.raise(p.GeneratorInSingleStatementContext, {
                                at: this.state.startLoc
                            });
                        }
                        this.next();
                        e1.generator = true;
                    }
                    if (n) {
                        e1.id = this.parseFunctionId(s);
                    }
                    const a = this.state.maybeInArrowParameters;
                    this.state.maybeInArrowParameters = false;
                    this.scope.enter(V);
                    this.prodParam.enter(functionFlags(i, e1.generator));
                    if (!n) {
                        e1.id = this.parseFunctionId();
                    }
                    this.parseFunctionParams(e1, false);
                    this.withSmartMixTopicForbiddingContext(()=>{
                        this.parseFunctionBodyAndFinish(e1, n ? "FunctionDeclaration" : "FunctionExpression");
                    });
                    this.prodParam.exit();
                    this.scope.exit();
                    if (n && !r) {
                        this.registerFunctionStatementId(e1);
                    }
                    this.state.maybeInArrowParameters = a;
                    return e1;
                }
                parseFunctionId(e1) {
                    return e1 || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
                }
                parseFunctionParams(e1, t) {
                    this.expect(10);
                    this.expressionScope.enter(newParameterDeclarationScope());
                    e1.params = this.parseBindingList(11, 41, 2 | (t ? 4 : 0));
                    this.expressionScope.exit();
                }
                registerFunctionStatementId(e1) {
                    if (!e1.id) return;
                    this.scope.declareName(e1.id.name, !this.options.annexB || this.state.strict || e1.generator || e1.async ? this.scope.treatFunctionsAsVar ? de : pe : he, e1.id.loc.start);
                }
                parseClass(e1, t, r) {
                    this.next();
                    const n = this.state.strict;
                    this.state.strict = true;
                    this.parseClassId(e1, t, r);
                    this.parseClassSuper(e1);
                    e1.body = this.parseClassBody(!!e1.superClass, n);
                    return this.finishNode(e1, t ? "ClassDeclaration" : "ClassExpression");
                }
                isClassProperty() {
                    return this.match(29) || this.match(13) || this.match(8);
                }
                isClassMethod() {
                    return this.match(10);
                }
                isNonstaticConstructor(e1) {
                    return !e1.computed && !e1.static && (e1.key.name === "constructor" || e1.key.value === "constructor");
                }
                parseClassBody(e1, t) {
                    this.classScope.enter();
                    const r = {
                        hadConstructor: false,
                        hadSuperClass: e1
                    };
                    let n = [];
                    const s = this.startNode();
                    s.body = [];
                    this.expect(5);
                    this.withSmartMixTopicForbiddingContext(()=>{
                        while(!this.match(8)){
                            if (this.eat(13)) {
                                if (n.length > 0) {
                                    throw this.raise(p.DecoratorSemicolon, {
                                        at: this.state.lastTokEndLoc
                                    });
                                }
                                continue;
                            }
                            if (this.match(26)) {
                                n.push(this.parseDecorator());
                                continue;
                            }
                            const e1 = this.startNode();
                            if (n.length) {
                                e1.decorators = n;
                                this.resetStartLocationFromNode(e1, n[0]);
                                n = [];
                            }
                            this.parseClassMember(s, e1, r);
                            if (e1.kind === "constructor" && e1.decorators && e1.decorators.length > 0) {
                                this.raise(p.DecoratorConstructor, {
                                    at: e1
                                });
                            }
                        }
                    });
                    this.state.strict = t;
                    this.next();
                    if (n.length) {
                        throw this.raise(p.TrailingDecorator, {
                            at: this.state.startLoc
                        });
                    }
                    this.classScope.exit();
                    return this.finishNode(s, "ClassBody");
                }
                parseClassMemberFromModifier(e1, t) {
                    const r = this.parseIdentifier(true);
                    if (this.isClassMethod()) {
                        const n = t;
                        n.kind = "method";
                        n.computed = false;
                        n.key = r;
                        n.static = false;
                        this.pushClassMethod(e1, n, false, false, false, false);
                        return true;
                    } else if (this.isClassProperty()) {
                        const n = t;
                        n.computed = false;
                        n.key = r;
                        n.static = false;
                        e1.body.push(this.parseClassProperty(n));
                        return true;
                    }
                    this.resetPreviousNodeTrailingComments(r);
                    return false;
                }
                parseClassMember(e1, t, r) {
                    const n = this.isContextual(104);
                    if (n) {
                        if (this.parseClassMemberFromModifier(e1, t)) {
                            return;
                        }
                        if (this.eat(5)) {
                            this.parseClassStaticBlock(e1, t);
                            return;
                        }
                    }
                    this.parseClassMemberWithIsStatic(e1, t, r, n);
                }
                parseClassMemberWithIsStatic(e1, t, r, n) {
                    const s = t;
                    const i = t;
                    const a = t;
                    const o = t;
                    const l = t;
                    const c = s;
                    const u = s;
                    t.static = n;
                    this.parsePropertyNamePrefixOperator(t);
                    if (this.eat(55)) {
                        c.kind = "method";
                        const t = this.match(136);
                        this.parseClassElementName(c);
                        if (t) {
                            this.pushClassPrivateMethod(e1, i, true, false);
                            return;
                        }
                        if (this.isNonstaticConstructor(s)) {
                            this.raise(p.ConstructorIsGenerator, {
                                at: s.key
                            });
                        }
                        this.pushClassMethod(e1, s, true, false, false, false);
                        return;
                    }
                    const f = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
                    const d = this.match(136);
                    const h = this.parseClassElementName(t);
                    const m = this.state.startLoc;
                    this.parsePostMemberNameModifiers(u);
                    if (this.isClassMethod()) {
                        c.kind = "method";
                        if (d) {
                            this.pushClassPrivateMethod(e1, i, false, false);
                            return;
                        }
                        const n = this.isNonstaticConstructor(s);
                        let a = false;
                        if (n) {
                            s.kind = "constructor";
                            if (r.hadConstructor && !this.hasPlugin("typescript")) {
                                this.raise(p.DuplicateConstructor, {
                                    at: h
                                });
                            }
                            if (n && this.hasPlugin("typescript") && t.override) {
                                this.raise(p.OverrideOnConstructor, {
                                    at: h
                                });
                            }
                            r.hadConstructor = true;
                            a = r.hadSuperClass;
                        }
                        this.pushClassMethod(e1, s, false, false, n, a);
                    } else if (this.isClassProperty()) {
                        if (d) {
                            this.pushClassPrivateProperty(e1, o);
                        } else {
                            this.pushClassProperty(e1, a);
                        }
                    } else if (f && h.name === "async" && !this.isLineTerminator()) {
                        this.resetPreviousNodeTrailingComments(h);
                        const t = this.eat(55);
                        if (u.optional) {
                            this.unexpected(m);
                        }
                        c.kind = "method";
                        const r = this.match(136);
                        this.parseClassElementName(c);
                        this.parsePostMemberNameModifiers(u);
                        if (r) {
                            this.pushClassPrivateMethod(e1, i, t, true);
                        } else {
                            if (this.isNonstaticConstructor(s)) {
                                this.raise(p.ConstructorIsAsync, {
                                    at: s.key
                                });
                            }
                            this.pushClassMethod(e1, s, t, true, false, false);
                        }
                    } else if (f && (h.name === "get" || h.name === "set") && !(this.match(55) && this.isLineTerminator())) {
                        this.resetPreviousNodeTrailingComments(h);
                        c.kind = h.name;
                        const t = this.match(136);
                        this.parseClassElementName(s);
                        if (t) {
                            this.pushClassPrivateMethod(e1, i, false, false);
                        } else {
                            if (this.isNonstaticConstructor(s)) {
                                this.raise(p.ConstructorIsAccessor, {
                                    at: s.key
                                });
                            }
                            this.pushClassMethod(e1, s, false, false, false, false);
                        }
                        this.checkGetterSetterParams(s);
                    } else if (f && h.name === "accessor" && !this.isLineTerminator()) {
                        this.expectPlugin("decoratorAutoAccessors");
                        this.resetPreviousNodeTrailingComments(h);
                        const t = this.match(136);
                        this.parseClassElementName(a);
                        this.pushClassAccessorProperty(e1, l, t);
                    } else if (this.isLineTerminator()) {
                        if (d) {
                            this.pushClassPrivateProperty(e1, o);
                        } else {
                            this.pushClassProperty(e1, a);
                        }
                    } else {
                        this.unexpected();
                    }
                }
                parseClassElementName(e1) {
                    const { type: t, value: r } = this.state;
                    if ((t === 130 || t === 131) && e1.static && r === "prototype") {
                        this.raise(p.StaticPrototype, {
                            at: this.state.startLoc
                        });
                    }
                    if (t === 136) {
                        if (r === "constructor") {
                            this.raise(p.ConstructorClassPrivateField, {
                                at: this.state.startLoc
                            });
                        }
                        const t = this.parsePrivateName();
                        e1.key = t;
                        return t;
                    }
                    return this.parsePropertyName(e1);
                }
                parseClassStaticBlock(e1, t) {
                    var r;
                    this.scope.enter(G | J | q);
                    const n = this.state.labels;
                    this.state.labels = [];
                    this.prodParam.enter(Xe);
                    const s = t.body = [];
                    this.parseBlockOrModuleBlockBody(s, undefined, false, 8);
                    this.prodParam.exit();
                    this.scope.exit();
                    this.state.labels = n;
                    e1.body.push(this.finishNode(t, "StaticBlock"));
                    if ((r = t.decorators) != null && r.length) {
                        this.raise(p.DecoratorStaticBlock, {
                            at: t
                        });
                    }
                }
                pushClassProperty(e1, t) {
                    if (!t.computed && (t.key.name === "constructor" || t.key.value === "constructor")) {
                        this.raise(p.ConstructorClassField, {
                            at: t.key
                        });
                    }
                    e1.body.push(this.parseClassProperty(t));
                }
                pushClassPrivateProperty(e1, t) {
                    const r = this.parseClassPrivateProperty(t);
                    e1.body.push(r);
                    this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), De, r.key.loc.start);
                }
                pushClassAccessorProperty(e1, t, r) {
                    if (!r && !t.computed) {
                        const e1 = t.key;
                        if (e1.name === "constructor" || e1.value === "constructor") {
                            this.raise(p.ConstructorClassField, {
                                at: e1
                            });
                        }
                    }
                    const n = this.parseClassAccessorProperty(t);
                    e1.body.push(n);
                    if (r) {
                        this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), De, n.key.loc.start);
                    }
                }
                pushClassMethod(e1, t, r, n, s, i) {
                    e1.body.push(this.parseMethod(t, r, n, s, i, "ClassMethod", true));
                }
                pushClassPrivateMethod(e1, t, r, n) {
                    const s = this.parseMethod(t, r, n, false, false, "ClassPrivateMethod", true);
                    e1.body.push(s);
                    const i = s.kind === "get" ? s.static ? Oe : Ne : s.kind === "set" ? s.static ? ke : _e : De;
                    this.declareClassPrivateMethodInScope(s, i);
                }
                declareClassPrivateMethodInScope(e1, t) {
                    this.classScope.declarePrivateName(this.getPrivateNameSV(e1.key), t, e1.key.loc.start);
                }
                parsePostMemberNameModifiers(e1) {}
                parseClassPrivateProperty(e1) {
                    this.parseInitializer(e1);
                    this.semicolon();
                    return this.finishNode(e1, "ClassPrivateProperty");
                }
                parseClassProperty(e1) {
                    this.parseInitializer(e1);
                    this.semicolon();
                    return this.finishNode(e1, "ClassProperty");
                }
                parseClassAccessorProperty(e1) {
                    this.parseInitializer(e1);
                    this.semicolon();
                    return this.finishNode(e1, "ClassAccessorProperty");
                }
                parseInitializer(e1) {
                    this.scope.enter(G | q);
                    this.expressionScope.enter(newExpressionScope());
                    this.prodParam.enter(Xe);
                    e1.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
                    this.expressionScope.exit();
                    this.prodParam.exit();
                    this.scope.exit();
                }
                parseClassId(e1, t, r, n = ue) {
                    if (tokenIsIdentifier(this.state.type)) {
                        e1.id = this.parseIdentifier();
                        if (t) {
                            this.declareNameFromIdentifier(e1.id, n);
                        }
                    } else {
                        if (r || !t) {
                            e1.id = null;
                        } else {
                            throw this.raise(p.MissingClassName, {
                                at: this.state.startLoc
                            });
                        }
                    }
                }
                parseClassSuper(e1) {
                    e1.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
                }
                parseExport(e1, t) {
                    const r = this.parseMaybeImportPhase(e1, true);
                    const n = this.maybeParseExportDefaultSpecifier(e1, r);
                    const s = !n || this.eat(12);
                    const i = s && this.eatExportStar(e1);
                    const a = i && this.maybeParseExportNamespaceSpecifier(e1);
                    const o = s && (!a || this.eat(12));
                    const l = n || i;
                    if (i && !a) {
                        if (n) this.unexpected();
                        if (t) {
                            throw this.raise(p.UnsupportedDecoratorExport, {
                                at: e1
                            });
                        }
                        this.parseExportFrom(e1, true);
                        return this.finishNode(e1, "ExportAllDeclaration");
                    }
                    const c = this.maybeParseExportNamedSpecifiers(e1);
                    if (n && s && !i && !c) {
                        this.unexpected(null, 5);
                    }
                    if (a && o) {
                        this.unexpected(null, 97);
                    }
                    let u;
                    if (l || c) {
                        u = false;
                        if (t) {
                            throw this.raise(p.UnsupportedDecoratorExport, {
                                at: e1
                            });
                        }
                        this.parseExportFrom(e1, l);
                    } else {
                        u = this.maybeParseExportDeclaration(e1);
                    }
                    if (l || c || u) {
                        var f;
                        const r = e1;
                        this.checkExport(r, true, false, !!r.source);
                        if (((f = r.declaration) == null ? void 0 : f.type) === "ClassDeclaration") {
                            this.maybeTakeDecorators(t, r.declaration, r);
                        } else if (t) {
                            throw this.raise(p.UnsupportedDecoratorExport, {
                                at: e1
                            });
                        }
                        return this.finishNode(r, "ExportNamedDeclaration");
                    }
                    if (this.eat(65)) {
                        const r = e1;
                        const n = this.parseExportDefaultExpression();
                        r.declaration = n;
                        if (n.type === "ClassDeclaration") {
                            this.maybeTakeDecorators(t, n, r);
                        } else if (t) {
                            throw this.raise(p.UnsupportedDecoratorExport, {
                                at: e1
                            });
                        }
                        this.checkExport(r, true, true);
                        return this.finishNode(r, "ExportDefaultDeclaration");
                    }
                    this.unexpected(null, 5);
                }
                eatExportStar(e1) {
                    return this.eat(55);
                }
                maybeParseExportDefaultSpecifier(e1, t) {
                    if (t || this.isExportDefaultSpecifier()) {
                        this.expectPlugin("exportDefaultFrom", t == null ? void 0 : t.loc.start);
                        const r = t || this.parseIdentifier(true);
                        const n = this.startNodeAtNode(r);
                        n.exported = r;
                        e1.specifiers = [
                            this.finishNode(n, "ExportDefaultSpecifier")
                        ];
                        return true;
                    }
                    return false;
                }
                maybeParseExportNamespaceSpecifier(e1) {
                    if (this.isContextual(93)) {
                        if (!e1.specifiers) e1.specifiers = [];
                        const t = this.startNodeAt(this.state.lastTokStartLoc);
                        this.next();
                        t.exported = this.parseModuleExportName();
                        e1.specifiers.push(this.finishNode(t, "ExportNamespaceSpecifier"));
                        return true;
                    }
                    return false;
                }
                maybeParseExportNamedSpecifiers(e1) {
                    if (this.match(5)) {
                        if (!e1.specifiers) e1.specifiers = [];
                        const t = e1.exportKind === "type";
                        e1.specifiers.push(...this.parseExportSpecifiers(t));
                        e1.source = null;
                        e1.declaration = null;
                        if (this.hasPlugin("importAssertions")) {
                            e1.assertions = [];
                        }
                        return true;
                    }
                    return false;
                }
                maybeParseExportDeclaration(e1) {
                    if (this.shouldParseExportDeclaration()) {
                        e1.specifiers = [];
                        e1.source = null;
                        if (this.hasPlugin("importAssertions")) {
                            e1.assertions = [];
                        }
                        e1.declaration = this.parseExportDeclaration(e1);
                        return true;
                    }
                    return false;
                }
                isAsyncFunction() {
                    if (!this.isContextual(95)) return false;
                    const e1 = this.nextTokenInLineStart();
                    return this.isUnparsedContextual(e1, "function");
                }
                parseExportDefaultExpression() {
                    const e1 = this.startNode();
                    if (this.match(68)) {
                        this.next();
                        return this.parseFunction(e1, 1 | 4);
                    } else if (this.isAsyncFunction()) {
                        this.next();
                        this.next();
                        return this.parseFunction(e1, 1 | 4 | 8);
                    }
                    if (this.match(80)) {
                        return this.parseClass(e1, true, true);
                    }
                    if (this.match(26)) {
                        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
                            this.raise(p.DecoratorBeforeExport, {
                                at: this.state.startLoc
                            });
                        }
                        return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
                    }
                    if (this.match(75) || this.match(74) || this.isLet()) {
                        throw this.raise(p.UnsupportedDefaultExport, {
                            at: this.state.startLoc
                        });
                    }
                    const t = this.parseMaybeAssignAllowIn();
                    this.semicolon();
                    return t;
                }
                parseExportDeclaration(e1) {
                    if (this.match(80)) {
                        const e1 = this.parseClass(this.startNode(), true, false);
                        return e1;
                    }
                    return this.parseStatementListItem();
                }
                isExportDefaultSpecifier() {
                    const { type: e1 } = this.state;
                    if (tokenIsIdentifier(e1)) {
                        if (e1 === 95 && !this.state.containsEsc || e1 === 99) {
                            return false;
                        }
                        if ((e1 === 128 || e1 === 127) && !this.state.containsEsc) {
                            const { type: e1 } = this.lookahead();
                            if (tokenIsIdentifier(e1) && e1 !== 97 || e1 === 5) {
                                this.expectOnePlugin([
                                    "flow",
                                    "typescript"
                                ]);
                                return false;
                            }
                        }
                    } else if (!this.match(65)) {
                        return false;
                    }
                    const t = this.nextTokenStart();
                    const r = this.isUnparsedContextual(t, "from");
                    if (this.input.charCodeAt(t) === 44 || tokenIsIdentifier(this.state.type) && r) {
                        return true;
                    }
                    if (this.match(65) && r) {
                        const e1 = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
                        return e1 === 34 || e1 === 39;
                    }
                    return false;
                }
                parseExportFrom(e1, t) {
                    if (this.eatContextual(97)) {
                        e1.source = this.parseImportSource();
                        this.checkExport(e1);
                        this.maybeParseImportAttributes(e1);
                        this.checkJSONModuleImport(e1);
                    } else if (t) {
                        this.unexpected();
                    }
                    this.semicolon();
                }
                shouldParseExportDeclaration() {
                    const { type: e1 } = this.state;
                    if (e1 === 26) {
                        this.expectOnePlugin([
                            "decorators",
                            "decorators-legacy"
                        ]);
                        if (this.hasPlugin("decorators")) {
                            if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
                                this.raise(p.DecoratorBeforeExport, {
                                    at: this.state.startLoc
                                });
                            }
                            return true;
                        }
                    }
                    return e1 === 74 || e1 === 75 || e1 === 68 || e1 === 80 || this.isLet() || this.isAsyncFunction();
                }
                checkExport(e1, t, r, n) {
                    if (t) {
                        if (r) {
                            this.checkDuplicateExports(e1, "default");
                            if (this.hasPlugin("exportDefaultFrom")) {
                                var s;
                                const t = e1.declaration;
                                if (t.type === "Identifier" && t.name === "from" && t.end - t.start === 4 && !((s = t.extra) != null && s.parenthesized)) {
                                    this.raise(p.ExportDefaultFromAsIdentifier, {
                                        at: t
                                    });
                                }
                            }
                        } else if (e1.specifiers && e1.specifiers.length) {
                            for (const t of e1.specifiers){
                                const { exported: e1 } = t;
                                const r = e1.type === "Identifier" ? e1.name : e1.value;
                                this.checkDuplicateExports(t, r);
                                if (!n && t.local) {
                                    const { local: e1 } = t;
                                    if (e1.type !== "Identifier") {
                                        this.raise(p.ExportBindingIsString, {
                                            at: t,
                                            localName: e1.value,
                                            exportName: r
                                        });
                                    } else {
                                        this.checkReservedWord(e1.name, e1.loc.start, true, false);
                                        this.scope.checkLocalExport(e1);
                                    }
                                }
                            }
                        } else if (e1.declaration) {
                            if (e1.declaration.type === "FunctionDeclaration" || e1.declaration.type === "ClassDeclaration") {
                                const t = e1.declaration.id;
                                if (!t) throw new Error("Assertion failure");
                                this.checkDuplicateExports(e1, t.name);
                            } else if (e1.declaration.type === "VariableDeclaration") {
                                for (const t of e1.declaration.declarations){
                                    this.checkDeclaration(t.id);
                                }
                            }
                        }
                    }
                }
                checkDeclaration(e1) {
                    if (e1.type === "Identifier") {
                        this.checkDuplicateExports(e1, e1.name);
                    } else if (e1.type === "ObjectPattern") {
                        for (const t of e1.properties){
                            this.checkDeclaration(t);
                        }
                    } else if (e1.type === "ArrayPattern") {
                        for (const t of e1.elements){
                            if (t) {
                                this.checkDeclaration(t);
                            }
                        }
                    } else if (e1.type === "ObjectProperty") {
                        this.checkDeclaration(e1.value);
                    } else if (e1.type === "RestElement") {
                        this.checkDeclaration(e1.argument);
                    } else if (e1.type === "AssignmentPattern") {
                        this.checkDeclaration(e1.left);
                    }
                }
                checkDuplicateExports(e1, t) {
                    if (this.exportedIdentifiers.has(t)) {
                        if (t === "default") {
                            this.raise(p.DuplicateDefaultExport, {
                                at: e1
                            });
                        } else {
                            this.raise(p.DuplicateExport, {
                                at: e1,
                                exportName: t
                            });
                        }
                    }
                    this.exportedIdentifiers.add(t);
                }
                parseExportSpecifiers(e1) {
                    const t = [];
                    let r = true;
                    this.expect(5);
                    while(!this.eat(8)){
                        if (r) {
                            r = false;
                        } else {
                            this.expect(12);
                            if (this.eat(8)) break;
                        }
                        const n = this.isContextual(128);
                        const s = this.match(131);
                        const i = this.startNode();
                        i.local = this.parseModuleExportName();
                        t.push(this.parseExportSpecifier(i, s, e1, n));
                    }
                    return t;
                }
                parseExportSpecifier(e1, t, r, n) {
                    if (this.eatContextual(93)) {
                        e1.exported = this.parseModuleExportName();
                    } else if (t) {
                        e1.exported = cloneStringLiteral(e1.local);
                    } else if (!e1.exported) {
                        e1.exported = cloneIdentifier(e1.local);
                    }
                    return this.finishNode(e1, "ExportSpecifier");
                }
                parseModuleExportName() {
                    if (this.match(131)) {
                        const e1 = this.parseStringLiteral(this.state.value);
                        const t = e1.value.match(gt);
                        if (t) {
                            this.raise(p.ModuleExportNameHasLoneSurrogate, {
                                at: e1,
                                surrogateCharCode: t[0].charCodeAt(0)
                            });
                        }
                        return e1;
                    }
                    return this.parseIdentifier(true);
                }
                isJSONModuleImport(e1) {
                    if (e1.assertions != null) {
                        return e1.assertions.some(({ key: e1, value: t })=>t.value === "json" && (e1.type === "Identifier" ? e1.name === "type" : e1.value === "type"));
                    }
                    return false;
                }
                checkImportReflection(e1) {
                    if (e1.module) {
                        var t;
                        if (e1.specifiers.length !== 1 || e1.specifiers[0].type !== "ImportDefaultSpecifier") {
                            this.raise(p.ImportReflectionNotBinding, {
                                at: e1.specifiers[0].loc.start
                            });
                        }
                        if (((t = e1.assertions) == null ? void 0 : t.length) > 0) {
                            this.raise(p.ImportReflectionHasAssertion, {
                                at: e1.specifiers[0].loc.start
                            });
                        }
                    }
                }
                checkJSONModuleImport(e1) {
                    if (this.isJSONModuleImport(e1) && e1.type !== "ExportAllDeclaration") {
                        const { specifiers: t } = e1;
                        if (t != null) {
                            const e1 = t.find((e1)=>{
                                let t;
                                if (e1.type === "ExportSpecifier") {
                                    t = e1.local;
                                } else if (e1.type === "ImportSpecifier") {
                                    t = e1.imported;
                                }
                                if (t !== undefined) {
                                    return t.type === "Identifier" ? t.name !== "default" : t.value !== "default";
                                }
                            });
                            if (e1 !== undefined) {
                                this.raise(p.ImportJSONBindingNotDefault, {
                                    at: e1.loc.start
                                });
                            }
                        }
                    }
                }
                isPotentialImportPhase(e1) {
                    return !e1 && this.isContextual(125);
                }
                applyImportPhase(e1, t, r, n) {
                    if (t) {
                        return;
                    }
                    if (r === "module") {
                        this.expectPlugin("importReflection", n);
                        e1.module = true;
                    } else if (this.hasPlugin("importReflection")) {
                        e1.module = false;
                    }
                }
                parseMaybeImportPhase(e1, t) {
                    if (!this.isPotentialImportPhase(t)) {
                        this.applyImportPhase(e1, t, null);
                        return null;
                    }
                    const r = this.parseIdentifier(true);
                    const { type: n } = this.state;
                    const s = tokenIsKeywordOrIdentifier(n) ? n !== 97 || this.lookaheadCharCode() === 102 : n !== 12;
                    if (s) {
                        this.resetPreviousIdentifierLeadingComments(r);
                        this.applyImportPhase(e1, t, r.name, r.loc.start);
                        return null;
                    } else {
                        this.applyImportPhase(e1, t, null);
                        return r;
                    }
                }
                isPrecedingIdImportPhase(e1) {
                    const { type: t } = this.state;
                    return tokenIsIdentifier(t) ? t !== 97 || this.lookaheadCharCode() === 102 : t !== 12;
                }
                parseImport(e1) {
                    if (this.match(131)) {
                        return this.parseImportSourceAndAttributes(e1);
                    }
                    return this.parseImportSpecifiersAndAfter(e1, this.parseMaybeImportPhase(e1, false));
                }
                parseImportSpecifiersAndAfter(e1, t) {
                    e1.specifiers = [];
                    const r = this.maybeParseDefaultImportSpecifier(e1, t);
                    const n = !r || this.eat(12);
                    const s = n && this.maybeParseStarImportSpecifier(e1);
                    if (n && !s) this.parseNamedImportSpecifiers(e1);
                    this.expectContextual(97);
                    return this.parseImportSourceAndAttributes(e1);
                }
                parseImportSourceAndAttributes(e1) {
                    var t;
                    (t = e1.specifiers) != null ? t : e1.specifiers = [];
                    e1.source = this.parseImportSource();
                    this.maybeParseImportAttributes(e1);
                    this.checkImportReflection(e1);
                    this.checkJSONModuleImport(e1);
                    this.semicolon();
                    return this.finishNode(e1, "ImportDeclaration");
                }
                parseImportSource() {
                    if (!this.match(131)) this.unexpected();
                    return this.parseExprAtom();
                }
                parseImportSpecifierLocal(e1, t, r) {
                    t.local = this.parseIdentifier();
                    e1.specifiers.push(this.finishImportSpecifier(t, r));
                }
                finishImportSpecifier(e1, t, r = pe) {
                    this.checkLVal(e1.local, {
                        in: {
                            type: t
                        },
                        binding: r
                    });
                    return this.finishNode(e1, t);
                }
                parseImportAttributes() {
                    this.expect(5);
                    const e1 = [];
                    const t = new Set;
                    do {
                        if (this.match(8)) {
                            break;
                        }
                        const r = this.startNode();
                        const n = this.state.value;
                        if (t.has(n)) {
                            this.raise(p.ModuleAttributesWithDuplicateKeys, {
                                at: this.state.startLoc,
                                key: n
                            });
                        }
                        t.add(n);
                        if (this.match(131)) {
                            r.key = this.parseStringLiteral(n);
                        } else {
                            r.key = this.parseIdentifier(true);
                        }
                        this.expect(14);
                        if (!this.match(131)) {
                            throw this.raise(p.ModuleAttributeInvalidValue, {
                                at: this.state.startLoc
                            });
                        }
                        r.value = this.parseStringLiteral(this.state.value);
                        e1.push(this.finishNode(r, "ImportAttribute"));
                    }while (this.eat(12))
                    this.expect(8);
                    return e1;
                }
                parseModuleAttributes() {
                    const e1 = [];
                    const t = new Set;
                    do {
                        const r = this.startNode();
                        r.key = this.parseIdentifier(true);
                        if (r.key.name !== "type") {
                            this.raise(p.ModuleAttributeDifferentFromType, {
                                at: r.key
                            });
                        }
                        if (t.has(r.key.name)) {
                            this.raise(p.ModuleAttributesWithDuplicateKeys, {
                                at: r.key,
                                key: r.key.name
                            });
                        }
                        t.add(r.key.name);
                        this.expect(14);
                        if (!this.match(131)) {
                            throw this.raise(p.ModuleAttributeInvalidValue, {
                                at: this.state.startLoc
                            });
                        }
                        r.value = this.parseStringLiteral(this.state.value);
                        e1.push(this.finishNode(r, "ImportAttribute"));
                    }while (this.eat(12))
                    return e1;
                }
                maybeParseImportAttributes(e1) {
                    let t;
                    let r = false;
                    if (this.match(76)) {
                        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
                            return;
                        }
                        this.next();
                        {
                            if (this.hasPlugin("moduleAttributes")) {
                                t = this.parseModuleAttributes();
                            } else {
                                this.expectImportAttributesPlugin();
                                t = this.parseImportAttributes();
                            }
                        }
                        r = true;
                    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
                        if (this.hasPlugin("importAttributes")) {
                            if (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true) {
                                this.raise(p.ImportAttributesUseAssert, {
                                    at: this.state.startLoc
                                });
                            }
                            this.addExtra(e1, "deprecatedAssertSyntax", true);
                        } else {
                            this.expectOnePlugin([
                                "importAttributes",
                                "importAssertions"
                            ]);
                        }
                        this.next();
                        t = this.parseImportAttributes();
                    } else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
                        t = [];
                    } else {
                        if (this.hasPlugin("moduleAttributes")) {
                            t = [];
                        } else return;
                    }
                    if (!r && this.hasPlugin("importAssertions")) {
                        e1.assertions = t;
                    } else {
                        e1.attributes = t;
                    }
                }
                maybeParseDefaultImportSpecifier(e1, t) {
                    if (t) {
                        const r = this.startNodeAtNode(t);
                        r.local = t;
                        e1.specifiers.push(this.finishImportSpecifier(r, "ImportDefaultSpecifier"));
                        return true;
                    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
                        this.parseImportSpecifierLocal(e1, this.startNode(), "ImportDefaultSpecifier");
                        return true;
                    }
                    return false;
                }
                maybeParseStarImportSpecifier(e1) {
                    if (this.match(55)) {
                        const t = this.startNode();
                        this.next();
                        this.expectContextual(93);
                        this.parseImportSpecifierLocal(e1, t, "ImportNamespaceSpecifier");
                        return true;
                    }
                    return false;
                }
                parseNamedImportSpecifiers(e1) {
                    let t = true;
                    this.expect(5);
                    while(!this.eat(8)){
                        if (t) {
                            t = false;
                        } else {
                            if (this.eat(14)) {
                                throw this.raise(p.DestructureNamedImport, {
                                    at: this.state.startLoc
                                });
                            }
                            this.expect(12);
                            if (this.eat(8)) break;
                        }
                        const r = this.startNode();
                        const n = this.match(131);
                        const s = this.isContextual(128);
                        r.imported = this.parseModuleExportName();
                        const i = this.parseImportSpecifier(r, n, e1.importKind === "type" || e1.importKind === "typeof", s, undefined);
                        e1.specifiers.push(i);
                    }
                }
                parseImportSpecifier(e1, t, r, n, s) {
                    if (this.eatContextual(93)) {
                        e1.local = this.parseIdentifier();
                    } else {
                        const { imported: r } = e1;
                        if (t) {
                            throw this.raise(p.ImportBindingIsString, {
                                at: e1,
                                importName: r.value
                            });
                        }
                        this.checkReservedWord(r.name, e1.loc.start, true, true);
                        if (!e1.local) {
                            e1.local = cloneIdentifier(r);
                        }
                    }
                    return this.finishImportSpecifier(e1, "ImportSpecifier", s);
                }
                isThisParam(e1) {
                    return e1.type === "Identifier" && e1.name === "this";
                }
            }
            class Parser extends StatementParser {
                constructor(e1, t){
                    e1 = getOptions(e1);
                    super(e1, t);
                    this.options = e1;
                    this.initializeScopes();
                    this.plugins = pluginsMap(this.options.plugins);
                    this.filename = e1.sourceFilename;
                }
                getScopeHandler() {
                    return ScopeHandler;
                }
                parse() {
                    this.enterInitialScopes();
                    const e1 = this.startNode();
                    const t = this.startNode();
                    this.nextToken();
                    e1.errors = null;
                    this.parseTopLevel(e1, t);
                    e1.errors = this.state.errors;
                    return e1;
                }
            }
            function pluginsMap(e1) {
                const t = new Map;
                for (const r of e1){
                    const [e1, n] = Array.isArray(r) ? r : [
                        r,
                        {}
                    ];
                    if (!t.has(e1)) t.set(e1, n || {});
                }
                return t;
            }
            function parse(e1, t) {
                var r;
                if (((r = t) == null ? void 0 : r.sourceType) === "unambiguous") {
                    t = Object.assign({}, t);
                    try {
                        t.sourceType = "module";
                        const r = getParser(t, e1);
                        const n = r.parse();
                        if (r.sawUnambiguousESM) {
                            return n;
                        }
                        if (r.ambiguousScriptDifferentAst) {
                            try {
                                t.sourceType = "script";
                                return getParser(t, e1).parse();
                            } catch (e1) {}
                        } else {
                            n.program.sourceType = "script";
                        }
                        return n;
                    } catch (r) {
                        try {
                            t.sourceType = "script";
                            return getParser(t, e1).parse();
                        } catch (e1) {}
                        throw r;
                    }
                } else {
                    return getParser(t, e1).parse();
                }
            }
            function parseExpression(e1, t) {
                const r = getParser(t, e1);
                if (r.options.strictMode) {
                    r.state.strict = true;
                }
                return r.getExpression();
            }
            function generateExportedTokenTypes(e1) {
                const t = {};
                for (const r of Object.keys(e1)){
                    t[r] = getExportedToken(e1[r]);
                }
                return t;
            }
            const Tt = generateExportedTokenTypes(I);
            function getParser(e1, t) {
                let r = Parser;
                if (e1 != null && e1.plugins) {
                    validatePlugins(e1.plugins);
                    r = getParserClass(e1.plugins);
                }
                return new r(e1, t);
            }
            const St = {};
            function getParserClass(e1) {
                const t = dt.filter((t)=>hasPlugin(e1, t));
                const r = t.join("/");
                let n = St[r];
                if (!n) {
                    n = Parser;
                    for (const e1 of t){
                        n = ft[e1](n);
                    }
                    St[r] = n;
                }
                return n;
            }
            t.parse = parse;
            t.parseExpression = parseExpression;
            t.tokTypes = Tt;
        },
        6085: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(5389);
            var s = (0, n.declare)((e1)=>{
                e1.assertVersion(7);
                return {
                    name: "syntax-jsx",
                    manipulateOptions (e1, t) {
                        {
                            if (t.plugins.some((e1)=>(Array.isArray(e1) ? e1[0] : e1) === "typescript")) {
                                return;
                            }
                        }
                        t.plugins.push("jsx");
                    }
                };
            });
            t["default"] = s;
        },
        6141: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(8863);
            {
                var removePlugin = function(e1, t) {
                    const r = [];
                    e1.forEach((e1, n)=>{
                        const s = Array.isArray(e1) ? e1[0] : e1;
                        if (s === t) {
                            r.unshift(n);
                        }
                    });
                    for (const t of r){
                        e1.splice(t, 1);
                    }
                };
            }
            var s = (0, n.declare)((e1, t)=>{
                e1.assertVersion(7);
                const { disallowAmbiguousJSXLike: r, dts: n } = t;
                {
                    var { isTSX: s } = t;
                }
                return {
                    name: "syntax-typescript",
                    manipulateOptions (e1, t) {
                        {
                            const { plugins: e1 } = t;
                            removePlugin(e1, "flow");
                            removePlugin(e1, "jsx");
                            e1.push("objectRestSpread", "classProperties");
                            if (s) {
                                e1.push("jsx");
                            }
                        }
                        t.plugins.push([
                            "typescript",
                            {
                                disallowAmbiguousJSXLike: r,
                                dts: n
                            }
                        ]);
                    }
                };
            });
            t["default"] = s;
        },
        9511: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.transformDynamicImport = transformDynamicImport;
            var n = r(3688);
            var s = r(6646);
            const requireNoInterop = (e1)=>n.template.expression.ast`require(${e1})`;
            const requireInterop = (e1, t)=>n.types.callExpression(t.addHelper("interopRequireWildcard"), [
                    requireNoInterop(e1)
                ]);
            function transformDynamicImport(e1, t, r) {
                const n = t ? requireNoInterop : requireInterop;
                e1.replaceWith((0, s.buildDynamicImport)(e1.node, true, false, (e1)=>n(e1, r)));
            }
        },
        8417: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(5389);
            var s = r(6646);
            var i = r(6118);
            var a = r(3688);
            var o = r(9511);
            var l = (0, n.declare)((e1, t)=>{
                var r, n, l;
                e1.assertVersion(7);
                const { strictNamespace: c = false, mjsStrictNamespace: u = c, allowTopLevelThis: p, strict: f, strictMode: d, noInterop: h, importInterop: m, lazy: y = false, allowCommonJSExports: g = true, loose: b = false } = t;
                const T = (r = e1.assumption("constantReexports")) != null ? r : b;
                const S = (n = e1.assumption("enumerableModuleMeta")) != null ? n : b;
                const E = (l = e1.assumption("noIncompleteNsImportDetection")) != null ? l : false;
                if (typeof y !== "boolean" && typeof y !== "function" && (!Array.isArray(y) || !y.every((e1)=>typeof e1 === "string"))) {
                    throw new Error(`.lazy must be a boolean, array of strings, or a function`);
                }
                if (typeof c !== "boolean") {
                    throw new Error(`.strictNamespace must be a boolean, or undefined`);
                }
                if (typeof u !== "boolean") {
                    throw new Error(`.mjsStrictNamespace must be a boolean, or undefined`);
                }
                const getAssertion = (e1)=>a.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${e1}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `;
                const v = {
                    ReferencedIdentifier (e1) {
                        const t = e1.node.name;
                        if (t !== "module" && t !== "exports") return;
                        const r = e1.scope.getBinding(t);
                        const n = this.scope.getBinding(t);
                        if (n !== r || e1.parentPath.isObjectProperty({
                            value: e1.node
                        }) && e1.parentPath.parentPath.isObjectPattern() || e1.parentPath.isAssignmentExpression({
                            left: e1.node
                        }) || e1.isAssignmentExpression({
                            left: e1.node
                        })) {
                            return;
                        }
                        e1.replaceWith(getAssertion(t));
                    },
                    UpdateExpression (e1) {
                        const t = e1.get("argument");
                        if (!t.isIdentifier()) return;
                        const r = t.node.name;
                        if (r !== "module" && r !== "exports") return;
                        const n = e1.scope.getBinding(r);
                        const s = this.scope.getBinding(r);
                        if (s !== n) return;
                        e1.replaceWith(a.types.assignmentExpression(e1.node.operator[0] + "=", t.node, getAssertion(r)));
                    },
                    AssignmentExpression (e1) {
                        const t = e1.get("left");
                        if (t.isIdentifier()) {
                            const r = t.node.name;
                            if (r !== "module" && r !== "exports") return;
                            const n = e1.scope.getBinding(r);
                            const s = this.scope.getBinding(r);
                            if (s !== n) return;
                            const i = e1.get("right");
                            i.replaceWith(a.types.sequenceExpression([
                                i.node,
                                getAssertion(r)
                            ]));
                        } else if (t.isPattern()) {
                            const r = t.getOuterBindingIdentifiers();
                            const n = Object.keys(r).filter((t)=>{
                                if (t !== "module" && t !== "exports") return false;
                                return this.scope.getBinding(t) === e1.scope.getBinding(t);
                            })[0];
                            if (n) {
                                const t = e1.get("right");
                                t.replaceWith(a.types.sequenceExpression([
                                    t.node,
                                    getAssertion(n)
                                ]));
                            }
                        }
                    }
                };
                return {
                    name: "transform-modules-commonjs",
                    pre () {
                        this.file.set("@babel/plugin-transform-modules-*", "commonjs");
                    },
                    visitor: {
                        CallExpression (e1) {
                            if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
                            if (!a.types.isImport(e1.node.callee)) return;
                            let { scope: t } = e1;
                            do {
                                t.rename("require");
                            }while (t = t.parent)
                            (0, o.transformDynamicImport)(e1, h, this.file);
                        },
                        Program: {
                            exit (e1, r) {
                                if (!(0, s.isModule)(e1)) return;
                                e1.scope.rename("exports");
                                e1.scope.rename("module");
                                e1.scope.rename("require");
                                e1.scope.rename("__filename");
                                e1.scope.rename("__dirname");
                                if (!g) {
                                    {
                                        (0, i.default)(e1, new Set([
                                            "module",
                                            "exports"
                                        ]), false);
                                    }
                                    e1.traverse(v, {
                                        scope: e1.scope
                                    });
                                }
                                let n = (0, s.getModuleName)(this.file.opts, t);
                                if (n) n = a.types.stringLiteral(n);
                                const { meta: o, headers: l } = (0, s.rewriteModuleStatementsAndPrepareHeader)(e1, {
                                    exportName: "exports",
                                    constantReexports: T,
                                    enumerableModuleMeta: S,
                                    strict: f,
                                    strictMode: d,
                                    allowTopLevelThis: p,
                                    noInterop: h,
                                    importInterop: m,
                                    lazy: y,
                                    esNamespaceOnly: typeof r.filename === "string" && /\.mjs$/.test(r.filename) ? u : c,
                                    noIncompleteNsImportDetection: E,
                                    filename: this.file.opts.filename
                                });
                                for (const [t, r] of o.source){
                                    const n = a.types.callExpression(a.types.identifier("require"), [
                                        a.types.stringLiteral(t)
                                    ]);
                                    let i;
                                    if ((0, s.isSideEffectImport)(r)) {
                                        if (r.lazy) throw new Error("Assertion failure");
                                        i = a.types.expressionStatement(n);
                                    } else {
                                        if (r.lazy && !r.referenced) {
                                            continue;
                                        }
                                        const t = (0, s.wrapInterop)(e1, n, r.interop) || n;
                                        if (r.lazy) {
                                            i = a.template.statement.ast`
                  function ${r.name}() {
                    const data = ${t};
                    ${r.name} = function(){ return data; };
                    return data;
                  }
                `;
                                        } else {
                                            i = a.template.statement.ast`
                  var ${r.name} = ${t};
                `;
                                        }
                                    }
                                    i.loc = r.loc;
                                    l.push(i);
                                    l.push(...(0, s.buildNamespaceInitStatements)(o, r, T));
                                }
                                (0, s.ensureStatementsHoisted)(l);
                                e1.unshiftContainer("body", l);
                                e1.get("body").forEach((e1)=>{
                                    if (l.indexOf(e1.node) === -1) return;
                                    if (e1.isVariableDeclaration()) {
                                        e1.scope.registerDeclaration(e1);
                                    }
                                });
                            }
                        }
                    }
                };
            });
            t["default"] = l;
        },
        6969: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = transpileConstEnum;
            var n = r(7812);
            function transpileConstEnum(e1, t) {
                const { name: r } = e1.node.id;
                const s = e1.parentPath.isExportNamedDeclaration();
                let i = s;
                if (!i && t.isProgram(e1.parent)) {
                    i = e1.parent.body.some((e1)=>t.isExportNamedDeclaration(e1) && e1.exportKind !== "type" && !e1.source && e1.specifiers.some((e1)=>t.isExportSpecifier(e1) && e1.exportKind !== "type" && e1.local.name === r));
                }
                const { enumValues: a } = (0, n.translateEnumValues)(e1, t);
                if (i) {
                    const n = t.objectExpression(a.map(([e1, r])=>t.objectProperty(t.isValidIdentifier(e1) ? t.identifier(e1) : t.stringLiteral(e1), r)));
                    if (e1.scope.hasOwnBinding(r)) {
                        (s ? e1.parentPath : e1).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("assign")), [
                            e1.node.id,
                            n
                        ])));
                    } else {
                        e1.replaceWith(t.variableDeclaration("var", [
                            t.variableDeclarator(e1.node.id, n)
                        ]));
                        e1.scope.registerDeclaration(e1);
                    }
                    return;
                }
                const o = new Map(a);
                e1.scope.path.traverse({
                    Scope (e1) {
                        if (e1.scope.hasOwnBinding(r)) e1.skip();
                    },
                    MemberExpression (e1) {
                        if (!t.isIdentifier(e1.node.object, {
                            name: r
                        })) return;
                        let n;
                        if (e1.node.computed) {
                            if (t.isStringLiteral(e1.node.property)) {
                                n = e1.node.property.value;
                            } else {
                                return;
                            }
                        } else if (t.isIdentifier(e1.node.property)) {
                            n = e1.node.property.name;
                        } else {
                            return;
                        }
                        if (!o.has(n)) return;
                        e1.replaceWith(t.cloneNode(o.get(n)));
                    }
                });
                e1.remove();
            }
        },
        7812: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = transpileEnum;
            t.translateEnumValues = translateEnumValues;
            var n = r(3688);
            var s = r(9491);
            var i = r(365);
            const a = new WeakMap;
            const o = n.template.expression(`\n    (function (ID) {\n      ASSIGNMENTS;\n      return ID;\n    })(INIT)\n  `);
            function transpileEnum(e1, t) {
                const { node: r, parentPath: n } = e1;
                if (r.declare) {
                    e1.remove();
                    return;
                }
                const s = r.id.name;
                const { fill: l, data: c, isPure: u } = enumFill(e1, t, r.id);
                switch(n.type){
                    case "BlockStatement":
                    case "ExportNamedDeclaration":
                    case "Program":
                        {
                            const p = t.isProgram(e1.parent);
                            const f = seen(n);
                            let d = t.objectExpression([]);
                            if (f || p) {
                                d = t.logicalExpression("||", t.cloneNode(l.ID), d);
                            }
                            const h = o(Object.assign({}, l, {
                                INIT: d
                            }));
                            if (u) (0, i.default)(h);
                            if (f) {
                                const s = n.isExportDeclaration() ? n : e1;
                                s.replaceWith(t.expressionStatement(t.assignmentExpression("=", t.cloneNode(r.id), h)));
                            } else {
                                e1.scope.registerDeclaration(e1.replaceWith(t.variableDeclaration(p ? "var" : "let", [
                                    t.variableDeclarator(r.id, h)
                                ]))[0]);
                            }
                            a.set(e1.scope.getBindingIdentifier(s), c);
                            break;
                        }
                    default:
                        throw new Error(`Unexpected enum parent '${e1.parent.type}`);
                }
                function seen(e1) {
                    if (e1.isExportDeclaration()) {
                        return seen(e1.parentPath);
                    }
                    if (e1.getData(s)) {
                        return true;
                    } else {
                        e1.setData(s, true);
                        return false;
                    }
                }
            }
            const l = (0, n.template)(`\n  ENUM["NAME"] = VALUE;\n`);
            const c = (0, n.template)(`\n  ENUM[ENUM["NAME"] = VALUE] = "NAME";\n`);
            const buildEnumMember = (e1, t)=>(e1 ? l : c)(t);
            function enumFill(e1, t, r) {
                const { enumValues: n, data: s, isPure: i } = translateEnumValues(e1, t);
                const a = n.map(([e1, n])=>buildEnumMember(t.isStringLiteral(n), {
                        ENUM: t.cloneNode(r),
                        NAME: e1,
                        VALUE: n
                    }));
                return {
                    fill: {
                        ID: t.cloneNode(r),
                        ASSIGNMENTS: a
                    },
                    data: s,
                    isPure: i
                };
            }
            function ReferencedIdentifier(e1, t) {
                const { seen: r, path: n, t: s } = t;
                const i = e1.node.name;
                if (r.has(i) && !e1.scope.hasOwnBinding(i)) {
                    e1.replaceWith(s.memberExpression(s.cloneNode(n.node.id), s.cloneNode(e1.node)));
                    e1.skip();
                }
            }
            const u = {
                ReferencedIdentifier: ReferencedIdentifier
            };
            function translateEnumValues(e1, t) {
                const r = new Map;
                let n = -1;
                let i;
                let a = true;
                const o = e1.get("members").map((o)=>{
                    const l = o.node;
                    const c = t.isIdentifier(l.id) ? l.id.name : l.id.value;
                    const p = o.get("initializer");
                    const f = l.initializer;
                    let d;
                    if (f) {
                        n = computeConstantValue(p, r);
                        if (n !== undefined) {
                            r.set(c, n);
                            s(typeof n === "number" || typeof n === "string");
                            if (n === Infinity || Number.isNaN(n)) {
                                d = t.identifier(String(n));
                            } else if (n === -Infinity) {
                                d = t.unaryExpression("-", t.identifier("Infinity"));
                            } else {
                                d = t.valueToNode(n);
                            }
                        } else {
                            a && (a = p.isPure());
                            if (p.isReferencedIdentifier()) {
                                ReferencedIdentifier(p, {
                                    t: t,
                                    seen: r,
                                    path: e1
                                });
                            } else {
                                p.traverse(u, {
                                    t: t,
                                    seen: r,
                                    path: e1
                                });
                            }
                            d = p.node;
                            r.set(c, undefined);
                        }
                    } else if (typeof n === "number") {
                        n += 1;
                        d = t.numericLiteral(n);
                        r.set(c, n);
                    } else if (typeof n === "string") {
                        throw e1.buildCodeFrameError("Enum member must have initializer.");
                    } else {
                        const n = t.memberExpression(t.cloneNode(e1.node.id), t.stringLiteral(i), true);
                        d = t.binaryExpression("+", t.numericLiteral(1), n);
                        r.set(c, undefined);
                    }
                    i = c;
                    return [
                        c,
                        d
                    ];
                });
                return {
                    isPure: a,
                    data: r,
                    enumValues: o
                };
            }
            function computeConstantValue(e1, t, r = new Set) {
                return evaluate(e1);
                "TURBOPACK unreachable";
                function evaluate(e1) {
                    const n = e1.node;
                    switch(n.type){
                        case "MemberExpression":
                            return evaluateRef(e1, t, r);
                        case "StringLiteral":
                            return n.value;
                        case "UnaryExpression":
                            return evalUnaryExpression(e1);
                        case "BinaryExpression":
                            return evalBinaryExpression(e1);
                        case "NumericLiteral":
                            return n.value;
                        case "ParenthesizedExpression":
                            return evaluate(e1.get("expression"));
                        case "Identifier":
                            return evaluateRef(e1, t, r);
                        case "TemplateLiteral":
                            {
                                if (n.quasis.length === 1) {
                                    return n.quasis[0].value.cooked;
                                }
                                const s = e1.get("expressions");
                                const i = n.quasis;
                                let a = "";
                                for(let e1 = 0; e1 < i.length; e1++){
                                    a += i[e1].value.cooked;
                                    if (e1 + 1 < i.length) {
                                        const n = evaluateRef(s[e1], t, r);
                                        if (n === undefined) return undefined;
                                        a += n;
                                    }
                                }
                                return a;
                            }
                        default:
                            return undefined;
                    }
                }
                function evaluateRef(e1, t, r) {
                    if (e1.isMemberExpression()) {
                        const t = e1.node;
                        const r = t.object;
                        const s = t.property;
                        if (!n.types.isIdentifier(r) || (t.computed ? !n.types.isStringLiteral(s) : !n.types.isIdentifier(s))) {
                            return;
                        }
                        const i = e1.scope.getBindingIdentifier(r.name);
                        const o = a.get(i);
                        if (!o) return;
                        return o.get(s.computed ? s.value : s.name);
                    } else if (e1.isIdentifier()) {
                        const n = e1.node.name;
                        if ([
                            "Infinity",
                            "NaN"
                        ].includes(n)) {
                            return Number(n);
                        }
                        let s = t == null ? void 0 : t.get(n);
                        if (s !== undefined) {
                            return s;
                        }
                        if (r.has(e1.node)) return;
                        const i = e1.resolve();
                        if (i) {
                            r.add(e1.node);
                            s = computeConstantValue(i, undefined, r);
                            t == null ? void 0 : t.set(n, s);
                            return s;
                        }
                    }
                }
                function evalUnaryExpression(e1) {
                    const t = evaluate(e1.get("argument"));
                    if (t === undefined) {
                        return undefined;
                    }
                    switch(e1.node.operator){
                        case "+":
                            return t;
                        case "-":
                            return -t;
                        case "~":
                            return ~t;
                        default:
                            return undefined;
                    }
                }
                function evalBinaryExpression(e1) {
                    const t = evaluate(e1.get("left"));
                    if (t === undefined) {
                        return undefined;
                    }
                    const r = evaluate(e1.get("right"));
                    if (r === undefined) {
                        return undefined;
                    }
                    switch(e1.node.operator){
                        case "|":
                            return t | r;
                        case "&":
                            return t & r;
                        case ">>":
                            return t >> r;
                        case ">>>":
                            return t >>> r;
                        case "<<":
                            return t << r;
                        case "^":
                            return t ^ r;
                        case "*":
                            return t * r;
                        case "/":
                            return t / r;
                        case "+":
                            return t + r;
                        case "-":
                            return t - r;
                        case "%":
                            return t % r;
                        case "**":
                            return Math.pow(t, r);
                        default:
                            return undefined;
                    }
                }
            }
        },
        7167: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(5389);
            var s = r(6141);
            var i = r(269);
            var a = r(6969);
            var o = r(7812);
            var l = r(2274);
            function isInType(e1) {
                switch(e1.parent.type){
                    case "TSTypeReference":
                    case "TSExpressionWithTypeArguments":
                    case "TSTypeQuery":
                        return true;
                    case "TSQualifiedName":
                        return e1.parentPath.findParent((e1)=>e1.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
                    case "ExportSpecifier":
                        return e1.parent.exportKind === "type" || e1.parentPath.parent.exportKind === "type";
                    default:
                        return false;
                }
            }
            const c = new WeakMap;
            const u = new WeakMap;
            const p = new WeakSet;
            function isGlobalType({ scope: e1 }, t) {
                if (e1.hasBinding(t)) return false;
                if (c.get(e1).has(t)) return true;
                console.warn(`The exported identifier "${t}" is not declared in Babel's scope tracker\n` + `as a JavaScript value binding, and "@babel/plugin-transform-typescript"\n` + `never encountered it as a TypeScript type declaration.\n` + `It will be treated as a JavaScript value.\n\n` + `This problem is likely caused by another plugin injecting\n` + `"${t}" without registering it in the scope tracker. If you are the author\n` + ` of that plugin, please use "scope.registerDeclaration(declarationPath)".`);
                return false;
            }
            function registerGlobalType(e1, t) {
                c.get(e1).add(t);
            }
            function safeRemove(e1) {
                const t = e1.getBindingIdentifiers();
                for (const r of Object.keys(t)){
                    const n = e1.scope.getBinding(r);
                    if (n && n.identifier === t[r]) {
                        n.scope.removeBinding(r);
                    }
                }
                e1.opts.noScope = true;
                e1.remove();
                e1.opts.noScope = false;
            }
            function assertCjsTransformEnabled(e1, t, r, n, s = "") {
                if (t.file.get("@babel/plugin-transform-modules-*") !== "commonjs") {
                    throw e1.buildCodeFrameError(`\`${r}\` is only supported when compiling modules to CommonJS.\n` + `Please consider using \`${n}\`${s}, or add ` + `@babel/plugin-transform-modules-commonjs to your Babel config.`);
                }
            }
            var f = (0, n.declare)((e1, t)=>{
                const { types: r, template: n } = e1;
                e1.assertVersion(7);
                const f = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/;
                const { allowNamespaces: d = true, jsxPragma: h = "React.createElement", jsxPragmaFrag: m = "React.Fragment", onlyRemoveTypeImports: y = false, optimizeConstEnums: g = false } = t;
                {
                    var { allowDeclareFields: b = false } = t;
                }
                const T = {
                    field (e1) {
                        const { node: t } = e1;
                        {
                            if (!b && t.declare) {
                                throw e1.buildCodeFrameError(`The 'declare' modifier is only allowed when the 'allowDeclareFields' option of ` + `@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.`);
                            }
                        }
                        if (t.declare) {
                            if (t.value) {
                                throw e1.buildCodeFrameError(`Fields with the 'declare' modifier cannot be initialized here, but only in the constructor`);
                            }
                            if (!t.decorators) {
                                e1.remove();
                            }
                        } else if (t.definite) {
                            if (t.value) {
                                throw e1.buildCodeFrameError(`Definitely assigned fields cannot be initialized here, but only in the constructor`);
                            }
                            {
                                if (!b && !t.decorators && !r.isClassPrivateProperty(t)) {
                                    e1.remove();
                                }
                            }
                        } else if (t.abstract) {
                            e1.remove();
                        } else {
                            if (!b && !t.value && !t.decorators && !r.isClassPrivateProperty(t)) {
                                e1.remove();
                            }
                        }
                        if (t.accessibility) t.accessibility = null;
                        if (t.abstract) t.abstract = null;
                        if (t.readonly) t.readonly = null;
                        if (t.optional) t.optional = null;
                        if (t.typeAnnotation) t.typeAnnotation = null;
                        if (t.definite) t.definite = null;
                        if (t.declare) t.declare = null;
                        if (t.override) t.override = null;
                    },
                    method ({ node: e1 }) {
                        if (e1.accessibility) e1.accessibility = null;
                        if (e1.abstract) e1.abstract = null;
                        if (e1.optional) e1.optional = null;
                        if (e1.override) e1.override = null;
                    },
                    constructor (e1, t) {
                        if (e1.node.accessibility) e1.node.accessibility = null;
                        const s = [];
                        const { scope: a } = e1;
                        for (const t of e1.get("params")){
                            const e1 = t.node;
                            if (e1.type === "TSParameterProperty") {
                                const i = e1.parameter;
                                if (p.has(i)) continue;
                                p.add(i);
                                let o;
                                if (r.isIdentifier(i)) {
                                    o = i;
                                } else if (r.isAssignmentPattern(i) && r.isIdentifier(i.left)) {
                                    o = i.left;
                                } else {
                                    throw t.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
                                }
                                s.push(n.statement.ast`
          this.${r.cloneNode(o)} = ${r.cloneNode(o)}`);
                                t.replaceWith(t.get("parameter"));
                                a.registerBinding("param", t);
                            }
                        }
                        (0, i.injectInitialization)(t, e1, s);
                    }
                };
                return {
                    name: "transform-typescript",
                    inherits: s.default,
                    visitor: {
                        Pattern: visitPattern,
                        Identifier: visitPattern,
                        RestElement: visitPattern,
                        Program: {
                            enter (e1, t) {
                                const { file: r } = t;
                                let n = null;
                                let s = null;
                                const i = e1.scope;
                                if (!c.has(i)) {
                                    c.set(i, new Set);
                                }
                                if (r.ast.comments) {
                                    for (const e1 of r.ast.comments){
                                        const t = f.exec(e1.value);
                                        if (t) {
                                            if (t[1]) {
                                                s = t[2];
                                            } else {
                                                n = t[2];
                                            }
                                        }
                                    }
                                }
                                let a = n || h;
                                if (a) {
                                    [a] = a.split(".");
                                }
                                let o = s || m;
                                if (o) {
                                    [o] = o.split(".");
                                }
                                for (let r of e1.get("body")){
                                    if (r.isImportDeclaration()) {
                                        if (!u.has(t.file.ast.program)) {
                                            u.set(t.file.ast.program, true);
                                        }
                                        if (r.node.importKind === "type") {
                                            for (const e1 of r.node.specifiers){
                                                registerGlobalType(i, e1.local.name);
                                            }
                                            r.remove();
                                            continue;
                                        }
                                        const n = new Set;
                                        const s = r.node.specifiers.length;
                                        const isAllSpecifiersElided = ()=>s > 0 && s === n.size;
                                        for (const e1 of r.node.specifiers){
                                            if (e1.type === "ImportSpecifier" && e1.importKind === "type") {
                                                registerGlobalType(i, e1.local.name);
                                                const t = r.scope.getBinding(e1.local.name);
                                                if (t) {
                                                    n.add(t.path);
                                                }
                                            }
                                        }
                                        if (y) {
                                            u.set(e1.node, false);
                                        } else {
                                            if (r.node.specifiers.length === 0) {
                                                u.set(e1.node, false);
                                                continue;
                                            }
                                            for (const t of r.node.specifiers){
                                                const s = r.scope.getBinding(t.local.name);
                                                if (s && !n.has(s.path)) {
                                                    if (isImportTypeOnly({
                                                        binding: s,
                                                        programPath: e1,
                                                        pragmaImportName: a,
                                                        pragmaFragImportName: o
                                                    })) {
                                                        n.add(s.path);
                                                    } else {
                                                        u.set(e1.node, false);
                                                    }
                                                }
                                            }
                                        }
                                        if (isAllSpecifiersElided() && !y) {
                                            r.remove();
                                        } else {
                                            for (const e1 of n){
                                                e1.remove();
                                            }
                                        }
                                        continue;
                                    }
                                    if (r.isExportDeclaration()) {
                                        r = r.get("declaration");
                                    }
                                    if (r.isVariableDeclaration({
                                        declare: true
                                    })) {
                                        for (const e1 of Object.keys(r.getBindingIdentifiers())){
                                            registerGlobalType(i, e1);
                                        }
                                    } else if (r.isTSTypeAliasDeclaration() || r.isTSDeclareFunction() && r.get("id").isIdentifier() || r.isTSInterfaceDeclaration() || r.isClassDeclaration({
                                        declare: true
                                    }) || r.isTSEnumDeclaration({
                                        declare: true
                                    }) || r.isTSModuleDeclaration({
                                        declare: true
                                    }) && r.get("id").isIdentifier()) {
                                        registerGlobalType(i, r.node.id.name);
                                    }
                                }
                            },
                            exit (e1) {
                                if (e1.node.sourceType === "module" && u.get(e1.node)) {
                                    e1.pushContainer("body", r.exportNamedDeclaration());
                                }
                            }
                        },
                        ExportNamedDeclaration (e1, t) {
                            if (!u.has(t.file.ast.program)) {
                                u.set(t.file.ast.program, true);
                            }
                            if (e1.node.exportKind === "type") {
                                e1.remove();
                                return;
                            }
                            if (e1.node.source && e1.node.specifiers.length > 0 && e1.node.specifiers.every((e1)=>e1.type === "ExportSpecifier" && e1.exportKind === "type")) {
                                e1.remove();
                                return;
                            }
                            if (!e1.node.source && e1.node.specifiers.length > 0 && e1.node.specifiers.every((t)=>r.isExportSpecifier(t) && isGlobalType(e1, t.local.name))) {
                                e1.remove();
                                return;
                            }
                            if (r.isTSModuleDeclaration(e1.node.declaration)) {
                                const t = e1.node.declaration;
                                const { id: n } = t;
                                if (r.isIdentifier(n)) {
                                    if (e1.scope.hasOwnBinding(n.name)) {
                                        e1.replaceWith(t);
                                    } else {
                                        const [s] = e1.replaceWithMultiple([
                                            r.exportNamedDeclaration(r.variableDeclaration("let", [
                                                r.variableDeclarator(r.cloneNode(n))
                                            ])),
                                            t
                                        ]);
                                        e1.scope.registerDeclaration(s);
                                    }
                                }
                            }
                            u.set(t.file.ast.program, false);
                        },
                        ExportAllDeclaration (e1) {
                            if (e1.node.exportKind === "type") e1.remove();
                        },
                        ExportSpecifier (e1) {
                            const t = e1.parent;
                            if (!t.source && isGlobalType(e1, e1.node.local.name) || e1.node.exportKind === "type") {
                                e1.remove();
                            }
                        },
                        ExportDefaultDeclaration (e1, t) {
                            if (!u.has(t.file.ast.program)) {
                                u.set(t.file.ast.program, true);
                            }
                            if (r.isIdentifier(e1.node.declaration) && isGlobalType(e1, e1.node.declaration.name)) {
                                e1.remove();
                                return;
                            }
                            u.set(t.file.ast.program, false);
                        },
                        TSDeclareFunction (e1) {
                            safeRemove(e1);
                        },
                        TSDeclareMethod (e1) {
                            safeRemove(e1);
                        },
                        VariableDeclaration (e1) {
                            if (e1.node.declare) {
                                safeRemove(e1);
                            }
                        },
                        VariableDeclarator ({ node: e1 }) {
                            if (e1.definite) e1.definite = null;
                        },
                        TSIndexSignature (e1) {
                            e1.remove();
                        },
                        ClassDeclaration (e1) {
                            const { node: t } = e1;
                            if (t.declare) {
                                safeRemove(e1);
                            }
                        },
                        Class (e1) {
                            const { node: t } = e1;
                            if (t.typeParameters) t.typeParameters = null;
                            if (t.superTypeParameters) t.superTypeParameters = null;
                            if (t.implements) t.implements = null;
                            if (t.abstract) t.abstract = null;
                            e1.get("body.body").forEach((t)=>{
                                if (t.isClassMethod() || t.isClassPrivateMethod()) {
                                    if (t.node.kind === "constructor") {
                                        T.constructor(t, e1);
                                    } else {
                                        T.method(t);
                                    }
                                } else if (t.isClassProperty() || t.isClassPrivateProperty() || t.isClassAccessorProperty()) {
                                    T.field(t);
                                }
                            });
                        },
                        Function (e1) {
                            const { node: t } = e1;
                            if (t.typeParameters) t.typeParameters = null;
                            if (t.returnType) t.returnType = null;
                            const n = t.params;
                            if (n.length > 0 && r.isIdentifier(n[0], {
                                name: "this"
                            })) {
                                n.shift();
                            }
                        },
                        TSModuleDeclaration (e1) {
                            (0, l.default)(e1, d);
                        },
                        TSInterfaceDeclaration (e1) {
                            e1.remove();
                        },
                        TSTypeAliasDeclaration (e1) {
                            e1.remove();
                        },
                        TSEnumDeclaration (e1) {
                            if (g && e1.node.const) {
                                (0, a.default)(e1, r);
                            } else {
                                (0, o.default)(e1, r);
                            }
                        },
                        TSImportEqualsDeclaration (e1, t) {
                            const { id: n, moduleReference: s } = e1.node;
                            let i;
                            let a;
                            if (r.isTSExternalModuleReference(s)) {
                                assertCjsTransformEnabled(e1, t, `import ${n.name} = require(...);`, `import ${n.name} from '...';`, " alongside Typescript's --allowSyntheticDefaultImports option");
                                i = r.callExpression(r.identifier("require"), [
                                    s.expression
                                ]);
                                a = "const";
                            } else {
                                i = entityNameToExpr(s);
                                a = "var";
                            }
                            e1.replaceWith(r.variableDeclaration(a, [
                                r.variableDeclarator(n, i)
                            ]));
                            e1.scope.registerDeclaration(e1);
                        },
                        TSExportAssignment (e1, t) {
                            assertCjsTransformEnabled(e1, t, `export = <value>;`, `export default <value>;`);
                            e1.replaceWith(n.statement.ast`module.exports = ${e1.node.expression}`);
                        },
                        TSTypeAssertion (e1) {
                            e1.replaceWith(e1.node.expression);
                        },
                        [`TSAsExpression${r.tsSatisfiesExpression ? "|TSSatisfiesExpression" : ""}`] (e1) {
                            let { node: t } = e1;
                            do {
                                t = t.expression;
                            }while (r.isTSAsExpression(t) || r.isTSSatisfiesExpression != null && r.isTSSatisfiesExpression(t))
                            e1.replaceWith(t);
                        },
                        [e1.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"] (e1) {
                            e1.replaceWith(e1.node.expression);
                        },
                        CallExpression (e1) {
                            e1.node.typeParameters = null;
                        },
                        OptionalCallExpression (e1) {
                            e1.node.typeParameters = null;
                        },
                        NewExpression (e1) {
                            e1.node.typeParameters = null;
                        },
                        JSXOpeningElement (e1) {
                            e1.node.typeParameters = null;
                        },
                        TaggedTemplateExpression (e1) {
                            e1.node.typeParameters = null;
                        }
                    }
                };
                "TURBOPACK unreachable";
                function entityNameToExpr(e1) {
                    if (r.isTSQualifiedName(e1)) {
                        return r.memberExpression(entityNameToExpr(e1.left), e1.right);
                    }
                    return e1;
                }
                function visitPattern({ node: e1 }) {
                    if (e1.typeAnnotation) e1.typeAnnotation = null;
                    if (r.isIdentifier(e1) && e1.optional) e1.optional = null;
                }
                function isImportTypeOnly({ binding: e1, programPath: t, pragmaImportName: r, pragmaFragImportName: n }) {
                    for (const t of e1.referencePaths){
                        if (!isInType(t)) {
                            return false;
                        }
                    }
                    if (e1.identifier.name !== r && e1.identifier.name !== n) {
                        return true;
                    }
                    let s = false;
                    t.traverse({
                        "JSXElement|JSXFragment" (e1) {
                            s = true;
                            e1.stop();
                        }
                    });
                    return !s;
                }
            });
            t["default"] = f;
        },
        2274: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = transpileNamespace;
            var n = r(3688);
            function transpileNamespace(e1, t) {
                if (e1.node.declare || e1.node.id.type === "StringLiteral") {
                    e1.remove();
                    return;
                }
                if (!t) {
                    throw e1.get("id").buildCodeFrameError("Namespace not marked type-only declare." + " Non-declarative namespaces are only supported experimentally in Babel." + " To enable and review caveats see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
                }
                const r = e1.node.id.name;
                const s = handleNested(e1, n.types.cloneNode(e1.node, true));
                if (s === null) {
                    e1.remove();
                } else if (e1.scope.hasOwnBinding(r)) {
                    e1.replaceWith(s);
                } else {
                    e1.scope.registerDeclaration(e1.replaceWithMultiple([
                        getDeclaration(r),
                        s
                    ])[0]);
                }
            }
            function getDeclaration(e1) {
                return n.types.variableDeclaration("let", [
                    n.types.variableDeclarator(n.types.identifier(e1))
                ]);
            }
            function getMemberExpression(e1, t) {
                return n.types.memberExpression(n.types.identifier(e1), n.types.identifier(t));
            }
            function handleVariableDeclaration(e1, t, r) {
                if (e1.kind !== "const") {
                    throw r.file.buildCodeFrameError(e1, "Namespaces exporting non-const are not supported by Babel." + " Change to const or see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
                }
                const { declarations: s } = e1;
                if (s.every((e1)=>n.types.isIdentifier(e1.id))) {
                    for (const e1 of s){
                        e1.init = n.types.assignmentExpression("=", getMemberExpression(t, e1.id.name), e1.init);
                    }
                    return [
                        e1
                    ];
                }
                const i = n.types.getBindingIdentifiers(e1);
                const a = [];
                for(const e1 in i){
                    a.push(n.types.assignmentExpression("=", getMemberExpression(t, e1), n.types.cloneNode(i[e1])));
                }
                return [
                    e1,
                    n.types.expressionStatement(n.types.sequenceExpression(a))
                ];
            }
            function buildNestedAmbientModuleError(e1, t) {
                return e1.hub.buildError(t, "Ambient modules cannot be nested in other modules or namespaces.", Error);
            }
            function handleNested(e1, t, r) {
                const s = new Set;
                const i = t.id;
                n.types.assertIdentifier(i);
                const a = e1.scope.generateUid(i.name);
                const o = n.types.isTSModuleBlock(t.body) ? t.body.body : [
                    n.types.exportNamedDeclaration(t.body)
                ];
                let l = true;
                for(let t = 0; t < o.length; t++){
                    const r = o[t];
                    switch(r.type){
                        case "TSModuleDeclaration":
                            {
                                if (!n.types.isIdentifier(r.id)) {
                                    throw buildNestedAmbientModuleError(e1, r);
                                }
                                const i = handleNested(e1, r);
                                if (i !== null) {
                                    l = false;
                                    const e1 = r.id.name;
                                    if (s.has(e1)) {
                                        o[t] = i;
                                    } else {
                                        s.add(e1);
                                        o.splice(t++, 1, getDeclaration(e1), i);
                                    }
                                }
                                continue;
                            }
                        case "TSEnumDeclaration":
                        case "FunctionDeclaration":
                        case "ClassDeclaration":
                            l = false;
                            s.add(r.id.name);
                            continue;
                        case "VariableDeclaration":
                            {
                                l = false;
                                for(const e1 in n.types.getBindingIdentifiers(r)){
                                    s.add(e1);
                                }
                                continue;
                            }
                        default:
                            l && (l = n.types.isTypeScript(r));
                            continue;
                        case "ExportNamedDeclaration":
                    }
                    if ("declare" in r.declaration && r.declaration.declare) {
                        continue;
                    }
                    switch(r.declaration.type){
                        case "TSEnumDeclaration":
                        case "FunctionDeclaration":
                        case "ClassDeclaration":
                            {
                                l = false;
                                const e1 = r.declaration.id.name;
                                s.add(e1);
                                o.splice(t++, 1, r.declaration, n.types.expressionStatement(n.types.assignmentExpression("=", getMemberExpression(a, e1), n.types.identifier(e1))));
                                break;
                            }
                        case "VariableDeclaration":
                            {
                                l = false;
                                const n = handleVariableDeclaration(r.declaration, a, e1.hub);
                                o.splice(t, n.length, ...n);
                                t += n.length - 1;
                                break;
                            }
                        case "TSModuleDeclaration":
                            {
                                if (!n.types.isIdentifier(r.declaration.id)) {
                                    throw buildNestedAmbientModuleError(e1, r.declaration);
                                }
                                const i = handleNested(e1, r.declaration, n.types.identifier(a));
                                if (i !== null) {
                                    l = false;
                                    const e1 = r.declaration.id.name;
                                    if (s.has(e1)) {
                                        o[t] = i;
                                    } else {
                                        s.add(e1);
                                        o.splice(t++, 1, getDeclaration(e1), i);
                                    }
                                } else {
                                    o.splice(t, 1);
                                    t--;
                                }
                            }
                    }
                }
                if (l) return null;
                let c = n.types.objectExpression([]);
                if (r) {
                    const e1 = n.types.memberExpression(r, i);
                    c = n.template.expression.ast`
      ${n.types.cloneNode(e1)} ||
        (${n.types.cloneNode(e1)} = ${c})
    `;
                }
                return n.template.statement.ast`
    (function (${n.types.identifier(a)}) {
      ${o}
    })(${i} || (${n.types.cloneNode(i)} = ${c}));
  `;
            }
        },
        5432: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            var n = r(5389);
            var s = r(7167);
            r(6085);
            var i = r(8417);
            var a = r(4716);
            function _interopDefaultLegacy(e1) {
                return e1 && typeof e1 === "object" && "default" in e1 ? e1 : {
                    default: e1
                };
            }
            var o = _interopDefaultLegacy(s);
            var l = _interopDefaultLegacy(i);
            const c = new a.OptionValidator("@babel/preset-typescript");
            function normalizeOptions(e1 = {}) {
                let { allowNamespaces: t = true, jsxPragma: r, onlyRemoveTypeImports: n } = e1;
                const s = {
                    ignoreExtensions: "ignoreExtensions",
                    allowNamespaces: "allowNamespaces",
                    disallowAmbiguousJSXLike: "disallowAmbiguousJSXLike",
                    jsxPragma: "jsxPragma",
                    jsxPragmaFrag: "jsxPragmaFrag",
                    onlyRemoveTypeImports: "onlyRemoveTypeImports",
                    optimizeConstEnums: "optimizeConstEnums",
                    allExtensions: "allExtensions",
                    isTSX: "isTSX"
                };
                const i = c.validateStringOption(s.jsxPragmaFrag, e1.jsxPragmaFrag, "React.Fragment");
                {
                    var a = c.validateBooleanOption(s.allExtensions, e1.allExtensions, false);
                    var o = c.validateBooleanOption(s.isTSX, e1.isTSX, false);
                    if (o) {
                        c.invariant(a, "isTSX:true requires allExtensions:true");
                    }
                }
                const l = c.validateBooleanOption(s.ignoreExtensions, e1.ignoreExtensions, false);
                const u = c.validateBooleanOption(s.disallowAmbiguousJSXLike, e1.disallowAmbiguousJSXLike, false);
                if (u) {
                    {
                        c.invariant(a, "disallowAmbiguousJSXLike:true requires allExtensions:true");
                    }
                }
                const p = c.validateBooleanOption(s.optimizeConstEnums, e1.optimizeConstEnums, false);
                const f = {
                    ignoreExtensions: l,
                    allowNamespaces: t,
                    disallowAmbiguousJSXLike: u,
                    jsxPragma: r,
                    jsxPragmaFrag: i,
                    onlyRemoveTypeImports: n,
                    optimizeConstEnums: p
                };
                {
                    f.allExtensions = a;
                    f.isTSX = o;
                }
                return f;
            }
            var u = n.declarePreset((e1, t)=>{
                e1.assertVersion(7);
                const { allExtensions: r, ignoreExtensions: n, allowNamespaces: s, disallowAmbiguousJSXLike: i, isTSX: a, jsxPragma: c, jsxPragmaFrag: u, onlyRemoveTypeImports: p, optimizeConstEnums: f } = normalizeOptions(t);
                const pluginOptions = (e1)=>({
                        allowDeclareFields: t.allowDeclareFields,
                        allowNamespaces: s,
                        disallowAmbiguousJSXLike: e1,
                        jsxPragma: c,
                        jsxPragmaFrag: u,
                        onlyRemoveTypeImports: p,
                        optimizeConstEnums: f
                    });
                const getPlugins = (e1, t)=>{
                    {
                        return [
                            [
                                o["default"],
                                Object.assign({
                                    isTSX: e1
                                }, pluginOptions(t))
                            ]
                        ];
                    }
                };
                const d = r || n;
                return {
                    overrides: d ? [
                        {
                            plugins: getPlugins(a, i)
                        }
                    ] : [
                        {
                            test: /\.ts$/,
                            plugins: getPlugins(false, false)
                        },
                        {
                            test: /\.mts$/,
                            sourceType: "module",
                            plugins: getPlugins(false, true)
                        },
                        {
                            test: /\.cts$/,
                            sourceType: "unambiguous",
                            plugins: [
                                [
                                    l["default"],
                                    {
                                        allowTopLevelThis: true
                                    }
                                ],
                                [
                                    o["default"],
                                    pluginOptions(true)
                                ]
                            ]
                        },
                        {
                            test: /\.tsx$/,
                            plugins: getPlugins(true, false)
                        }
                    ]
                };
            });
            t["default"] = u;
        },
        7601: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = createTemplateBuilder;
            var n = r(4287);
            var s = r(4430);
            var i = r(5202);
            const a = (0, n.validate)({
                placeholderPattern: false
            });
            function createTemplateBuilder(e1, t) {
                const r = new WeakMap;
                const o = new WeakMap;
                const l = t || (0, n.validate)(null);
                return Object.assign((t, ...a)=>{
                    if (typeof t === "string") {
                        if (a.length > 1) throw new Error("Unexpected extra params.");
                        return extendedTrace((0, s.default)(e1, t, (0, n.merge)(l, (0, n.validate)(a[0]))));
                    } else if (Array.isArray(t)) {
                        let n = r.get(t);
                        if (!n) {
                            n = (0, i.default)(e1, t, l);
                            r.set(t, n);
                        }
                        return extendedTrace(n(a));
                    } else if (typeof t === "object" && t) {
                        if (a.length > 0) throw new Error("Unexpected extra params.");
                        return createTemplateBuilder(e1, (0, n.merge)(l, (0, n.validate)(t)));
                    }
                    throw new Error(`Unexpected template param ${typeof t}`);
                }, {
                    ast: (t, ...r)=>{
                        if (typeof t === "string") {
                            if (r.length > 1) throw new Error("Unexpected extra params.");
                            return (0, s.default)(e1, t, (0, n.merge)((0, n.merge)(l, (0, n.validate)(r[0])), a))();
                        } else if (Array.isArray(t)) {
                            let s = o.get(t);
                            if (!s) {
                                s = (0, i.default)(e1, t, (0, n.merge)(l, a));
                                o.set(t, s);
                            }
                            return s(r)();
                        }
                        throw new Error(`Unexpected template param ${typeof t}`);
                    }
                });
            }
            function extendedTrace(e1) {
                let t = "";
                try {
                    throw new Error;
                } catch (e1) {
                    if (e1.stack) {
                        t = e1.stack.split("\n").slice(3).join("\n");
                    }
                }
                return (r)=>{
                    try {
                        return e1(r);
                    } catch (e1) {
                        e1.stack += `\n    =============\n${t}`;
                        throw e1;
                    }
                };
            }
        },
        9550: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.statements = t.statement = t.smart = t.program = t.expression = void 0;
            var n = r(776);
            const { assertExpressionStatement: s } = n;
            function makeStatementFormatter(e1) {
                return {
                    code: (e1)=>`/* @babel/template */;\n${e1}`,
                    validate: ()=>{},
                    unwrap: (t)=>e1(t.program.body.slice(1))
                };
            }
            const i = makeStatementFormatter((e1)=>{
                if (e1.length > 1) {
                    return e1;
                } else {
                    return e1[0];
                }
            });
            t.smart = i;
            const a = makeStatementFormatter((e1)=>e1);
            t.statements = a;
            const o = makeStatementFormatter((e1)=>{
                if (e1.length === 0) {
                    throw new Error("Found nothing to return.");
                }
                if (e1.length > 1) {
                    throw new Error("Found multiple statements but wanted one");
                }
                return e1[0];
            });
            t.statement = o;
            const l = {
                code: (e1)=>`(\n${e1}\n)`,
                validate: (e1)=>{
                    if (e1.program.body.length > 1) {
                        throw new Error("Found multiple statements but wanted one");
                    }
                    if (l.unwrap(e1).start === 0) {
                        throw new Error("Parse result included parens.");
                    }
                },
                unwrap: ({ program: e1 })=>{
                    const [t] = e1.body;
                    s(t);
                    return t.expression;
                }
            };
            t.expression = l;
            const c = {
                code: (e1)=>e1,
                validate: ()=>{},
                unwrap: (e1)=>e1.program
            };
            t.program = c;
        },
        9128: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.statements = t.statement = t.smart = t.program = t.expression = t["default"] = void 0;
            var n = r(9550);
            var s = r(7601);
            const i = (0, s.default)(n.smart);
            t.smart = i;
            const a = (0, s.default)(n.statement);
            t.statement = a;
            const o = (0, s.default)(n.statements);
            t.statements = o;
            const l = (0, s.default)(n.expression);
            t.expression = l;
            const c = (0, s.default)(n.program);
            t.program = c;
            var u = Object.assign(i.bind(undefined), {
                smart: i,
                statement: a,
                statements: o,
                expression: l,
                program: c,
                ast: i.ast
            });
            t["default"] = u;
        },
        5202: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = literalTemplate;
            var n = r(4287);
            var s = r(8782);
            var i = r(974);
            function literalTemplate(e1, t, r) {
                const { metadata: s, names: a } = buildLiteralData(e1, t, r);
                return (t)=>{
                    const r = {};
                    t.forEach((e1, t)=>{
                        r[a[t]] = e1;
                    });
                    return (t)=>{
                        const a = (0, n.normalizeReplacements)(t);
                        if (a) {
                            Object.keys(a).forEach((e1)=>{
                                if (Object.prototype.hasOwnProperty.call(r, e1)) {
                                    throw new Error("Unexpected replacement overlap.");
                                }
                            });
                        }
                        return e1.unwrap((0, i.default)(s, a ? Object.assign(a, r) : r));
                    };
                };
            }
            function buildLiteralData(e1, t, r) {
                let n = "BABEL_TPL$";
                const i = t.join("");
                do {
                    n = "$$" + n;
                }while (i.includes(n))
                const { names: a, code: o } = buildTemplateCode(t, n);
                const l = (0, s.default)(e1, e1.code(o), {
                    parser: r.parser,
                    placeholderWhitelist: new Set(a.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
                    placeholderPattern: r.placeholderPattern,
                    preserveComments: r.preserveComments,
                    syntacticPlaceholders: r.syntacticPlaceholders
                });
                return {
                    metadata: l,
                    names: a
                };
            }
            function buildTemplateCode(e1, t) {
                const r = [];
                let n = e1[0];
                for(let s = 1; s < e1.length; s++){
                    const i = `${t}${s - 1}`;
                    r.push(i);
                    n += i + e1[s];
                }
                return {
                    names: r,
                    code: n
                };
            }
        },
        4287: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.merge = merge;
            t.normalizeReplacements = normalizeReplacements;
            t.validate = validate;
            const r = [
                "placeholderWhitelist",
                "placeholderPattern",
                "preserveComments",
                "syntacticPlaceholders"
            ];
            function _objectWithoutPropertiesLoose(e1, t) {
                if (e1 == null) return {};
                var r = {};
                var n = Object.keys(e1);
                var s, i;
                for(i = 0; i < n.length; i++){
                    s = n[i];
                    if (t.indexOf(s) >= 0) continue;
                    r[s] = e1[s];
                }
                return r;
            }
            function merge(e1, t) {
                const { placeholderWhitelist: r = e1.placeholderWhitelist, placeholderPattern: n = e1.placeholderPattern, preserveComments: s = e1.preserveComments, syntacticPlaceholders: i = e1.syntacticPlaceholders } = t;
                return {
                    parser: Object.assign({}, e1.parser, t.parser),
                    placeholderWhitelist: r,
                    placeholderPattern: n,
                    preserveComments: s,
                    syntacticPlaceholders: i
                };
            }
            function validate(e1) {
                if (e1 != null && typeof e1 !== "object") {
                    throw new Error("Unknown template options.");
                }
                const t = e1 || {}, { placeholderWhitelist: n, placeholderPattern: s, preserveComments: i, syntacticPlaceholders: a } = t, o = _objectWithoutPropertiesLoose(t, r);
                if (n != null && !(n instanceof Set)) {
                    throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
                }
                if (s != null && !(s instanceof RegExp) && s !== false) {
                    throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
                }
                if (i != null && typeof i !== "boolean") {
                    throw new Error("'.preserveComments' must be a boolean, null, or undefined");
                }
                if (a != null && typeof a !== "boolean") {
                    throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
                }
                if (a === true && (n != null || s != null)) {
                    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
                }
                return {
                    parser: o,
                    placeholderWhitelist: n || undefined,
                    placeholderPattern: s == null ? undefined : s,
                    preserveComments: i == null ? undefined : i,
                    syntacticPlaceholders: a == null ? undefined : a
                };
            }
            function normalizeReplacements(e1) {
                if (Array.isArray(e1)) {
                    return e1.reduce((e1, t, r)=>{
                        e1["$" + r] = t;
                        return e1;
                    }, {});
                } else if (typeof e1 === "object" || e1 == null) {
                    return e1 || undefined;
                }
                throw new Error("Template replacements must be an array, object, null, or undefined");
            }
        },
        8782: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = parseAndBuildMetadata;
            var n = r(776);
            var s = r(7383);
            var i = r(3327);
            const { isCallExpression: a, isExpressionStatement: o, isFunction: l, isIdentifier: c, isJSXIdentifier: u, isNewExpression: p, isPlaceholder: f, isStatement: d, isStringLiteral: h, removePropertiesDeep: m, traverse: y } = n;
            const g = /^[_$A-Z0-9]+$/;
            function parseAndBuildMetadata(e1, t, r) {
                const { placeholderWhitelist: n, placeholderPattern: s, preserveComments: i, syntacticPlaceholders: a } = r;
                const o = parseWithCodeFrame(t, r.parser, a);
                m(o, {
                    preserveComments: i
                });
                e1.validate(o);
                const l = {
                    syntactic: {
                        placeholders: [],
                        placeholderNames: new Set
                    },
                    legacy: {
                        placeholders: [],
                        placeholderNames: new Set
                    },
                    placeholderWhitelist: n,
                    placeholderPattern: s,
                    syntacticPlaceholders: a
                };
                y(o, placeholderVisitorHandler, l);
                return Object.assign({
                    ast: o
                }, l.syntactic.placeholders.length ? l.syntactic : l.legacy);
            }
            function placeholderVisitorHandler(e1, t, r) {
                var n;
                let s;
                let i = r.syntactic.placeholders.length > 0;
                if (f(e1)) {
                    if (r.syntacticPlaceholders === false) {
                        throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
                    }
                    s = e1.name.name;
                    i = true;
                } else if (i || r.syntacticPlaceholders) {
                    return;
                } else if (c(e1) || u(e1)) {
                    s = e1.name;
                } else if (h(e1)) {
                    s = e1.value;
                } else {
                    return;
                }
                if (i && (r.placeholderPattern != null || r.placeholderWhitelist != null)) {
                    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
                }
                if (!i && (r.placeholderPattern === false || !(r.placeholderPattern || g).test(s)) && !((n = r.placeholderWhitelist) != null && n.has(s))) {
                    return;
                }
                t = t.slice();
                const { node: m, key: y } = t[t.length - 1];
                let b;
                if (h(e1) || f(e1, {
                    expectedNode: "StringLiteral"
                })) {
                    b = "string";
                } else if (p(m) && y === "arguments" || a(m) && y === "arguments" || l(m) && y === "params") {
                    b = "param";
                } else if (o(m) && !f(e1)) {
                    b = "statement";
                    t = t.slice(0, -1);
                } else if (d(e1) && f(e1)) {
                    b = "statement";
                } else {
                    b = "other";
                }
                const { placeholders: T, placeholderNames: S } = !i ? r.legacy : r.syntactic;
                T.push({
                    name: s,
                    type: b,
                    resolve: (e1)=>resolveAncestors(e1, t),
                    isDuplicate: S.has(s)
                });
                S.add(s);
            }
            function resolveAncestors(e1, t) {
                let r = e1;
                for(let e1 = 0; e1 < t.length - 1; e1++){
                    const { key: n, index: s } = t[e1];
                    if (s === undefined) {
                        r = r[n];
                    } else {
                        r = r[n][s];
                    }
                }
                const { key: n, index: s } = t[t.length - 1];
                return {
                    parent: r,
                    key: n,
                    index: s
                };
            }
            function parseWithCodeFrame(e1, t, r) {
                const n = (t.plugins || []).slice();
                if (r !== false) {
                    n.push("placeholders");
                }
                t = Object.assign({
                    allowReturnOutsideFunction: true,
                    allowSuperOutsideMethod: true,
                    sourceType: "module"
                }, t, {
                    plugins: n
                });
                try {
                    return (0, s.parse)(e1, t);
                } catch (t) {
                    const r = t.loc;
                    if (r) {
                        t.message += "\n" + (0, i.codeFrameColumns)(e1, {
                            start: r
                        });
                        t.code = "BABEL_TEMPLATE_PARSE_ERROR";
                    }
                    throw t;
                }
            }
        },
        974: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = populatePlaceholders;
            var n = r(776);
            const { blockStatement: s, cloneNode: i, emptyStatement: a, expressionStatement: o, identifier: l, isStatement: c, isStringLiteral: u, stringLiteral: p, validate: f } = n;
            function populatePlaceholders(e1, t) {
                const r = i(e1.ast);
                if (t) {
                    e1.placeholders.forEach((e1)=>{
                        if (!Object.prototype.hasOwnProperty.call(t, e1.name)) {
                            const t = e1.name;
                            throw new Error(`Error: No substitution given for "${t}". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${t}'])}\n            - { placeholderPattern: /^${t}$/ }`);
                        }
                    });
                    Object.keys(t).forEach((t)=>{
                        if (!e1.placeholderNames.has(t)) {
                            throw new Error(`Unknown substitution "${t}" given`);
                        }
                    });
                }
                e1.placeholders.slice().reverse().forEach((e1)=>{
                    try {
                        applyReplacement(e1, r, t && t[e1.name] || null);
                    } catch (t) {
                        t.message = `@babel/template placeholder "${e1.name}": ${t.message}`;
                        throw t;
                    }
                });
                return r;
            }
            function applyReplacement(e1, t, r) {
                if (e1.isDuplicate) {
                    if (Array.isArray(r)) {
                        r = r.map((e1)=>i(e1));
                    } else if (typeof r === "object") {
                        r = i(r);
                    }
                }
                const { parent: n, key: d, index: h } = e1.resolve(t);
                if (e1.type === "string") {
                    if (typeof r === "string") {
                        r = p(r);
                    }
                    if (!r || !u(r)) {
                        throw new Error("Expected string substitution");
                    }
                } else if (e1.type === "statement") {
                    if (h === undefined) {
                        if (!r) {
                            r = a();
                        } else if (Array.isArray(r)) {
                            r = s(r);
                        } else if (typeof r === "string") {
                            r = o(l(r));
                        } else if (!c(r)) {
                            r = o(r);
                        }
                    } else {
                        if (r && !Array.isArray(r)) {
                            if (typeof r === "string") {
                                r = l(r);
                            }
                            if (!c(r)) {
                                r = o(r);
                            }
                        }
                    }
                } else if (e1.type === "param") {
                    if (typeof r === "string") {
                        r = l(r);
                    }
                    if (h === undefined) throw new Error("Assertion failure.");
                } else {
                    if (typeof r === "string") {
                        r = l(r);
                    }
                    if (Array.isArray(r)) {
                        throw new Error("Cannot replace single expression with an array.");
                    }
                }
                if (h === undefined) {
                    f(n, d, r);
                    n[d] = r;
                } else {
                    const t = n[d].slice();
                    if (e1.type === "statement" || e1.type === "param") {
                        if (r == null) {
                            t.splice(h, 1);
                        } else if (Array.isArray(r)) {
                            t.splice(h, 1, ...r);
                        } else {
                            t[h] = r;
                        }
                    } else {
                        t[h] = r;
                    }
                    f(n, d, t);
                    n[d] = t;
                }
            }
        },
        4430: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = stringTemplate;
            var n = r(4287);
            var s = r(8782);
            var i = r(974);
            function stringTemplate(e1, t, r) {
                t = e1.code(t);
                let a;
                return (o)=>{
                    const l = (0, n.normalizeReplacements)(o);
                    if (!a) a = (0, s.default)(e1, t, r);
                    return e1.unwrap((0, i.default)(a, l));
                };
            }
        },
        2781: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = createTemplateBuilder;
            var n = r(7586);
            var s = r(9920);
            var i = r(6734);
            const a = (0, n.validate)({
                placeholderPattern: false
            });
            function createTemplateBuilder(e1, t) {
                const r = new WeakMap;
                const o = new WeakMap;
                const l = t || (0, n.validate)(null);
                return Object.assign((t, ...a)=>{
                    if (typeof t === "string") {
                        if (a.length > 1) throw new Error("Unexpected extra params.");
                        return extendedTrace((0, s.default)(e1, t, (0, n.merge)(l, (0, n.validate)(a[0]))));
                    } else if (Array.isArray(t)) {
                        let n = r.get(t);
                        if (!n) {
                            n = (0, i.default)(e1, t, l);
                            r.set(t, n);
                        }
                        return extendedTrace(n(a));
                    } else if (typeof t === "object" && t) {
                        if (a.length > 0) throw new Error("Unexpected extra params.");
                        return createTemplateBuilder(e1, (0, n.merge)(l, (0, n.validate)(t)));
                    }
                    throw new Error(`Unexpected template param ${typeof t}`);
                }, {
                    ast: (t, ...r)=>{
                        if (typeof t === "string") {
                            if (r.length > 1) throw new Error("Unexpected extra params.");
                            return (0, s.default)(e1, t, (0, n.merge)((0, n.merge)(l, (0, n.validate)(r[0])), a))();
                        } else if (Array.isArray(t)) {
                            let s = o.get(t);
                            if (!s) {
                                s = (0, i.default)(e1, t, (0, n.merge)(l, a));
                                o.set(t, s);
                            }
                            return s(r)();
                        }
                        throw new Error(`Unexpected template param ${typeof t}`);
                    }
                });
            }
            function extendedTrace(e1) {
                let t = "";
                try {
                    throw new Error;
                } catch (e1) {
                    if (e1.stack) {
                        t = e1.stack.split("\n").slice(3).join("\n");
                    }
                }
                return (r)=>{
                    try {
                        return e1(r);
                    } catch (e1) {
                        e1.stack += `\n    =============\n${t}`;
                        throw e1;
                    }
                };
            }
        },
        8865: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.statements = t.statement = t.smart = t.program = t.expression = void 0;
            var n = r(776);
            const { assertExpressionStatement: s } = n;
            function makeStatementFormatter(e1) {
                return {
                    code: (e1)=>`/* @babel/template */;\n${e1}`,
                    validate: ()=>{},
                    unwrap: (t)=>e1(t.program.body.slice(1))
                };
            }
            const i = t.smart = makeStatementFormatter((e1)=>{
                if (e1.length > 1) {
                    return e1;
                } else {
                    return e1[0];
                }
            });
            const a = t.statements = makeStatementFormatter((e1)=>e1);
            const o = t.statement = makeStatementFormatter((e1)=>{
                if (e1.length === 0) {
                    throw new Error("Found nothing to return.");
                }
                if (e1.length > 1) {
                    throw new Error("Found multiple statements but wanted one");
                }
                return e1[0];
            });
            const l = t.expression = {
                code: (e1)=>`(\n${e1}\n)`,
                validate: (e1)=>{
                    if (e1.program.body.length > 1) {
                        throw new Error("Found multiple statements but wanted one");
                    }
                    if (l.unwrap(e1).start === 0) {
                        throw new Error("Parse result included parens.");
                    }
                },
                unwrap: ({ program: e1 })=>{
                    const [t] = e1.body;
                    s(t);
                    return t.expression;
                }
            };
            const c = t.program = {
                code: (e1)=>e1,
                validate: ()=>{},
                unwrap: (e1)=>e1.program
            };
        },
        789: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.statements = t.statement = t.smart = t.program = t.expression = t["default"] = void 0;
            var n = r(8865);
            var s = r(2781);
            const i = t.smart = (0, s.default)(n.smart);
            const a = t.statement = (0, s.default)(n.statement);
            const o = t.statements = (0, s.default)(n.statements);
            const l = t.expression = (0, s.default)(n.expression);
            const c = t.program = (0, s.default)(n.program);
            var u = t["default"] = Object.assign(i.bind(undefined), {
                smart: i,
                statement: a,
                statements: o,
                expression: l,
                program: c,
                ast: i.ast
            });
        },
        6734: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = literalTemplate;
            var n = r(7586);
            var s = r(5413);
            var i = r(9431);
            function literalTemplate(e1, t, r) {
                const { metadata: s, names: a } = buildLiteralData(e1, t, r);
                return (t)=>{
                    const r = {};
                    t.forEach((e1, t)=>{
                        r[a[t]] = e1;
                    });
                    return (t)=>{
                        const a = (0, n.normalizeReplacements)(t);
                        if (a) {
                            Object.keys(a).forEach((e1)=>{
                                if (hasOwnProperty.call(r, e1)) {
                                    throw new Error("Unexpected replacement overlap.");
                                }
                            });
                        }
                        return e1.unwrap((0, i.default)(s, a ? Object.assign(a, r) : r));
                    };
                };
            }
            function buildLiteralData(e1, t, r) {
                let n = "BABEL_TPL$";
                const i = t.join("");
                do {
                    n = "$$" + n;
                }while (i.includes(n))
                const { names: a, code: o } = buildTemplateCode(t, n);
                const l = (0, s.default)(e1, e1.code(o), {
                    parser: r.parser,
                    placeholderWhitelist: new Set(a.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
                    placeholderPattern: r.placeholderPattern,
                    preserveComments: r.preserveComments,
                    syntacticPlaceholders: r.syntacticPlaceholders
                });
                return {
                    metadata: l,
                    names: a
                };
            }
            function buildTemplateCode(e1, t) {
                const r = [];
                let n = e1[0];
                for(let s = 1; s < e1.length; s++){
                    const i = `${t}${s - 1}`;
                    r.push(i);
                    n += i + e1[s];
                }
                return {
                    names: r,
                    code: n
                };
            }
        },
        7586: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.merge = merge;
            t.normalizeReplacements = normalizeReplacements;
            t.validate = validate;
            const r = [
                "placeholderWhitelist",
                "placeholderPattern",
                "preserveComments",
                "syntacticPlaceholders"
            ];
            function _objectWithoutPropertiesLoose(e1, t) {
                if (e1 == null) return {};
                var r = {};
                var n = Object.keys(e1);
                var s, i;
                for(i = 0; i < n.length; i++){
                    s = n[i];
                    if (t.indexOf(s) >= 0) continue;
                    r[s] = e1[s];
                }
                return r;
            }
            function merge(e1, t) {
                const { placeholderWhitelist: r = e1.placeholderWhitelist, placeholderPattern: n = e1.placeholderPattern, preserveComments: s = e1.preserveComments, syntacticPlaceholders: i = e1.syntacticPlaceholders } = t;
                return {
                    parser: Object.assign({}, e1.parser, t.parser),
                    placeholderWhitelist: r,
                    placeholderPattern: n,
                    preserveComments: s,
                    syntacticPlaceholders: i
                };
            }
            function validate(e1) {
                if (e1 != null && typeof e1 !== "object") {
                    throw new Error("Unknown template options.");
                }
                const t = e1 || {}, { placeholderWhitelist: n, placeholderPattern: s, preserveComments: i, syntacticPlaceholders: a } = t, o = _objectWithoutPropertiesLoose(t, r);
                if (n != null && !(n instanceof Set)) {
                    throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
                }
                if (s != null && !(s instanceof RegExp) && s !== false) {
                    throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
                }
                if (i != null && typeof i !== "boolean") {
                    throw new Error("'.preserveComments' must be a boolean, null, or undefined");
                }
                if (a != null && typeof a !== "boolean") {
                    throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
                }
                if (a === true && (n != null || s != null)) {
                    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
                }
                return {
                    parser: o,
                    placeholderWhitelist: n || undefined,
                    placeholderPattern: s == null ? undefined : s,
                    preserveComments: i == null ? undefined : i,
                    syntacticPlaceholders: a == null ? undefined : a
                };
            }
            function normalizeReplacements(e1) {
                if (Array.isArray(e1)) {
                    return e1.reduce((e1, t, r)=>{
                        e1["$" + r] = t;
                        return e1;
                    }, {});
                } else if (typeof e1 === "object" || e1 == null) {
                    return e1 || undefined;
                }
                throw new Error("Template replacements must be an array, object, null, or undefined");
            }
        },
        5413: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = parseAndBuildMetadata;
            var n = r(776);
            var s = r(7383);
            var i = r(3950);
            const { isCallExpression: a, isExpressionStatement: o, isFunction: l, isIdentifier: c, isJSXIdentifier: u, isNewExpression: p, isPlaceholder: f, isStatement: d, isStringLiteral: h, removePropertiesDeep: m, traverse: y } = n;
            const g = /^[_$A-Z0-9]+$/;
            function parseAndBuildMetadata(e1, t, r) {
                const { placeholderWhitelist: n, placeholderPattern: s, preserveComments: i, syntacticPlaceholders: a } = r;
                const o = parseWithCodeFrame(t, r.parser, a);
                m(o, {
                    preserveComments: i
                });
                e1.validate(o);
                const l = {
                    syntactic: {
                        placeholders: [],
                        placeholderNames: new Set
                    },
                    legacy: {
                        placeholders: [],
                        placeholderNames: new Set
                    },
                    placeholderWhitelist: n,
                    placeholderPattern: s,
                    syntacticPlaceholders: a
                };
                y(o, placeholderVisitorHandler, l);
                return Object.assign({
                    ast: o
                }, l.syntactic.placeholders.length ? l.syntactic : l.legacy);
            }
            function placeholderVisitorHandler(e1, t, r) {
                var n;
                let s;
                let i = r.syntactic.placeholders.length > 0;
                if (f(e1)) {
                    if (r.syntacticPlaceholders === false) {
                        throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
                    }
                    s = e1.name.name;
                    i = true;
                } else if (i || r.syntacticPlaceholders) {
                    return;
                } else if (c(e1) || u(e1)) {
                    s = e1.name;
                } else if (h(e1)) {
                    s = e1.value;
                } else {
                    return;
                }
                if (i && (r.placeholderPattern != null || r.placeholderWhitelist != null)) {
                    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
                }
                if (!i && (r.placeholderPattern === false || !(r.placeholderPattern || g).test(s)) && !((n = r.placeholderWhitelist) != null && n.has(s))) {
                    return;
                }
                t = t.slice();
                const { node: m, key: y } = t[t.length - 1];
                let b;
                if (h(e1) || f(e1, {
                    expectedNode: "StringLiteral"
                })) {
                    b = "string";
                } else if (p(m) && y === "arguments" || a(m) && y === "arguments" || l(m) && y === "params") {
                    b = "param";
                } else if (o(m) && !f(e1)) {
                    b = "statement";
                    t = t.slice(0, -1);
                } else if (d(e1) && f(e1)) {
                    b = "statement";
                } else {
                    b = "other";
                }
                const { placeholders: T, placeholderNames: S } = !i ? r.legacy : r.syntactic;
                T.push({
                    name: s,
                    type: b,
                    resolve: (e1)=>resolveAncestors(e1, t),
                    isDuplicate: S.has(s)
                });
                S.add(s);
            }
            function resolveAncestors(e1, t) {
                let r = e1;
                for(let e1 = 0; e1 < t.length - 1; e1++){
                    const { key: n, index: s } = t[e1];
                    if (s === undefined) {
                        r = r[n];
                    } else {
                        r = r[n][s];
                    }
                }
                const { key: n, index: s } = t[t.length - 1];
                return {
                    parent: r,
                    key: n,
                    index: s
                };
            }
            function parseWithCodeFrame(e1, t, r) {
                const n = (t.plugins || []).slice();
                if (r !== false) {
                    n.push("placeholders");
                }
                t = Object.assign({
                    allowReturnOutsideFunction: true,
                    allowSuperOutsideMethod: true,
                    sourceType: "module"
                }, t, {
                    plugins: n
                });
                try {
                    return (0, s.parse)(e1, t);
                } catch (t) {
                    const r = t.loc;
                    if (r) {
                        t.message += "\n" + (0, i.codeFrameColumns)(e1, {
                            start: r
                        });
                        t.code = "BABEL_TEMPLATE_PARSE_ERROR";
                    }
                    throw t;
                }
            }
        },
        9431: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = populatePlaceholders;
            var n = r(776);
            const { blockStatement: s, cloneNode: i, emptyStatement: a, expressionStatement: o, identifier: l, isStatement: c, isStringLiteral: u, stringLiteral: p, validate: f } = n;
            function populatePlaceholders(e1, t) {
                const r = i(e1.ast);
                if (t) {
                    e1.placeholders.forEach((e1)=>{
                        if (!hasOwnProperty.call(t, e1.name)) {
                            const t = e1.name;
                            throw new Error(`Error: No substitution given for "${t}". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${t}'])}\n            - { placeholderPattern: /^${t}$/ }`);
                        }
                    });
                    Object.keys(t).forEach((t)=>{
                        if (!e1.placeholderNames.has(t)) {
                            throw new Error(`Unknown substitution "${t}" given`);
                        }
                    });
                }
                e1.placeholders.slice().reverse().forEach((e1)=>{
                    try {
                        applyReplacement(e1, r, t && t[e1.name] || null);
                    } catch (t) {
                        t.message = `@babel/template placeholder "${e1.name}": ${t.message}`;
                        throw t;
                    }
                });
                return r;
            }
            function applyReplacement(e1, t, r) {
                if (e1.isDuplicate) {
                    if (Array.isArray(r)) {
                        r = r.map((e1)=>i(e1));
                    } else if (typeof r === "object") {
                        r = i(r);
                    }
                }
                const { parent: n, key: d, index: h } = e1.resolve(t);
                if (e1.type === "string") {
                    if (typeof r === "string") {
                        r = p(r);
                    }
                    if (!r || !u(r)) {
                        throw new Error("Expected string substitution");
                    }
                } else if (e1.type === "statement") {
                    if (h === undefined) {
                        if (!r) {
                            r = a();
                        } else if (Array.isArray(r)) {
                            r = s(r);
                        } else if (typeof r === "string") {
                            r = o(l(r));
                        } else if (!c(r)) {
                            r = o(r);
                        }
                    } else {
                        if (r && !Array.isArray(r)) {
                            if (typeof r === "string") {
                                r = l(r);
                            }
                            if (!c(r)) {
                                r = o(r);
                            }
                        }
                    }
                } else if (e1.type === "param") {
                    if (typeof r === "string") {
                        r = l(r);
                    }
                    if (h === undefined) throw new Error("Assertion failure.");
                } else {
                    if (typeof r === "string") {
                        r = l(r);
                    }
                    if (Array.isArray(r)) {
                        throw new Error("Cannot replace single expression with an array.");
                    }
                }
                if (h === undefined) {
                    f(n, d, r);
                    n[d] = r;
                } else {
                    const t = n[d].slice();
                    if (e1.type === "statement" || e1.type === "param") {
                        if (r == null) {
                            t.splice(h, 1);
                        } else if (Array.isArray(r)) {
                            t.splice(h, 1, ...r);
                        } else {
                            t[h] = r;
                        }
                    } else {
                        t[h] = r;
                    }
                    f(n, d, t);
                    n[d] = t;
                }
            }
        },
        9920: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = stringTemplate;
            var n = r(7586);
            var s = r(5413);
            var i = r(9431);
            function stringTemplate(e1, t, r) {
                t = e1.code(t);
                let a;
                return (o)=>{
                    const l = (0, n.normalizeReplacements)(o);
                    if (!a) a = (0, s.default)(e1, t, r);
                    return e1.unwrap((0, i.default)(a, l));
                };
            }
        },
        6419: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.clear = clear;
            t.clearPath = clearPath;
            t.clearScope = clearScope;
            t.scope = t.path = void 0;
            let r = new WeakMap;
            t.path = r;
            let n = new WeakMap;
            t.scope = n;
            function clear() {
                clearPath();
                clearScope();
            }
            function clearPath() {
                t.path = r = new WeakMap;
            }
            function clearScope() {
                t.scope = n = new WeakMap;
            }
        },
        6983: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(8485);
            var s = r(776);
            const { VISITOR_KEYS: i } = s;
            class TraversalContext {
                constructor(e1, t, r, n){
                    this.queue = null;
                    this.priorityQueue = null;
                    this.parentPath = n;
                    this.scope = e1;
                    this.state = r;
                    this.opts = t;
                }
                shouldVisit(e1) {
                    const t = this.opts;
                    if (t.enter || t.exit) return true;
                    if (t[e1.type]) return true;
                    const r = i[e1.type];
                    if (!(r != null && r.length)) return false;
                    for (const t of r){
                        if (e1[t]) {
                            return true;
                        }
                    }
                    return false;
                }
                create(e1, t, r, s) {
                    return n.default.get({
                        parentPath: this.parentPath,
                        parent: e1,
                        container: t,
                        key: r,
                        listKey: s
                    });
                }
                maybeQueue(e1, t) {
                    if (this.queue) {
                        if (t) {
                            this.queue.push(e1);
                        } else {
                            this.priorityQueue.push(e1);
                        }
                    }
                }
                visitMultiple(e1, t, r) {
                    if (e1.length === 0) return false;
                    const n = [];
                    for(let s = 0; s < e1.length; s++){
                        const i = e1[s];
                        if (i && this.shouldVisit(i)) {
                            n.push(this.create(t, e1, s, r));
                        }
                    }
                    return this.visitQueue(n);
                }
                visitSingle(e1, t) {
                    if (this.shouldVisit(e1[t])) {
                        return this.visitQueue([
                            this.create(e1, e1, t)
                        ]);
                    } else {
                        return false;
                    }
                }
                visitQueue(e1) {
                    this.queue = e1;
                    this.priorityQueue = [];
                    const t = new WeakSet;
                    let r = false;
                    for (const n of e1){
                        n.resync();
                        if (n.contexts.length === 0 || n.contexts[n.contexts.length - 1] !== this) {
                            n.pushContext(this);
                        }
                        if (n.key === null) continue;
                        const { node: s } = n;
                        if (t.has(s)) continue;
                        if (s) t.add(s);
                        if (n.visit()) {
                            r = true;
                            break;
                        }
                        if (this.priorityQueue.length) {
                            r = this.visitQueue(this.priorityQueue);
                            this.priorityQueue = [];
                            this.queue = e1;
                            if (r) break;
                        }
                    }
                    for (const t of e1){
                        t.popContext();
                    }
                    this.queue = null;
                    return r;
                }
                visit(e1, t) {
                    const r = e1[t];
                    if (!r) return false;
                    if (Array.isArray(r)) {
                        return this.visitMultiple(r, e1, t);
                    } else {
                        return this.visitSingle(e1, t);
                    }
                }
            }
            t["default"] = TraversalContext;
        },
        1568: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            class Hub {
                getCode() {}
                getScope() {}
                addHelper() {
                    throw new Error("Helpers are not supported by the default hub.");
                }
                buildError(e1, t, r = TypeError) {
                    return new r(t);
                }
            }
            t["default"] = Hub;
        },
        2297: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "Hub", {
                enumerable: true,
                get: function() {
                    return c.default;
                }
            });
            Object.defineProperty(t, "NodePath", {
                enumerable: true,
                get: function() {
                    return o.default;
                }
            });
            Object.defineProperty(t, "Scope", {
                enumerable: true,
                get: function() {
                    return l.default;
                }
            });
            t.visitors = t["default"] = void 0;
            var n = r(5399);
            t.visitors = n;
            var s = r(776);
            var i = r(6419);
            var a = r(81);
            var o = r(8485);
            var l = r(9632);
            var c = r(1568);
            const { VISITOR_KEYS: u, removeProperties: p, traverseFast: f } = s;
            function traverse(e1, t = {}, r, s, i) {
                if (!e1) return;
                if (!t.noScope && !r) {
                    if (e1.type !== "Program" && e1.type !== "File") {
                        throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + `Instead of that you tried to traverse a ${e1.type} node without ` + "passing scope and parentPath.");
                    }
                }
                if (!u[e1.type]) {
                    return;
                }
                n.explode(t);
                (0, a.traverseNode)(e1, t, r, s, i);
            }
            var d = traverse;
            t["default"] = d;
            traverse.visitors = n;
            traverse.verify = n.verify;
            traverse.explode = n.explode;
            traverse.cheap = function(e1, t) {
                f(e1, t);
                return;
            };
            traverse.node = function(e1, t, r, n, s, i) {
                (0, a.traverseNode)(e1, t, r, n, s, i);
            };
            traverse.clearNode = function(e1, t) {
                p(e1, t);
                i.path.delete(e1);
            };
            traverse.removeProperties = function(e1, t) {
                f(e1, traverse.clearNode, t);
                return e1;
            };
            function hasDenylistedType(e1, t) {
                if (e1.node.type === t.type) {
                    t.has = true;
                    e1.stop();
                }
            }
            traverse.hasType = function(e1, t, r) {
                if (r != null && r.includes(e1.type)) return false;
                if (e1.type === t) return true;
                const n = {
                    has: false,
                    type: t
                };
                traverse(e1, {
                    noScope: true,
                    denylist: r,
                    enter: hasDenylistedType
                }, null, n);
                return n.has;
            };
            traverse.cache = i;
        },
        5852: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.find = find;
            t.findParent = findParent;
            t.getAncestry = getAncestry;
            t.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
            t.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
            t.getFunctionParent = getFunctionParent;
            t.getStatementParent = getStatementParent;
            t.inType = inType;
            t.isAncestor = isAncestor;
            t.isDescendant = isDescendant;
            var n = r(776);
            const { VISITOR_KEYS: s } = n;
            function findParent(e1) {
                let t = this;
                while(t = t.parentPath){
                    if (e1(t)) return t;
                }
                return null;
            }
            function find(e1) {
                let t = this;
                do {
                    if (e1(t)) return t;
                }while (t = t.parentPath)
                return null;
            }
            function getFunctionParent() {
                return this.findParent((e1)=>e1.isFunction());
            }
            function getStatementParent() {
                let e1 = this;
                do {
                    if (!e1.parentPath || Array.isArray(e1.container) && e1.isStatement()) {
                        break;
                    } else {
                        e1 = e1.parentPath;
                    }
                }while (e1)
                if (e1 && (e1.isProgram() || e1.isFile())) {
                    throw new Error("File/Program node, we can't possibly find a statement parent to this");
                }
                return e1;
            }
            function getEarliestCommonAncestorFrom(e1) {
                return this.getDeepestCommonAncestorFrom(e1, function(e1, t, r) {
                    let n;
                    const i = s[e1.type];
                    for (const e1 of r){
                        const r = e1[t + 1];
                        if (!n) {
                            n = r;
                            continue;
                        }
                        if (r.listKey && n.listKey === r.listKey) {
                            if (r.key < n.key) {
                                n = r;
                                continue;
                            }
                        }
                        const s = i.indexOf(n.parentKey);
                        const a = i.indexOf(r.parentKey);
                        if (s > a) {
                            n = r;
                        }
                    }
                    return n;
                });
            }
            function getDeepestCommonAncestorFrom(e1, t) {
                if (!e1.length) {
                    return this;
                }
                if (e1.length === 1) {
                    return e1[0];
                }
                let r = Infinity;
                let n, s;
                const i = e1.map((e1)=>{
                    const t = [];
                    do {
                        t.unshift(e1);
                    }while ((e1 = e1.parentPath) && e1 !== this)
                    if (t.length < r) {
                        r = t.length;
                    }
                    return t;
                });
                const a = i[0];
                e1: for(let e1 = 0; e1 < r; e1++){
                    const t = a[e1];
                    for (const r of i){
                        if (r[e1] !== t) {
                            break e1;
                        }
                    }
                    n = e1;
                    s = t;
                }
                if (s) {
                    if (t) {
                        return t(s, n, i);
                    } else {
                        return s;
                    }
                } else {
                    throw new Error("Couldn't find intersection");
                }
            }
            function getAncestry() {
                let e1 = this;
                const t = [];
                do {
                    t.push(e1);
                }while (e1 = e1.parentPath)
                return t;
            }
            function isAncestor(e1) {
                return e1.isDescendant(this);
            }
            function isDescendant(e1) {
                return !!this.findParent((t)=>t === e1);
            }
            function inType(...e1) {
                let t = this;
                while(t){
                    for (const r of e1){
                        if (t.node.type === r) return true;
                    }
                    t = t.parentPath;
                }
                return false;
            }
        },
        1702: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.addComment = addComment;
            t.addComments = addComments;
            t.shareCommentsWithSiblings = shareCommentsWithSiblings;
            var n = r(776);
            const { addComment: s, addComments: i } = n;
            function shareCommentsWithSiblings() {
                if (typeof this.key === "string") return;
                const e1 = this.node;
                if (!e1) return;
                const t = e1.trailingComments;
                const r = e1.leadingComments;
                if (!t && !r) return;
                const n = this.getSibling(this.key - 1);
                const s = this.getSibling(this.key + 1);
                const i = Boolean(n.node);
                const a = Boolean(s.node);
                if (i) {
                    if (r) {
                        n.addComments("trailing", removeIfExisting(r, n.node.trailingComments));
                    }
                    if (t && !a) n.addComments("trailing", t);
                }
                if (a) {
                    if (t) {
                        s.addComments("leading", removeIfExisting(t, s.node.leadingComments));
                    }
                    if (r && !i) s.addComments("leading", r);
                }
            }
            function removeIfExisting(e1, t) {
                if (!t) return e1;
                let r = -1;
                return e1.filter((e1)=>{
                    const n = t.indexOf(e1, r);
                    if (n === -1) return true;
                    r = n;
                });
            }
            function addComment(e1, t, r) {
                s(this.node, e1, t, r);
            }
            function addComments(e1, t) {
                i(this.node, e1, t);
            }
        },
        7446: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._call = _call;
            t._getQueueContexts = _getQueueContexts;
            t._resyncKey = _resyncKey;
            t._resyncList = _resyncList;
            t._resyncParent = _resyncParent;
            t._resyncRemoved = _resyncRemoved;
            t.call = call;
            t.isBlacklisted = t.isDenylisted = isDenylisted;
            t.popContext = popContext;
            t.pushContext = pushContext;
            t.requeue = requeue;
            t.resync = resync;
            t.setContext = setContext;
            t.setKey = setKey;
            t.setScope = setScope;
            t.setup = setup;
            t.skip = skip;
            t.skipKey = skipKey;
            t.stop = stop;
            t.visit = visit;
            var n = r(81);
            var s = r(8485);
            function call(e1) {
                const t = this.opts;
                this.debug(e1);
                if (this.node) {
                    if (this._call(t[e1])) return true;
                }
                if (this.node) {
                    var r;
                    return this._call((r = t[this.node.type]) == null ? void 0 : r[e1]);
                }
                return false;
            }
            function _call(e1) {
                if (!e1) return false;
                for (const t of e1){
                    if (!t) continue;
                    const e1 = this.node;
                    if (!e1) return true;
                    const r = t.call(this.state, this, this.state);
                    if (r && typeof r === "object" && typeof r.then === "function") {
                        throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);
                    }
                    if (r) {
                        throw new Error(`Unexpected return value from visitor method ${t}`);
                    }
                    if (this.node !== e1) return true;
                    if (this._traverseFlags > 0) return true;
                }
                return false;
            }
            function isDenylisted() {
                var e1;
                const t = (e1 = this.opts.denylist) != null ? e1 : this.opts.blacklist;
                return t && t.indexOf(this.node.type) > -1;
            }
            function restoreContext(e1, t) {
                if (e1.context !== t) {
                    e1.context = t;
                    e1.state = t.state;
                    e1.opts = t.opts;
                }
            }
            function visit() {
                var e1, t;
                if (!this.node) {
                    return false;
                }
                if (this.isDenylisted()) {
                    return false;
                }
                if ((e1 = (t = this.opts).shouldSkip) != null && e1.call(t, this)) {
                    return false;
                }
                const r = this.context;
                if (this.shouldSkip || this.call("enter")) {
                    this.debug("Skip...");
                    return this.shouldStop;
                }
                restoreContext(this, r);
                this.debug("Recursing into...");
                this.shouldStop = (0, n.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
                restoreContext(this, r);
                this.call("exit");
                return this.shouldStop;
            }
            function skip() {
                this.shouldSkip = true;
            }
            function skipKey(e1) {
                if (this.skipKeys == null) {
                    this.skipKeys = {};
                }
                this.skipKeys[e1] = true;
            }
            function stop() {
                this._traverseFlags |= s.SHOULD_SKIP | s.SHOULD_STOP;
            }
            function setScope() {
                var e1, t;
                if ((e1 = this.opts) != null && e1.noScope) return;
                let r = this.parentPath;
                if ((this.key === "key" || this.listKey === "decorators") && r.isMethod() || this.key === "discriminant" && r.isSwitchStatement()) {
                    r = r.parentPath;
                }
                let n;
                while(r && !n){
                    var s;
                    if ((s = r.opts) != null && s.noScope) return;
                    n = r.scope;
                    r = r.parentPath;
                }
                this.scope = this.getScope(n);
                (t = this.scope) == null ? void 0 : t.init();
            }
            function setContext(e1) {
                if (this.skipKeys != null) {
                    this.skipKeys = {};
                }
                this._traverseFlags = 0;
                if (e1) {
                    this.context = e1;
                    this.state = e1.state;
                    this.opts = e1.opts;
                }
                this.setScope();
                return this;
            }
            function resync() {
                if (this.removed) return;
                this._resyncParent();
                this._resyncList();
                this._resyncKey();
            }
            function _resyncParent() {
                if (this.parentPath) {
                    this.parent = this.parentPath.node;
                }
            }
            function _resyncKey() {
                if (!this.container) return;
                if (this.node === this.container[this.key]) {
                    return;
                }
                if (Array.isArray(this.container)) {
                    for(let e1 = 0; e1 < this.container.length; e1++){
                        if (this.container[e1] === this.node) {
                            this.setKey(e1);
                            return;
                        }
                    }
                } else {
                    for (const e1 of Object.keys(this.container)){
                        if (this.container[e1] === this.node) {
                            this.setKey(e1);
                            return;
                        }
                    }
                }
                this.key = null;
            }
            function _resyncList() {
                if (!this.parent || !this.inList) return;
                const e1 = this.parent[this.listKey];
                if (this.container === e1) return;
                this.container = e1 || null;
            }
            function _resyncRemoved() {
                if (this.key == null || !this.container || this.container[this.key] !== this.node) {
                    this._markRemoved();
                }
            }
            function popContext() {
                this.contexts.pop();
                if (this.contexts.length > 0) {
                    this.setContext(this.contexts[this.contexts.length - 1]);
                } else {
                    this.setContext(undefined);
                }
            }
            function pushContext(e1) {
                this.contexts.push(e1);
                this.setContext(e1);
            }
            function setup(e1, t, r, n) {
                this.listKey = r;
                this.container = t;
                this.parentPath = e1 || this.parentPath;
                this.setKey(n);
            }
            function setKey(e1) {
                var t;
                this.key = e1;
                this.node = this.container[this.key];
                this.type = (t = this.node) == null ? void 0 : t.type;
            }
            function requeue(e1 = this) {
                if (e1.removed) return;
                const t = this.contexts;
                for (const r of t){
                    r.maybeQueue(e1);
                }
            }
            function _getQueueContexts() {
                let e1 = this;
                let t = this.contexts;
                while(!t.length){
                    e1 = e1.parentPath;
                    if (!e1) break;
                    t = e1.contexts;
                }
                return t;
            }
        },
        5702: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.arrowFunctionToExpression = arrowFunctionToExpression;
            t.ensureBlock = ensureBlock;
            t.toComputedKey = toComputedKey;
            t.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
            var n = r(776);
            var s = r(8552);
            var i = r(4940);
            var a = r(5399);
            const { arrowFunctionExpression: o, assignmentExpression: l, binaryExpression: c, blockStatement: u, callExpression: p, conditionalExpression: f, expressionStatement: d, identifier: h, isIdentifier: m, jsxIdentifier: y, logicalExpression: g, LOGICAL_OPERATORS: b, memberExpression: T, metaProperty: S, numericLiteral: E, objectExpression: v, restElement: x, returnStatement: P, sequenceExpression: w, spreadElement: A, stringLiteral: C, super: I, thisExpression: O, toExpression: k, unaryExpression: N } = n;
            function toComputedKey() {
                let e1;
                if (this.isMemberExpression()) {
                    e1 = this.node.property;
                } else if (this.isProperty() || this.isMethod()) {
                    e1 = this.node.key;
                } else {
                    throw new ReferenceError("todo");
                }
                if (!this.node.computed) {
                    if (m(e1)) e1 = C(e1.name);
                }
                return e1;
            }
            function ensureBlock() {
                const e1 = this.get("body");
                const t = e1.node;
                if (Array.isArray(e1)) {
                    throw new Error("Can't convert array path to a block statement");
                }
                if (!t) {
                    throw new Error("Can't convert node without a body");
                }
                if (e1.isBlockStatement()) {
                    return t;
                }
                const r = [];
                let n = "body";
                let s;
                let i;
                if (e1.isStatement()) {
                    i = "body";
                    s = 0;
                    r.push(e1.node);
                } else {
                    n += ".body.0";
                    if (this.isFunction()) {
                        s = "argument";
                        r.push(P(e1.node));
                    } else {
                        s = "expression";
                        r.push(d(e1.node));
                    }
                }
                this.node.body = u(r);
                const a = this.get(n);
                e1.setup(a, i ? a.node[i] : a.node, i, s);
                return this.node;
            }
            {
                {
                    t.arrowFunctionToShadowed = function() {
                        if (!this.isArrowFunctionExpression()) return;
                        this.arrowFunctionToExpression();
                    };
                }
            }
            function unwrapFunctionEnvironment() {
                if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
                    throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
                }
                hoistFunctionEnvironment(this);
            }
            function setType(e1, t) {
                e1.node.type = t;
            }
            function arrowFunctionToExpression({ allowInsertArrow: e1 = true, allowInsertArrowWithRest: t = e1, noNewArrows: r = !(()=>{
                var e1;
                return (e1 = arguments[0]) == null ? void 0 : e1.specCompliant;
            })() } = {}) {
                if (!this.isArrowFunctionExpression()) {
                    throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
                }
                const { thisBinding: n, fnPath: s } = hoistFunctionEnvironment(this, r, e1, t);
                s.ensureBlock();
                setType(s, "FunctionExpression");
                if (!r) {
                    const e1 = n ? null : s.scope.generateUidIdentifier("arrowCheckId");
                    if (e1) {
                        s.parentPath.scope.push({
                            id: e1,
                            init: v([])
                        });
                    }
                    s.get("body").unshiftContainer("body", d(p(this.hub.addHelper("newArrowCheck"), [
                        O(),
                        e1 ? h(e1.name) : h(n)
                    ])));
                    s.replaceWith(p(T((0, i.default)(this, true) || s.node, h("bind")), [
                        e1 ? h(e1.name) : O()
                    ]));
                    return s.get("callee.object");
                }
                return s;
            }
            const _ = (0, a.merge)([
                {
                    CallExpression (e1, { allSuperCalls: t }) {
                        if (!e1.get("callee").isSuper()) return;
                        t.push(e1);
                    }
                },
                s.default
            ]);
            function hoistFunctionEnvironment(e1, t = true, r = true, n = true) {
                let s;
                let i = e1.findParent((e1)=>{
                    if (e1.isArrowFunctionExpression()) {
                        var t;
                        (t = s) != null ? t : s = e1;
                        return false;
                    }
                    return e1.isFunction() || e1.isProgram() || e1.isClassProperty({
                        static: false
                    }) || e1.isClassPrivateProperty({
                        static: false
                    });
                });
                const a = i.isClassMethod({
                    kind: "constructor"
                });
                if (i.isClassProperty() || i.isClassPrivateProperty()) {
                    if (s) {
                        i = s;
                    } else if (r) {
                        e1.replaceWith(p(o([], k(e1.node)), []));
                        i = e1.get("callee");
                        e1 = i.get("body");
                    } else {
                        throw e1.buildCodeFrameError("Unable to transform arrow inside class property");
                    }
                }
                const { thisPaths: l, argumentsPaths: u, newTargetPaths: d, superProps: m, superCalls: g } = getScopeInformation(e1);
                if (a && g.length > 0) {
                    if (!r) {
                        throw g[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', " + "it's not possible to compile `super()` in an arrow function without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
                    }
                    if (!n) {
                        throw g[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', " + "it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
                    }
                    const e1 = [];
                    i.traverse(_, {
                        allSuperCalls: e1
                    });
                    const t = getSuperBinding(i);
                    e1.forEach((e1)=>{
                        const r = h(t);
                        r.loc = e1.node.callee.loc;
                        e1.get("callee").replaceWith(r);
                    });
                }
                if (u.length > 0) {
                    const e1 = getBinding(i, "arguments", ()=>{
                        const args = ()=>h("arguments");
                        if (i.scope.path.isProgram()) {
                            return f(c("===", N("typeof", args()), C("undefined")), i.scope.buildUndefinedNode(), args());
                        } else {
                            return args();
                        }
                    });
                    u.forEach((t)=>{
                        const r = h(e1);
                        r.loc = t.node.loc;
                        t.replaceWith(r);
                    });
                }
                if (d.length > 0) {
                    const e1 = getBinding(i, "newtarget", ()=>S(h("new"), h("target")));
                    d.forEach((t)=>{
                        const r = h(e1);
                        r.loc = t.node.loc;
                        t.replaceWith(r);
                    });
                }
                if (m.length > 0) {
                    if (!r) {
                        throw m[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', " + "it's not possible to compile `super.prop` in an arrow function without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
                    }
                    const e1 = m.reduce((e1, t)=>e1.concat(standardizeSuperProperty(t)), []);
                    e1.forEach((e1)=>{
                        const t = e1.node.computed ? "" : e1.get("property").node.name;
                        const r = e1.parentPath;
                        const n = r.isAssignmentExpression({
                            left: e1.node
                        });
                        const s = r.isCallExpression({
                            callee: e1.node
                        });
                        const a = r.isTaggedTemplateExpression({
                            tag: e1.node
                        });
                        const o = getSuperPropBinding(i, n, t);
                        const c = [];
                        if (e1.node.computed) {
                            c.push(e1.get("property").node);
                        }
                        if (n) {
                            const e1 = r.node.right;
                            c.push(e1);
                        }
                        const u = p(h(o), c);
                        if (s) {
                            r.unshiftContainer("arguments", O());
                            e1.replaceWith(T(u, h("call")));
                            l.push(r.get("arguments.0"));
                        } else if (n) {
                            r.replaceWith(u);
                        } else if (a) {
                            e1.replaceWith(p(T(u, h("bind"), false), [
                                O()
                            ]));
                            l.push(e1.get("arguments.0"));
                        } else {
                            e1.replaceWith(u);
                        }
                    });
                }
                let b;
                if (l.length > 0 || !t) {
                    b = getThisBinding(i, a);
                    if (t || a && hasSuperClass(i)) {
                        l.forEach((e1)=>{
                            const t = e1.isJSX() ? y(b) : h(b);
                            t.loc = e1.node.loc;
                            e1.replaceWith(t);
                        });
                        if (!t) b = null;
                    }
                }
                return {
                    thisBinding: b,
                    fnPath: e1
                };
            }
            function isLogicalOp(e1) {
                return b.includes(e1);
            }
            function standardizeSuperProperty(e1) {
                if (e1.parentPath.isAssignmentExpression() && e1.parentPath.node.operator !== "=") {
                    const t = e1.parentPath;
                    const r = t.node.operator.slice(0, -1);
                    const n = t.node.right;
                    const s = isLogicalOp(r);
                    if (e1.node.computed) {
                        const i = e1.scope.generateDeclaredUidIdentifier("tmp");
                        const a = e1.node.object;
                        const o = e1.node.property;
                        t.get("left").replaceWith(T(a, l("=", i, o), true));
                        t.get("right").replaceWith(rightExpression(s ? "=" : r, T(a, h(i.name), true), n));
                    } else {
                        const i = e1.node.object;
                        const a = e1.node.property;
                        t.get("left").replaceWith(T(i, a));
                        t.get("right").replaceWith(rightExpression(s ? "=" : r, T(i, h(a.name)), n));
                    }
                    if (s) {
                        t.replaceWith(g(r, t.node.left, t.node.right));
                    } else {
                        t.node.operator = "=";
                    }
                    return [
                        t.get("left"),
                        t.get("right").get("left")
                    ];
                } else if (e1.parentPath.isUpdateExpression()) {
                    const t = e1.parentPath;
                    const r = e1.scope.generateDeclaredUidIdentifier("tmp");
                    const n = e1.node.computed ? e1.scope.generateDeclaredUidIdentifier("prop") : null;
                    const s = [
                        l("=", r, T(e1.node.object, n ? l("=", n, e1.node.property) : e1.node.property, e1.node.computed)),
                        l("=", T(e1.node.object, n ? h(n.name) : e1.node.property, e1.node.computed), c(e1.parentPath.node.operator[0], h(r.name), E(1)))
                    ];
                    if (!e1.parentPath.node.prefix) {
                        s.push(h(r.name));
                    }
                    t.replaceWith(w(s));
                    const i = t.get("expressions.0.right");
                    const a = t.get("expressions.1.left");
                    return [
                        i,
                        a
                    ];
                }
                return [
                    e1
                ];
                "TURBOPACK unreachable";
                function rightExpression(e1, t, r) {
                    if (e1 === "=") {
                        return l("=", t, r);
                    } else {
                        return c(e1, t, r);
                    }
                }
            }
            function hasSuperClass(e1) {
                return e1.isClassMethod() && !!e1.parentPath.parentPath.node.superClass;
            }
            const D = (0, a.merge)([
                {
                    CallExpression (e1, { supers: t, thisBinding: r }) {
                        if (!e1.get("callee").isSuper()) return;
                        if (t.has(e1.node)) return;
                        t.add(e1.node);
                        e1.replaceWithMultiple([
                            e1.node,
                            l("=", h(r), h("this"))
                        ]);
                    }
                },
                s.default
            ]);
            function getThisBinding(e1, t) {
                return getBinding(e1, "this", (r)=>{
                    if (!t || !hasSuperClass(e1)) return O();
                    e1.traverse(D, {
                        supers: new WeakSet,
                        thisBinding: r
                    });
                });
            }
            function getSuperBinding(e1) {
                return getBinding(e1, "supercall", ()=>{
                    const t = e1.scope.generateUidIdentifier("args");
                    return o([
                        x(t)
                    ], p(I(), [
                        A(h(t.name))
                    ]));
                });
            }
            function getSuperPropBinding(e1, t, r) {
                const n = t ? "set" : "get";
                return getBinding(e1, `superprop_${n}:${r || ""}`, ()=>{
                    const n = [];
                    let s;
                    if (r) {
                        s = T(I(), h(r));
                    } else {
                        const t = e1.scope.generateUidIdentifier("prop");
                        n.unshift(t);
                        s = T(I(), h(t.name), true);
                    }
                    if (t) {
                        const t = e1.scope.generateUidIdentifier("value");
                        n.push(t);
                        s = l("=", s, h(t.name));
                    }
                    return o(n, s);
                });
            }
            function getBinding(e1, t, r) {
                const n = "binding:" + t;
                let s = e1.getData(n);
                if (!s) {
                    const i = e1.scope.generateUidIdentifier(t);
                    s = i.name;
                    e1.setData(n, s);
                    e1.scope.push({
                        id: i,
                        init: r(s)
                    });
                }
                return s;
            }
            const M = (0, a.merge)([
                {
                    ThisExpression (e1, { thisPaths: t }) {
                        t.push(e1);
                    },
                    JSXIdentifier (e1, { thisPaths: t }) {
                        if (e1.node.name !== "this") return;
                        if (!e1.parentPath.isJSXMemberExpression({
                            object: e1.node
                        }) && !e1.parentPath.isJSXOpeningElement({
                            name: e1.node
                        })) {
                            return;
                        }
                        t.push(e1);
                    },
                    CallExpression (e1, { superCalls: t }) {
                        if (e1.get("callee").isSuper()) t.push(e1);
                    },
                    MemberExpression (e1, { superProps: t }) {
                        if (e1.get("object").isSuper()) t.push(e1);
                    },
                    Identifier (e1, { argumentsPaths: t }) {
                        if (!e1.isReferencedIdentifier({
                            name: "arguments"
                        })) return;
                        let r = e1.scope;
                        do {
                            if (r.hasOwnBinding("arguments")) {
                                r.rename("arguments");
                                return;
                            }
                            if (r.path.isFunction() && !r.path.isArrowFunctionExpression()) {
                                break;
                            }
                        }while (r = r.parent)
                        t.push(e1);
                    },
                    MetaProperty (e1, { newTargetPaths: t }) {
                        if (!e1.get("meta").isIdentifier({
                            name: "new"
                        })) return;
                        if (!e1.get("property").isIdentifier({
                            name: "target"
                        })) return;
                        t.push(e1);
                    }
                },
                s.default
            ]);
            function getScopeInformation(e1) {
                const t = [];
                const r = [];
                const n = [];
                const s = [];
                const i = [];
                e1.traverse(M, {
                    thisPaths: t,
                    argumentsPaths: r,
                    newTargetPaths: n,
                    superProps: s,
                    superCalls: i
                });
                return {
                    thisPaths: t,
                    argumentsPaths: r,
                    newTargetPaths: n,
                    superProps: s,
                    superCalls: i
                };
            }
        },
        118: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.evaluate = evaluate;
            t.evaluateTruthy = evaluateTruthy;
            const r = [
                "String",
                "Number",
                "Math"
            ];
            const n = [
                "random"
            ];
            function isValidCallee(e1) {
                return r.includes(e1);
            }
            function isInvalidMethod(e1) {
                return n.includes(e1);
            }
            function evaluateTruthy() {
                const e1 = this.evaluate();
                if (e1.confident) return !!e1.value;
            }
            function deopt(e1, t) {
                if (!t.confident) return;
                t.deoptPath = e1;
                t.confident = false;
            }
            const s = new Map([
                [
                    "undefined",
                    undefined
                ],
                [
                    "Infinity",
                    Infinity
                ],
                [
                    "NaN",
                    NaN
                ]
            ]);
            function evaluateCached(e1, t) {
                const { node: r } = e1;
                const { seen: n } = t;
                if (n.has(r)) {
                    const s = n.get(r);
                    if (s.resolved) {
                        return s.value;
                    } else {
                        deopt(e1, t);
                        return;
                    }
                } else {
                    const s = {
                        resolved: false
                    };
                    n.set(r, s);
                    const i = _evaluate(e1, t);
                    if (t.confident) {
                        s.resolved = true;
                        s.value = i;
                    }
                    return i;
                }
            }
            function _evaluate(e1, t) {
                if (!t.confident) return;
                if (e1.isSequenceExpression()) {
                    const r = e1.get("expressions");
                    return evaluateCached(r[r.length - 1], t);
                }
                if (e1.isStringLiteral() || e1.isNumericLiteral() || e1.isBooleanLiteral()) {
                    return e1.node.value;
                }
                if (e1.isNullLiteral()) {
                    return null;
                }
                if (e1.isTemplateLiteral()) {
                    return evaluateQuasis(e1, e1.node.quasis, t);
                }
                if (e1.isTaggedTemplateExpression() && e1.get("tag").isMemberExpression()) {
                    const r = e1.get("tag.object");
                    const { node: { name: n } } = r;
                    const s = e1.get("tag.property");
                    if (r.isIdentifier() && n === "String" && !e1.scope.getBinding(n) && s.isIdentifier() && s.node.name === "raw") {
                        return evaluateQuasis(e1, e1.node.quasi.quasis, t, true);
                    }
                }
                if (e1.isConditionalExpression()) {
                    const r = evaluateCached(e1.get("test"), t);
                    if (!t.confident) return;
                    if (r) {
                        return evaluateCached(e1.get("consequent"), t);
                    } else {
                        return evaluateCached(e1.get("alternate"), t);
                    }
                }
                if (e1.isExpressionWrapper()) {
                    return evaluateCached(e1.get("expression"), t);
                }
                if (e1.isMemberExpression() && !e1.parentPath.isCallExpression({
                    callee: e1.node
                })) {
                    const r = e1.get("property");
                    const n = e1.get("object");
                    if (n.isLiteral()) {
                        const s = n.node.value;
                        const i = typeof s;
                        let a = null;
                        if (e1.node.computed) {
                            a = evaluateCached(r, t);
                            if (!t.confident) return;
                        } else if (r.isIdentifier()) {
                            a = r.node.name;
                        }
                        if ((i === "number" || i === "string") && a != null && (typeof a === "number" || typeof a === "string")) {
                            return s[a];
                        }
                    }
                }
                if (e1.isReferencedIdentifier()) {
                    const r = e1.scope.getBinding(e1.node.name);
                    if (r) {
                        if (r.constantViolations.length > 0 || e1.node.start < r.path.node.end) {
                            deopt(r.path, t);
                            return;
                        }
                        if (r.hasValue) {
                            return r.value;
                        }
                    }
                    const n = e1.node.name;
                    if (s.has(n)) {
                        if (!r) {
                            return s.get(n);
                        }
                        deopt(r.path, t);
                        return;
                    }
                    const i = e1.resolve();
                    if (i === e1) {
                        deopt(e1, t);
                        return;
                    } else {
                        return evaluateCached(i, t);
                    }
                }
                if (e1.isUnaryExpression({
                    prefix: true
                })) {
                    if (e1.node.operator === "void") {
                        return undefined;
                    }
                    const r = e1.get("argument");
                    if (e1.node.operator === "typeof" && (r.isFunction() || r.isClass())) {
                        return "function";
                    }
                    const n = evaluateCached(r, t);
                    if (!t.confident) return;
                    switch(e1.node.operator){
                        case "!":
                            return !n;
                        case "+":
                            return +n;
                        case "-":
                            return -n;
                        case "~":
                            return ~n;
                        case "typeof":
                            return typeof n;
                    }
                }
                if (e1.isArrayExpression()) {
                    const r = [];
                    const n = e1.get("elements");
                    for (const e1 of n){
                        const n = e1.evaluate();
                        if (n.confident) {
                            r.push(n.value);
                        } else {
                            deopt(n.deopt, t);
                            return;
                        }
                    }
                    return r;
                }
                if (e1.isObjectExpression()) {
                    const r = {};
                    const n = e1.get("properties");
                    for (const e1 of n){
                        if (e1.isObjectMethod() || e1.isSpreadElement()) {
                            deopt(e1, t);
                            return;
                        }
                        const n = e1.get("key");
                        let s;
                        if (e1.node.computed) {
                            s = n.evaluate();
                            if (!s.confident) {
                                deopt(s.deopt, t);
                                return;
                            }
                            s = s.value;
                        } else if (n.isIdentifier()) {
                            s = n.node.name;
                        } else {
                            s = n.node.value;
                        }
                        const i = e1.get("value");
                        let a = i.evaluate();
                        if (!a.confident) {
                            deopt(a.deopt, t);
                            return;
                        }
                        a = a.value;
                        r[s] = a;
                    }
                    return r;
                }
                if (e1.isLogicalExpression()) {
                    const r = t.confident;
                    const n = evaluateCached(e1.get("left"), t);
                    const s = t.confident;
                    t.confident = r;
                    const i = evaluateCached(e1.get("right"), t);
                    const a = t.confident;
                    switch(e1.node.operator){
                        case "||":
                            t.confident = s && (!!n || a);
                            if (!t.confident) return;
                            return n || i;
                        case "&&":
                            t.confident = s && (!n || a);
                            if (!t.confident) return;
                            return n && i;
                        case "??":
                            t.confident = s && (n != null || a);
                            if (!t.confident) return;
                            return n != null ? n : i;
                    }
                }
                if (e1.isBinaryExpression()) {
                    const r = evaluateCached(e1.get("left"), t);
                    if (!t.confident) return;
                    const n = evaluateCached(e1.get("right"), t);
                    if (!t.confident) return;
                    switch(e1.node.operator){
                        case "-":
                            return r - n;
                        case "+":
                            return r + n;
                        case "/":
                            return r / n;
                        case "*":
                            return r * n;
                        case "%":
                            return r % n;
                        case "**":
                            return Math.pow(r, n);
                        case "<":
                            return r < n;
                        case ">":
                            return r > n;
                        case "<=":
                            return r <= n;
                        case ">=":
                            return r >= n;
                        case "==":
                            return r == n;
                        case "!=":
                            return r != n;
                        case "===":
                            return r === n;
                        case "!==":
                            return r !== n;
                        case "|":
                            return r | n;
                        case "&":
                            return r & n;
                        case "^":
                            return r ^ n;
                        case "<<":
                            return r << n;
                        case ">>":
                            return r >> n;
                        case ">>>":
                            return r >>> n;
                    }
                }
                if (e1.isCallExpression()) {
                    const r = e1.get("callee");
                    let n;
                    let s;
                    if (r.isIdentifier() && !e1.scope.getBinding(r.node.name) && isValidCallee(r.node.name)) {
                        s = global[r.node.name];
                    }
                    if (r.isMemberExpression()) {
                        const e1 = r.get("object");
                        const t = r.get("property");
                        if (e1.isIdentifier() && t.isIdentifier() && isValidCallee(e1.node.name) && !isInvalidMethod(t.node.name)) {
                            n = global[e1.node.name];
                            s = n[t.node.name];
                        }
                        if (e1.isLiteral() && t.isIdentifier()) {
                            const r = typeof e1.node.value;
                            if (r === "string" || r === "number") {
                                n = e1.node.value;
                                s = n[t.node.name];
                            }
                        }
                    }
                    if (s) {
                        const r = e1.get("arguments").map((e1)=>evaluateCached(e1, t));
                        if (!t.confident) return;
                        return s.apply(n, r);
                    }
                }
                deopt(e1, t);
            }
            function evaluateQuasis(e1, t, r, n = false) {
                let s = "";
                let i = 0;
                const a = e1.isTemplateLiteral() ? e1.get("expressions") : e1.get("quasi.expressions");
                for (const e1 of t){
                    if (!r.confident) break;
                    s += n ? e1.value.raw : e1.value.cooked;
                    const t = a[i++];
                    if (t) s += String(evaluateCached(t, r));
                }
                if (!r.confident) return;
                return s;
            }
            function evaluate() {
                const e1 = {
                    confident: true,
                    deoptPath: null,
                    seen: new Map
                };
                let t = evaluateCached(this, e1);
                if (!e1.confident) t = undefined;
                return {
                    confident: e1.confident,
                    deopt: e1.deoptPath,
                    value: t
                };
            }
        },
        1481: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._getKey = _getKey;
            t._getPattern = _getPattern;
            t.get = get;
            t.getAllNextSiblings = getAllNextSiblings;
            t.getAllPrevSiblings = getAllPrevSiblings;
            t.getBindingIdentifierPaths = getBindingIdentifierPaths;
            t.getBindingIdentifiers = getBindingIdentifiers;
            t.getCompletionRecords = getCompletionRecords;
            t.getNextSibling = getNextSibling;
            t.getOpposite = getOpposite;
            t.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
            t.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
            t.getPrevSibling = getPrevSibling;
            t.getSibling = getSibling;
            var n = r(8485);
            var s = r(776);
            const { getBindingIdentifiers: i, getOuterBindingIdentifiers: a, isDeclaration: o, numericLiteral: l, unaryExpression: c } = s;
            const u = 0;
            const p = 1;
            function NormalCompletion(e1) {
                return {
                    type: u,
                    path: e1
                };
            }
            function BreakCompletion(e1) {
                return {
                    type: p,
                    path: e1
                };
            }
            function getOpposite() {
                if (this.key === "left") {
                    return this.getSibling("right");
                } else if (this.key === "right") {
                    return this.getSibling("left");
                }
                return null;
            }
            function addCompletionRecords(e1, t, r) {
                if (e1) {
                    t.push(..._getCompletionRecords(e1, r));
                }
                return t;
            }
            function completionRecordForSwitch(e1, t, r) {
                let n = [];
                for(let s = 0; s < e1.length; s++){
                    const i = e1[s];
                    const a = _getCompletionRecords(i, r);
                    const o = [];
                    const l = [];
                    for (const e1 of a){
                        if (e1.type === u) {
                            o.push(e1);
                        }
                        if (e1.type === p) {
                            l.push(e1);
                        }
                    }
                    if (o.length) {
                        n = o;
                    }
                    t.push(...l);
                }
                t.push(...n);
                return t;
            }
            function normalCompletionToBreak(e1) {
                e1.forEach((e1)=>{
                    e1.type = p;
                });
            }
            function replaceBreakStatementInBreakCompletion(e1, t) {
                e1.forEach((e1)=>{
                    if (e1.path.isBreakStatement({
                        label: null
                    })) {
                        if (t) {
                            e1.path.replaceWith(c("void", l(0)));
                        } else {
                            e1.path.remove();
                        }
                    }
                });
            }
            function getStatementListCompletion(e1, t) {
                const r = [];
                if (t.canHaveBreak) {
                    let n = [];
                    for(let s = 0; s < e1.length; s++){
                        const i = e1[s];
                        const a = Object.assign({}, t, {
                            inCaseClause: false
                        });
                        if (i.isBlockStatement() && (t.inCaseClause || t.shouldPopulateBreak)) {
                            a.shouldPopulateBreak = true;
                        } else {
                            a.shouldPopulateBreak = false;
                        }
                        const o = _getCompletionRecords(i, a);
                        if (o.length > 0 && o.every((e1)=>e1.type === p)) {
                            if (n.length > 0 && o.every((e1)=>e1.path.isBreakStatement({
                                    label: null
                                }))) {
                                normalCompletionToBreak(n);
                                r.push(...n);
                                if (n.some((e1)=>e1.path.isDeclaration())) {
                                    r.push(...o);
                                    replaceBreakStatementInBreakCompletion(o, true);
                                }
                                replaceBreakStatementInBreakCompletion(o, false);
                            } else {
                                r.push(...o);
                                if (!t.shouldPopulateBreak) {
                                    replaceBreakStatementInBreakCompletion(o, true);
                                }
                            }
                            break;
                        }
                        if (s === e1.length - 1) {
                            r.push(...o);
                        } else {
                            n = [];
                            for(let e1 = 0; e1 < o.length; e1++){
                                const t = o[e1];
                                if (t.type === p) {
                                    r.push(t);
                                }
                                if (t.type === u) {
                                    n.push(t);
                                }
                            }
                        }
                    }
                } else if (e1.length) {
                    for(let n = e1.length - 1; n >= 0; n--){
                        const s = _getCompletionRecords(e1[n], t);
                        if (s.length > 1 || s.length === 1 && !s[0].path.isVariableDeclaration()) {
                            r.push(...s);
                            break;
                        }
                    }
                }
                return r;
            }
            function _getCompletionRecords(e1, t) {
                let r = [];
                if (e1.isIfStatement()) {
                    r = addCompletionRecords(e1.get("consequent"), r, t);
                    r = addCompletionRecords(e1.get("alternate"), r, t);
                } else if (e1.isDoExpression() || e1.isFor() || e1.isWhile() || e1.isLabeledStatement()) {
                    return addCompletionRecords(e1.get("body"), r, t);
                } else if (e1.isProgram() || e1.isBlockStatement()) {
                    return getStatementListCompletion(e1.get("body"), t);
                } else if (e1.isFunction()) {
                    return _getCompletionRecords(e1.get("body"), t);
                } else if (e1.isTryStatement()) {
                    r = addCompletionRecords(e1.get("block"), r, t);
                    r = addCompletionRecords(e1.get("handler"), r, t);
                } else if (e1.isCatchClause()) {
                    return addCompletionRecords(e1.get("body"), r, t);
                } else if (e1.isSwitchStatement()) {
                    return completionRecordForSwitch(e1.get("cases"), r, t);
                } else if (e1.isSwitchCase()) {
                    return getStatementListCompletion(e1.get("consequent"), {
                        canHaveBreak: true,
                        shouldPopulateBreak: false,
                        inCaseClause: true
                    });
                } else if (e1.isBreakStatement()) {
                    r.push(BreakCompletion(e1));
                } else {
                    r.push(NormalCompletion(e1));
                }
                return r;
            }
            function getCompletionRecords() {
                const e1 = _getCompletionRecords(this, {
                    canHaveBreak: false,
                    shouldPopulateBreak: false,
                    inCaseClause: false
                });
                return e1.map((e1)=>e1.path);
            }
            function getSibling(e1) {
                return n.default.get({
                    parentPath: this.parentPath,
                    parent: this.parent,
                    container: this.container,
                    listKey: this.listKey,
                    key: e1
                }).setContext(this.context);
            }
            function getPrevSibling() {
                return this.getSibling(this.key - 1);
            }
            function getNextSibling() {
                return this.getSibling(this.key + 1);
            }
            function getAllNextSiblings() {
                let e1 = this.key;
                let t = this.getSibling(++e1);
                const r = [];
                while(t.node){
                    r.push(t);
                    t = this.getSibling(++e1);
                }
                return r;
            }
            function getAllPrevSiblings() {
                let e1 = this.key;
                let t = this.getSibling(--e1);
                const r = [];
                while(t.node){
                    r.push(t);
                    t = this.getSibling(--e1);
                }
                return r;
            }
            function get(e1, t = true) {
                if (t === true) t = this.context;
                const r = e1.split(".");
                if (r.length === 1) {
                    return this._getKey(e1, t);
                } else {
                    return this._getPattern(r, t);
                }
            }
            function _getKey(e1, t) {
                const r = this.node;
                const s = r[e1];
                if (Array.isArray(s)) {
                    return s.map((i, a)=>n.default.get({
                            listKey: e1,
                            parentPath: this,
                            parent: r,
                            container: s,
                            key: a
                        }).setContext(t));
                } else {
                    return n.default.get({
                        parentPath: this,
                        parent: r,
                        container: r,
                        key: e1
                    }).setContext(t);
                }
            }
            function _getPattern(e1, t) {
                let r = this;
                for (const n of e1){
                    if (n === ".") {
                        r = r.parentPath;
                    } else {
                        if (Array.isArray(r)) {
                            r = r[n];
                        } else {
                            r = r.get(n, t);
                        }
                    }
                }
                return r;
            }
            function getBindingIdentifiers(e1) {
                return i(this.node, e1);
            }
            function getOuterBindingIdentifiers(e1) {
                return a(this.node, e1);
            }
            function getBindingIdentifierPaths(e1 = false, t = false) {
                const r = this;
                const n = [
                    r
                ];
                const s = Object.create(null);
                while(n.length){
                    const r = n.shift();
                    if (!r) continue;
                    if (!r.node) continue;
                    const a = i.keys[r.node.type];
                    if (r.isIdentifier()) {
                        if (e1) {
                            const e1 = s[r.node.name] = s[r.node.name] || [];
                            e1.push(r);
                        } else {
                            s[r.node.name] = r;
                        }
                        continue;
                    }
                    if (r.isExportDeclaration()) {
                        const e1 = r.get("declaration");
                        if (o(e1)) {
                            n.push(e1);
                        }
                        continue;
                    }
                    if (t) {
                        if (r.isFunctionDeclaration()) {
                            n.push(r.get("id"));
                            continue;
                        }
                        if (r.isFunctionExpression()) {
                            continue;
                        }
                    }
                    if (a) {
                        for(let e1 = 0; e1 < a.length; e1++){
                            const t = a[e1];
                            const s = r.get(t);
                            if (Array.isArray(s)) {
                                n.push(...s);
                            } else if (s.node) {
                                n.push(s);
                            }
                        }
                    }
                }
                return s;
            }
            function getOuterBindingIdentifierPaths(e1 = false) {
                return this.getBindingIdentifierPaths(e1, true);
            }
        },
        8485: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = t.SHOULD_STOP = t.SHOULD_SKIP = t.REMOVED = void 0;
            var n = r(8958);
            var s = r(6937);
            var i = r(2297);
            var a = r(9632);
            var o = r(776);
            var l = o;
            var c = r(6419);
            var u = r(3956);
            var p = r(5852);
            var f = r(6337);
            var d = r(9554);
            var h = r(118);
            var m = r(5702);
            var y = r(3837);
            var g = r(7446);
            var b = r(4565);
            var T = r(6799);
            var S = r(1481);
            var E = r(1702);
            var v = r(2957);
            const { validate: x } = o;
            const P = s("babel");
            const w = 1 << 0;
            t.REMOVED = w;
            const A = 1 << 1;
            t.SHOULD_STOP = A;
            const C = 1 << 2;
            t.SHOULD_SKIP = C;
            class NodePath {
                constructor(e1, t){
                    this.contexts = [];
                    this.state = null;
                    this.opts = null;
                    this._traverseFlags = 0;
                    this.skipKeys = null;
                    this.parentPath = null;
                    this.container = null;
                    this.listKey = null;
                    this.key = null;
                    this.node = null;
                    this.type = null;
                    this.parent = t;
                    this.hub = e1;
                    this.data = null;
                    this.context = null;
                    this.scope = null;
                }
                static get({ hub: e1, parentPath: t, parent: r, container: n, listKey: s, key: i }) {
                    if (!e1 && t) {
                        e1 = t.hub;
                    }
                    if (!r) {
                        throw new Error("To get a node path the parent needs to exist");
                    }
                    const a = n[i];
                    let o = c.path.get(r);
                    if (!o) {
                        o = new Map;
                        c.path.set(r, o);
                    }
                    let l = o.get(a);
                    if (!l) {
                        l = new NodePath(e1, r);
                        if (a) o.set(a, l);
                    }
                    l.setup(t, n, s, i);
                    return l;
                }
                getScope(e1) {
                    return this.isScope() ? new a.default(this) : e1;
                }
                setData(e1, t) {
                    if (this.data == null) {
                        this.data = Object.create(null);
                    }
                    return this.data[e1] = t;
                }
                getData(e1, t) {
                    if (this.data == null) {
                        this.data = Object.create(null);
                    }
                    let r = this.data[e1];
                    if (r === undefined && t !== undefined) r = this.data[e1] = t;
                    return r;
                }
                hasNode() {
                    return this.node != null;
                }
                buildCodeFrameError(e1, t = SyntaxError) {
                    return this.hub.buildError(this.node, e1, t);
                }
                traverse(e1, t) {
                    (0, i.default)(this.node, e1, this.scope, t, this);
                }
                set(e1, t) {
                    x(this.node, e1, t);
                    this.node[e1] = t;
                }
                getPathLocation() {
                    const e1 = [];
                    let t = this;
                    do {
                        let r = t.key;
                        if (t.inList) r = `${t.listKey}[${r}]`;
                        e1.unshift(r);
                    }while (t = t.parentPath)
                    return e1.join(".");
                }
                debug(e1) {
                    if (!P.enabled) return;
                    P(`${this.getPathLocation()} ${this.type}: ${e1}`);
                }
                toString() {
                    return (0, u.default)(this.node).code;
                }
                get inList() {
                    return !!this.listKey;
                }
                set inList(e1) {
                    if (!e1) {
                        this.listKey = null;
                    }
                }
                get parentKey() {
                    return this.listKey || this.key;
                }
                get shouldSkip() {
                    return !!(this._traverseFlags & C);
                }
                set shouldSkip(e1) {
                    if (e1) {
                        this._traverseFlags |= C;
                    } else {
                        this._traverseFlags &= ~C;
                    }
                }
                get shouldStop() {
                    return !!(this._traverseFlags & A);
                }
                set shouldStop(e1) {
                    if (e1) {
                        this._traverseFlags |= A;
                    } else {
                        this._traverseFlags &= ~A;
                    }
                }
                get removed() {
                    return !!(this._traverseFlags & w);
                }
                set removed(e1) {
                    if (e1) {
                        this._traverseFlags |= w;
                    } else {
                        this._traverseFlags &= ~w;
                    }
                }
            }
            Object.assign(NodePath.prototype, p, f, d, h, m, y, g, b, T, S, E);
            {
                NodePath.prototype._guessExecutionStatusRelativeToDifferentFunctions = y._guessExecutionStatusRelativeTo;
            }
            for (const e1 of l.TYPES){
                const t = `is${e1}`;
                const r = l[t];
                NodePath.prototype[t] = function(e1) {
                    return r(this.node, e1);
                };
                NodePath.prototype[`assert${e1}`] = function(t) {
                    if (!r(this.node, t)) {
                        throw new TypeError(`Expected node path of type ${e1}`);
                    }
                };
            }
            Object.assign(NodePath.prototype, v);
            for (const e1 of Object.keys(n)){
                if (e1[0] === "_") continue;
                if (!l.TYPES.includes(e1)) l.TYPES.push(e1);
            }
            var I = NodePath;
            t["default"] = I;
        },
        6337: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._getTypeAnnotation = _getTypeAnnotation;
            t.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
            t.couldBeBaseType = couldBeBaseType;
            t.getTypeAnnotation = getTypeAnnotation;
            t.isBaseType = isBaseType;
            t.isGenericType = isGenericType;
            var n = r(8224);
            var s = r(776);
            const { anyTypeAnnotation: i, isAnyTypeAnnotation: a, isArrayTypeAnnotation: o, isBooleanTypeAnnotation: l, isEmptyTypeAnnotation: c, isFlowBaseAnnotation: u, isGenericTypeAnnotation: p, isIdentifier: f, isMixedTypeAnnotation: d, isNumberTypeAnnotation: h, isStringTypeAnnotation: m, isTSArrayType: y, isTSTypeAnnotation: g, isTSTypeReference: b, isTupleTypeAnnotation: T, isTypeAnnotation: S, isUnionTypeAnnotation: E, isVoidTypeAnnotation: v, stringTypeAnnotation: x, voidTypeAnnotation: P } = s;
            function getTypeAnnotation() {
                let e1 = this.getData("typeAnnotation");
                if (e1 != null) {
                    return e1;
                }
                e1 = this._getTypeAnnotation() || i();
                if (S(e1) || g(e1)) {
                    e1 = e1.typeAnnotation;
                }
                this.setData("typeAnnotation", e1);
                return e1;
            }
            const w = new WeakSet;
            function _getTypeAnnotation() {
                const e1 = this.node;
                if (!e1) {
                    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
                        const e1 = this.parentPath.parentPath;
                        const t = e1.parentPath;
                        if (e1.key === "left" && t.isForInStatement()) {
                            return x();
                        }
                        if (e1.key === "left" && t.isForOfStatement()) {
                            return i();
                        }
                        return P();
                    } else {
                        return;
                    }
                }
                if (e1.typeAnnotation) {
                    return e1.typeAnnotation;
                }
                if (w.has(e1)) {
                    return;
                }
                w.add(e1);
                try {
                    var t;
                    let r = n[e1.type];
                    if (r) {
                        return r.call(this, e1);
                    }
                    r = n[this.parentPath.type];
                    if ((t = r) != null && t.validParent) {
                        return this.parentPath.getTypeAnnotation();
                    }
                } finally{
                    w.delete(e1);
                }
            }
            function isBaseType(e1, t) {
                return _isBaseType(e1, this.getTypeAnnotation(), t);
            }
            function _isBaseType(e1, t, r) {
                if (e1 === "string") {
                    return m(t);
                } else if (e1 === "number") {
                    return h(t);
                } else if (e1 === "boolean") {
                    return l(t);
                } else if (e1 === "any") {
                    return a(t);
                } else if (e1 === "mixed") {
                    return d(t);
                } else if (e1 === "empty") {
                    return c(t);
                } else if (e1 === "void") {
                    return v(t);
                } else {
                    if (r) {
                        return false;
                    } else {
                        throw new Error(`Unknown base type ${e1}`);
                    }
                }
            }
            function couldBeBaseType(e1) {
                const t = this.getTypeAnnotation();
                if (a(t)) return true;
                if (E(t)) {
                    for (const r of t.types){
                        if (a(r) || _isBaseType(e1, r, true)) {
                            return true;
                        }
                    }
                    return false;
                } else {
                    return _isBaseType(e1, t, true);
                }
            }
            function baseTypeStrictlyMatches(e1) {
                const t = this.getTypeAnnotation();
                const r = e1.getTypeAnnotation();
                if (!a(t) && u(t)) {
                    return r.type === t.type;
                }
                return false;
            }
            function isGenericType(e1) {
                const t = this.getTypeAnnotation();
                if (e1 === "Array") {
                    if (y(t) || o(t) || T(t)) {
                        return true;
                    }
                }
                return p(t) && f(t.id, {
                    name: e1
                }) || b(t) && f(t.typeName, {
                    name: e1
                });
            }
        },
        5017: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = _default;
            var n = r(776);
            var s = r(5783);
            const { BOOLEAN_NUMBER_BINARY_OPERATORS: i, createTypeAnnotationBasedOnTypeof: a, numberTypeAnnotation: o, voidTypeAnnotation: l } = n;
            function _default(e1) {
                if (!this.isReferenced()) return;
                const t = this.scope.getBinding(e1.name);
                if (t) {
                    if (t.identifier.typeAnnotation) {
                        return t.identifier.typeAnnotation;
                    } else {
                        return getTypeAnnotationBindingConstantViolations(t, this, e1.name);
                    }
                }
                if (e1.name === "undefined") {
                    return l();
                } else if (e1.name === "NaN" || e1.name === "Infinity") {
                    return o();
                } else if (e1.name === "arguments") {}
            }
            function getTypeAnnotationBindingConstantViolations(e1, t, r) {
                const n = [];
                const i = [];
                let a = getConstantViolationsBefore(e1, t, i);
                const o = getConditionalAnnotation(e1, t, r);
                if (o) {
                    const t = getConstantViolationsBefore(e1, o.ifStatement);
                    a = a.filter((e1)=>t.indexOf(e1) < 0);
                    n.push(o.typeAnnotation);
                }
                if (a.length) {
                    a.push(...i);
                    for (const e1 of a){
                        n.push(e1.getTypeAnnotation());
                    }
                }
                if (!n.length) {
                    return;
                }
                return (0, s.createUnionType)(n);
            }
            function getConstantViolationsBefore(e1, t, r) {
                const n = e1.constantViolations.slice();
                n.unshift(e1.path);
                return n.filter((e1)=>{
                    e1 = e1.resolve();
                    const n = e1._guessExecutionStatusRelativeTo(t);
                    if (r && n === "unknown") r.push(e1);
                    return n === "before";
                });
            }
            function inferAnnotationFromBinaryExpression(e1, t) {
                const r = t.node.operator;
                const n = t.get("right").resolve();
                const s = t.get("left").resolve();
                let l;
                if (s.isIdentifier({
                    name: e1
                })) {
                    l = n;
                } else if (n.isIdentifier({
                    name: e1
                })) {
                    l = s;
                }
                if (l) {
                    if (r === "===") {
                        return l.getTypeAnnotation();
                    }
                    if (i.indexOf(r) >= 0) {
                        return o();
                    }
                    return;
                }
                if (r !== "===" && r !== "==") return;
                let c;
                let u;
                if (s.isUnaryExpression({
                    operator: "typeof"
                })) {
                    c = s;
                    u = n;
                } else if (n.isUnaryExpression({
                    operator: "typeof"
                })) {
                    c = n;
                    u = s;
                }
                if (!c) return;
                if (!c.get("argument").isIdentifier({
                    name: e1
                })) return;
                u = u.resolve();
                if (!u.isLiteral()) return;
                const p = u.node.value;
                if (typeof p !== "string") return;
                return a(p);
            }
            function getParentConditionalPath(e1, t, r) {
                let n;
                while(n = t.parentPath){
                    if (n.isIfStatement() || n.isConditionalExpression()) {
                        if (t.key === "test") {
                            return;
                        }
                        return n;
                    }
                    if (n.isFunction()) {
                        if (n.parentPath.scope.getBinding(r) !== e1) return;
                    }
                    t = n;
                }
            }
            function getConditionalAnnotation(e1, t, r) {
                const n = getParentConditionalPath(e1, t, r);
                if (!n) return;
                const i = n.get("test");
                const a = [
                    i
                ];
                const o = [];
                for(let e1 = 0; e1 < a.length; e1++){
                    const t = a[e1];
                    if (t.isLogicalExpression()) {
                        if (t.node.operator === "&&") {
                            a.push(t.get("left"));
                            a.push(t.get("right"));
                        }
                    } else if (t.isBinaryExpression()) {
                        const e1 = inferAnnotationFromBinaryExpression(r, t);
                        if (e1) o.push(e1);
                    }
                }
                if (o.length) {
                    return {
                        typeAnnotation: (0, s.createUnionType)(o),
                        ifStatement: n
                    };
                }
                return getConditionalAnnotation(e1, n, r);
            }
        },
        8224: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ArrayExpression = ArrayExpression;
            t.AssignmentExpression = AssignmentExpression;
            t.BinaryExpression = BinaryExpression;
            t.BooleanLiteral = BooleanLiteral;
            t.CallExpression = CallExpression;
            t.ConditionalExpression = ConditionalExpression;
            t.ClassDeclaration = t.ClassExpression = t.FunctionDeclaration = t.ArrowFunctionExpression = t.FunctionExpression = Func;
            Object.defineProperty(t, "Identifier", {
                enumerable: true,
                get: function() {
                    return s.default;
                }
            });
            t.LogicalExpression = LogicalExpression;
            t.NewExpression = NewExpression;
            t.NullLiteral = NullLiteral;
            t.NumericLiteral = NumericLiteral;
            t.ObjectExpression = ObjectExpression;
            t.ParenthesizedExpression = ParenthesizedExpression;
            t.RegExpLiteral = RegExpLiteral;
            t.RestElement = RestElement;
            t.SequenceExpression = SequenceExpression;
            t.StringLiteral = StringLiteral;
            t.TSAsExpression = TSAsExpression;
            t.TSNonNullExpression = TSNonNullExpression;
            t.TaggedTemplateExpression = TaggedTemplateExpression;
            t.TemplateLiteral = TemplateLiteral;
            t.TypeCastExpression = TypeCastExpression;
            t.UnaryExpression = UnaryExpression;
            t.UpdateExpression = UpdateExpression;
            t.VariableDeclarator = VariableDeclarator;
            var n = r(776);
            var s = r(5017);
            var i = r(5783);
            const { BOOLEAN_BINARY_OPERATORS: a, BOOLEAN_UNARY_OPERATORS: o, NUMBER_BINARY_OPERATORS: l, NUMBER_UNARY_OPERATORS: c, STRING_UNARY_OPERATORS: u, anyTypeAnnotation: p, arrayTypeAnnotation: f, booleanTypeAnnotation: d, buildMatchMemberExpression: h, genericTypeAnnotation: m, identifier: y, nullLiteralTypeAnnotation: g, numberTypeAnnotation: b, stringTypeAnnotation: T, tupleTypeAnnotation: S, unionTypeAnnotation: E, voidTypeAnnotation: v, isIdentifier: x } = n;
            function VariableDeclarator() {
                if (!this.get("id").isIdentifier()) return;
                return this.get("init").getTypeAnnotation();
            }
            function TypeCastExpression(e1) {
                return e1.typeAnnotation;
            }
            TypeCastExpression.validParent = true;
            function TSAsExpression(e1) {
                return e1.typeAnnotation;
            }
            TSAsExpression.validParent = true;
            function TSNonNullExpression() {
                return this.get("expression").getTypeAnnotation();
            }
            function NewExpression(e1) {
                if (e1.callee.type === "Identifier") {
                    return m(e1.callee);
                }
            }
            function TemplateLiteral() {
                return T();
            }
            function UnaryExpression(e1) {
                const t = e1.operator;
                if (t === "void") {
                    return v();
                } else if (c.indexOf(t) >= 0) {
                    return b();
                } else if (u.indexOf(t) >= 0) {
                    return T();
                } else if (o.indexOf(t) >= 0) {
                    return d();
                }
            }
            function BinaryExpression(e1) {
                const t = e1.operator;
                if (l.indexOf(t) >= 0) {
                    return b();
                } else if (a.indexOf(t) >= 0) {
                    return d();
                } else if (t === "+") {
                    const e1 = this.get("right");
                    const t = this.get("left");
                    if (t.isBaseType("number") && e1.isBaseType("number")) {
                        return b();
                    } else if (t.isBaseType("string") || e1.isBaseType("string")) {
                        return T();
                    }
                    return E([
                        T(),
                        b()
                    ]);
                }
            }
            function LogicalExpression() {
                const e1 = [
                    this.get("left").getTypeAnnotation(),
                    this.get("right").getTypeAnnotation()
                ];
                return (0, i.createUnionType)(e1);
            }
            function ConditionalExpression() {
                const e1 = [
                    this.get("consequent").getTypeAnnotation(),
                    this.get("alternate").getTypeAnnotation()
                ];
                return (0, i.createUnionType)(e1);
            }
            function SequenceExpression() {
                return this.get("expressions").pop().getTypeAnnotation();
            }
            function ParenthesizedExpression() {
                return this.get("expression").getTypeAnnotation();
            }
            function AssignmentExpression() {
                return this.get("right").getTypeAnnotation();
            }
            function UpdateExpression(e1) {
                const t = e1.operator;
                if (t === "++" || t === "--") {
                    return b();
                }
            }
            function StringLiteral() {
                return T();
            }
            function NumericLiteral() {
                return b();
            }
            function BooleanLiteral() {
                return d();
            }
            function NullLiteral() {
                return g();
            }
            function RegExpLiteral() {
                return m(y("RegExp"));
            }
            function ObjectExpression() {
                return m(y("Object"));
            }
            function ArrayExpression() {
                return m(y("Array"));
            }
            function RestElement() {
                return ArrayExpression();
            }
            RestElement.validParent = true;
            function Func() {
                return m(y("Function"));
            }
            const P = h("Array.from");
            const w = h("Object.keys");
            const A = h("Object.values");
            const C = h("Object.entries");
            function CallExpression() {
                const { callee: e1 } = this.node;
                if (w(e1)) {
                    return f(T());
                } else if (P(e1) || A(e1) || x(e1, {
                    name: "Array"
                })) {
                    return f(p());
                } else if (C(e1)) {
                    return f(S([
                        T(),
                        p()
                    ]));
                }
                return resolveCall(this.get("callee"));
            }
            function TaggedTemplateExpression() {
                return resolveCall(this.get("tag"));
            }
            function resolveCall(e1) {
                e1 = e1.resolve();
                if (e1.isFunction()) {
                    const { node: t } = e1;
                    if (t.async) {
                        if (t.generator) {
                            return m(y("AsyncIterator"));
                        } else {
                            return m(y("Promise"));
                        }
                    } else {
                        if (t.generator) {
                            return m(y("Iterator"));
                        } else if (e1.node.returnType) {
                            return e1.node.returnType;
                        } else {}
                    }
                }
            }
        },
        5783: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.createUnionType = createUnionType;
            var n = r(776);
            const { createFlowUnionType: s, createTSUnionType: i, createUnionTypeAnnotation: a, isFlowType: o, isTSType: l } = n;
            function createUnionType(e1) {
                {
                    if (o(e1[0])) {
                        if (s) {
                            return s(e1);
                        }
                        return a(e1);
                    } else {
                        if (i) {
                            return i(e1);
                        }
                    }
                }
            }
        },
        3837: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
            t._resolve = _resolve;
            t.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
            t.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
            t.equals = equals;
            t.getSource = getSource;
            t.has = has;
            t.is = void 0;
            t.isCompletionRecord = isCompletionRecord;
            t.isConstantExpression = isConstantExpression;
            t.isInStrictMode = isInStrictMode;
            t.isNodeType = isNodeType;
            t.isStatementOrBlock = isStatementOrBlock;
            t.isStatic = isStatic;
            t.isnt = isnt;
            t.matchesPattern = matchesPattern;
            t.referencesImport = referencesImport;
            t.resolve = resolve;
            t.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
            var n = r(776);
            const { STATEMENT_OR_BLOCK_KEYS: s, VISITOR_KEYS: i, isBlockStatement: a, isExpression: o, isIdentifier: l, isLiteral: c, isStringLiteral: u, isType: p, matchesPattern: f } = n;
            function matchesPattern(e1, t) {
                return f(this.node, e1, t);
            }
            function has(e1) {
                const t = this.node && this.node[e1];
                if (t && Array.isArray(t)) {
                    return !!t.length;
                } else {
                    return !!t;
                }
            }
            function isStatic() {
                return this.scope.isStatic(this.node);
            }
            const d = has;
            t.is = d;
            function isnt(e1) {
                return !this.has(e1);
            }
            function equals(e1, t) {
                return this.node[e1] === t;
            }
            function isNodeType(e1) {
                return p(this.type, e1);
            }
            function canHaveVariableDeclarationOrExpression() {
                return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
            }
            function canSwapBetweenExpressionAndStatement(e1) {
                if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
                    return false;
                }
                if (this.isExpression()) {
                    return a(e1);
                } else if (this.isBlockStatement()) {
                    return o(e1);
                }
                return false;
            }
            function isCompletionRecord(e1) {
                let t = this;
                let r = true;
                do {
                    const { type: n, container: s } = t;
                    if (!r && (t.isFunction() || n === "StaticBlock")) {
                        return !!e1;
                    }
                    r = false;
                    if (Array.isArray(s) && t.key !== s.length - 1) {
                        return false;
                    }
                }while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression())
                return true;
            }
            function isStatementOrBlock() {
                if (this.parentPath.isLabeledStatement() || a(this.container)) {
                    return false;
                } else {
                    return s.includes(this.key);
                }
            }
            function referencesImport(e1, t) {
                if (!this.isReferencedIdentifier()) {
                    if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? u(this.node.property, {
                        value: t
                    }) : this.node.property.name === t)) {
                        const t = this.get("object");
                        return t.isReferencedIdentifier() && t.referencesImport(e1, "*");
                    }
                    return false;
                }
                const r = this.scope.getBinding(this.node.name);
                if (!r || r.kind !== "module") return false;
                const n = r.path;
                const s = n.parentPath;
                if (!s.isImportDeclaration()) return false;
                if (s.node.source.value === e1) {
                    if (!t) return true;
                } else {
                    return false;
                }
                if (n.isImportDefaultSpecifier() && t === "default") {
                    return true;
                }
                if (n.isImportNamespaceSpecifier() && t === "*") {
                    return true;
                }
                if (n.isImportSpecifier() && l(n.node.imported, {
                    name: t
                })) {
                    return true;
                }
                return false;
            }
            function getSource() {
                const e1 = this.node;
                if (e1.end) {
                    const t = this.hub.getCode();
                    if (t) return t.slice(e1.start, e1.end);
                }
                return "";
            }
            function willIMaybeExecuteBefore(e1) {
                return this._guessExecutionStatusRelativeTo(e1) !== "after";
            }
            function getOuterFunction(e1) {
                return e1.isProgram() ? e1 : (e1.parentPath.scope.getFunctionParent() || e1.parentPath.scope.getProgramParent()).path;
            }
            function isExecutionUncertain(e1, t) {
                switch(e1){
                    case "LogicalExpression":
                        return t === "right";
                    case "ConditionalExpression":
                    case "IfStatement":
                        return t === "consequent" || t === "alternate";
                    case "WhileStatement":
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForOfStatement":
                        return t === "body";
                    case "ForStatement":
                        return t === "body" || t === "update";
                    case "SwitchStatement":
                        return t === "cases";
                    case "TryStatement":
                        return t === "handler";
                    case "AssignmentPattern":
                        return t === "right";
                    case "OptionalMemberExpression":
                        return t === "property";
                    case "OptionalCallExpression":
                        return t === "arguments";
                    default:
                        return false;
                }
            }
            function isExecutionUncertainInList(e1, t) {
                for(let r = 0; r < t; r++){
                    const t = e1[r];
                    if (isExecutionUncertain(t.parent.type, t.parentKey)) {
                        return true;
                    }
                }
                return false;
            }
            const h = Symbol();
            function _guessExecutionStatusRelativeTo(e1) {
                return _guessExecutionStatusRelativeToCached(this, e1, new Map);
            }
            function _guessExecutionStatusRelativeToCached(e1, t, r) {
                const n = {
                    this: getOuterFunction(e1),
                    target: getOuterFunction(t)
                };
                if (n.target.node !== n.this.node) {
                    return _guessExecutionStatusRelativeToDifferentFunctionsCached(e1, n.target, r);
                }
                const s = {
                    target: t.getAncestry(),
                    this: e1.getAncestry()
                };
                if (s.target.indexOf(e1) >= 0) return "after";
                if (s.this.indexOf(t) >= 0) return "before";
                let a;
                const o = {
                    target: 0,
                    this: 0
                };
                while(!a && o.this < s.this.length){
                    const e1 = s.this[o.this];
                    o.target = s.target.indexOf(e1);
                    if (o.target >= 0) {
                        a = e1;
                    } else {
                        o.this++;
                    }
                }
                if (!a) {
                    throw new Error("Internal Babel error - The two compared nodes" + " don't appear to belong to the same program.");
                }
                if (isExecutionUncertainInList(s.this, o.this - 1) || isExecutionUncertainInList(s.target, o.target - 1)) {
                    return "unknown";
                }
                const l = {
                    this: s.this[o.this - 1],
                    target: s.target[o.target - 1]
                };
                if (l.target.listKey && l.this.listKey && l.target.container === l.this.container) {
                    return l.target.key > l.this.key ? "before" : "after";
                }
                const c = i[a.type];
                const u = {
                    this: c.indexOf(l.this.parentKey),
                    target: c.indexOf(l.target.parentKey)
                };
                return u.target > u.this ? "before" : "after";
            }
            function _guessExecutionStatusRelativeToDifferentFunctionsInternal(e1, t, r) {
                if (!t.isFunctionDeclaration()) {
                    if (_guessExecutionStatusRelativeToCached(e1, t, r) === "before") {
                        return "before";
                    }
                    return "unknown";
                } else if (t.parentPath.isExportDeclaration()) {
                    return "unknown";
                }
                const n = t.scope.getBinding(t.node.id.name);
                if (!n.references) return "before";
                const s = n.referencePaths;
                let i;
                for (const n of s){
                    const s = !!n.find((e1)=>e1.node === t.node);
                    if (s) continue;
                    if (n.key !== "callee" || !n.parentPath.isCallExpression()) {
                        return "unknown";
                    }
                    const a = _guessExecutionStatusRelativeToCached(e1, n, r);
                    if (i && i !== a) {
                        return "unknown";
                    } else {
                        i = a;
                    }
                }
                return i;
            }
            function _guessExecutionStatusRelativeToDifferentFunctionsCached(e1, t, r) {
                let n = r.get(e1.node);
                let s;
                if (!n) {
                    r.set(e1.node, n = new Map);
                } else if (s = n.get(t.node)) {
                    if (s === h) {
                        return "unknown";
                    }
                    return s;
                }
                n.set(t.node, h);
                const i = _guessExecutionStatusRelativeToDifferentFunctionsInternal(e1, t, r);
                n.set(t.node, i);
                return i;
            }
            function resolve(e1, t) {
                return this._resolve(e1, t) || this;
            }
            function _resolve(e1, t) {
                if (t && t.indexOf(this) >= 0) return;
                t = t || [];
                t.push(this);
                if (this.isVariableDeclarator()) {
                    if (this.get("id").isIdentifier()) {
                        return this.get("init").resolve(e1, t);
                    } else {}
                } else if (this.isReferencedIdentifier()) {
                    const r = this.scope.getBinding(this.node.name);
                    if (!r) return;
                    if (!r.constant) return;
                    if (r.kind === "module") return;
                    if (r.path !== this) {
                        const n = r.path.resolve(e1, t);
                        if (this.find((e1)=>e1.node === n.node)) return;
                        return n;
                    }
                } else if (this.isTypeCastExpression()) {
                    return this.get("expression").resolve(e1, t);
                } else if (e1 && this.isMemberExpression()) {
                    const r = this.toComputedKey();
                    if (!c(r)) return;
                    const n = r.value;
                    const s = this.get("object").resolve(e1, t);
                    if (s.isObjectExpression()) {
                        const r = s.get("properties");
                        for (const s of r){
                            if (!s.isProperty()) continue;
                            const r = s.get("key");
                            let i = s.isnt("computed") && r.isIdentifier({
                                name: n
                            });
                            i = i || r.isLiteral({
                                value: n
                            });
                            if (i) return s.get("value").resolve(e1, t);
                        }
                    } else if (s.isArrayExpression() && !isNaN(+n)) {
                        const r = s.get("elements");
                        const i = r[n];
                        if (i) return i.resolve(e1, t);
                    }
                }
            }
            function isConstantExpression() {
                if (this.isIdentifier()) {
                    const e1 = this.scope.getBinding(this.node.name);
                    if (!e1) return false;
                    return e1.constant;
                }
                if (this.isLiteral()) {
                    if (this.isRegExpLiteral()) {
                        return false;
                    }
                    if (this.isTemplateLiteral()) {
                        return this.get("expressions").every((e1)=>e1.isConstantExpression());
                    }
                    return true;
                }
                if (this.isUnaryExpression()) {
                    if (this.node.operator !== "void") {
                        return false;
                    }
                    return this.get("argument").isConstantExpression();
                }
                if (this.isBinaryExpression()) {
                    const { operator: e1 } = this.node;
                    return e1 !== "in" && e1 !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
                }
                return false;
            }
            function isInStrictMode() {
                const e1 = this.isProgram() ? this : this.parentPath;
                const t = e1.find((e1)=>{
                    if (e1.isProgram({
                        sourceType: "module"
                    })) return true;
                    if (e1.isClass()) return true;
                    if (e1.isArrowFunctionExpression() && !e1.get("body").isBlockStatement()) {
                        return false;
                    }
                    let t;
                    if (e1.isFunction()) {
                        t = e1.node.body;
                    } else if (e1.isProgram()) {
                        t = e1.node;
                    } else {
                        return false;
                    }
                    for (const e1 of t.directives){
                        if (e1.value.value === "use strict") {
                            return true;
                        }
                    }
                });
                return !!t;
            }
        },
        2350: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(776);
            var s = n;
            const { react: i } = n;
            const { cloneNode: a, jsxExpressionContainer: o, variableDeclaration: l, variableDeclarator: c } = s;
            const u = {
                ReferencedIdentifier (e1, t) {
                    if (e1.isJSXIdentifier() && i.isCompatTag(e1.node.name) && !e1.parentPath.isJSXMemberExpression()) {
                        return;
                    }
                    if (e1.node.name === "this") {
                        let r = e1.scope;
                        do {
                            if (r.path.isFunction() && !r.path.isArrowFunctionExpression()) {
                                break;
                            }
                        }while (r = r.parent)
                        if (r) t.breakOnScopePaths.push(r.path);
                    }
                    const r = e1.scope.getBinding(e1.node.name);
                    if (!r) return;
                    for (const n of r.constantViolations){
                        if (n.scope !== r.path.scope) {
                            t.mutableBinding = true;
                            e1.stop();
                            return;
                        }
                    }
                    if (r !== t.scope.getBinding(e1.node.name)) return;
                    t.bindings[e1.node.name] = r;
                }
            };
            class PathHoister {
                constructor(e1, t){
                    this.breakOnScopePaths = void 0;
                    this.bindings = void 0;
                    this.mutableBinding = void 0;
                    this.scopes = void 0;
                    this.scope = void 0;
                    this.path = void 0;
                    this.attachAfter = void 0;
                    this.breakOnScopePaths = [];
                    this.bindings = {};
                    this.mutableBinding = false;
                    this.scopes = [];
                    this.scope = t;
                    this.path = e1;
                    this.attachAfter = false;
                }
                isCompatibleScope(e1) {
                    for (const t of Object.keys(this.bindings)){
                        const r = this.bindings[t];
                        if (!e1.bindingIdentifierEquals(t, r.identifier)) {
                            return false;
                        }
                    }
                    return true;
                }
                getCompatibleScopes() {
                    let e1 = this.path.scope;
                    do {
                        if (this.isCompatibleScope(e1)) {
                            this.scopes.push(e1);
                        } else {
                            break;
                        }
                        if (this.breakOnScopePaths.indexOf(e1.path) >= 0) {
                            break;
                        }
                    }while (e1 = e1.parent)
                }
                getAttachmentPath() {
                    let e1 = this._getAttachmentPath();
                    if (!e1) return;
                    let t = e1.scope;
                    if (t.path === e1) {
                        t = e1.scope.parent;
                    }
                    if (t.path.isProgram() || t.path.isFunction()) {
                        for (const r of Object.keys(this.bindings)){
                            if (!t.hasOwnBinding(r)) continue;
                            const n = this.bindings[r];
                            if (n.kind === "param" || n.path.parentKey === "params") {
                                continue;
                            }
                            const s = this.getAttachmentParentForPath(n.path);
                            if (s.key >= e1.key) {
                                this.attachAfter = true;
                                e1 = n.path;
                                for (const t of n.constantViolations){
                                    if (this.getAttachmentParentForPath(t).key > e1.key) {
                                        e1 = t;
                                    }
                                }
                            }
                        }
                    }
                    return e1;
                }
                _getAttachmentPath() {
                    const e1 = this.scopes;
                    const t = e1.pop();
                    if (!t) return;
                    if (t.path.isFunction()) {
                        if (this.hasOwnParamBindings(t)) {
                            if (this.scope === t) return;
                            const e1 = t.path.get("body").get("body");
                            for(let t = 0; t < e1.length; t++){
                                if (e1[t].node._blockHoist) continue;
                                return e1[t];
                            }
                        } else {
                            return this.getNextScopeAttachmentParent();
                        }
                    } else if (t.path.isProgram()) {
                        return this.getNextScopeAttachmentParent();
                    }
                }
                getNextScopeAttachmentParent() {
                    const e1 = this.scopes.pop();
                    if (e1) return this.getAttachmentParentForPath(e1.path);
                }
                getAttachmentParentForPath(e1) {
                    do {
                        if (!e1.parentPath || Array.isArray(e1.container) && e1.isStatement()) {
                            return e1;
                        }
                    }while (e1 = e1.parentPath)
                }
                hasOwnParamBindings(e1) {
                    for (const t of Object.keys(this.bindings)){
                        if (!e1.hasOwnBinding(t)) continue;
                        const r = this.bindings[t];
                        if (r.kind === "param" && r.constant) return true;
                    }
                    return false;
                }
                run() {
                    this.path.traverse(u, this);
                    if (this.mutableBinding) return;
                    this.getCompatibleScopes();
                    const e1 = this.getAttachmentPath();
                    if (!e1) return;
                    if (e1.getFunctionParent() === this.path.getFunctionParent()) return;
                    let t = e1.scope.generateUidIdentifier("ref");
                    const r = c(t, this.path.node);
                    const n = this.attachAfter ? "insertAfter" : "insertBefore";
                    const [s] = e1[n]([
                        e1.isVariableDeclarator() ? r : l("var", [
                            r
                        ])
                    ]);
                    const i = this.path.parentPath;
                    if (i.isJSXElement() && this.path.container === i.node.children) {
                        t = o(t);
                    }
                    this.path.replaceWith(a(t));
                    return e1.isVariableDeclarator() ? s.get("init") : s.get("declarations.0.init");
                }
            }
            t["default"] = PathHoister;
        },
        3857: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.hooks = void 0;
            const r = [
                function(e1, t) {
                    const r = e1.key === "test" && (t.isWhile() || t.isSwitchCase()) || e1.key === "declaration" && t.isExportDeclaration() || e1.key === "body" && t.isLabeledStatement() || e1.listKey === "declarations" && t.isVariableDeclaration() && t.node.declarations.length === 1 || e1.key === "expression" && t.isExpressionStatement();
                    if (r) {
                        t.remove();
                        return true;
                    }
                },
                function(e1, t) {
                    if (t.isSequenceExpression() && t.node.expressions.length === 1) {
                        t.replaceWith(t.node.expressions[0]);
                        return true;
                    }
                },
                function(e1, t) {
                    if (t.isBinary()) {
                        if (e1.key === "left") {
                            t.replaceWith(t.node.right);
                        } else {
                            t.replaceWith(t.node.left);
                        }
                        return true;
                    }
                },
                function(e1, t) {
                    if (t.isIfStatement() && e1.key === "consequent" || e1.key === "body" && (t.isLoop() || t.isArrowFunctionExpression())) {
                        e1.replaceWith({
                            type: "BlockStatement",
                            body: []
                        });
                        return true;
                    }
                }
            ];
            t.hooks = r;
        },
        2957: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isBindingIdentifier = isBindingIdentifier;
            t.isBlockScoped = isBlockScoped;
            t.isExistentialTypeParam = isExistentialTypeParam;
            t.isExpression = isExpression;
            t.isFlow = isFlow;
            t.isForAwaitStatement = isForAwaitStatement;
            t.isGenerated = isGenerated;
            t.isNumericLiteralTypeAnnotation = isNumericLiteralTypeAnnotation;
            t.isPure = isPure;
            t.isReferenced = isReferenced;
            t.isReferencedIdentifier = isReferencedIdentifier;
            t.isReferencedMemberExpression = isReferencedMemberExpression;
            t.isRestProperty = isRestProperty;
            t.isScope = isScope;
            t.isSpreadProperty = isSpreadProperty;
            t.isStatement = isStatement;
            t.isUser = isUser;
            t.isVar = isVar;
            var n = r(776);
            const { isBinding: s, isBlockScoped: i, isExportDeclaration: a, isExpression: o, isFlow: l, isForStatement: c, isForXStatement: u, isIdentifier: p, isImportDeclaration: f, isImportSpecifier: d, isJSXIdentifier: h, isJSXMemberExpression: m, isMemberExpression: y, isRestElement: g, isReferenced: b, isScope: T, isStatement: S, isVar: E, isVariableDeclaration: v, react: x, isForOfStatement: P } = n;
            const { isCompatTag: w } = x;
            function isReferencedIdentifier(e1) {
                const { node: t, parent: r } = this;
                if (!p(t, e1) && !m(r, e1)) {
                    if (h(t, e1)) {
                        if (w(t.name)) return false;
                    } else {
                        return false;
                    }
                }
                return b(t, r, this.parentPath.parent);
            }
            function isReferencedMemberExpression() {
                const { node: e1, parent: t } = this;
                return y(e1) && b(e1, t);
            }
            function isBindingIdentifier() {
                const { node: e1, parent: t } = this;
                const r = this.parentPath.parent;
                return p(e1) && s(e1, t, r);
            }
            function isStatement() {
                const { node: e1, parent: t } = this;
                if (S(e1)) {
                    if (v(e1)) {
                        if (u(t, {
                            left: e1
                        })) return false;
                        if (c(t, {
                            init: e1
                        })) return false;
                    }
                    return true;
                } else {
                    return false;
                }
            }
            function isExpression() {
                if (this.isIdentifier()) {
                    return this.isReferencedIdentifier();
                } else {
                    return o(this.node);
                }
            }
            function isScope() {
                return T(this.node, this.parent);
            }
            function isReferenced() {
                return b(this.node, this.parent);
            }
            function isBlockScoped() {
                return i(this.node);
            }
            function isVar() {
                return E(this.node);
            }
            function isUser() {
                return this.node && !!this.node.loc;
            }
            function isGenerated() {
                return !this.isUser();
            }
            function isPure(e1) {
                return this.scope.isPure(this.node, e1);
            }
            function isFlow() {
                const { node: e1 } = this;
                if (l(e1)) {
                    return true;
                } else if (f(e1)) {
                    return e1.importKind === "type" || e1.importKind === "typeof";
                } else if (a(e1)) {
                    return e1.exportKind === "type";
                } else if (d(e1)) {
                    return e1.importKind === "type" || e1.importKind === "typeof";
                } else {
                    return false;
                }
            }
            function isRestProperty() {
                return g(this.node) && this.parentPath && this.parentPath.isObjectPattern();
            }
            function isSpreadProperty() {
                return g(this.node) && this.parentPath && this.parentPath.isObjectExpression();
            }
            function isForAwaitStatement() {
                return P(this.node, {
                    await: true
                });
            }
            function isExistentialTypeParam() {
                throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
            }
            function isNumericLiteralTypeAnnotation() {
                throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
            }
        },
        8958: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Var = t.User = t.Statement = t.SpreadProperty = t.Scope = t.RestProperty = t.ReferencedMemberExpression = t.ReferencedIdentifier = t.Referenced = t.Pure = t.NumericLiteralTypeAnnotation = t.Generated = t.ForAwaitStatement = t.Flow = t.Expression = t.ExistentialTypeParam = t.BlockScoped = t.BindingIdentifier = void 0;
            const r = [
                "Identifier",
                "JSXIdentifier"
            ];
            t.ReferencedIdentifier = r;
            const n = [
                "MemberExpression"
            ];
            t.ReferencedMemberExpression = n;
            const s = [
                "Identifier"
            ];
            t.BindingIdentifier = s;
            const i = [
                "Statement"
            ];
            t.Statement = i;
            const a = [
                "Expression"
            ];
            t.Expression = a;
            const o = [
                "Scopable",
                "Pattern"
            ];
            t.Scope = o;
            const l = null;
            t.Referenced = l;
            const c = null;
            t.BlockScoped = c;
            const u = [
                "VariableDeclaration"
            ];
            t.Var = u;
            const p = null;
            t.User = p;
            const f = null;
            t.Generated = f;
            const d = null;
            t.Pure = d;
            const h = [
                "Flow",
                "ImportDeclaration",
                "ExportDeclaration",
                "ImportSpecifier"
            ];
            t.Flow = h;
            const m = [
                "RestElement"
            ];
            t.RestProperty = m;
            const y = [
                "RestElement"
            ];
            t.SpreadProperty = y;
            const g = [
                "ExistsTypeAnnotation"
            ];
            t.ExistentialTypeParam = g;
            const b = [
                "NumberLiteralTypeAnnotation"
            ];
            t.NumericLiteralTypeAnnotation = b;
            const T = [
                "ForOfStatement"
            ];
            t.ForAwaitStatement = T;
        },
        6799: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._containerInsert = _containerInsert;
            t._containerInsertAfter = _containerInsertAfter;
            t._containerInsertBefore = _containerInsertBefore;
            t._verifyNodeList = _verifyNodeList;
            t.hoist = hoist;
            t.insertAfter = insertAfter;
            t.insertBefore = insertBefore;
            t.pushContainer = pushContainer;
            t.unshiftContainer = unshiftContainer;
            t.updateSiblingKeys = updateSiblingKeys;
            var n = r(6419);
            var s = r(2350);
            var i = r(8485);
            var a = r(776);
            const { arrowFunctionExpression: o, assertExpression: l, assignmentExpression: c, blockStatement: u, callExpression: p, cloneNode: f, expressionStatement: d, isAssignmentExpression: h, isCallExpression: m, isExportNamedDeclaration: y, isExpression: g, isIdentifier: b, isSequenceExpression: T, isSuper: S, thisExpression: E } = a;
            function insertBefore(e1) {
                this._assertUnremoved();
                const t = this._verifyNodeList(e1);
                const { parentPath: r, parent: n } = this;
                if (r.isExpressionStatement() || r.isLabeledStatement() || y(n) || r.isExportDefaultDeclaration() && this.isDeclaration()) {
                    return r.insertBefore(t);
                } else if (this.isNodeType("Expression") && !this.isJSXElement() || r.isForStatement() && this.key === "init") {
                    if (this.node) t.push(this.node);
                    return this.replaceExpressionWithStatements(t);
                } else if (Array.isArray(this.container)) {
                    return this._containerInsertBefore(t);
                } else if (this.isStatementOrBlock()) {
                    const e1 = this.node;
                    const r = e1 && (!this.isExpressionStatement() || e1.expression != null);
                    this.replaceWith(u(r ? [
                        e1
                    ] : []));
                    return this.unshiftContainer("body", t);
                } else {
                    throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
                }
            }
            function _containerInsert(e1, t) {
                this.updateSiblingKeys(e1, t.length);
                const r = [];
                this.container.splice(e1, 0, ...t);
                for(let n = 0; n < t.length; n++){
                    const t = e1 + n;
                    const s = this.getSibling(t);
                    r.push(s);
                    if (this.context && this.context.queue) {
                        s.pushContext(this.context);
                    }
                }
                const n = this._getQueueContexts();
                for (const e1 of r){
                    e1.setScope();
                    e1.debug("Inserted.");
                    for (const t of n){
                        t.maybeQueue(e1, true);
                    }
                }
                return r;
            }
            function _containerInsertBefore(e1) {
                return this._containerInsert(this.key, e1);
            }
            function _containerInsertAfter(e1) {
                return this._containerInsert(this.key + 1, e1);
            }
            const last = (e1)=>e1[e1.length - 1];
            function isHiddenInSequenceExpression(e1) {
                return T(e1.parent) && (last(e1.parent.expressions) !== e1.node || isHiddenInSequenceExpression(e1.parentPath));
            }
            function isAlmostConstantAssignment(e1, t) {
                if (!h(e1) || !b(e1.left)) {
                    return false;
                }
                const r = t.getBlockParent();
                return r.hasOwnBinding(e1.left.name) && r.getOwnBinding(e1.left.name).constantViolations.length <= 1;
            }
            function insertAfter(e1) {
                this._assertUnremoved();
                if (this.isSequenceExpression()) {
                    return last(this.get("expressions")).insertAfter(e1);
                }
                const t = this._verifyNodeList(e1);
                const { parentPath: r, parent: n } = this;
                if (r.isExpressionStatement() || r.isLabeledStatement() || y(n) || r.isExportDefaultDeclaration() && this.isDeclaration()) {
                    return r.insertAfter(t.map((e1)=>g(e1) ? d(e1) : e1));
                } else if (this.isNodeType("Expression") && !this.isJSXElement() && !r.isJSXElement() || r.isForStatement() && this.key === "init") {
                    if (this.node) {
                        const e1 = this.node;
                        let { scope: n } = this;
                        if (n.path.isPattern()) {
                            l(e1);
                            this.replaceWith(p(o([], e1), []));
                            this.get("callee.body").insertAfter(t);
                            return [
                                this
                            ];
                        }
                        if (isHiddenInSequenceExpression(this)) {
                            t.unshift(e1);
                        } else if (m(e1) && S(e1.callee)) {
                            t.unshift(e1);
                            t.push(E());
                        } else if (isAlmostConstantAssignment(e1, n)) {
                            t.unshift(e1);
                            t.push(f(e1.left));
                        } else if (n.isPure(e1, true)) {
                            t.push(e1);
                        } else {
                            if (r.isMethod({
                                computed: true,
                                key: e1
                            })) {
                                n = n.parent;
                            }
                            const s = n.generateDeclaredUidIdentifier();
                            t.unshift(d(c("=", f(s), e1)));
                            t.push(d(f(s)));
                        }
                    }
                    return this.replaceExpressionWithStatements(t);
                } else if (Array.isArray(this.container)) {
                    return this._containerInsertAfter(t);
                } else if (this.isStatementOrBlock()) {
                    const e1 = this.node;
                    const r = e1 && (!this.isExpressionStatement() || e1.expression != null);
                    this.replaceWith(u(r ? [
                        e1
                    ] : []));
                    return this.pushContainer("body", t);
                } else {
                    throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
                }
            }
            function updateSiblingKeys(e1, t) {
                if (!this.parent) return;
                const r = n.path.get(this.parent);
                for (const [, n] of r){
                    if (typeof n.key === "number" && n.key >= e1) {
                        n.key += t;
                    }
                }
            }
            function _verifyNodeList(e1) {
                if (!e1) {
                    return [];
                }
                if (!Array.isArray(e1)) {
                    e1 = [
                        e1
                    ];
                }
                for(let t = 0; t < e1.length; t++){
                    const r = e1[t];
                    let n;
                    if (!r) {
                        n = "has falsy node";
                    } else if (typeof r !== "object") {
                        n = "contains a non-object node";
                    } else if (!r.type) {
                        n = "without a type";
                    } else if (r instanceof i.default) {
                        n = "has a NodePath when it expected a raw object";
                    }
                    if (n) {
                        const e1 = Array.isArray(r) ? "array" : typeof r;
                        throw new Error(`Node list ${n} with the index of ${t} and type of ${e1}`);
                    }
                }
                return e1;
            }
            function unshiftContainer(e1, t) {
                this._assertUnremoved();
                t = this._verifyNodeList(t);
                const r = i.default.get({
                    parentPath: this,
                    parent: this.node,
                    container: this.node[e1],
                    listKey: e1,
                    key: 0
                }).setContext(this.context);
                return r._containerInsertBefore(t);
            }
            function pushContainer(e1, t) {
                this._assertUnremoved();
                const r = this._verifyNodeList(t);
                const n = this.node[e1];
                const s = i.default.get({
                    parentPath: this,
                    parent: this.node,
                    container: n,
                    listKey: e1,
                    key: n.length
                }).setContext(this.context);
                return s.replaceWithMultiple(r);
            }
            function hoist(e1 = this.scope) {
                const t = new s.default(this, e1);
                return t.run();
            }
        },
        4565: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._assertUnremoved = _assertUnremoved;
            t._callRemovalHooks = _callRemovalHooks;
            t._markRemoved = _markRemoved;
            t._remove = _remove;
            t._removeFromScope = _removeFromScope;
            t.remove = remove;
            var n = r(3857);
            var s = r(6419);
            var i = r(8485);
            function remove() {
                var e1;
                this._assertUnremoved();
                this.resync();
                if (!((e1 = this.opts) != null && e1.noScope)) {
                    this._removeFromScope();
                }
                if (this._callRemovalHooks()) {
                    this._markRemoved();
                    return;
                }
                this.shareCommentsWithSiblings();
                this._remove();
                this._markRemoved();
            }
            function _removeFromScope() {
                const e1 = this.getBindingIdentifiers();
                Object.keys(e1).forEach((e1)=>this.scope.removeBinding(e1));
            }
            function _callRemovalHooks() {
                for (const e1 of n.hooks){
                    if (e1(this, this.parentPath)) return true;
                }
            }
            function _remove() {
                if (Array.isArray(this.container)) {
                    this.container.splice(this.key, 1);
                    this.updateSiblingKeys(this.key, -1);
                } else {
                    this._replaceWith(null);
                }
            }
            function _markRemoved() {
                this._traverseFlags |= i.SHOULD_SKIP | i.REMOVED;
                if (this.parent) s.path.get(this.parent).delete(this.node);
                this.node = null;
            }
            function _assertUnremoved() {
                if (this.removed) {
                    throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
                }
            }
        },
        9554: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t._replaceWith = _replaceWith;
            t.replaceExpressionWithStatements = replaceExpressionWithStatements;
            t.replaceInline = replaceInline;
            t.replaceWith = replaceWith;
            t.replaceWithMultiple = replaceWithMultiple;
            t.replaceWithSourceString = replaceWithSourceString;
            var n = r(2430);
            var s = r(2297);
            var i = r(8485);
            var a = r(6419);
            var o = r(7383);
            var l = r(776);
            var c = r(405);
            const { FUNCTION_TYPES: u, arrowFunctionExpression: p, assignmentExpression: f, awaitExpression: d, blockStatement: h, callExpression: m, cloneNode: y, expressionStatement: g, identifier: b, inheritLeadingComments: T, inheritTrailingComments: S, inheritsComments: E, isExpression: v, isProgram: x, isStatement: P, removeComments: w, returnStatement: A, toSequenceExpression: C, validate: I, yieldExpression: O } = l;
            function replaceWithMultiple(e1) {
                var t;
                this.resync();
                e1 = this._verifyNodeList(e1);
                T(e1[0], this.node);
                S(e1[e1.length - 1], this.node);
                (t = a.path.get(this.parent)) == null ? void 0 : t.delete(this.node);
                this.node = this.container[this.key] = null;
                const r = this.insertAfter(e1);
                if (this.node) {
                    this.requeue();
                } else {
                    this.remove();
                }
                return r;
            }
            function replaceWithSourceString(e1) {
                this.resync();
                let t;
                try {
                    e1 = `(${e1})`;
                    t = (0, o.parse)(e1);
                } catch (t) {
                    const r = t.loc;
                    if (r) {
                        t.message += " - make sure this is an expression.\n" + (0, n.codeFrameColumns)(e1, {
                            start: {
                                line: r.line,
                                column: r.column + 1
                            }
                        });
                        t.code = "BABEL_REPLACE_SOURCE_ERROR";
                    }
                    throw t;
                }
                const r = t.program.body[0].expression;
                s.default.removeProperties(r);
                return this.replaceWith(r);
            }
            function replaceWith(e1) {
                this.resync();
                if (this.removed) {
                    throw new Error("You can't replace this node, we've already removed it");
                }
                let t = e1 instanceof i.default ? e1.node : e1;
                if (!t) {
                    throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
                }
                if (this.node === t) {
                    return [
                        this
                    ];
                }
                if (this.isProgram() && !x(t)) {
                    throw new Error("You can only replace a Program root node with another Program node");
                }
                if (Array.isArray(t)) {
                    throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
                }
                if (typeof t === "string") {
                    throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
                }
                let r = "";
                if (this.isNodeType("Statement") && v(t)) {
                    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t) && !this.parentPath.isExportDefaultDeclaration()) {
                        t = g(t);
                        r = "expression";
                    }
                }
                if (this.isNodeType("Expression") && P(t)) {
                    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t)) {
                        return this.replaceExpressionWithStatements([
                            t
                        ]);
                    }
                }
                const n = this.node;
                if (n) {
                    E(t, n);
                    w(n);
                }
                this._replaceWith(t);
                this.type = t.type;
                this.setScope();
                this.requeue();
                return [
                    r ? this.get(r) : this
                ];
            }
            function _replaceWith(e1) {
                var t;
                if (!this.container) {
                    throw new ReferenceError("Container is falsy");
                }
                if (this.inList) {
                    I(this.parent, this.key, [
                        e1
                    ]);
                } else {
                    I(this.parent, this.key, e1);
                }
                this.debug(`Replace with ${e1 == null ? void 0 : e1.type}`);
                (t = a.path.get(this.parent)) == null ? void 0 : t.set(e1, this).delete(this.node);
                this.node = this.container[this.key] = e1;
            }
            function replaceExpressionWithStatements(e1) {
                this.resync();
                const t = C(e1, this.scope);
                if (t) {
                    return this.replaceWith(t)[0].get("expressions");
                }
                const r = this.getFunctionParent();
                const n = r == null ? void 0 : r.is("async");
                const i = r == null ? void 0 : r.is("generator");
                const a = p([], h(e1));
                this.replaceWith(m(a, []));
                const o = this.get("callee");
                (0, c.default)(o.get("body"), (e1)=>{
                    this.scope.push({
                        id: e1
                    });
                }, "var");
                const l = this.get("callee").getCompletionRecords();
                for (const e1 of l){
                    if (!e1.isExpressionStatement()) continue;
                    const t = e1.findParent((e1)=>e1.isLoop());
                    if (t) {
                        let r = t.getData("expressionReplacementReturnUid");
                        if (!r) {
                            r = o.scope.generateDeclaredUidIdentifier("ret");
                            o.get("body").pushContainer("body", A(y(r)));
                            t.setData("expressionReplacementReturnUid", r);
                        } else {
                            r = b(r.name);
                        }
                        e1.get("expression").replaceWith(f("=", y(r), e1.node.expression));
                    } else {
                        e1.replaceWith(A(e1.node.expression));
                    }
                }
                o.arrowFunctionToExpression();
                const g = o;
                const T = n && s.default.hasType(this.get("callee.body").node, "AwaitExpression", u);
                const S = i && s.default.hasType(this.get("callee.body").node, "YieldExpression", u);
                if (T) {
                    g.set("async", true);
                    if (!S) {
                        this.replaceWith(d(this.node));
                    }
                }
                if (S) {
                    g.set("generator", true);
                    this.replaceWith(O(this.node, true));
                }
                return g.get("body.body");
            }
            function replaceInline(e1) {
                this.resync();
                if (Array.isArray(e1)) {
                    if (Array.isArray(this.container)) {
                        e1 = this._verifyNodeList(e1);
                        const t = this._containerInsertAfter(e1);
                        this.remove();
                        return t;
                    } else {
                        return this.replaceWithMultiple(e1);
                    }
                } else {
                    return this.replaceWith(e1);
                }
            }
        },
        9307: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            class Binding {
                constructor({ identifier: e1, scope: t, path: r, kind: n }){
                    this.identifier = void 0;
                    this.scope = void 0;
                    this.path = void 0;
                    this.kind = void 0;
                    this.constantViolations = [];
                    this.constant = true;
                    this.referencePaths = [];
                    this.referenced = false;
                    this.references = 0;
                    this.identifier = e1;
                    this.scope = t;
                    this.path = r;
                    this.kind = n;
                    if ((n === "var" || n === "hoisted") && isDeclaredInLoop(r || (()=>{
                        throw new Error("Internal Babel error: unreachable ");
                    })())) {
                        this.reassign(r);
                    }
                    this.clearValue();
                }
                deoptValue() {
                    this.clearValue();
                    this.hasDeoptedValue = true;
                }
                setValue(e1) {
                    if (this.hasDeoptedValue) return;
                    this.hasValue = true;
                    this.value = e1;
                }
                clearValue() {
                    this.hasDeoptedValue = false;
                    this.hasValue = false;
                    this.value = null;
                }
                reassign(e1) {
                    this.constant = false;
                    if (this.constantViolations.indexOf(e1) !== -1) {
                        return;
                    }
                    this.constantViolations.push(e1);
                }
                reference(e1) {
                    if (this.referencePaths.indexOf(e1) !== -1) {
                        return;
                    }
                    this.referenced = true;
                    this.references++;
                    this.referencePaths.push(e1);
                }
                dereference() {
                    this.references--;
                    this.referenced = !!this.references;
                }
            }
            t["default"] = Binding;
            function isDeclaredInLoop(e1) {
                for(let { parentPath: t, key: r } = e1; t; { parentPath: t, key: r } = t){
                    if (t.isFunctionParent()) return false;
                    if (t.isWhile() || t.isForXStatement() || t.isForStatement() && r === "body") {
                        return true;
                    }
                }
                return false;
            }
        },
        9632: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(5391);
            var s = r(2297);
            var i = r(9307);
            var a = r(6929);
            var o = r(776);
            var l = r(6419);
            var c = r(5399);
            const { NOT_LOCAL_BINDING: u, callExpression: p, cloneNode: f, getBindingIdentifiers: d, identifier: h, isArrayExpression: m, isBinary: y, isClass: g, isClassBody: b, isClassDeclaration: T, isExportAllDeclaration: S, isExportDefaultDeclaration: E, isExportNamedDeclaration: v, isFunctionDeclaration: x, isIdentifier: P, isImportDeclaration: w, isLiteral: A, isMethod: C, isModuleSpecifier: I, isNullLiteral: O, isObjectExpression: k, isProperty: N, isPureish: _, isRegExpLiteral: D, isSuper: M, isTaggedTemplateExpression: L, isTemplateLiteral: j, isThisExpression: F, isUnaryExpression: R, isVariableDeclaration: B, matchesPattern: U, memberExpression: K, numericLiteral: V, toIdentifier: W, unaryExpression: $, variableDeclaration: q, variableDeclarator: H, isRecordExpression: G, isTupleExpression: J, isObjectProperty: X, isTopicReference: z, isMetaProperty: Y, isPrivateName: Q, isExportDeclaration: Z } = o;
            function gatherNodeParts(e1, t) {
                switch(e1 == null ? void 0 : e1.type){
                    default:
                        if (w(e1) || Z(e1)) {
                            if ((S(e1) || v(e1) || w(e1)) && e1.source) {
                                gatherNodeParts(e1.source, t);
                            } else if ((v(e1) || w(e1)) && e1.specifiers && e1.specifiers.length) {
                                for (const r of e1.specifiers)gatherNodeParts(r, t);
                            } else if ((E(e1) || v(e1)) && e1.declaration) {
                                gatherNodeParts(e1.declaration, t);
                            }
                        } else if (I(e1)) {
                            gatherNodeParts(e1.local, t);
                        } else if (A(e1) && !O(e1) && !D(e1) && !j(e1)) {
                            t.push(e1.value);
                        }
                        break;
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                    case "JSXMemberExpression":
                        gatherNodeParts(e1.object, t);
                        gatherNodeParts(e1.property, t);
                        break;
                    case "Identifier":
                    case "JSXIdentifier":
                        t.push(e1.name);
                        break;
                    case "CallExpression":
                    case "OptionalCallExpression":
                    case "NewExpression":
                        gatherNodeParts(e1.callee, t);
                        break;
                    case "ObjectExpression":
                    case "ObjectPattern":
                        for (const r of e1.properties){
                            gatherNodeParts(r, t);
                        }
                        break;
                    case "SpreadElement":
                    case "RestElement":
                        gatherNodeParts(e1.argument, t);
                        break;
                    case "ObjectProperty":
                    case "ObjectMethod":
                    case "ClassProperty":
                    case "ClassMethod":
                    case "ClassPrivateProperty":
                    case "ClassPrivateMethod":
                        gatherNodeParts(e1.key, t);
                        break;
                    case "ThisExpression":
                        t.push("this");
                        break;
                    case "Super":
                        t.push("super");
                        break;
                    case "Import":
                        t.push("import");
                        break;
                    case "DoExpression":
                        t.push("do");
                        break;
                    case "YieldExpression":
                        t.push("yield");
                        gatherNodeParts(e1.argument, t);
                        break;
                    case "AwaitExpression":
                        t.push("await");
                        gatherNodeParts(e1.argument, t);
                        break;
                    case "AssignmentExpression":
                        gatherNodeParts(e1.left, t);
                        break;
                    case "VariableDeclarator":
                        gatherNodeParts(e1.id, t);
                        break;
                    case "FunctionExpression":
                    case "FunctionDeclaration":
                    case "ClassExpression":
                    case "ClassDeclaration":
                        gatherNodeParts(e1.id, t);
                        break;
                    case "PrivateName":
                        gatherNodeParts(e1.id, t);
                        break;
                    case "ParenthesizedExpression":
                        gatherNodeParts(e1.expression, t);
                        break;
                    case "UnaryExpression":
                    case "UpdateExpression":
                        gatherNodeParts(e1.argument, t);
                        break;
                    case "MetaProperty":
                        gatherNodeParts(e1.meta, t);
                        gatherNodeParts(e1.property, t);
                        break;
                    case "JSXElement":
                        gatherNodeParts(e1.openingElement, t);
                        break;
                    case "JSXOpeningElement":
                        gatherNodeParts(e1.name, t);
                        break;
                    case "JSXFragment":
                        gatherNodeParts(e1.openingFragment, t);
                        break;
                    case "JSXOpeningFragment":
                        t.push("Fragment");
                        break;
                    case "JSXNamespacedName":
                        gatherNodeParts(e1.namespace, t);
                        gatherNodeParts(e1.name, t);
                        break;
                }
            }
            const ee = {
                ForStatement (e1) {
                    const t = e1.get("init");
                    if (t.isVar()) {
                        const { scope: r } = e1;
                        const n = r.getFunctionParent() || r.getProgramParent();
                        n.registerBinding("var", t);
                    }
                },
                Declaration (e1) {
                    if (e1.isBlockScoped()) return;
                    if (e1.isImportDeclaration()) return;
                    if (e1.isExportDeclaration()) return;
                    const t = e1.scope.getFunctionParent() || e1.scope.getProgramParent();
                    t.registerDeclaration(e1);
                },
                ImportDeclaration (e1) {
                    const t = e1.scope.getBlockParent();
                    t.registerDeclaration(e1);
                },
                ReferencedIdentifier (e1, t) {
                    t.references.push(e1);
                },
                ForXStatement (e1, t) {
                    const r = e1.get("left");
                    if (r.isPattern() || r.isIdentifier()) {
                        t.constantViolations.push(e1);
                    } else if (r.isVar()) {
                        const { scope: t } = e1;
                        const n = t.getFunctionParent() || t.getProgramParent();
                        n.registerBinding("var", r);
                    }
                },
                ExportDeclaration: {
                    exit (e1) {
                        const { node: t, scope: r } = e1;
                        if (S(t)) return;
                        const n = t.declaration;
                        if (T(n) || x(n)) {
                            const t = n.id;
                            if (!t) return;
                            const s = r.getBinding(t.name);
                            s == null ? void 0 : s.reference(e1);
                        } else if (B(n)) {
                            for (const t of n.declarations){
                                for (const n of Object.keys(d(t))){
                                    const t = r.getBinding(n);
                                    t == null ? void 0 : t.reference(e1);
                                }
                            }
                        }
                    }
                },
                LabeledStatement (e1) {
                    e1.scope.getBlockParent().registerDeclaration(e1);
                },
                AssignmentExpression (e1, t) {
                    t.assignments.push(e1);
                },
                UpdateExpression (e1, t) {
                    t.constantViolations.push(e1);
                },
                UnaryExpression (e1, t) {
                    if (e1.node.operator === "delete") {
                        t.constantViolations.push(e1);
                    }
                },
                BlockScoped (e1) {
                    let t = e1.scope;
                    if (t.path === e1) t = t.parent;
                    const r = t.getBlockParent();
                    r.registerDeclaration(e1);
                    if (e1.isClassDeclaration() && e1.node.id) {
                        const t = e1.node.id;
                        const r = t.name;
                        e1.scope.bindings[r] = e1.scope.parent.getBinding(r);
                    }
                },
                CatchClause (e1) {
                    e1.scope.registerBinding("let", e1);
                },
                Function (e1) {
                    const t = e1.get("params");
                    for (const r of t){
                        e1.scope.registerBinding("param", r);
                    }
                    if (e1.isFunctionExpression() && e1.has("id") && !e1.get("id").node[u]) {
                        e1.scope.registerBinding("local", e1.get("id"), e1);
                    }
                },
                ClassExpression (e1) {
                    if (e1.has("id") && !e1.get("id").node[u]) {
                        e1.scope.registerBinding("local", e1);
                    }
                }
            };
            let te = 0;
            class Scope {
                constructor(e1){
                    this.uid = void 0;
                    this.path = void 0;
                    this.block = void 0;
                    this.labels = void 0;
                    this.inited = void 0;
                    this.bindings = void 0;
                    this.references = void 0;
                    this.globals = void 0;
                    this.uids = void 0;
                    this.data = void 0;
                    this.crawling = void 0;
                    const { node: t } = e1;
                    const r = l.scope.get(t);
                    if ((r == null ? void 0 : r.path) === e1) {
                        return r;
                    }
                    l.scope.set(t, this);
                    this.uid = te++;
                    this.block = t;
                    this.path = e1;
                    this.labels = new Map;
                    this.inited = false;
                }
                get parent() {
                    var e1;
                    let t, r = this.path;
                    do {
                        const e1 = r.key === "key" || r.listKey === "decorators";
                        r = r.parentPath;
                        if (e1 && r.isMethod()) r = r.parentPath;
                        if (r && r.isScope()) t = r;
                    }while (r && !t)
                    return (e1 = t) == null ? void 0 : e1.scope;
                }
                get parentBlock() {
                    return this.path.parent;
                }
                get hub() {
                    return this.path.hub;
                }
                traverse(e1, t, r) {
                    (0, s.default)(e1, t, this, r, this.path);
                }
                generateDeclaredUidIdentifier(e1) {
                    const t = this.generateUidIdentifier(e1);
                    this.push({
                        id: t
                    });
                    return f(t);
                }
                generateUidIdentifier(e1) {
                    return h(this.generateUid(e1));
                }
                generateUid(e1 = "temp") {
                    e1 = W(e1).replace(/^_+/, "").replace(/[0-9]+$/g, "");
                    let t;
                    let r = 1;
                    do {
                        t = this._generateUid(e1, r);
                        r++;
                    }while (this.hasLabel(t) || this.hasBinding(t) || this.hasGlobal(t) || this.hasReference(t))
                    const n = this.getProgramParent();
                    n.references[t] = true;
                    n.uids[t] = true;
                    return t;
                }
                _generateUid(e1, t) {
                    let r = e1;
                    if (t > 1) r += t;
                    return `_${r}`;
                }
                generateUidBasedOnNode(e1, t) {
                    const r = [];
                    gatherNodeParts(e1, r);
                    let n = r.join("$");
                    n = n.replace(/^_/, "") || t || "ref";
                    return this.generateUid(n.slice(0, 20));
                }
                generateUidIdentifierBasedOnNode(e1, t) {
                    return h(this.generateUidBasedOnNode(e1, t));
                }
                isStatic(e1) {
                    if (F(e1) || M(e1) || z(e1)) {
                        return true;
                    }
                    if (P(e1)) {
                        const t = this.getBinding(e1.name);
                        if (t) {
                            return t.constant;
                        } else {
                            return this.hasBinding(e1.name);
                        }
                    }
                    return false;
                }
                maybeGenerateMemoised(e1, t) {
                    if (this.isStatic(e1)) {
                        return null;
                    } else {
                        const r = this.generateUidIdentifierBasedOnNode(e1);
                        if (!t) {
                            this.push({
                                id: r
                            });
                            return f(r);
                        }
                        return r;
                    }
                }
                checkBlockScopedCollisions(e1, t, r, n) {
                    if (t === "param") return;
                    if (e1.kind === "local") return;
                    const s = t === "let" || e1.kind === "let" || e1.kind === "const" || e1.kind === "module" || e1.kind === "param" && t === "const";
                    if (s) {
                        throw this.hub.buildError(n, `Duplicate declaration "${r}"`, TypeError);
                    }
                }
                rename(e1, t) {
                    const r = this.getBinding(e1);
                    if (r) {
                        t || (t = this.generateUidIdentifier(e1).name);
                        const s = new n.default(r, e1, t);
                        {
                            s.rename(arguments[2]);
                        }
                    }
                }
                _renameFromMap(e1, t, r, n) {
                    if (e1[t]) {
                        e1[r] = n;
                        e1[t] = null;
                    }
                }
                dump() {
                    const e1 = "-".repeat(60);
                    console.log(e1);
                    let t = this;
                    do {
                        console.log("#", t.block.type);
                        for (const e1 of Object.keys(t.bindings)){
                            const r = t.bindings[e1];
                            console.log(" -", e1, {
                                constant: r.constant,
                                references: r.references,
                                violations: r.constantViolations.length,
                                kind: r.kind
                            });
                        }
                    }while (t = t.parent)
                    console.log(e1);
                }
                toArray(e1, t, r) {
                    if (P(e1)) {
                        const t = this.getBinding(e1.name);
                        if (t != null && t.constant && t.path.isGenericType("Array")) {
                            return e1;
                        }
                    }
                    if (m(e1)) {
                        return e1;
                    }
                    if (P(e1, {
                        name: "arguments"
                    })) {
                        return p(K(K(K(h("Array"), h("prototype")), h("slice")), h("call")), [
                            e1
                        ]);
                    }
                    let n;
                    const s = [
                        e1
                    ];
                    if (t === true) {
                        n = "toConsumableArray";
                    } else if (typeof t === "number") {
                        s.push(V(t));
                        n = "slicedToArray";
                    } else {
                        n = "toArray";
                    }
                    if (r) {
                        s.unshift(this.hub.addHelper(n));
                        n = "maybeArrayLike";
                    }
                    return p(this.hub.addHelper(n), s);
                }
                hasLabel(e1) {
                    return !!this.getLabel(e1);
                }
                getLabel(e1) {
                    return this.labels.get(e1);
                }
                registerLabel(e1) {
                    this.labels.set(e1.node.label.name, e1);
                }
                registerDeclaration(e1) {
                    if (e1.isLabeledStatement()) {
                        this.registerLabel(e1);
                    } else if (e1.isFunctionDeclaration()) {
                        this.registerBinding("hoisted", e1.get("id"), e1);
                    } else if (e1.isVariableDeclaration()) {
                        const t = e1.get("declarations");
                        const { kind: r } = e1.node;
                        for (const e1 of t){
                            this.registerBinding(r === "using" || r === "await using" ? "const" : r, e1);
                        }
                    } else if (e1.isClassDeclaration()) {
                        if (e1.node.declare) return;
                        this.registerBinding("let", e1);
                    } else if (e1.isImportDeclaration()) {
                        const t = e1.node.importKind === "type" || e1.node.importKind === "typeof";
                        const r = e1.get("specifiers");
                        for (const e1 of r){
                            const r = t || e1.isImportSpecifier() && (e1.node.importKind === "type" || e1.node.importKind === "typeof");
                            this.registerBinding(r ? "unknown" : "module", e1);
                        }
                    } else if (e1.isExportDeclaration()) {
                        const t = e1.get("declaration");
                        if (t.isClassDeclaration() || t.isFunctionDeclaration() || t.isVariableDeclaration()) {
                            this.registerDeclaration(t);
                        }
                    } else {
                        this.registerBinding("unknown", e1);
                    }
                }
                buildUndefinedNode() {
                    return $("void", V(0), true);
                }
                registerConstantViolation(e1) {
                    const t = e1.getBindingIdentifiers();
                    for (const r of Object.keys(t)){
                        const t = this.getBinding(r);
                        if (t) t.reassign(e1);
                    }
                }
                registerBinding(e1, t, r = t) {
                    if (!e1) throw new ReferenceError("no `kind`");
                    if (t.isVariableDeclaration()) {
                        const r = t.get("declarations");
                        for (const t of r){
                            this.registerBinding(e1, t);
                        }
                        return;
                    }
                    const n = this.getProgramParent();
                    const s = t.getOuterBindingIdentifiers(true);
                    for (const t of Object.keys(s)){
                        n.references[t] = true;
                        for (const n of s[t]){
                            const s = this.getOwnBinding(t);
                            if (s) {
                                if (s.identifier === n) continue;
                                this.checkBlockScopedCollisions(s, e1, t, n);
                            }
                            if (s) {
                                this.registerConstantViolation(r);
                            } else {
                                this.bindings[t] = new i.default({
                                    identifier: n,
                                    scope: this,
                                    path: r,
                                    kind: e1
                                });
                            }
                        }
                    }
                }
                addGlobal(e1) {
                    this.globals[e1.name] = e1;
                }
                hasUid(e1) {
                    let t = this;
                    do {
                        if (t.uids[e1]) return true;
                    }while (t = t.parent)
                    return false;
                }
                hasGlobal(e1) {
                    let t = this;
                    do {
                        if (t.globals[e1]) return true;
                    }while (t = t.parent)
                    return false;
                }
                hasReference(e1) {
                    return !!this.getProgramParent().references[e1];
                }
                isPure(e1, t) {
                    if (P(e1)) {
                        const r = this.getBinding(e1.name);
                        if (!r) return false;
                        if (t) return r.constant;
                        return true;
                    } else if (F(e1) || Y(e1) || z(e1) || Q(e1)) {
                        return true;
                    } else if (g(e1)) {
                        var r;
                        if (e1.superClass && !this.isPure(e1.superClass, t)) {
                            return false;
                        }
                        if (((r = e1.decorators) == null ? void 0 : r.length) > 0) {
                            return false;
                        }
                        return this.isPure(e1.body, t);
                    } else if (b(e1)) {
                        for (const r of e1.body){
                            if (!this.isPure(r, t)) return false;
                        }
                        return true;
                    } else if (y(e1)) {
                        return this.isPure(e1.left, t) && this.isPure(e1.right, t);
                    } else if (m(e1) || J(e1)) {
                        for (const r of e1.elements){
                            if (r !== null && !this.isPure(r, t)) return false;
                        }
                        return true;
                    } else if (k(e1) || G(e1)) {
                        for (const r of e1.properties){
                            if (!this.isPure(r, t)) return false;
                        }
                        return true;
                    } else if (C(e1)) {
                        var n;
                        if (e1.computed && !this.isPure(e1.key, t)) return false;
                        if (((n = e1.decorators) == null ? void 0 : n.length) > 0) {
                            return false;
                        }
                        return true;
                    } else if (N(e1)) {
                        var s;
                        if (e1.computed && !this.isPure(e1.key, t)) return false;
                        if (((s = e1.decorators) == null ? void 0 : s.length) > 0) {
                            return false;
                        }
                        if (X(e1) || e1.static) {
                            if (e1.value !== null && !this.isPure(e1.value, t)) {
                                return false;
                            }
                        }
                        return true;
                    } else if (R(e1)) {
                        return this.isPure(e1.argument, t);
                    } else if (L(e1)) {
                        return U(e1.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(e1.quasi, t);
                    } else if (j(e1)) {
                        for (const r of e1.expressions){
                            if (!this.isPure(r, t)) return false;
                        }
                        return true;
                    } else {
                        return _(e1);
                    }
                }
                setData(e1, t) {
                    return this.data[e1] = t;
                }
                getData(e1) {
                    let t = this;
                    do {
                        const r = t.data[e1];
                        if (r != null) return r;
                    }while (t = t.parent)
                }
                removeData(e1) {
                    let t = this;
                    do {
                        const r = t.data[e1];
                        if (r != null) t.data[e1] = null;
                    }while (t = t.parent)
                }
                init() {
                    if (!this.inited) {
                        this.inited = true;
                        this.crawl();
                    }
                }
                crawl() {
                    const e1 = this.path;
                    this.references = Object.create(null);
                    this.bindings = Object.create(null);
                    this.globals = Object.create(null);
                    this.uids = Object.create(null);
                    this.data = Object.create(null);
                    const t = this.getProgramParent();
                    if (t.crawling) return;
                    const r = {
                        references: [],
                        constantViolations: [],
                        assignments: []
                    };
                    this.crawling = true;
                    if (e1.type !== "Program" && (0, c.isExplodedVisitor)(ee)) {
                        for (const t of ee.enter){
                            t.call(r, e1, r);
                        }
                        const t = ee[e1.type];
                        if (t) {
                            for (const n of t.enter){
                                n.call(r, e1, r);
                            }
                        }
                    }
                    e1.traverse(ee, r);
                    this.crawling = false;
                    for (const e1 of r.assignments){
                        const r = e1.getBindingIdentifiers();
                        for (const n of Object.keys(r)){
                            if (e1.scope.getBinding(n)) continue;
                            t.addGlobal(r[n]);
                        }
                        e1.scope.registerConstantViolation(e1);
                    }
                    for (const e1 of r.references){
                        const r = e1.scope.getBinding(e1.node.name);
                        if (r) {
                            r.reference(e1);
                        } else {
                            t.addGlobal(e1.node);
                        }
                    }
                    for (const e1 of r.constantViolations){
                        e1.scope.registerConstantViolation(e1);
                    }
                }
                push(e1) {
                    let t = this.path;
                    if (t.isPattern()) {
                        t = this.getPatternParent().path;
                    } else if (!t.isBlockStatement() && !t.isProgram()) {
                        t = this.getBlockParent().path;
                    }
                    if (t.isSwitchStatement()) {
                        t = (this.getFunctionParent() || this.getProgramParent()).path;
                    }
                    if (t.isLoop() || t.isCatchClause() || t.isFunction()) {
                        t.ensureBlock();
                        t = t.get("body");
                    }
                    const r = e1.unique;
                    const n = e1.kind || "var";
                    const s = e1._blockHoist == null ? 2 : e1._blockHoist;
                    const i = `declaration:${n}:${s}`;
                    let a = !r && t.getData(i);
                    if (!a) {
                        const e1 = q(n, []);
                        e1._blockHoist = s;
                        [a] = t.unshiftContainer("body", [
                            e1
                        ]);
                        if (!r) t.setData(i, a);
                    }
                    const o = H(e1.id, e1.init);
                    const l = a.node.declarations.push(o);
                    t.scope.registerBinding(n, a.get("declarations")[l - 1]);
                }
                getProgramParent() {
                    let e1 = this;
                    do {
                        if (e1.path.isProgram()) {
                            return e1;
                        }
                    }while (e1 = e1.parent)
                    throw new Error("Couldn't find a Program");
                }
                getFunctionParent() {
                    let e1 = this;
                    do {
                        if (e1.path.isFunctionParent()) {
                            return e1;
                        }
                    }while (e1 = e1.parent)
                    return null;
                }
                getBlockParent() {
                    let e1 = this;
                    do {
                        if (e1.path.isBlockParent()) {
                            return e1;
                        }
                    }while (e1 = e1.parent)
                    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
                }
                getPatternParent() {
                    let e1 = this;
                    do {
                        if (!e1.path.isPattern()) {
                            return e1.getBlockParent();
                        }
                    }while (e1 = e1.parent.parent)
                    throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
                }
                getAllBindings() {
                    const e1 = Object.create(null);
                    let t = this;
                    do {
                        for (const r of Object.keys(t.bindings)){
                            if (r in e1 === false) {
                                e1[r] = t.bindings[r];
                            }
                        }
                        t = t.parent;
                    }while (t)
                    return e1;
                }
                getAllBindingsOfKind(...e1) {
                    const t = Object.create(null);
                    for (const r of e1){
                        let e1 = this;
                        do {
                            for (const n of Object.keys(e1.bindings)){
                                const s = e1.bindings[n];
                                if (s.kind === r) t[n] = s;
                            }
                            e1 = e1.parent;
                        }while (e1)
                    }
                    return t;
                }
                bindingIdentifierEquals(e1, t) {
                    return this.getBindingIdentifier(e1) === t;
                }
                getBinding(e1) {
                    let t = this;
                    let r;
                    do {
                        const s = t.getOwnBinding(e1);
                        if (s) {
                            var n;
                            if ((n = r) != null && n.isPattern() && s.kind !== "param" && s.kind !== "local") {} else {
                                return s;
                            }
                        } else if (!s && e1 === "arguments" && t.path.isFunction() && !t.path.isArrowFunctionExpression()) {
                            break;
                        }
                        r = t.path;
                    }while (t = t.parent)
                }
                getOwnBinding(e1) {
                    return this.bindings[e1];
                }
                getBindingIdentifier(e1) {
                    var t;
                    return (t = this.getBinding(e1)) == null ? void 0 : t.identifier;
                }
                getOwnBindingIdentifier(e1) {
                    const t = this.bindings[e1];
                    return t == null ? void 0 : t.identifier;
                }
                hasOwnBinding(e1) {
                    return !!this.getOwnBinding(e1);
                }
                hasBinding(e1, t) {
                    var r, n, s;
                    if (!e1) return false;
                    if (this.hasOwnBinding(e1)) return true;
                    {
                        if (typeof t === "boolean") t = {
                            noGlobals: t
                        };
                    }
                    if (this.parentHasBinding(e1, t)) return true;
                    if (!((r = t) != null && r.noUids) && this.hasUid(e1)) return true;
                    if (!((n = t) != null && n.noGlobals) && Scope.globals.includes(e1)) return true;
                    if (!((s = t) != null && s.noGlobals) && Scope.contextVariables.includes(e1)) return true;
                    return false;
                }
                parentHasBinding(e1, t) {
                    var r;
                    return (r = this.parent) == null ? void 0 : r.hasBinding(e1, t);
                }
                moveBindingTo(e1, t) {
                    const r = this.getBinding(e1);
                    if (r) {
                        r.scope.removeOwnBinding(e1);
                        r.scope = t;
                        t.bindings[e1] = r;
                    }
                }
                removeOwnBinding(e1) {
                    delete this.bindings[e1];
                }
                removeBinding(e1) {
                    var t;
                    (t = this.getBinding(e1)) == null ? void 0 : t.scope.removeOwnBinding(e1);
                    let r = this;
                    do {
                        if (r.uids[e1]) {
                            r.uids[e1] = false;
                        }
                    }while (r = r.parent)
                }
            }
            t["default"] = Scope;
            Scope.globals = Object.keys(a.builtin);
            Scope.contextVariables = [
                "arguments",
                "undefined",
                "Infinity",
                "NaN"
            ];
        },
        5391: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(4097);
            var s = r(776);
            var i = r(8552);
            var a = r(81);
            var o = r(5399);
            const l = {
                ReferencedIdentifier ({ node: e1 }, t) {
                    if (e1.name === t.oldName) {
                        e1.name = t.newName;
                    }
                },
                Scope (e1, t) {
                    if (!e1.scope.bindingIdentifierEquals(t.oldName, t.binding.identifier)) {
                        e1.skip();
                        if (e1.isMethod()) {
                            (0, i.requeueComputedKeyAndDecorators)(e1);
                        }
                    }
                },
                ObjectProperty ({ node: e1, scope: t }, r) {
                    const { name: n } = e1.key;
                    if (e1.shorthand && (n === r.oldName || n === r.newName) && t.getBindingIdentifier(n) === r.binding.identifier) {
                        var s;
                        e1.shorthand = false;
                        if ((s = e1.extra) != null && s.shorthand) e1.extra.shorthand = false;
                    }
                },
                "AssignmentExpression|Declaration|VariableDeclarator" (e1, t) {
                    if (e1.isVariableDeclaration()) return;
                    const r = e1.getOuterBindingIdentifiers();
                    for(const e1 in r){
                        if (e1 === t.oldName) r[e1].name = t.newName;
                    }
                }
            };
            class Renamer {
                constructor(e1, t, r){
                    this.newName = r;
                    this.oldName = t;
                    this.binding = e1;
                }
                maybeConvertFromExportDeclaration(e1) {
                    const t = e1.parentPath;
                    if (!t.isExportDeclaration()) {
                        return;
                    }
                    if (t.isExportDefaultDeclaration()) {
                        const { declaration: e1 } = t.node;
                        if (s.isDeclaration(e1) && !e1.id) {
                            return;
                        }
                    }
                    if (t.isExportAllDeclaration()) {
                        return;
                    }
                    (0, n.default)(t);
                }
                maybeConvertFromClassFunctionDeclaration(e1) {
                    return e1;
                }
                maybeConvertFromClassFunctionExpression(e1) {
                    return e1;
                }
                rename() {
                    const { binding: e1, oldName: t, newName: r } = this;
                    const { scope: n, path: s } = e1;
                    const i = s.find((e1)=>e1.isDeclaration() || e1.isFunctionExpression() || e1.isClassExpression());
                    if (i) {
                        const r = i.getOuterBindingIdentifiers();
                        if (r[t] === e1.identifier) {
                            this.maybeConvertFromExportDeclaration(i);
                        }
                    }
                    const c = arguments[0] || n.block;
                    (0, a.traverseNode)(c, (0, o.explode)(l), n, this, n.path, {
                        discriminant: true
                    });
                    if (!arguments[0]) {
                        n.removeOwnBinding(t);
                        n.bindings[r] = e1;
                        this.binding.identifier.name = r;
                    }
                    if (i) {
                        this.maybeConvertFromClassFunctionDeclaration(s);
                        this.maybeConvertFromClassFunctionExpression(s);
                    }
                }
            }
            t["default"] = Renamer;
        },
        81: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.traverseNode = traverseNode;
            var n = r(6983);
            var s = r(776);
            const { VISITOR_KEYS: i } = s;
            function traverseNode(e1, t, r, s, a, o) {
                const l = i[e1.type];
                if (!l) return false;
                const c = new n.default(r, t, s, a);
                for (const t of l){
                    if (o && o[t]) continue;
                    if (c.visit(e1, t)) {
                        return true;
                    }
                }
                return false;
            }
        },
        5399: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.explode = explode;
            t.isExplodedVisitor = isExplodedVisitor;
            t.merge = merge;
            t.verify = verify;
            var n = r(8958);
            var s = r(776);
            const { DEPRECATED_KEYS: i, DEPRECATED_ALIASES: a, FLIPPED_ALIAS_KEYS: o, TYPES: l, __internal__deprecationWarning: c } = s;
            function isVirtualType(e1) {
                return e1 in n;
            }
            function isExplodedVisitor(e1) {
                return e1 == null ? void 0 : e1._exploded;
            }
            function explode(e1) {
                if (isExplodedVisitor(e1)) return e1;
                e1._exploded = true;
                for (const t of Object.keys(e1)){
                    if (shouldIgnoreKey(t)) continue;
                    const r = t.split("|");
                    if (r.length === 1) continue;
                    const n = e1[t];
                    delete e1[t];
                    for (const t of r){
                        e1[t] = n;
                    }
                }
                verify(e1);
                delete e1.__esModule;
                ensureEntranceObjects(e1);
                ensureCallbackArrays(e1);
                for (const t of Object.keys(e1)){
                    if (shouldIgnoreKey(t)) continue;
                    if (!isVirtualType(t)) continue;
                    const r = e1[t];
                    for (const e1 of Object.keys(r)){
                        r[e1] = wrapCheck(t, r[e1]);
                    }
                    delete e1[t];
                    const s = n[t];
                    if (s !== null) {
                        for (const t of s){
                            if (e1[t]) {
                                mergePair(e1[t], r);
                            } else {
                                e1[t] = r;
                            }
                        }
                    } else {
                        mergePair(e1, r);
                    }
                }
                for (const t of Object.keys(e1)){
                    if (shouldIgnoreKey(t)) continue;
                    let r = o[t];
                    if (t in i) {
                        const e1 = i[t];
                        c(t, e1, "Visitor ");
                        r = [
                            e1
                        ];
                    } else if (t in a) {
                        const e1 = a[t];
                        c(t, e1, "Visitor ");
                        r = o[e1];
                    }
                    if (!r) continue;
                    const n = e1[t];
                    delete e1[t];
                    for (const t of r){
                        const r = e1[t];
                        if (r) {
                            mergePair(r, n);
                        } else {
                            e1[t] = Object.assign({}, n);
                        }
                    }
                }
                for (const t of Object.keys(e1)){
                    if (shouldIgnoreKey(t)) continue;
                    ensureCallbackArrays(e1[t]);
                }
                return e1;
            }
            function verify(e1) {
                if (e1._verified) return;
                if (typeof e1 === "function") {
                    throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
                }
                for (const t of Object.keys(e1)){
                    if (t === "enter" || t === "exit") {
                        validateVisitorMethods(t, e1[t]);
                    }
                    if (shouldIgnoreKey(t)) continue;
                    if (l.indexOf(t) < 0) {
                        throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type`);
                    }
                    const r = e1[t];
                    if (typeof r === "object") {
                        for (const e1 of Object.keys(r)){
                            if (e1 === "enter" || e1 === "exit") {
                                validateVisitorMethods(`${t}.${e1}`, r[e1]);
                            } else {
                                throw new Error("You passed `traverse()` a visitor object with the property " + `${t} that has the invalid property ${e1}`);
                            }
                        }
                    }
                }
                e1._verified = true;
            }
            function validateVisitorMethods(e1, t) {
                const r = [].concat(t);
                for (const t of r){
                    if (typeof t !== "function") {
                        throw new TypeError(`Non-function found defined in ${e1} with type ${typeof t}`);
                    }
                }
            }
            function merge(e1, t = [], r) {
                const n = {};
                for(let s = 0; s < e1.length; s++){
                    const i = e1[s];
                    const a = t[s];
                    explode(i);
                    for (const e1 of Object.keys(i)){
                        let t = i[e1];
                        if (a || r) {
                            t = wrapWithStateOrWrapper(t, a, r);
                        }
                        const s = n[e1] || (n[e1] = {});
                        mergePair(s, t);
                    }
                }
                return n;
            }
            function wrapWithStateOrWrapper(e1, t, r) {
                const n = {};
                for (const s of Object.keys(e1)){
                    let i = e1[s];
                    if (!Array.isArray(i)) continue;
                    i = i.map(function(e1) {
                        let n = e1;
                        if (t) {
                            n = function(r) {
                                e1.call(t, r, t);
                            };
                        }
                        if (r) {
                            n = r(t.key, s, n);
                        }
                        if (n !== e1) {
                            n.toString = ()=>e1.toString();
                        }
                        return n;
                    });
                    n[s] = i;
                }
                return n;
            }
            function ensureEntranceObjects(e1) {
                for (const t of Object.keys(e1)){
                    if (shouldIgnoreKey(t)) continue;
                    const r = e1[t];
                    if (typeof r === "function") {
                        e1[t] = {
                            enter: r
                        };
                    }
                }
            }
            function ensureCallbackArrays(e1) {
                if (e1.enter && !Array.isArray(e1.enter)) e1.enter = [
                    e1.enter
                ];
                if (e1.exit && !Array.isArray(e1.exit)) e1.exit = [
                    e1.exit
                ];
            }
            function wrapCheck(e1, t) {
                const newFn = function(r) {
                    if (r[`is${e1}`]()) {
                        return t.apply(this, arguments);
                    }
                };
                newFn.toString = ()=>t.toString();
                return newFn;
            }
            function shouldIgnoreKey(e1) {
                if (e1[0] === "_") return true;
                if (e1 === "enter" || e1 === "exit" || e1 === "shouldSkip") return true;
                if (e1 === "denylist" || e1 === "noScope" || e1 === "skipKeys") {
                    return true;
                }
                {
                    if (e1 === "blacklist") {
                        return true;
                    }
                }
                return false;
            }
            function mergePair(e1, t) {
                for (const r of Object.keys(t)){
                    e1[r] = [].concat(e1[r] || [], t[r]);
                }
            }
        },
        6958: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = assertNode;
            var n = r(4955);
            function assertNode(e1) {
                if (!(0, n.default)(e1)) {
                    var t;
                    const r = (t = e1 == null ? void 0 : e1.type) != null ? t : JSON.stringify(e1);
                    throw new TypeError(`Not a valid node of type "${r}"`);
                }
            }
        },
        9174: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.assertAccessor = assertAccessor;
            t.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
            t.assertArgumentPlaceholder = assertArgumentPlaceholder;
            t.assertArrayExpression = assertArrayExpression;
            t.assertArrayPattern = assertArrayPattern;
            t.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
            t.assertArrowFunctionExpression = assertArrowFunctionExpression;
            t.assertAssignmentExpression = assertAssignmentExpression;
            t.assertAssignmentPattern = assertAssignmentPattern;
            t.assertAwaitExpression = assertAwaitExpression;
            t.assertBigIntLiteral = assertBigIntLiteral;
            t.assertBinary = assertBinary;
            t.assertBinaryExpression = assertBinaryExpression;
            t.assertBindExpression = assertBindExpression;
            t.assertBlock = assertBlock;
            t.assertBlockParent = assertBlockParent;
            t.assertBlockStatement = assertBlockStatement;
            t.assertBooleanLiteral = assertBooleanLiteral;
            t.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
            t.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
            t.assertBreakStatement = assertBreakStatement;
            t.assertCallExpression = assertCallExpression;
            t.assertCatchClause = assertCatchClause;
            t.assertClass = assertClass;
            t.assertClassAccessorProperty = assertClassAccessorProperty;
            t.assertClassBody = assertClassBody;
            t.assertClassDeclaration = assertClassDeclaration;
            t.assertClassExpression = assertClassExpression;
            t.assertClassImplements = assertClassImplements;
            t.assertClassMethod = assertClassMethod;
            t.assertClassPrivateMethod = assertClassPrivateMethod;
            t.assertClassPrivateProperty = assertClassPrivateProperty;
            t.assertClassProperty = assertClassProperty;
            t.assertCompletionStatement = assertCompletionStatement;
            t.assertConditional = assertConditional;
            t.assertConditionalExpression = assertConditionalExpression;
            t.assertContinueStatement = assertContinueStatement;
            t.assertDebuggerStatement = assertDebuggerStatement;
            t.assertDecimalLiteral = assertDecimalLiteral;
            t.assertDeclaration = assertDeclaration;
            t.assertDeclareClass = assertDeclareClass;
            t.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
            t.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
            t.assertDeclareFunction = assertDeclareFunction;
            t.assertDeclareInterface = assertDeclareInterface;
            t.assertDeclareModule = assertDeclareModule;
            t.assertDeclareModuleExports = assertDeclareModuleExports;
            t.assertDeclareOpaqueType = assertDeclareOpaqueType;
            t.assertDeclareTypeAlias = assertDeclareTypeAlias;
            t.assertDeclareVariable = assertDeclareVariable;
            t.assertDeclaredPredicate = assertDeclaredPredicate;
            t.assertDecorator = assertDecorator;
            t.assertDirective = assertDirective;
            t.assertDirectiveLiteral = assertDirectiveLiteral;
            t.assertDoExpression = assertDoExpression;
            t.assertDoWhileStatement = assertDoWhileStatement;
            t.assertEmptyStatement = assertEmptyStatement;
            t.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
            t.assertEnumBody = assertEnumBody;
            t.assertEnumBooleanBody = assertEnumBooleanBody;
            t.assertEnumBooleanMember = assertEnumBooleanMember;
            t.assertEnumDeclaration = assertEnumDeclaration;
            t.assertEnumDefaultedMember = assertEnumDefaultedMember;
            t.assertEnumMember = assertEnumMember;
            t.assertEnumNumberBody = assertEnumNumberBody;
            t.assertEnumNumberMember = assertEnumNumberMember;
            t.assertEnumStringBody = assertEnumStringBody;
            t.assertEnumStringMember = assertEnumStringMember;
            t.assertEnumSymbolBody = assertEnumSymbolBody;
            t.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
            t.assertExportAllDeclaration = assertExportAllDeclaration;
            t.assertExportDeclaration = assertExportDeclaration;
            t.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
            t.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
            t.assertExportNamedDeclaration = assertExportNamedDeclaration;
            t.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
            t.assertExportSpecifier = assertExportSpecifier;
            t.assertExpression = assertExpression;
            t.assertExpressionStatement = assertExpressionStatement;
            t.assertExpressionWrapper = assertExpressionWrapper;
            t.assertFile = assertFile;
            t.assertFlow = assertFlow;
            t.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
            t.assertFlowDeclaration = assertFlowDeclaration;
            t.assertFlowPredicate = assertFlowPredicate;
            t.assertFlowType = assertFlowType;
            t.assertFor = assertFor;
            t.assertForInStatement = assertForInStatement;
            t.assertForOfStatement = assertForOfStatement;
            t.assertForStatement = assertForStatement;
            t.assertForXStatement = assertForXStatement;
            t.assertFunction = assertFunction;
            t.assertFunctionDeclaration = assertFunctionDeclaration;
            t.assertFunctionExpression = assertFunctionExpression;
            t.assertFunctionParent = assertFunctionParent;
            t.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
            t.assertFunctionTypeParam = assertFunctionTypeParam;
            t.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
            t.assertIdentifier = assertIdentifier;
            t.assertIfStatement = assertIfStatement;
            t.assertImmutable = assertImmutable;
            t.assertImport = assertImport;
            t.assertImportAttribute = assertImportAttribute;
            t.assertImportDeclaration = assertImportDeclaration;
            t.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
            t.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
            t.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
            t.assertImportSpecifier = assertImportSpecifier;
            t.assertIndexedAccessType = assertIndexedAccessType;
            t.assertInferredPredicate = assertInferredPredicate;
            t.assertInterfaceDeclaration = assertInterfaceDeclaration;
            t.assertInterfaceExtends = assertInterfaceExtends;
            t.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
            t.assertInterpreterDirective = assertInterpreterDirective;
            t.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
            t.assertJSX = assertJSX;
            t.assertJSXAttribute = assertJSXAttribute;
            t.assertJSXClosingElement = assertJSXClosingElement;
            t.assertJSXClosingFragment = assertJSXClosingFragment;
            t.assertJSXElement = assertJSXElement;
            t.assertJSXEmptyExpression = assertJSXEmptyExpression;
            t.assertJSXExpressionContainer = assertJSXExpressionContainer;
            t.assertJSXFragment = assertJSXFragment;
            t.assertJSXIdentifier = assertJSXIdentifier;
            t.assertJSXMemberExpression = assertJSXMemberExpression;
            t.assertJSXNamespacedName = assertJSXNamespacedName;
            t.assertJSXOpeningElement = assertJSXOpeningElement;
            t.assertJSXOpeningFragment = assertJSXOpeningFragment;
            t.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
            t.assertJSXSpreadChild = assertJSXSpreadChild;
            t.assertJSXText = assertJSXText;
            t.assertLVal = assertLVal;
            t.assertLabeledStatement = assertLabeledStatement;
            t.assertLiteral = assertLiteral;
            t.assertLogicalExpression = assertLogicalExpression;
            t.assertLoop = assertLoop;
            t.assertMemberExpression = assertMemberExpression;
            t.assertMetaProperty = assertMetaProperty;
            t.assertMethod = assertMethod;
            t.assertMiscellaneous = assertMiscellaneous;
            t.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
            t.assertModuleDeclaration = assertModuleDeclaration;
            t.assertModuleExpression = assertModuleExpression;
            t.assertModuleSpecifier = assertModuleSpecifier;
            t.assertNewExpression = assertNewExpression;
            t.assertNoop = assertNoop;
            t.assertNullLiteral = assertNullLiteral;
            t.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
            t.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
            t.assertNumberLiteral = assertNumberLiteral;
            t.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
            t.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
            t.assertNumericLiteral = assertNumericLiteral;
            t.assertObjectExpression = assertObjectExpression;
            t.assertObjectMember = assertObjectMember;
            t.assertObjectMethod = assertObjectMethod;
            t.assertObjectPattern = assertObjectPattern;
            t.assertObjectProperty = assertObjectProperty;
            t.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
            t.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
            t.assertObjectTypeIndexer = assertObjectTypeIndexer;
            t.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
            t.assertObjectTypeProperty = assertObjectTypeProperty;
            t.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
            t.assertOpaqueType = assertOpaqueType;
            t.assertOptionalCallExpression = assertOptionalCallExpression;
            t.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
            t.assertOptionalMemberExpression = assertOptionalMemberExpression;
            t.assertParenthesizedExpression = assertParenthesizedExpression;
            t.assertPattern = assertPattern;
            t.assertPatternLike = assertPatternLike;
            t.assertPipelineBareFunction = assertPipelineBareFunction;
            t.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
            t.assertPipelineTopicExpression = assertPipelineTopicExpression;
            t.assertPlaceholder = assertPlaceholder;
            t.assertPrivate = assertPrivate;
            t.assertPrivateName = assertPrivateName;
            t.assertProgram = assertProgram;
            t.assertProperty = assertProperty;
            t.assertPureish = assertPureish;
            t.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
            t.assertRecordExpression = assertRecordExpression;
            t.assertRegExpLiteral = assertRegExpLiteral;
            t.assertRegexLiteral = assertRegexLiteral;
            t.assertRestElement = assertRestElement;
            t.assertRestProperty = assertRestProperty;
            t.assertReturnStatement = assertReturnStatement;
            t.assertScopable = assertScopable;
            t.assertSequenceExpression = assertSequenceExpression;
            t.assertSpreadElement = assertSpreadElement;
            t.assertSpreadProperty = assertSpreadProperty;
            t.assertStandardized = assertStandardized;
            t.assertStatement = assertStatement;
            t.assertStaticBlock = assertStaticBlock;
            t.assertStringLiteral = assertStringLiteral;
            t.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
            t.assertStringTypeAnnotation = assertStringTypeAnnotation;
            t.assertSuper = assertSuper;
            t.assertSwitchCase = assertSwitchCase;
            t.assertSwitchStatement = assertSwitchStatement;
            t.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
            t.assertTSAnyKeyword = assertTSAnyKeyword;
            t.assertTSArrayType = assertTSArrayType;
            t.assertTSAsExpression = assertTSAsExpression;
            t.assertTSBaseType = assertTSBaseType;
            t.assertTSBigIntKeyword = assertTSBigIntKeyword;
            t.assertTSBooleanKeyword = assertTSBooleanKeyword;
            t.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
            t.assertTSConditionalType = assertTSConditionalType;
            t.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
            t.assertTSConstructorType = assertTSConstructorType;
            t.assertTSDeclareFunction = assertTSDeclareFunction;
            t.assertTSDeclareMethod = assertTSDeclareMethod;
            t.assertTSEntityName = assertTSEntityName;
            t.assertTSEnumDeclaration = assertTSEnumDeclaration;
            t.assertTSEnumMember = assertTSEnumMember;
            t.assertTSExportAssignment = assertTSExportAssignment;
            t.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
            t.assertTSExternalModuleReference = assertTSExternalModuleReference;
            t.assertTSFunctionType = assertTSFunctionType;
            t.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
            t.assertTSImportType = assertTSImportType;
            t.assertTSIndexSignature = assertTSIndexSignature;
            t.assertTSIndexedAccessType = assertTSIndexedAccessType;
            t.assertTSInferType = assertTSInferType;
            t.assertTSInstantiationExpression = assertTSInstantiationExpression;
            t.assertTSInterfaceBody = assertTSInterfaceBody;
            t.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
            t.assertTSIntersectionType = assertTSIntersectionType;
            t.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
            t.assertTSLiteralType = assertTSLiteralType;
            t.assertTSMappedType = assertTSMappedType;
            t.assertTSMethodSignature = assertTSMethodSignature;
            t.assertTSModuleBlock = assertTSModuleBlock;
            t.assertTSModuleDeclaration = assertTSModuleDeclaration;
            t.assertTSNamedTupleMember = assertTSNamedTupleMember;
            t.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
            t.assertTSNeverKeyword = assertTSNeverKeyword;
            t.assertTSNonNullExpression = assertTSNonNullExpression;
            t.assertTSNullKeyword = assertTSNullKeyword;
            t.assertTSNumberKeyword = assertTSNumberKeyword;
            t.assertTSObjectKeyword = assertTSObjectKeyword;
            t.assertTSOptionalType = assertTSOptionalType;
            t.assertTSParameterProperty = assertTSParameterProperty;
            t.assertTSParenthesizedType = assertTSParenthesizedType;
            t.assertTSPropertySignature = assertTSPropertySignature;
            t.assertTSQualifiedName = assertTSQualifiedName;
            t.assertTSRestType = assertTSRestType;
            t.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
            t.assertTSStringKeyword = assertTSStringKeyword;
            t.assertTSSymbolKeyword = assertTSSymbolKeyword;
            t.assertTSThisType = assertTSThisType;
            t.assertTSTupleType = assertTSTupleType;
            t.assertTSType = assertTSType;
            t.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
            t.assertTSTypeAnnotation = assertTSTypeAnnotation;
            t.assertTSTypeAssertion = assertTSTypeAssertion;
            t.assertTSTypeElement = assertTSTypeElement;
            t.assertTSTypeLiteral = assertTSTypeLiteral;
            t.assertTSTypeOperator = assertTSTypeOperator;
            t.assertTSTypeParameter = assertTSTypeParameter;
            t.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
            t.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
            t.assertTSTypePredicate = assertTSTypePredicate;
            t.assertTSTypeQuery = assertTSTypeQuery;
            t.assertTSTypeReference = assertTSTypeReference;
            t.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
            t.assertTSUnionType = assertTSUnionType;
            t.assertTSUnknownKeyword = assertTSUnknownKeyword;
            t.assertTSVoidKeyword = assertTSVoidKeyword;
            t.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
            t.assertTemplateElement = assertTemplateElement;
            t.assertTemplateLiteral = assertTemplateLiteral;
            t.assertTerminatorless = assertTerminatorless;
            t.assertThisExpression = assertThisExpression;
            t.assertThisTypeAnnotation = assertThisTypeAnnotation;
            t.assertThrowStatement = assertThrowStatement;
            t.assertTopicReference = assertTopicReference;
            t.assertTryStatement = assertTryStatement;
            t.assertTupleExpression = assertTupleExpression;
            t.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
            t.assertTypeAlias = assertTypeAlias;
            t.assertTypeAnnotation = assertTypeAnnotation;
            t.assertTypeCastExpression = assertTypeCastExpression;
            t.assertTypeParameter = assertTypeParameter;
            t.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
            t.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
            t.assertTypeScript = assertTypeScript;
            t.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
            t.assertUnaryExpression = assertUnaryExpression;
            t.assertUnaryLike = assertUnaryLike;
            t.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
            t.assertUpdateExpression = assertUpdateExpression;
            t.assertUserWhitespacable = assertUserWhitespacable;
            t.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
            t.assertVariableDeclaration = assertVariableDeclaration;
            t.assertVariableDeclarator = assertVariableDeclarator;
            t.assertVariance = assertVariance;
            t.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
            t.assertWhile = assertWhile;
            t.assertWhileStatement = assertWhileStatement;
            t.assertWithStatement = assertWithStatement;
            t.assertYieldExpression = assertYieldExpression;
            var n = r(9247);
            var s = r(4585);
            function assert(e1, t, r) {
                if (!(0, n.default)(e1, t, r)) {
                    throw new Error(`Expected type "${e1}" with option ${JSON.stringify(r)}, ` + `but instead got "${t.type}".`);
                }
            }
            function assertArrayExpression(e1, t) {
                assert("ArrayExpression", e1, t);
            }
            function assertAssignmentExpression(e1, t) {
                assert("AssignmentExpression", e1, t);
            }
            function assertBinaryExpression(e1, t) {
                assert("BinaryExpression", e1, t);
            }
            function assertInterpreterDirective(e1, t) {
                assert("InterpreterDirective", e1, t);
            }
            function assertDirective(e1, t) {
                assert("Directive", e1, t);
            }
            function assertDirectiveLiteral(e1, t) {
                assert("DirectiveLiteral", e1, t);
            }
            function assertBlockStatement(e1, t) {
                assert("BlockStatement", e1, t);
            }
            function assertBreakStatement(e1, t) {
                assert("BreakStatement", e1, t);
            }
            function assertCallExpression(e1, t) {
                assert("CallExpression", e1, t);
            }
            function assertCatchClause(e1, t) {
                assert("CatchClause", e1, t);
            }
            function assertConditionalExpression(e1, t) {
                assert("ConditionalExpression", e1, t);
            }
            function assertContinueStatement(e1, t) {
                assert("ContinueStatement", e1, t);
            }
            function assertDebuggerStatement(e1, t) {
                assert("DebuggerStatement", e1, t);
            }
            function assertDoWhileStatement(e1, t) {
                assert("DoWhileStatement", e1, t);
            }
            function assertEmptyStatement(e1, t) {
                assert("EmptyStatement", e1, t);
            }
            function assertExpressionStatement(e1, t) {
                assert("ExpressionStatement", e1, t);
            }
            function assertFile(e1, t) {
                assert("File", e1, t);
            }
            function assertForInStatement(e1, t) {
                assert("ForInStatement", e1, t);
            }
            function assertForStatement(e1, t) {
                assert("ForStatement", e1, t);
            }
            function assertFunctionDeclaration(e1, t) {
                assert("FunctionDeclaration", e1, t);
            }
            function assertFunctionExpression(e1, t) {
                assert("FunctionExpression", e1, t);
            }
            function assertIdentifier(e1, t) {
                assert("Identifier", e1, t);
            }
            function assertIfStatement(e1, t) {
                assert("IfStatement", e1, t);
            }
            function assertLabeledStatement(e1, t) {
                assert("LabeledStatement", e1, t);
            }
            function assertStringLiteral(e1, t) {
                assert("StringLiteral", e1, t);
            }
            function assertNumericLiteral(e1, t) {
                assert("NumericLiteral", e1, t);
            }
            function assertNullLiteral(e1, t) {
                assert("NullLiteral", e1, t);
            }
            function assertBooleanLiteral(e1, t) {
                assert("BooleanLiteral", e1, t);
            }
            function assertRegExpLiteral(e1, t) {
                assert("RegExpLiteral", e1, t);
            }
            function assertLogicalExpression(e1, t) {
                assert("LogicalExpression", e1, t);
            }
            function assertMemberExpression(e1, t) {
                assert("MemberExpression", e1, t);
            }
            function assertNewExpression(e1, t) {
                assert("NewExpression", e1, t);
            }
            function assertProgram(e1, t) {
                assert("Program", e1, t);
            }
            function assertObjectExpression(e1, t) {
                assert("ObjectExpression", e1, t);
            }
            function assertObjectMethod(e1, t) {
                assert("ObjectMethod", e1, t);
            }
            function assertObjectProperty(e1, t) {
                assert("ObjectProperty", e1, t);
            }
            function assertRestElement(e1, t) {
                assert("RestElement", e1, t);
            }
            function assertReturnStatement(e1, t) {
                assert("ReturnStatement", e1, t);
            }
            function assertSequenceExpression(e1, t) {
                assert("SequenceExpression", e1, t);
            }
            function assertParenthesizedExpression(e1, t) {
                assert("ParenthesizedExpression", e1, t);
            }
            function assertSwitchCase(e1, t) {
                assert("SwitchCase", e1, t);
            }
            function assertSwitchStatement(e1, t) {
                assert("SwitchStatement", e1, t);
            }
            function assertThisExpression(e1, t) {
                assert("ThisExpression", e1, t);
            }
            function assertThrowStatement(e1, t) {
                assert("ThrowStatement", e1, t);
            }
            function assertTryStatement(e1, t) {
                assert("TryStatement", e1, t);
            }
            function assertUnaryExpression(e1, t) {
                assert("UnaryExpression", e1, t);
            }
            function assertUpdateExpression(e1, t) {
                assert("UpdateExpression", e1, t);
            }
            function assertVariableDeclaration(e1, t) {
                assert("VariableDeclaration", e1, t);
            }
            function assertVariableDeclarator(e1, t) {
                assert("VariableDeclarator", e1, t);
            }
            function assertWhileStatement(e1, t) {
                assert("WhileStatement", e1, t);
            }
            function assertWithStatement(e1, t) {
                assert("WithStatement", e1, t);
            }
            function assertAssignmentPattern(e1, t) {
                assert("AssignmentPattern", e1, t);
            }
            function assertArrayPattern(e1, t) {
                assert("ArrayPattern", e1, t);
            }
            function assertArrowFunctionExpression(e1, t) {
                assert("ArrowFunctionExpression", e1, t);
            }
            function assertClassBody(e1, t) {
                assert("ClassBody", e1, t);
            }
            function assertClassExpression(e1, t) {
                assert("ClassExpression", e1, t);
            }
            function assertClassDeclaration(e1, t) {
                assert("ClassDeclaration", e1, t);
            }
            function assertExportAllDeclaration(e1, t) {
                assert("ExportAllDeclaration", e1, t);
            }
            function assertExportDefaultDeclaration(e1, t) {
                assert("ExportDefaultDeclaration", e1, t);
            }
            function assertExportNamedDeclaration(e1, t) {
                assert("ExportNamedDeclaration", e1, t);
            }
            function assertExportSpecifier(e1, t) {
                assert("ExportSpecifier", e1, t);
            }
            function assertForOfStatement(e1, t) {
                assert("ForOfStatement", e1, t);
            }
            function assertImportDeclaration(e1, t) {
                assert("ImportDeclaration", e1, t);
            }
            function assertImportDefaultSpecifier(e1, t) {
                assert("ImportDefaultSpecifier", e1, t);
            }
            function assertImportNamespaceSpecifier(e1, t) {
                assert("ImportNamespaceSpecifier", e1, t);
            }
            function assertImportSpecifier(e1, t) {
                assert("ImportSpecifier", e1, t);
            }
            function assertMetaProperty(e1, t) {
                assert("MetaProperty", e1, t);
            }
            function assertClassMethod(e1, t) {
                assert("ClassMethod", e1, t);
            }
            function assertObjectPattern(e1, t) {
                assert("ObjectPattern", e1, t);
            }
            function assertSpreadElement(e1, t) {
                assert("SpreadElement", e1, t);
            }
            function assertSuper(e1, t) {
                assert("Super", e1, t);
            }
            function assertTaggedTemplateExpression(e1, t) {
                assert("TaggedTemplateExpression", e1, t);
            }
            function assertTemplateElement(e1, t) {
                assert("TemplateElement", e1, t);
            }
            function assertTemplateLiteral(e1, t) {
                assert("TemplateLiteral", e1, t);
            }
            function assertYieldExpression(e1, t) {
                assert("YieldExpression", e1, t);
            }
            function assertAwaitExpression(e1, t) {
                assert("AwaitExpression", e1, t);
            }
            function assertImport(e1, t) {
                assert("Import", e1, t);
            }
            function assertBigIntLiteral(e1, t) {
                assert("BigIntLiteral", e1, t);
            }
            function assertExportNamespaceSpecifier(e1, t) {
                assert("ExportNamespaceSpecifier", e1, t);
            }
            function assertOptionalMemberExpression(e1, t) {
                assert("OptionalMemberExpression", e1, t);
            }
            function assertOptionalCallExpression(e1, t) {
                assert("OptionalCallExpression", e1, t);
            }
            function assertClassProperty(e1, t) {
                assert("ClassProperty", e1, t);
            }
            function assertClassAccessorProperty(e1, t) {
                assert("ClassAccessorProperty", e1, t);
            }
            function assertClassPrivateProperty(e1, t) {
                assert("ClassPrivateProperty", e1, t);
            }
            function assertClassPrivateMethod(e1, t) {
                assert("ClassPrivateMethod", e1, t);
            }
            function assertPrivateName(e1, t) {
                assert("PrivateName", e1, t);
            }
            function assertStaticBlock(e1, t) {
                assert("StaticBlock", e1, t);
            }
            function assertAnyTypeAnnotation(e1, t) {
                assert("AnyTypeAnnotation", e1, t);
            }
            function assertArrayTypeAnnotation(e1, t) {
                assert("ArrayTypeAnnotation", e1, t);
            }
            function assertBooleanTypeAnnotation(e1, t) {
                assert("BooleanTypeAnnotation", e1, t);
            }
            function assertBooleanLiteralTypeAnnotation(e1, t) {
                assert("BooleanLiteralTypeAnnotation", e1, t);
            }
            function assertNullLiteralTypeAnnotation(e1, t) {
                assert("NullLiteralTypeAnnotation", e1, t);
            }
            function assertClassImplements(e1, t) {
                assert("ClassImplements", e1, t);
            }
            function assertDeclareClass(e1, t) {
                assert("DeclareClass", e1, t);
            }
            function assertDeclareFunction(e1, t) {
                assert("DeclareFunction", e1, t);
            }
            function assertDeclareInterface(e1, t) {
                assert("DeclareInterface", e1, t);
            }
            function assertDeclareModule(e1, t) {
                assert("DeclareModule", e1, t);
            }
            function assertDeclareModuleExports(e1, t) {
                assert("DeclareModuleExports", e1, t);
            }
            function assertDeclareTypeAlias(e1, t) {
                assert("DeclareTypeAlias", e1, t);
            }
            function assertDeclareOpaqueType(e1, t) {
                assert("DeclareOpaqueType", e1, t);
            }
            function assertDeclareVariable(e1, t) {
                assert("DeclareVariable", e1, t);
            }
            function assertDeclareExportDeclaration(e1, t) {
                assert("DeclareExportDeclaration", e1, t);
            }
            function assertDeclareExportAllDeclaration(e1, t) {
                assert("DeclareExportAllDeclaration", e1, t);
            }
            function assertDeclaredPredicate(e1, t) {
                assert("DeclaredPredicate", e1, t);
            }
            function assertExistsTypeAnnotation(e1, t) {
                assert("ExistsTypeAnnotation", e1, t);
            }
            function assertFunctionTypeAnnotation(e1, t) {
                assert("FunctionTypeAnnotation", e1, t);
            }
            function assertFunctionTypeParam(e1, t) {
                assert("FunctionTypeParam", e1, t);
            }
            function assertGenericTypeAnnotation(e1, t) {
                assert("GenericTypeAnnotation", e1, t);
            }
            function assertInferredPredicate(e1, t) {
                assert("InferredPredicate", e1, t);
            }
            function assertInterfaceExtends(e1, t) {
                assert("InterfaceExtends", e1, t);
            }
            function assertInterfaceDeclaration(e1, t) {
                assert("InterfaceDeclaration", e1, t);
            }
            function assertInterfaceTypeAnnotation(e1, t) {
                assert("InterfaceTypeAnnotation", e1, t);
            }
            function assertIntersectionTypeAnnotation(e1, t) {
                assert("IntersectionTypeAnnotation", e1, t);
            }
            function assertMixedTypeAnnotation(e1, t) {
                assert("MixedTypeAnnotation", e1, t);
            }
            function assertEmptyTypeAnnotation(e1, t) {
                assert("EmptyTypeAnnotation", e1, t);
            }
            function assertNullableTypeAnnotation(e1, t) {
                assert("NullableTypeAnnotation", e1, t);
            }
            function assertNumberLiteralTypeAnnotation(e1, t) {
                assert("NumberLiteralTypeAnnotation", e1, t);
            }
            function assertNumberTypeAnnotation(e1, t) {
                assert("NumberTypeAnnotation", e1, t);
            }
            function assertObjectTypeAnnotation(e1, t) {
                assert("ObjectTypeAnnotation", e1, t);
            }
            function assertObjectTypeInternalSlot(e1, t) {
                assert("ObjectTypeInternalSlot", e1, t);
            }
            function assertObjectTypeCallProperty(e1, t) {
                assert("ObjectTypeCallProperty", e1, t);
            }
            function assertObjectTypeIndexer(e1, t) {
                assert("ObjectTypeIndexer", e1, t);
            }
            function assertObjectTypeProperty(e1, t) {
                assert("ObjectTypeProperty", e1, t);
            }
            function assertObjectTypeSpreadProperty(e1, t) {
                assert("ObjectTypeSpreadProperty", e1, t);
            }
            function assertOpaqueType(e1, t) {
                assert("OpaqueType", e1, t);
            }
            function assertQualifiedTypeIdentifier(e1, t) {
                assert("QualifiedTypeIdentifier", e1, t);
            }
            function assertStringLiteralTypeAnnotation(e1, t) {
                assert("StringLiteralTypeAnnotation", e1, t);
            }
            function assertStringTypeAnnotation(e1, t) {
                assert("StringTypeAnnotation", e1, t);
            }
            function assertSymbolTypeAnnotation(e1, t) {
                assert("SymbolTypeAnnotation", e1, t);
            }
            function assertThisTypeAnnotation(e1, t) {
                assert("ThisTypeAnnotation", e1, t);
            }
            function assertTupleTypeAnnotation(e1, t) {
                assert("TupleTypeAnnotation", e1, t);
            }
            function assertTypeofTypeAnnotation(e1, t) {
                assert("TypeofTypeAnnotation", e1, t);
            }
            function assertTypeAlias(e1, t) {
                assert("TypeAlias", e1, t);
            }
            function assertTypeAnnotation(e1, t) {
                assert("TypeAnnotation", e1, t);
            }
            function assertTypeCastExpression(e1, t) {
                assert("TypeCastExpression", e1, t);
            }
            function assertTypeParameter(e1, t) {
                assert("TypeParameter", e1, t);
            }
            function assertTypeParameterDeclaration(e1, t) {
                assert("TypeParameterDeclaration", e1, t);
            }
            function assertTypeParameterInstantiation(e1, t) {
                assert("TypeParameterInstantiation", e1, t);
            }
            function assertUnionTypeAnnotation(e1, t) {
                assert("UnionTypeAnnotation", e1, t);
            }
            function assertVariance(e1, t) {
                assert("Variance", e1, t);
            }
            function assertVoidTypeAnnotation(e1, t) {
                assert("VoidTypeAnnotation", e1, t);
            }
            function assertEnumDeclaration(e1, t) {
                assert("EnumDeclaration", e1, t);
            }
            function assertEnumBooleanBody(e1, t) {
                assert("EnumBooleanBody", e1, t);
            }
            function assertEnumNumberBody(e1, t) {
                assert("EnumNumberBody", e1, t);
            }
            function assertEnumStringBody(e1, t) {
                assert("EnumStringBody", e1, t);
            }
            function assertEnumSymbolBody(e1, t) {
                assert("EnumSymbolBody", e1, t);
            }
            function assertEnumBooleanMember(e1, t) {
                assert("EnumBooleanMember", e1, t);
            }
            function assertEnumNumberMember(e1, t) {
                assert("EnumNumberMember", e1, t);
            }
            function assertEnumStringMember(e1, t) {
                assert("EnumStringMember", e1, t);
            }
            function assertEnumDefaultedMember(e1, t) {
                assert("EnumDefaultedMember", e1, t);
            }
            function assertIndexedAccessType(e1, t) {
                assert("IndexedAccessType", e1, t);
            }
            function assertOptionalIndexedAccessType(e1, t) {
                assert("OptionalIndexedAccessType", e1, t);
            }
            function assertJSXAttribute(e1, t) {
                assert("JSXAttribute", e1, t);
            }
            function assertJSXClosingElement(e1, t) {
                assert("JSXClosingElement", e1, t);
            }
            function assertJSXElement(e1, t) {
                assert("JSXElement", e1, t);
            }
            function assertJSXEmptyExpression(e1, t) {
                assert("JSXEmptyExpression", e1, t);
            }
            function assertJSXExpressionContainer(e1, t) {
                assert("JSXExpressionContainer", e1, t);
            }
            function assertJSXSpreadChild(e1, t) {
                assert("JSXSpreadChild", e1, t);
            }
            function assertJSXIdentifier(e1, t) {
                assert("JSXIdentifier", e1, t);
            }
            function assertJSXMemberExpression(e1, t) {
                assert("JSXMemberExpression", e1, t);
            }
            function assertJSXNamespacedName(e1, t) {
                assert("JSXNamespacedName", e1, t);
            }
            function assertJSXOpeningElement(e1, t) {
                assert("JSXOpeningElement", e1, t);
            }
            function assertJSXSpreadAttribute(e1, t) {
                assert("JSXSpreadAttribute", e1, t);
            }
            function assertJSXText(e1, t) {
                assert("JSXText", e1, t);
            }
            function assertJSXFragment(e1, t) {
                assert("JSXFragment", e1, t);
            }
            function assertJSXOpeningFragment(e1, t) {
                assert("JSXOpeningFragment", e1, t);
            }
            function assertJSXClosingFragment(e1, t) {
                assert("JSXClosingFragment", e1, t);
            }
            function assertNoop(e1, t) {
                assert("Noop", e1, t);
            }
            function assertPlaceholder(e1, t) {
                assert("Placeholder", e1, t);
            }
            function assertV8IntrinsicIdentifier(e1, t) {
                assert("V8IntrinsicIdentifier", e1, t);
            }
            function assertArgumentPlaceholder(e1, t) {
                assert("ArgumentPlaceholder", e1, t);
            }
            function assertBindExpression(e1, t) {
                assert("BindExpression", e1, t);
            }
            function assertImportAttribute(e1, t) {
                assert("ImportAttribute", e1, t);
            }
            function assertDecorator(e1, t) {
                assert("Decorator", e1, t);
            }
            function assertDoExpression(e1, t) {
                assert("DoExpression", e1, t);
            }
            function assertExportDefaultSpecifier(e1, t) {
                assert("ExportDefaultSpecifier", e1, t);
            }
            function assertRecordExpression(e1, t) {
                assert("RecordExpression", e1, t);
            }
            function assertTupleExpression(e1, t) {
                assert("TupleExpression", e1, t);
            }
            function assertDecimalLiteral(e1, t) {
                assert("DecimalLiteral", e1, t);
            }
            function assertModuleExpression(e1, t) {
                assert("ModuleExpression", e1, t);
            }
            function assertTopicReference(e1, t) {
                assert("TopicReference", e1, t);
            }
            function assertPipelineTopicExpression(e1, t) {
                assert("PipelineTopicExpression", e1, t);
            }
            function assertPipelineBareFunction(e1, t) {
                assert("PipelineBareFunction", e1, t);
            }
            function assertPipelinePrimaryTopicReference(e1, t) {
                assert("PipelinePrimaryTopicReference", e1, t);
            }
            function assertTSParameterProperty(e1, t) {
                assert("TSParameterProperty", e1, t);
            }
            function assertTSDeclareFunction(e1, t) {
                assert("TSDeclareFunction", e1, t);
            }
            function assertTSDeclareMethod(e1, t) {
                assert("TSDeclareMethod", e1, t);
            }
            function assertTSQualifiedName(e1, t) {
                assert("TSQualifiedName", e1, t);
            }
            function assertTSCallSignatureDeclaration(e1, t) {
                assert("TSCallSignatureDeclaration", e1, t);
            }
            function assertTSConstructSignatureDeclaration(e1, t) {
                assert("TSConstructSignatureDeclaration", e1, t);
            }
            function assertTSPropertySignature(e1, t) {
                assert("TSPropertySignature", e1, t);
            }
            function assertTSMethodSignature(e1, t) {
                assert("TSMethodSignature", e1, t);
            }
            function assertTSIndexSignature(e1, t) {
                assert("TSIndexSignature", e1, t);
            }
            function assertTSAnyKeyword(e1, t) {
                assert("TSAnyKeyword", e1, t);
            }
            function assertTSBooleanKeyword(e1, t) {
                assert("TSBooleanKeyword", e1, t);
            }
            function assertTSBigIntKeyword(e1, t) {
                assert("TSBigIntKeyword", e1, t);
            }
            function assertTSIntrinsicKeyword(e1, t) {
                assert("TSIntrinsicKeyword", e1, t);
            }
            function assertTSNeverKeyword(e1, t) {
                assert("TSNeverKeyword", e1, t);
            }
            function assertTSNullKeyword(e1, t) {
                assert("TSNullKeyword", e1, t);
            }
            function assertTSNumberKeyword(e1, t) {
                assert("TSNumberKeyword", e1, t);
            }
            function assertTSObjectKeyword(e1, t) {
                assert("TSObjectKeyword", e1, t);
            }
            function assertTSStringKeyword(e1, t) {
                assert("TSStringKeyword", e1, t);
            }
            function assertTSSymbolKeyword(e1, t) {
                assert("TSSymbolKeyword", e1, t);
            }
            function assertTSUndefinedKeyword(e1, t) {
                assert("TSUndefinedKeyword", e1, t);
            }
            function assertTSUnknownKeyword(e1, t) {
                assert("TSUnknownKeyword", e1, t);
            }
            function assertTSVoidKeyword(e1, t) {
                assert("TSVoidKeyword", e1, t);
            }
            function assertTSThisType(e1, t) {
                assert("TSThisType", e1, t);
            }
            function assertTSFunctionType(e1, t) {
                assert("TSFunctionType", e1, t);
            }
            function assertTSConstructorType(e1, t) {
                assert("TSConstructorType", e1, t);
            }
            function assertTSTypeReference(e1, t) {
                assert("TSTypeReference", e1, t);
            }
            function assertTSTypePredicate(e1, t) {
                assert("TSTypePredicate", e1, t);
            }
            function assertTSTypeQuery(e1, t) {
                assert("TSTypeQuery", e1, t);
            }
            function assertTSTypeLiteral(e1, t) {
                assert("TSTypeLiteral", e1, t);
            }
            function assertTSArrayType(e1, t) {
                assert("TSArrayType", e1, t);
            }
            function assertTSTupleType(e1, t) {
                assert("TSTupleType", e1, t);
            }
            function assertTSOptionalType(e1, t) {
                assert("TSOptionalType", e1, t);
            }
            function assertTSRestType(e1, t) {
                assert("TSRestType", e1, t);
            }
            function assertTSNamedTupleMember(e1, t) {
                assert("TSNamedTupleMember", e1, t);
            }
            function assertTSUnionType(e1, t) {
                assert("TSUnionType", e1, t);
            }
            function assertTSIntersectionType(e1, t) {
                assert("TSIntersectionType", e1, t);
            }
            function assertTSConditionalType(e1, t) {
                assert("TSConditionalType", e1, t);
            }
            function assertTSInferType(e1, t) {
                assert("TSInferType", e1, t);
            }
            function assertTSParenthesizedType(e1, t) {
                assert("TSParenthesizedType", e1, t);
            }
            function assertTSTypeOperator(e1, t) {
                assert("TSTypeOperator", e1, t);
            }
            function assertTSIndexedAccessType(e1, t) {
                assert("TSIndexedAccessType", e1, t);
            }
            function assertTSMappedType(e1, t) {
                assert("TSMappedType", e1, t);
            }
            function assertTSLiteralType(e1, t) {
                assert("TSLiteralType", e1, t);
            }
            function assertTSExpressionWithTypeArguments(e1, t) {
                assert("TSExpressionWithTypeArguments", e1, t);
            }
            function assertTSInterfaceDeclaration(e1, t) {
                assert("TSInterfaceDeclaration", e1, t);
            }
            function assertTSInterfaceBody(e1, t) {
                assert("TSInterfaceBody", e1, t);
            }
            function assertTSTypeAliasDeclaration(e1, t) {
                assert("TSTypeAliasDeclaration", e1, t);
            }
            function assertTSInstantiationExpression(e1, t) {
                assert("TSInstantiationExpression", e1, t);
            }
            function assertTSAsExpression(e1, t) {
                assert("TSAsExpression", e1, t);
            }
            function assertTSSatisfiesExpression(e1, t) {
                assert("TSSatisfiesExpression", e1, t);
            }
            function assertTSTypeAssertion(e1, t) {
                assert("TSTypeAssertion", e1, t);
            }
            function assertTSEnumDeclaration(e1, t) {
                assert("TSEnumDeclaration", e1, t);
            }
            function assertTSEnumMember(e1, t) {
                assert("TSEnumMember", e1, t);
            }
            function assertTSModuleDeclaration(e1, t) {
                assert("TSModuleDeclaration", e1, t);
            }
            function assertTSModuleBlock(e1, t) {
                assert("TSModuleBlock", e1, t);
            }
            function assertTSImportType(e1, t) {
                assert("TSImportType", e1, t);
            }
            function assertTSImportEqualsDeclaration(e1, t) {
                assert("TSImportEqualsDeclaration", e1, t);
            }
            function assertTSExternalModuleReference(e1, t) {
                assert("TSExternalModuleReference", e1, t);
            }
            function assertTSNonNullExpression(e1, t) {
                assert("TSNonNullExpression", e1, t);
            }
            function assertTSExportAssignment(e1, t) {
                assert("TSExportAssignment", e1, t);
            }
            function assertTSNamespaceExportDeclaration(e1, t) {
                assert("TSNamespaceExportDeclaration", e1, t);
            }
            function assertTSTypeAnnotation(e1, t) {
                assert("TSTypeAnnotation", e1, t);
            }
            function assertTSTypeParameterInstantiation(e1, t) {
                assert("TSTypeParameterInstantiation", e1, t);
            }
            function assertTSTypeParameterDeclaration(e1, t) {
                assert("TSTypeParameterDeclaration", e1, t);
            }
            function assertTSTypeParameter(e1, t) {
                assert("TSTypeParameter", e1, t);
            }
            function assertStandardized(e1, t) {
                assert("Standardized", e1, t);
            }
            function assertExpression(e1, t) {
                assert("Expression", e1, t);
            }
            function assertBinary(e1, t) {
                assert("Binary", e1, t);
            }
            function assertScopable(e1, t) {
                assert("Scopable", e1, t);
            }
            function assertBlockParent(e1, t) {
                assert("BlockParent", e1, t);
            }
            function assertBlock(e1, t) {
                assert("Block", e1, t);
            }
            function assertStatement(e1, t) {
                assert("Statement", e1, t);
            }
            function assertTerminatorless(e1, t) {
                assert("Terminatorless", e1, t);
            }
            function assertCompletionStatement(e1, t) {
                assert("CompletionStatement", e1, t);
            }
            function assertConditional(e1, t) {
                assert("Conditional", e1, t);
            }
            function assertLoop(e1, t) {
                assert("Loop", e1, t);
            }
            function assertWhile(e1, t) {
                assert("While", e1, t);
            }
            function assertExpressionWrapper(e1, t) {
                assert("ExpressionWrapper", e1, t);
            }
            function assertFor(e1, t) {
                assert("For", e1, t);
            }
            function assertForXStatement(e1, t) {
                assert("ForXStatement", e1, t);
            }
            function assertFunction(e1, t) {
                assert("Function", e1, t);
            }
            function assertFunctionParent(e1, t) {
                assert("FunctionParent", e1, t);
            }
            function assertPureish(e1, t) {
                assert("Pureish", e1, t);
            }
            function assertDeclaration(e1, t) {
                assert("Declaration", e1, t);
            }
            function assertPatternLike(e1, t) {
                assert("PatternLike", e1, t);
            }
            function assertLVal(e1, t) {
                assert("LVal", e1, t);
            }
            function assertTSEntityName(e1, t) {
                assert("TSEntityName", e1, t);
            }
            function assertLiteral(e1, t) {
                assert("Literal", e1, t);
            }
            function assertImmutable(e1, t) {
                assert("Immutable", e1, t);
            }
            function assertUserWhitespacable(e1, t) {
                assert("UserWhitespacable", e1, t);
            }
            function assertMethod(e1, t) {
                assert("Method", e1, t);
            }
            function assertObjectMember(e1, t) {
                assert("ObjectMember", e1, t);
            }
            function assertProperty(e1, t) {
                assert("Property", e1, t);
            }
            function assertUnaryLike(e1, t) {
                assert("UnaryLike", e1, t);
            }
            function assertPattern(e1, t) {
                assert("Pattern", e1, t);
            }
            function assertClass(e1, t) {
                assert("Class", e1, t);
            }
            function assertImportOrExportDeclaration(e1, t) {
                assert("ImportOrExportDeclaration", e1, t);
            }
            function assertExportDeclaration(e1, t) {
                assert("ExportDeclaration", e1, t);
            }
            function assertModuleSpecifier(e1, t) {
                assert("ModuleSpecifier", e1, t);
            }
            function assertAccessor(e1, t) {
                assert("Accessor", e1, t);
            }
            function assertPrivate(e1, t) {
                assert("Private", e1, t);
            }
            function assertFlow(e1, t) {
                assert("Flow", e1, t);
            }
            function assertFlowType(e1, t) {
                assert("FlowType", e1, t);
            }
            function assertFlowBaseAnnotation(e1, t) {
                assert("FlowBaseAnnotation", e1, t);
            }
            function assertFlowDeclaration(e1, t) {
                assert("FlowDeclaration", e1, t);
            }
            function assertFlowPredicate(e1, t) {
                assert("FlowPredicate", e1, t);
            }
            function assertEnumBody(e1, t) {
                assert("EnumBody", e1, t);
            }
            function assertEnumMember(e1, t) {
                assert("EnumMember", e1, t);
            }
            function assertJSX(e1, t) {
                assert("JSX", e1, t);
            }
            function assertMiscellaneous(e1, t) {
                assert("Miscellaneous", e1, t);
            }
            function assertTypeScript(e1, t) {
                assert("TypeScript", e1, t);
            }
            function assertTSTypeElement(e1, t) {
                assert("TSTypeElement", e1, t);
            }
            function assertTSType(e1, t) {
                assert("TSType", e1, t);
            }
            function assertTSBaseType(e1, t) {
                assert("TSBaseType", e1, t);
            }
            function assertNumberLiteral(e1, t) {
                (0, s.default)("assertNumberLiteral", "assertNumericLiteral");
                assert("NumberLiteral", e1, t);
            }
            function assertRegexLiteral(e1, t) {
                (0, s.default)("assertRegexLiteral", "assertRegExpLiteral");
                assert("RegexLiteral", e1, t);
            }
            function assertRestProperty(e1, t) {
                (0, s.default)("assertRestProperty", "assertRestElement");
                assert("RestProperty", e1, t);
            }
            function assertSpreadProperty(e1, t) {
                (0, s.default)("assertSpreadProperty", "assertSpreadElement");
                assert("SpreadProperty", e1, t);
            }
            function assertModuleDeclaration(e1, t) {
                (0, s.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
                assert("ModuleDeclaration", e1, t);
            }
        },
        3103: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = createFlowUnionType;
            var n = r(7453);
            var s = r(6627);
            function createFlowUnionType(e1) {
                const t = (0, s.default)(e1);
                if (t.length === 1) {
                    return t[0];
                } else {
                    return (0, n.unionTypeAnnotation)(t);
                }
            }
        },
        785: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(7453);
            var s = createTypeAnnotationBasedOnTypeof;
            t["default"] = s;
            function createTypeAnnotationBasedOnTypeof(e1) {
                switch(e1){
                    case "string":
                        return (0, n.stringTypeAnnotation)();
                    case "number":
                        return (0, n.numberTypeAnnotation)();
                    case "undefined":
                        return (0, n.voidTypeAnnotation)();
                    case "boolean":
                        return (0, n.booleanTypeAnnotation)();
                    case "function":
                        return (0, n.genericTypeAnnotation)((0, n.identifier)("Function"));
                    case "object":
                        return (0, n.genericTypeAnnotation)((0, n.identifier)("Object"));
                    case "symbol":
                        return (0, n.genericTypeAnnotation)((0, n.identifier)("Symbol"));
                    case "bigint":
                        return (0, n.anyTypeAnnotation)();
                }
                throw new Error("Invalid typeof value: " + e1);
            }
        },
        7453: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.anyTypeAnnotation = anyTypeAnnotation;
            t.argumentPlaceholder = argumentPlaceholder;
            t.arrayExpression = arrayExpression;
            t.arrayPattern = arrayPattern;
            t.arrayTypeAnnotation = arrayTypeAnnotation;
            t.arrowFunctionExpression = arrowFunctionExpression;
            t.assignmentExpression = assignmentExpression;
            t.assignmentPattern = assignmentPattern;
            t.awaitExpression = awaitExpression;
            t.bigIntLiteral = bigIntLiteral;
            t.binaryExpression = binaryExpression;
            t.bindExpression = bindExpression;
            t.blockStatement = blockStatement;
            t.booleanLiteral = booleanLiteral;
            t.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
            t.booleanTypeAnnotation = booleanTypeAnnotation;
            t.breakStatement = breakStatement;
            t.callExpression = callExpression;
            t.catchClause = catchClause;
            t.classAccessorProperty = classAccessorProperty;
            t.classBody = classBody;
            t.classDeclaration = classDeclaration;
            t.classExpression = classExpression;
            t.classImplements = classImplements;
            t.classMethod = classMethod;
            t.classPrivateMethod = classPrivateMethod;
            t.classPrivateProperty = classPrivateProperty;
            t.classProperty = classProperty;
            t.conditionalExpression = conditionalExpression;
            t.continueStatement = continueStatement;
            t.debuggerStatement = debuggerStatement;
            t.decimalLiteral = decimalLiteral;
            t.declareClass = declareClass;
            t.declareExportAllDeclaration = declareExportAllDeclaration;
            t.declareExportDeclaration = declareExportDeclaration;
            t.declareFunction = declareFunction;
            t.declareInterface = declareInterface;
            t.declareModule = declareModule;
            t.declareModuleExports = declareModuleExports;
            t.declareOpaqueType = declareOpaqueType;
            t.declareTypeAlias = declareTypeAlias;
            t.declareVariable = declareVariable;
            t.declaredPredicate = declaredPredicate;
            t.decorator = decorator;
            t.directive = directive;
            t.directiveLiteral = directiveLiteral;
            t.doExpression = doExpression;
            t.doWhileStatement = doWhileStatement;
            t.emptyStatement = emptyStatement;
            t.emptyTypeAnnotation = emptyTypeAnnotation;
            t.enumBooleanBody = enumBooleanBody;
            t.enumBooleanMember = enumBooleanMember;
            t.enumDeclaration = enumDeclaration;
            t.enumDefaultedMember = enumDefaultedMember;
            t.enumNumberBody = enumNumberBody;
            t.enumNumberMember = enumNumberMember;
            t.enumStringBody = enumStringBody;
            t.enumStringMember = enumStringMember;
            t.enumSymbolBody = enumSymbolBody;
            t.existsTypeAnnotation = existsTypeAnnotation;
            t.exportAllDeclaration = exportAllDeclaration;
            t.exportDefaultDeclaration = exportDefaultDeclaration;
            t.exportDefaultSpecifier = exportDefaultSpecifier;
            t.exportNamedDeclaration = exportNamedDeclaration;
            t.exportNamespaceSpecifier = exportNamespaceSpecifier;
            t.exportSpecifier = exportSpecifier;
            t.expressionStatement = expressionStatement;
            t.file = file;
            t.forInStatement = forInStatement;
            t.forOfStatement = forOfStatement;
            t.forStatement = forStatement;
            t.functionDeclaration = functionDeclaration;
            t.functionExpression = functionExpression;
            t.functionTypeAnnotation = functionTypeAnnotation;
            t.functionTypeParam = functionTypeParam;
            t.genericTypeAnnotation = genericTypeAnnotation;
            t.identifier = identifier;
            t.ifStatement = ifStatement;
            t["import"] = _import;
            t.importAttribute = importAttribute;
            t.importDeclaration = importDeclaration;
            t.importDefaultSpecifier = importDefaultSpecifier;
            t.importNamespaceSpecifier = importNamespaceSpecifier;
            t.importSpecifier = importSpecifier;
            t.indexedAccessType = indexedAccessType;
            t.inferredPredicate = inferredPredicate;
            t.interfaceDeclaration = interfaceDeclaration;
            t.interfaceExtends = interfaceExtends;
            t.interfaceTypeAnnotation = interfaceTypeAnnotation;
            t.interpreterDirective = interpreterDirective;
            t.intersectionTypeAnnotation = intersectionTypeAnnotation;
            t.jSXAttribute = t.jsxAttribute = jsxAttribute;
            t.jSXClosingElement = t.jsxClosingElement = jsxClosingElement;
            t.jSXClosingFragment = t.jsxClosingFragment = jsxClosingFragment;
            t.jSXElement = t.jsxElement = jsxElement;
            t.jSXEmptyExpression = t.jsxEmptyExpression = jsxEmptyExpression;
            t.jSXExpressionContainer = t.jsxExpressionContainer = jsxExpressionContainer;
            t.jSXFragment = t.jsxFragment = jsxFragment;
            t.jSXIdentifier = t.jsxIdentifier = jsxIdentifier;
            t.jSXMemberExpression = t.jsxMemberExpression = jsxMemberExpression;
            t.jSXNamespacedName = t.jsxNamespacedName = jsxNamespacedName;
            t.jSXOpeningElement = t.jsxOpeningElement = jsxOpeningElement;
            t.jSXOpeningFragment = t.jsxOpeningFragment = jsxOpeningFragment;
            t.jSXSpreadAttribute = t.jsxSpreadAttribute = jsxSpreadAttribute;
            t.jSXSpreadChild = t.jsxSpreadChild = jsxSpreadChild;
            t.jSXText = t.jsxText = jsxText;
            t.labeledStatement = labeledStatement;
            t.logicalExpression = logicalExpression;
            t.memberExpression = memberExpression;
            t.metaProperty = metaProperty;
            t.mixedTypeAnnotation = mixedTypeAnnotation;
            t.moduleExpression = moduleExpression;
            t.newExpression = newExpression;
            t.noop = noop;
            t.nullLiteral = nullLiteral;
            t.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
            t.nullableTypeAnnotation = nullableTypeAnnotation;
            t.numberLiteral = NumberLiteral;
            t.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
            t.numberTypeAnnotation = numberTypeAnnotation;
            t.numericLiteral = numericLiteral;
            t.objectExpression = objectExpression;
            t.objectMethod = objectMethod;
            t.objectPattern = objectPattern;
            t.objectProperty = objectProperty;
            t.objectTypeAnnotation = objectTypeAnnotation;
            t.objectTypeCallProperty = objectTypeCallProperty;
            t.objectTypeIndexer = objectTypeIndexer;
            t.objectTypeInternalSlot = objectTypeInternalSlot;
            t.objectTypeProperty = objectTypeProperty;
            t.objectTypeSpreadProperty = objectTypeSpreadProperty;
            t.opaqueType = opaqueType;
            t.optionalCallExpression = optionalCallExpression;
            t.optionalIndexedAccessType = optionalIndexedAccessType;
            t.optionalMemberExpression = optionalMemberExpression;
            t.parenthesizedExpression = parenthesizedExpression;
            t.pipelineBareFunction = pipelineBareFunction;
            t.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
            t.pipelineTopicExpression = pipelineTopicExpression;
            t.placeholder = placeholder;
            t.privateName = privateName;
            t.program = program;
            t.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
            t.recordExpression = recordExpression;
            t.regExpLiteral = regExpLiteral;
            t.regexLiteral = RegexLiteral;
            t.restElement = restElement;
            t.restProperty = RestProperty;
            t.returnStatement = returnStatement;
            t.sequenceExpression = sequenceExpression;
            t.spreadElement = spreadElement;
            t.spreadProperty = SpreadProperty;
            t.staticBlock = staticBlock;
            t.stringLiteral = stringLiteral;
            t.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
            t.stringTypeAnnotation = stringTypeAnnotation;
            t["super"] = _super;
            t.switchCase = switchCase;
            t.switchStatement = switchStatement;
            t.symbolTypeAnnotation = symbolTypeAnnotation;
            t.taggedTemplateExpression = taggedTemplateExpression;
            t.templateElement = templateElement;
            t.templateLiteral = templateLiteral;
            t.thisExpression = thisExpression;
            t.thisTypeAnnotation = thisTypeAnnotation;
            t.throwStatement = throwStatement;
            t.topicReference = topicReference;
            t.tryStatement = tryStatement;
            t.tSAnyKeyword = t.tsAnyKeyword = tsAnyKeyword;
            t.tSArrayType = t.tsArrayType = tsArrayType;
            t.tSAsExpression = t.tsAsExpression = tsAsExpression;
            t.tSBigIntKeyword = t.tsBigIntKeyword = tsBigIntKeyword;
            t.tSBooleanKeyword = t.tsBooleanKeyword = tsBooleanKeyword;
            t.tSCallSignatureDeclaration = t.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
            t.tSConditionalType = t.tsConditionalType = tsConditionalType;
            t.tSConstructSignatureDeclaration = t.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
            t.tSConstructorType = t.tsConstructorType = tsConstructorType;
            t.tSDeclareFunction = t.tsDeclareFunction = tsDeclareFunction;
            t.tSDeclareMethod = t.tsDeclareMethod = tsDeclareMethod;
            t.tSEnumDeclaration = t.tsEnumDeclaration = tsEnumDeclaration;
            t.tSEnumMember = t.tsEnumMember = tsEnumMember;
            t.tSExportAssignment = t.tsExportAssignment = tsExportAssignment;
            t.tSExpressionWithTypeArguments = t.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
            t.tSExternalModuleReference = t.tsExternalModuleReference = tsExternalModuleReference;
            t.tSFunctionType = t.tsFunctionType = tsFunctionType;
            t.tSImportEqualsDeclaration = t.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
            t.tSImportType = t.tsImportType = tsImportType;
            t.tSIndexSignature = t.tsIndexSignature = tsIndexSignature;
            t.tSIndexedAccessType = t.tsIndexedAccessType = tsIndexedAccessType;
            t.tSInferType = t.tsInferType = tsInferType;
            t.tSInstantiationExpression = t.tsInstantiationExpression = tsInstantiationExpression;
            t.tSInterfaceBody = t.tsInterfaceBody = tsInterfaceBody;
            t.tSInterfaceDeclaration = t.tsInterfaceDeclaration = tsInterfaceDeclaration;
            t.tSIntersectionType = t.tsIntersectionType = tsIntersectionType;
            t.tSIntrinsicKeyword = t.tsIntrinsicKeyword = tsIntrinsicKeyword;
            t.tSLiteralType = t.tsLiteralType = tsLiteralType;
            t.tSMappedType = t.tsMappedType = tsMappedType;
            t.tSMethodSignature = t.tsMethodSignature = tsMethodSignature;
            t.tSModuleBlock = t.tsModuleBlock = tsModuleBlock;
            t.tSModuleDeclaration = t.tsModuleDeclaration = tsModuleDeclaration;
            t.tSNamedTupleMember = t.tsNamedTupleMember = tsNamedTupleMember;
            t.tSNamespaceExportDeclaration = t.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
            t.tSNeverKeyword = t.tsNeverKeyword = tsNeverKeyword;
            t.tSNonNullExpression = t.tsNonNullExpression = tsNonNullExpression;
            t.tSNullKeyword = t.tsNullKeyword = tsNullKeyword;
            t.tSNumberKeyword = t.tsNumberKeyword = tsNumberKeyword;
            t.tSObjectKeyword = t.tsObjectKeyword = tsObjectKeyword;
            t.tSOptionalType = t.tsOptionalType = tsOptionalType;
            t.tSParameterProperty = t.tsParameterProperty = tsParameterProperty;
            t.tSParenthesizedType = t.tsParenthesizedType = tsParenthesizedType;
            t.tSPropertySignature = t.tsPropertySignature = tsPropertySignature;
            t.tSQualifiedName = t.tsQualifiedName = tsQualifiedName;
            t.tSRestType = t.tsRestType = tsRestType;
            t.tSSatisfiesExpression = t.tsSatisfiesExpression = tsSatisfiesExpression;
            t.tSStringKeyword = t.tsStringKeyword = tsStringKeyword;
            t.tSSymbolKeyword = t.tsSymbolKeyword = tsSymbolKeyword;
            t.tSThisType = t.tsThisType = tsThisType;
            t.tSTupleType = t.tsTupleType = tsTupleType;
            t.tSTypeAliasDeclaration = t.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
            t.tSTypeAnnotation = t.tsTypeAnnotation = tsTypeAnnotation;
            t.tSTypeAssertion = t.tsTypeAssertion = tsTypeAssertion;
            t.tSTypeLiteral = t.tsTypeLiteral = tsTypeLiteral;
            t.tSTypeOperator = t.tsTypeOperator = tsTypeOperator;
            t.tSTypeParameter = t.tsTypeParameter = tsTypeParameter;
            t.tSTypeParameterDeclaration = t.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
            t.tSTypeParameterInstantiation = t.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
            t.tSTypePredicate = t.tsTypePredicate = tsTypePredicate;
            t.tSTypeQuery = t.tsTypeQuery = tsTypeQuery;
            t.tSTypeReference = t.tsTypeReference = tsTypeReference;
            t.tSUndefinedKeyword = t.tsUndefinedKeyword = tsUndefinedKeyword;
            t.tSUnionType = t.tsUnionType = tsUnionType;
            t.tSUnknownKeyword = t.tsUnknownKeyword = tsUnknownKeyword;
            t.tSVoidKeyword = t.tsVoidKeyword = tsVoidKeyword;
            t.tupleExpression = tupleExpression;
            t.tupleTypeAnnotation = tupleTypeAnnotation;
            t.typeAlias = typeAlias;
            t.typeAnnotation = typeAnnotation;
            t.typeCastExpression = typeCastExpression;
            t.typeParameter = typeParameter;
            t.typeParameterDeclaration = typeParameterDeclaration;
            t.typeParameterInstantiation = typeParameterInstantiation;
            t.typeofTypeAnnotation = typeofTypeAnnotation;
            t.unaryExpression = unaryExpression;
            t.unionTypeAnnotation = unionTypeAnnotation;
            t.updateExpression = updateExpression;
            t.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
            t.variableDeclaration = variableDeclaration;
            t.variableDeclarator = variableDeclarator;
            t.variance = variance;
            t.voidTypeAnnotation = voidTypeAnnotation;
            t.whileStatement = whileStatement;
            t.withStatement = withStatement;
            t.yieldExpression = yieldExpression;
            var n = r(7170);
            var s = r(4585);
            function arrayExpression(e1 = []) {
                return (0, n.default)({
                    type: "ArrayExpression",
                    elements: e1
                });
            }
            function assignmentExpression(e1, t, r) {
                return (0, n.default)({
                    type: "AssignmentExpression",
                    operator: e1,
                    left: t,
                    right: r
                });
            }
            function binaryExpression(e1, t, r) {
                return (0, n.default)({
                    type: "BinaryExpression",
                    operator: e1,
                    left: t,
                    right: r
                });
            }
            function interpreterDirective(e1) {
                return (0, n.default)({
                    type: "InterpreterDirective",
                    value: e1
                });
            }
            function directive(e1) {
                return (0, n.default)({
                    type: "Directive",
                    value: e1
                });
            }
            function directiveLiteral(e1) {
                return (0, n.default)({
                    type: "DirectiveLiteral",
                    value: e1
                });
            }
            function blockStatement(e1, t = []) {
                return (0, n.default)({
                    type: "BlockStatement",
                    body: e1,
                    directives: t
                });
            }
            function breakStatement(e1 = null) {
                return (0, n.default)({
                    type: "BreakStatement",
                    label: e1
                });
            }
            function callExpression(e1, t) {
                return (0, n.default)({
                    type: "CallExpression",
                    callee: e1,
                    arguments: t
                });
            }
            function catchClause(e1 = null, t) {
                return (0, n.default)({
                    type: "CatchClause",
                    param: e1,
                    body: t
                });
            }
            function conditionalExpression(e1, t, r) {
                return (0, n.default)({
                    type: "ConditionalExpression",
                    test: e1,
                    consequent: t,
                    alternate: r
                });
            }
            function continueStatement(e1 = null) {
                return (0, n.default)({
                    type: "ContinueStatement",
                    label: e1
                });
            }
            function debuggerStatement() {
                return {
                    type: "DebuggerStatement"
                };
            }
            function doWhileStatement(e1, t) {
                return (0, n.default)({
                    type: "DoWhileStatement",
                    test: e1,
                    body: t
                });
            }
            function emptyStatement() {
                return {
                    type: "EmptyStatement"
                };
            }
            function expressionStatement(e1) {
                return (0, n.default)({
                    type: "ExpressionStatement",
                    expression: e1
                });
            }
            function file(e1, t = null, r = null) {
                return (0, n.default)({
                    type: "File",
                    program: e1,
                    comments: t,
                    tokens: r
                });
            }
            function forInStatement(e1, t, r) {
                return (0, n.default)({
                    type: "ForInStatement",
                    left: e1,
                    right: t,
                    body: r
                });
            }
            function forStatement(e1 = null, t = null, r = null, s) {
                return (0, n.default)({
                    type: "ForStatement",
                    init: e1,
                    test: t,
                    update: r,
                    body: s
                });
            }
            function functionDeclaration(e1 = null, t, r, s = false, i = false) {
                return (0, n.default)({
                    type: "FunctionDeclaration",
                    id: e1,
                    params: t,
                    body: r,
                    generator: s,
                    async: i
                });
            }
            function functionExpression(e1 = null, t, r, s = false, i = false) {
                return (0, n.default)({
                    type: "FunctionExpression",
                    id: e1,
                    params: t,
                    body: r,
                    generator: s,
                    async: i
                });
            }
            function identifier(e1) {
                return (0, n.default)({
                    type: "Identifier",
                    name: e1
                });
            }
            function ifStatement(e1, t, r = null) {
                return (0, n.default)({
                    type: "IfStatement",
                    test: e1,
                    consequent: t,
                    alternate: r
                });
            }
            function labeledStatement(e1, t) {
                return (0, n.default)({
                    type: "LabeledStatement",
                    label: e1,
                    body: t
                });
            }
            function stringLiteral(e1) {
                return (0, n.default)({
                    type: "StringLiteral",
                    value: e1
                });
            }
            function numericLiteral(e1) {
                return (0, n.default)({
                    type: "NumericLiteral",
                    value: e1
                });
            }
            function nullLiteral() {
                return {
                    type: "NullLiteral"
                };
            }
            function booleanLiteral(e1) {
                return (0, n.default)({
                    type: "BooleanLiteral",
                    value: e1
                });
            }
            function regExpLiteral(e1, t = "") {
                return (0, n.default)({
                    type: "RegExpLiteral",
                    pattern: e1,
                    flags: t
                });
            }
            function logicalExpression(e1, t, r) {
                return (0, n.default)({
                    type: "LogicalExpression",
                    operator: e1,
                    left: t,
                    right: r
                });
            }
            function memberExpression(e1, t, r = false, s = null) {
                return (0, n.default)({
                    type: "MemberExpression",
                    object: e1,
                    property: t,
                    computed: r,
                    optional: s
                });
            }
            function newExpression(e1, t) {
                return (0, n.default)({
                    type: "NewExpression",
                    callee: e1,
                    arguments: t
                });
            }
            function program(e1, t = [], r = "script", s = null) {
                return (0, n.default)({
                    type: "Program",
                    body: e1,
                    directives: t,
                    sourceType: r,
                    interpreter: s,
                    sourceFile: null
                });
            }
            function objectExpression(e1) {
                return (0, n.default)({
                    type: "ObjectExpression",
                    properties: e1
                });
            }
            function objectMethod(e1 = "method", t, r, s, i = false, a = false, o = false) {
                return (0, n.default)({
                    type: "ObjectMethod",
                    kind: e1,
                    key: t,
                    params: r,
                    body: s,
                    computed: i,
                    generator: a,
                    async: o
                });
            }
            function objectProperty(e1, t, r = false, s = false, i = null) {
                return (0, n.default)({
                    type: "ObjectProperty",
                    key: e1,
                    value: t,
                    computed: r,
                    shorthand: s,
                    decorators: i
                });
            }
            function restElement(e1) {
                return (0, n.default)({
                    type: "RestElement",
                    argument: e1
                });
            }
            function returnStatement(e1 = null) {
                return (0, n.default)({
                    type: "ReturnStatement",
                    argument: e1
                });
            }
            function sequenceExpression(e1) {
                return (0, n.default)({
                    type: "SequenceExpression",
                    expressions: e1
                });
            }
            function parenthesizedExpression(e1) {
                return (0, n.default)({
                    type: "ParenthesizedExpression",
                    expression: e1
                });
            }
            function switchCase(e1 = null, t) {
                return (0, n.default)({
                    type: "SwitchCase",
                    test: e1,
                    consequent: t
                });
            }
            function switchStatement(e1, t) {
                return (0, n.default)({
                    type: "SwitchStatement",
                    discriminant: e1,
                    cases: t
                });
            }
            function thisExpression() {
                return {
                    type: "ThisExpression"
                };
            }
            function throwStatement(e1) {
                return (0, n.default)({
                    type: "ThrowStatement",
                    argument: e1
                });
            }
            function tryStatement(e1, t = null, r = null) {
                return (0, n.default)({
                    type: "TryStatement",
                    block: e1,
                    handler: t,
                    finalizer: r
                });
            }
            function unaryExpression(e1, t, r = true) {
                return (0, n.default)({
                    type: "UnaryExpression",
                    operator: e1,
                    argument: t,
                    prefix: r
                });
            }
            function updateExpression(e1, t, r = false) {
                return (0, n.default)({
                    type: "UpdateExpression",
                    operator: e1,
                    argument: t,
                    prefix: r
                });
            }
            function variableDeclaration(e1, t) {
                return (0, n.default)({
                    type: "VariableDeclaration",
                    kind: e1,
                    declarations: t
                });
            }
            function variableDeclarator(e1, t = null) {
                return (0, n.default)({
                    type: "VariableDeclarator",
                    id: e1,
                    init: t
                });
            }
            function whileStatement(e1, t) {
                return (0, n.default)({
                    type: "WhileStatement",
                    test: e1,
                    body: t
                });
            }
            function withStatement(e1, t) {
                return (0, n.default)({
                    type: "WithStatement",
                    object: e1,
                    body: t
                });
            }
            function assignmentPattern(e1, t) {
                return (0, n.default)({
                    type: "AssignmentPattern",
                    left: e1,
                    right: t
                });
            }
            function arrayPattern(e1) {
                return (0, n.default)({
                    type: "ArrayPattern",
                    elements: e1
                });
            }
            function arrowFunctionExpression(e1, t, r = false) {
                return (0, n.default)({
                    type: "ArrowFunctionExpression",
                    params: e1,
                    body: t,
                    async: r,
                    expression: null
                });
            }
            function classBody(e1) {
                return (0, n.default)({
                    type: "ClassBody",
                    body: e1
                });
            }
            function classExpression(e1 = null, t = null, r, s = null) {
                return (0, n.default)({
                    type: "ClassExpression",
                    id: e1,
                    superClass: t,
                    body: r,
                    decorators: s
                });
            }
            function classDeclaration(e1, t = null, r, s = null) {
                return (0, n.default)({
                    type: "ClassDeclaration",
                    id: e1,
                    superClass: t,
                    body: r,
                    decorators: s
                });
            }
            function exportAllDeclaration(e1) {
                return (0, n.default)({
                    type: "ExportAllDeclaration",
                    source: e1
                });
            }
            function exportDefaultDeclaration(e1) {
                return (0, n.default)({
                    type: "ExportDefaultDeclaration",
                    declaration: e1
                });
            }
            function exportNamedDeclaration(e1 = null, t = [], r = null) {
                return (0, n.default)({
                    type: "ExportNamedDeclaration",
                    declaration: e1,
                    specifiers: t,
                    source: r
                });
            }
            function exportSpecifier(e1, t) {
                return (0, n.default)({
                    type: "ExportSpecifier",
                    local: e1,
                    exported: t
                });
            }
            function forOfStatement(e1, t, r, s = false) {
                return (0, n.default)({
                    type: "ForOfStatement",
                    left: e1,
                    right: t,
                    body: r,
                    await: s
                });
            }
            function importDeclaration(e1, t) {
                return (0, n.default)({
                    type: "ImportDeclaration",
                    specifiers: e1,
                    source: t
                });
            }
            function importDefaultSpecifier(e1) {
                return (0, n.default)({
                    type: "ImportDefaultSpecifier",
                    local: e1
                });
            }
            function importNamespaceSpecifier(e1) {
                return (0, n.default)({
                    type: "ImportNamespaceSpecifier",
                    local: e1
                });
            }
            function importSpecifier(e1, t) {
                return (0, n.default)({
                    type: "ImportSpecifier",
                    local: e1,
                    imported: t
                });
            }
            function metaProperty(e1, t) {
                return (0, n.default)({
                    type: "MetaProperty",
                    meta: e1,
                    property: t
                });
            }
            function classMethod(e1 = "method", t, r, s, i = false, a = false, o = false, l = false) {
                return (0, n.default)({
                    type: "ClassMethod",
                    kind: e1,
                    key: t,
                    params: r,
                    body: s,
                    computed: i,
                    static: a,
                    generator: o,
                    async: l
                });
            }
            function objectPattern(e1) {
                return (0, n.default)({
                    type: "ObjectPattern",
                    properties: e1
                });
            }
            function spreadElement(e1) {
                return (0, n.default)({
                    type: "SpreadElement",
                    argument: e1
                });
            }
            function _super() {
                return {
                    type: "Super"
                };
            }
            function taggedTemplateExpression(e1, t) {
                return (0, n.default)({
                    type: "TaggedTemplateExpression",
                    tag: e1,
                    quasi: t
                });
            }
            function templateElement(e1, t = false) {
                return (0, n.default)({
                    type: "TemplateElement",
                    value: e1,
                    tail: t
                });
            }
            function templateLiteral(e1, t) {
                return (0, n.default)({
                    type: "TemplateLiteral",
                    quasis: e1,
                    expressions: t
                });
            }
            function yieldExpression(e1 = null, t = false) {
                return (0, n.default)({
                    type: "YieldExpression",
                    argument: e1,
                    delegate: t
                });
            }
            function awaitExpression(e1) {
                return (0, n.default)({
                    type: "AwaitExpression",
                    argument: e1
                });
            }
            function _import() {
                return {
                    type: "Import"
                };
            }
            function bigIntLiteral(e1) {
                return (0, n.default)({
                    type: "BigIntLiteral",
                    value: e1
                });
            }
            function exportNamespaceSpecifier(e1) {
                return (0, n.default)({
                    type: "ExportNamespaceSpecifier",
                    exported: e1
                });
            }
            function optionalMemberExpression(e1, t, r = false, s) {
                return (0, n.default)({
                    type: "OptionalMemberExpression",
                    object: e1,
                    property: t,
                    computed: r,
                    optional: s
                });
            }
            function optionalCallExpression(e1, t, r) {
                return (0, n.default)({
                    type: "OptionalCallExpression",
                    callee: e1,
                    arguments: t,
                    optional: r
                });
            }
            function classProperty(e1, t = null, r = null, s = null, i = false, a = false) {
                return (0, n.default)({
                    type: "ClassProperty",
                    key: e1,
                    value: t,
                    typeAnnotation: r,
                    decorators: s,
                    computed: i,
                    static: a
                });
            }
            function classAccessorProperty(e1, t = null, r = null, s = null, i = false, a = false) {
                return (0, n.default)({
                    type: "ClassAccessorProperty",
                    key: e1,
                    value: t,
                    typeAnnotation: r,
                    decorators: s,
                    computed: i,
                    static: a
                });
            }
            function classPrivateProperty(e1, t = null, r = null, s = false) {
                return (0, n.default)({
                    type: "ClassPrivateProperty",
                    key: e1,
                    value: t,
                    decorators: r,
                    static: s
                });
            }
            function classPrivateMethod(e1 = "method", t, r, s, i = false) {
                return (0, n.default)({
                    type: "ClassPrivateMethod",
                    kind: e1,
                    key: t,
                    params: r,
                    body: s,
                    static: i
                });
            }
            function privateName(e1) {
                return (0, n.default)({
                    type: "PrivateName",
                    id: e1
                });
            }
            function staticBlock(e1) {
                return (0, n.default)({
                    type: "StaticBlock",
                    body: e1
                });
            }
            function anyTypeAnnotation() {
                return {
                    type: "AnyTypeAnnotation"
                };
            }
            function arrayTypeAnnotation(e1) {
                return (0, n.default)({
                    type: "ArrayTypeAnnotation",
                    elementType: e1
                });
            }
            function booleanTypeAnnotation() {
                return {
                    type: "BooleanTypeAnnotation"
                };
            }
            function booleanLiteralTypeAnnotation(e1) {
                return (0, n.default)({
                    type: "BooleanLiteralTypeAnnotation",
                    value: e1
                });
            }
            function nullLiteralTypeAnnotation() {
                return {
                    type: "NullLiteralTypeAnnotation"
                };
            }
            function classImplements(e1, t = null) {
                return (0, n.default)({
                    type: "ClassImplements",
                    id: e1,
                    typeParameters: t
                });
            }
            function declareClass(e1, t = null, r = null, s) {
                return (0, n.default)({
                    type: "DeclareClass",
                    id: e1,
                    typeParameters: t,
                    extends: r,
                    body: s
                });
            }
            function declareFunction(e1) {
                return (0, n.default)({
                    type: "DeclareFunction",
                    id: e1
                });
            }
            function declareInterface(e1, t = null, r = null, s) {
                return (0, n.default)({
                    type: "DeclareInterface",
                    id: e1,
                    typeParameters: t,
                    extends: r,
                    body: s
                });
            }
            function declareModule(e1, t, r = null) {
                return (0, n.default)({
                    type: "DeclareModule",
                    id: e1,
                    body: t,
                    kind: r
                });
            }
            function declareModuleExports(e1) {
                return (0, n.default)({
                    type: "DeclareModuleExports",
                    typeAnnotation: e1
                });
            }
            function declareTypeAlias(e1, t = null, r) {
                return (0, n.default)({
                    type: "DeclareTypeAlias",
                    id: e1,
                    typeParameters: t,
                    right: r
                });
            }
            function declareOpaqueType(e1, t = null, r = null) {
                return (0, n.default)({
                    type: "DeclareOpaqueType",
                    id: e1,
                    typeParameters: t,
                    supertype: r
                });
            }
            function declareVariable(e1) {
                return (0, n.default)({
                    type: "DeclareVariable",
                    id: e1
                });
            }
            function declareExportDeclaration(e1 = null, t = null, r = null) {
                return (0, n.default)({
                    type: "DeclareExportDeclaration",
                    declaration: e1,
                    specifiers: t,
                    source: r
                });
            }
            function declareExportAllDeclaration(e1) {
                return (0, n.default)({
                    type: "DeclareExportAllDeclaration",
                    source: e1
                });
            }
            function declaredPredicate(e1) {
                return (0, n.default)({
                    type: "DeclaredPredicate",
                    value: e1
                });
            }
            function existsTypeAnnotation() {
                return {
                    type: "ExistsTypeAnnotation"
                };
            }
            function functionTypeAnnotation(e1 = null, t, r = null, s) {
                return (0, n.default)({
                    type: "FunctionTypeAnnotation",
                    typeParameters: e1,
                    params: t,
                    rest: r,
                    returnType: s
                });
            }
            function functionTypeParam(e1 = null, t) {
                return (0, n.default)({
                    type: "FunctionTypeParam",
                    name: e1,
                    typeAnnotation: t
                });
            }
            function genericTypeAnnotation(e1, t = null) {
                return (0, n.default)({
                    type: "GenericTypeAnnotation",
                    id: e1,
                    typeParameters: t
                });
            }
            function inferredPredicate() {
                return {
                    type: "InferredPredicate"
                };
            }
            function interfaceExtends(e1, t = null) {
                return (0, n.default)({
                    type: "InterfaceExtends",
                    id: e1,
                    typeParameters: t
                });
            }
            function interfaceDeclaration(e1, t = null, r = null, s) {
                return (0, n.default)({
                    type: "InterfaceDeclaration",
                    id: e1,
                    typeParameters: t,
                    extends: r,
                    body: s
                });
            }
            function interfaceTypeAnnotation(e1 = null, t) {
                return (0, n.default)({
                    type: "InterfaceTypeAnnotation",
                    extends: e1,
                    body: t
                });
            }
            function intersectionTypeAnnotation(e1) {
                return (0, n.default)({
                    type: "IntersectionTypeAnnotation",
                    types: e1
                });
            }
            function mixedTypeAnnotation() {
                return {
                    type: "MixedTypeAnnotation"
                };
            }
            function emptyTypeAnnotation() {
                return {
                    type: "EmptyTypeAnnotation"
                };
            }
            function nullableTypeAnnotation(e1) {
                return (0, n.default)({
                    type: "NullableTypeAnnotation",
                    typeAnnotation: e1
                });
            }
            function numberLiteralTypeAnnotation(e1) {
                return (0, n.default)({
                    type: "NumberLiteralTypeAnnotation",
                    value: e1
                });
            }
            function numberTypeAnnotation() {
                return {
                    type: "NumberTypeAnnotation"
                };
            }
            function objectTypeAnnotation(e1, t = [], r = [], s = [], i = false) {
                return (0, n.default)({
                    type: "ObjectTypeAnnotation",
                    properties: e1,
                    indexers: t,
                    callProperties: r,
                    internalSlots: s,
                    exact: i
                });
            }
            function objectTypeInternalSlot(e1, t, r, s, i) {
                return (0, n.default)({
                    type: "ObjectTypeInternalSlot",
                    id: e1,
                    value: t,
                    optional: r,
                    static: s,
                    method: i
                });
            }
            function objectTypeCallProperty(e1) {
                return (0, n.default)({
                    type: "ObjectTypeCallProperty",
                    value: e1,
                    static: null
                });
            }
            function objectTypeIndexer(e1 = null, t, r, s = null) {
                return (0, n.default)({
                    type: "ObjectTypeIndexer",
                    id: e1,
                    key: t,
                    value: r,
                    variance: s,
                    static: null
                });
            }
            function objectTypeProperty(e1, t, r = null) {
                return (0, n.default)({
                    type: "ObjectTypeProperty",
                    key: e1,
                    value: t,
                    variance: r,
                    kind: null,
                    method: null,
                    optional: null,
                    proto: null,
                    static: null
                });
            }
            function objectTypeSpreadProperty(e1) {
                return (0, n.default)({
                    type: "ObjectTypeSpreadProperty",
                    argument: e1
                });
            }
            function opaqueType(e1, t = null, r = null, s) {
                return (0, n.default)({
                    type: "OpaqueType",
                    id: e1,
                    typeParameters: t,
                    supertype: r,
                    impltype: s
                });
            }
            function qualifiedTypeIdentifier(e1, t) {
                return (0, n.default)({
                    type: "QualifiedTypeIdentifier",
                    id: e1,
                    qualification: t
                });
            }
            function stringLiteralTypeAnnotation(e1) {
                return (0, n.default)({
                    type: "StringLiteralTypeAnnotation",
                    value: e1
                });
            }
            function stringTypeAnnotation() {
                return {
                    type: "StringTypeAnnotation"
                };
            }
            function symbolTypeAnnotation() {
                return {
                    type: "SymbolTypeAnnotation"
                };
            }
            function thisTypeAnnotation() {
                return {
                    type: "ThisTypeAnnotation"
                };
            }
            function tupleTypeAnnotation(e1) {
                return (0, n.default)({
                    type: "TupleTypeAnnotation",
                    types: e1
                });
            }
            function typeofTypeAnnotation(e1) {
                return (0, n.default)({
                    type: "TypeofTypeAnnotation",
                    argument: e1
                });
            }
            function typeAlias(e1, t = null, r) {
                return (0, n.default)({
                    type: "TypeAlias",
                    id: e1,
                    typeParameters: t,
                    right: r
                });
            }
            function typeAnnotation(e1) {
                return (0, n.default)({
                    type: "TypeAnnotation",
                    typeAnnotation: e1
                });
            }
            function typeCastExpression(e1, t) {
                return (0, n.default)({
                    type: "TypeCastExpression",
                    expression: e1,
                    typeAnnotation: t
                });
            }
            function typeParameter(e1 = null, t = null, r = null) {
                return (0, n.default)({
                    type: "TypeParameter",
                    bound: e1,
                    default: t,
                    variance: r,
                    name: null
                });
            }
            function typeParameterDeclaration(e1) {
                return (0, n.default)({
                    type: "TypeParameterDeclaration",
                    params: e1
                });
            }
            function typeParameterInstantiation(e1) {
                return (0, n.default)({
                    type: "TypeParameterInstantiation",
                    params: e1
                });
            }
            function unionTypeAnnotation(e1) {
                return (0, n.default)({
                    type: "UnionTypeAnnotation",
                    types: e1
                });
            }
            function variance(e1) {
                return (0, n.default)({
                    type: "Variance",
                    kind: e1
                });
            }
            function voidTypeAnnotation() {
                return {
                    type: "VoidTypeAnnotation"
                };
            }
            function enumDeclaration(e1, t) {
                return (0, n.default)({
                    type: "EnumDeclaration",
                    id: e1,
                    body: t
                });
            }
            function enumBooleanBody(e1) {
                return (0, n.default)({
                    type: "EnumBooleanBody",
                    members: e1,
                    explicitType: null,
                    hasUnknownMembers: null
                });
            }
            function enumNumberBody(e1) {
                return (0, n.default)({
                    type: "EnumNumberBody",
                    members: e1,
                    explicitType: null,
                    hasUnknownMembers: null
                });
            }
            function enumStringBody(e1) {
                return (0, n.default)({
                    type: "EnumStringBody",
                    members: e1,
                    explicitType: null,
                    hasUnknownMembers: null
                });
            }
            function enumSymbolBody(e1) {
                return (0, n.default)({
                    type: "EnumSymbolBody",
                    members: e1,
                    hasUnknownMembers: null
                });
            }
            function enumBooleanMember(e1) {
                return (0, n.default)({
                    type: "EnumBooleanMember",
                    id: e1,
                    init: null
                });
            }
            function enumNumberMember(e1, t) {
                return (0, n.default)({
                    type: "EnumNumberMember",
                    id: e1,
                    init: t
                });
            }
            function enumStringMember(e1, t) {
                return (0, n.default)({
                    type: "EnumStringMember",
                    id: e1,
                    init: t
                });
            }
            function enumDefaultedMember(e1) {
                return (0, n.default)({
                    type: "EnumDefaultedMember",
                    id: e1
                });
            }
            function indexedAccessType(e1, t) {
                return (0, n.default)({
                    type: "IndexedAccessType",
                    objectType: e1,
                    indexType: t
                });
            }
            function optionalIndexedAccessType(e1, t) {
                return (0, n.default)({
                    type: "OptionalIndexedAccessType",
                    objectType: e1,
                    indexType: t,
                    optional: null
                });
            }
            function jsxAttribute(e1, t = null) {
                return (0, n.default)({
                    type: "JSXAttribute",
                    name: e1,
                    value: t
                });
            }
            function jsxClosingElement(e1) {
                return (0, n.default)({
                    type: "JSXClosingElement",
                    name: e1
                });
            }
            function jsxElement(e1, t = null, r, s = null) {
                return (0, n.default)({
                    type: "JSXElement",
                    openingElement: e1,
                    closingElement: t,
                    children: r,
                    selfClosing: s
                });
            }
            function jsxEmptyExpression() {
                return {
                    type: "JSXEmptyExpression"
                };
            }
            function jsxExpressionContainer(e1) {
                return (0, n.default)({
                    type: "JSXExpressionContainer",
                    expression: e1
                });
            }
            function jsxSpreadChild(e1) {
                return (0, n.default)({
                    type: "JSXSpreadChild",
                    expression: e1
                });
            }
            function jsxIdentifier(e1) {
                return (0, n.default)({
                    type: "JSXIdentifier",
                    name: e1
                });
            }
            function jsxMemberExpression(e1, t) {
                return (0, n.default)({
                    type: "JSXMemberExpression",
                    object: e1,
                    property: t
                });
            }
            function jsxNamespacedName(e1, t) {
                return (0, n.default)({
                    type: "JSXNamespacedName",
                    namespace: e1,
                    name: t
                });
            }
            function jsxOpeningElement(e1, t, r = false) {
                return (0, n.default)({
                    type: "JSXOpeningElement",
                    name: e1,
                    attributes: t,
                    selfClosing: r
                });
            }
            function jsxSpreadAttribute(e1) {
                return (0, n.default)({
                    type: "JSXSpreadAttribute",
                    argument: e1
                });
            }
            function jsxText(e1) {
                return (0, n.default)({
                    type: "JSXText",
                    value: e1
                });
            }
            function jsxFragment(e1, t, r) {
                return (0, n.default)({
                    type: "JSXFragment",
                    openingFragment: e1,
                    closingFragment: t,
                    children: r
                });
            }
            function jsxOpeningFragment() {
                return {
                    type: "JSXOpeningFragment"
                };
            }
            function jsxClosingFragment() {
                return {
                    type: "JSXClosingFragment"
                };
            }
            function noop() {
                return {
                    type: "Noop"
                };
            }
            function placeholder(e1, t) {
                return (0, n.default)({
                    type: "Placeholder",
                    expectedNode: e1,
                    name: t
                });
            }
            function v8IntrinsicIdentifier(e1) {
                return (0, n.default)({
                    type: "V8IntrinsicIdentifier",
                    name: e1
                });
            }
            function argumentPlaceholder() {
                return {
                    type: "ArgumentPlaceholder"
                };
            }
            function bindExpression(e1, t) {
                return (0, n.default)({
                    type: "BindExpression",
                    object: e1,
                    callee: t
                });
            }
            function importAttribute(e1, t) {
                return (0, n.default)({
                    type: "ImportAttribute",
                    key: e1,
                    value: t
                });
            }
            function decorator(e1) {
                return (0, n.default)({
                    type: "Decorator",
                    expression: e1
                });
            }
            function doExpression(e1, t = false) {
                return (0, n.default)({
                    type: "DoExpression",
                    body: e1,
                    async: t
                });
            }
            function exportDefaultSpecifier(e1) {
                return (0, n.default)({
                    type: "ExportDefaultSpecifier",
                    exported: e1
                });
            }
            function recordExpression(e1) {
                return (0, n.default)({
                    type: "RecordExpression",
                    properties: e1
                });
            }
            function tupleExpression(e1 = []) {
                return (0, n.default)({
                    type: "TupleExpression",
                    elements: e1
                });
            }
            function decimalLiteral(e1) {
                return (0, n.default)({
                    type: "DecimalLiteral",
                    value: e1
                });
            }
            function moduleExpression(e1) {
                return (0, n.default)({
                    type: "ModuleExpression",
                    body: e1
                });
            }
            function topicReference() {
                return {
                    type: "TopicReference"
                };
            }
            function pipelineTopicExpression(e1) {
                return (0, n.default)({
                    type: "PipelineTopicExpression",
                    expression: e1
                });
            }
            function pipelineBareFunction(e1) {
                return (0, n.default)({
                    type: "PipelineBareFunction",
                    callee: e1
                });
            }
            function pipelinePrimaryTopicReference() {
                return {
                    type: "PipelinePrimaryTopicReference"
                };
            }
            function tsParameterProperty(e1) {
                return (0, n.default)({
                    type: "TSParameterProperty",
                    parameter: e1
                });
            }
            function tsDeclareFunction(e1 = null, t = null, r, s = null) {
                return (0, n.default)({
                    type: "TSDeclareFunction",
                    id: e1,
                    typeParameters: t,
                    params: r,
                    returnType: s
                });
            }
            function tsDeclareMethod(e1 = null, t, r = null, s, i = null) {
                return (0, n.default)({
                    type: "TSDeclareMethod",
                    decorators: e1,
                    key: t,
                    typeParameters: r,
                    params: s,
                    returnType: i
                });
            }
            function tsQualifiedName(e1, t) {
                return (0, n.default)({
                    type: "TSQualifiedName",
                    left: e1,
                    right: t
                });
            }
            function tsCallSignatureDeclaration(e1 = null, t, r = null) {
                return (0, n.default)({
                    type: "TSCallSignatureDeclaration",
                    typeParameters: e1,
                    parameters: t,
                    typeAnnotation: r
                });
            }
            function tsConstructSignatureDeclaration(e1 = null, t, r = null) {
                return (0, n.default)({
                    type: "TSConstructSignatureDeclaration",
                    typeParameters: e1,
                    parameters: t,
                    typeAnnotation: r
                });
            }
            function tsPropertySignature(e1, t = null, r = null) {
                return (0, n.default)({
                    type: "TSPropertySignature",
                    key: e1,
                    typeAnnotation: t,
                    initializer: r,
                    kind: null
                });
            }
            function tsMethodSignature(e1, t = null, r, s = null) {
                return (0, n.default)({
                    type: "TSMethodSignature",
                    key: e1,
                    typeParameters: t,
                    parameters: r,
                    typeAnnotation: s,
                    kind: null
                });
            }
            function tsIndexSignature(e1, t = null) {
                return (0, n.default)({
                    type: "TSIndexSignature",
                    parameters: e1,
                    typeAnnotation: t
                });
            }
            function tsAnyKeyword() {
                return {
                    type: "TSAnyKeyword"
                };
            }
            function tsBooleanKeyword() {
                return {
                    type: "TSBooleanKeyword"
                };
            }
            function tsBigIntKeyword() {
                return {
                    type: "TSBigIntKeyword"
                };
            }
            function tsIntrinsicKeyword() {
                return {
                    type: "TSIntrinsicKeyword"
                };
            }
            function tsNeverKeyword() {
                return {
                    type: "TSNeverKeyword"
                };
            }
            function tsNullKeyword() {
                return {
                    type: "TSNullKeyword"
                };
            }
            function tsNumberKeyword() {
                return {
                    type: "TSNumberKeyword"
                };
            }
            function tsObjectKeyword() {
                return {
                    type: "TSObjectKeyword"
                };
            }
            function tsStringKeyword() {
                return {
                    type: "TSStringKeyword"
                };
            }
            function tsSymbolKeyword() {
                return {
                    type: "TSSymbolKeyword"
                };
            }
            function tsUndefinedKeyword() {
                return {
                    type: "TSUndefinedKeyword"
                };
            }
            function tsUnknownKeyword() {
                return {
                    type: "TSUnknownKeyword"
                };
            }
            function tsVoidKeyword() {
                return {
                    type: "TSVoidKeyword"
                };
            }
            function tsThisType() {
                return {
                    type: "TSThisType"
                };
            }
            function tsFunctionType(e1 = null, t, r = null) {
                return (0, n.default)({
                    type: "TSFunctionType",
                    typeParameters: e1,
                    parameters: t,
                    typeAnnotation: r
                });
            }
            function tsConstructorType(e1 = null, t, r = null) {
                return (0, n.default)({
                    type: "TSConstructorType",
                    typeParameters: e1,
                    parameters: t,
                    typeAnnotation: r
                });
            }
            function tsTypeReference(e1, t = null) {
                return (0, n.default)({
                    type: "TSTypeReference",
                    typeName: e1,
                    typeParameters: t
                });
            }
            function tsTypePredicate(e1, t = null, r = null) {
                return (0, n.default)({
                    type: "TSTypePredicate",
                    parameterName: e1,
                    typeAnnotation: t,
                    asserts: r
                });
            }
            function tsTypeQuery(e1, t = null) {
                return (0, n.default)({
                    type: "TSTypeQuery",
                    exprName: e1,
                    typeParameters: t
                });
            }
            function tsTypeLiteral(e1) {
                return (0, n.default)({
                    type: "TSTypeLiteral",
                    members: e1
                });
            }
            function tsArrayType(e1) {
                return (0, n.default)({
                    type: "TSArrayType",
                    elementType: e1
                });
            }
            function tsTupleType(e1) {
                return (0, n.default)({
                    type: "TSTupleType",
                    elementTypes: e1
                });
            }
            function tsOptionalType(e1) {
                return (0, n.default)({
                    type: "TSOptionalType",
                    typeAnnotation: e1
                });
            }
            function tsRestType(e1) {
                return (0, n.default)({
                    type: "TSRestType",
                    typeAnnotation: e1
                });
            }
            function tsNamedTupleMember(e1, t, r = false) {
                return (0, n.default)({
                    type: "TSNamedTupleMember",
                    label: e1,
                    elementType: t,
                    optional: r
                });
            }
            function tsUnionType(e1) {
                return (0, n.default)({
                    type: "TSUnionType",
                    types: e1
                });
            }
            function tsIntersectionType(e1) {
                return (0, n.default)({
                    type: "TSIntersectionType",
                    types: e1
                });
            }
            function tsConditionalType(e1, t, r, s) {
                return (0, n.default)({
                    type: "TSConditionalType",
                    checkType: e1,
                    extendsType: t,
                    trueType: r,
                    falseType: s
                });
            }
            function tsInferType(e1) {
                return (0, n.default)({
                    type: "TSInferType",
                    typeParameter: e1
                });
            }
            function tsParenthesizedType(e1) {
                return (0, n.default)({
                    type: "TSParenthesizedType",
                    typeAnnotation: e1
                });
            }
            function tsTypeOperator(e1) {
                return (0, n.default)({
                    type: "TSTypeOperator",
                    typeAnnotation: e1,
                    operator: null
                });
            }
            function tsIndexedAccessType(e1, t) {
                return (0, n.default)({
                    type: "TSIndexedAccessType",
                    objectType: e1,
                    indexType: t
                });
            }
            function tsMappedType(e1, t = null, r = null) {
                return (0, n.default)({
                    type: "TSMappedType",
                    typeParameter: e1,
                    typeAnnotation: t,
                    nameType: r
                });
            }
            function tsLiteralType(e1) {
                return (0, n.default)({
                    type: "TSLiteralType",
                    literal: e1
                });
            }
            function tsExpressionWithTypeArguments(e1, t = null) {
                return (0, n.default)({
                    type: "TSExpressionWithTypeArguments",
                    expression: e1,
                    typeParameters: t
                });
            }
            function tsInterfaceDeclaration(e1, t = null, r = null, s) {
                return (0, n.default)({
                    type: "TSInterfaceDeclaration",
                    id: e1,
                    typeParameters: t,
                    extends: r,
                    body: s
                });
            }
            function tsInterfaceBody(e1) {
                return (0, n.default)({
                    type: "TSInterfaceBody",
                    body: e1
                });
            }
            function tsTypeAliasDeclaration(e1, t = null, r) {
                return (0, n.default)({
                    type: "TSTypeAliasDeclaration",
                    id: e1,
                    typeParameters: t,
                    typeAnnotation: r
                });
            }
            function tsInstantiationExpression(e1, t = null) {
                return (0, n.default)({
                    type: "TSInstantiationExpression",
                    expression: e1,
                    typeParameters: t
                });
            }
            function tsAsExpression(e1, t) {
                return (0, n.default)({
                    type: "TSAsExpression",
                    expression: e1,
                    typeAnnotation: t
                });
            }
            function tsSatisfiesExpression(e1, t) {
                return (0, n.default)({
                    type: "TSSatisfiesExpression",
                    expression: e1,
                    typeAnnotation: t
                });
            }
            function tsTypeAssertion(e1, t) {
                return (0, n.default)({
                    type: "TSTypeAssertion",
                    typeAnnotation: e1,
                    expression: t
                });
            }
            function tsEnumDeclaration(e1, t) {
                return (0, n.default)({
                    type: "TSEnumDeclaration",
                    id: e1,
                    members: t
                });
            }
            function tsEnumMember(e1, t = null) {
                return (0, n.default)({
                    type: "TSEnumMember",
                    id: e1,
                    initializer: t
                });
            }
            function tsModuleDeclaration(e1, t) {
                return (0, n.default)({
                    type: "TSModuleDeclaration",
                    id: e1,
                    body: t
                });
            }
            function tsModuleBlock(e1) {
                return (0, n.default)({
                    type: "TSModuleBlock",
                    body: e1
                });
            }
            function tsImportType(e1, t = null, r = null) {
                return (0, n.default)({
                    type: "TSImportType",
                    argument: e1,
                    qualifier: t,
                    typeParameters: r
                });
            }
            function tsImportEqualsDeclaration(e1, t) {
                return (0, n.default)({
                    type: "TSImportEqualsDeclaration",
                    id: e1,
                    moduleReference: t,
                    isExport: null
                });
            }
            function tsExternalModuleReference(e1) {
                return (0, n.default)({
                    type: "TSExternalModuleReference",
                    expression: e1
                });
            }
            function tsNonNullExpression(e1) {
                return (0, n.default)({
                    type: "TSNonNullExpression",
                    expression: e1
                });
            }
            function tsExportAssignment(e1) {
                return (0, n.default)({
                    type: "TSExportAssignment",
                    expression: e1
                });
            }
            function tsNamespaceExportDeclaration(e1) {
                return (0, n.default)({
                    type: "TSNamespaceExportDeclaration",
                    id: e1
                });
            }
            function tsTypeAnnotation(e1) {
                return (0, n.default)({
                    type: "TSTypeAnnotation",
                    typeAnnotation: e1
                });
            }
            function tsTypeParameterInstantiation(e1) {
                return (0, n.default)({
                    type: "TSTypeParameterInstantiation",
                    params: e1
                });
            }
            function tsTypeParameterDeclaration(e1) {
                return (0, n.default)({
                    type: "TSTypeParameterDeclaration",
                    params: e1
                });
            }
            function tsTypeParameter(e1 = null, t = null, r) {
                return (0, n.default)({
                    type: "TSTypeParameter",
                    constraint: e1,
                    default: t,
                    name: r
                });
            }
            function NumberLiteral(e1) {
                (0, s.default)("NumberLiteral", "NumericLiteral", "The node type ");
                return numericLiteral(e1);
            }
            function RegexLiteral(e1, t = "") {
                (0, s.default)("RegexLiteral", "RegExpLiteral", "The node type ");
                return regExpLiteral(e1, t);
            }
            function RestProperty(e1) {
                (0, s.default)("RestProperty", "RestElement", "The node type ");
                return restElement(e1);
            }
            function SpreadProperty(e1) {
                (0, s.default)("SpreadProperty", "SpreadElement", "The node type ");
                return spreadElement(e1);
            }
        },
        8611: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "AnyTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.anyTypeAnnotation;
                }
            });
            Object.defineProperty(t, "ArgumentPlaceholder", {
                enumerable: true,
                get: function() {
                    return n.argumentPlaceholder;
                }
            });
            Object.defineProperty(t, "ArrayExpression", {
                enumerable: true,
                get: function() {
                    return n.arrayExpression;
                }
            });
            Object.defineProperty(t, "ArrayPattern", {
                enumerable: true,
                get: function() {
                    return n.arrayPattern;
                }
            });
            Object.defineProperty(t, "ArrayTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.arrayTypeAnnotation;
                }
            });
            Object.defineProperty(t, "ArrowFunctionExpression", {
                enumerable: true,
                get: function() {
                    return n.arrowFunctionExpression;
                }
            });
            Object.defineProperty(t, "AssignmentExpression", {
                enumerable: true,
                get: function() {
                    return n.assignmentExpression;
                }
            });
            Object.defineProperty(t, "AssignmentPattern", {
                enumerable: true,
                get: function() {
                    return n.assignmentPattern;
                }
            });
            Object.defineProperty(t, "AwaitExpression", {
                enumerable: true,
                get: function() {
                    return n.awaitExpression;
                }
            });
            Object.defineProperty(t, "BigIntLiteral", {
                enumerable: true,
                get: function() {
                    return n.bigIntLiteral;
                }
            });
            Object.defineProperty(t, "BinaryExpression", {
                enumerable: true,
                get: function() {
                    return n.binaryExpression;
                }
            });
            Object.defineProperty(t, "BindExpression", {
                enumerable: true,
                get: function() {
                    return n.bindExpression;
                }
            });
            Object.defineProperty(t, "BlockStatement", {
                enumerable: true,
                get: function() {
                    return n.blockStatement;
                }
            });
            Object.defineProperty(t, "BooleanLiteral", {
                enumerable: true,
                get: function() {
                    return n.booleanLiteral;
                }
            });
            Object.defineProperty(t, "BooleanLiteralTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.booleanLiteralTypeAnnotation;
                }
            });
            Object.defineProperty(t, "BooleanTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.booleanTypeAnnotation;
                }
            });
            Object.defineProperty(t, "BreakStatement", {
                enumerable: true,
                get: function() {
                    return n.breakStatement;
                }
            });
            Object.defineProperty(t, "CallExpression", {
                enumerable: true,
                get: function() {
                    return n.callExpression;
                }
            });
            Object.defineProperty(t, "CatchClause", {
                enumerable: true,
                get: function() {
                    return n.catchClause;
                }
            });
            Object.defineProperty(t, "ClassAccessorProperty", {
                enumerable: true,
                get: function() {
                    return n.classAccessorProperty;
                }
            });
            Object.defineProperty(t, "ClassBody", {
                enumerable: true,
                get: function() {
                    return n.classBody;
                }
            });
            Object.defineProperty(t, "ClassDeclaration", {
                enumerable: true,
                get: function() {
                    return n.classDeclaration;
                }
            });
            Object.defineProperty(t, "ClassExpression", {
                enumerable: true,
                get: function() {
                    return n.classExpression;
                }
            });
            Object.defineProperty(t, "ClassImplements", {
                enumerable: true,
                get: function() {
                    return n.classImplements;
                }
            });
            Object.defineProperty(t, "ClassMethod", {
                enumerable: true,
                get: function() {
                    return n.classMethod;
                }
            });
            Object.defineProperty(t, "ClassPrivateMethod", {
                enumerable: true,
                get: function() {
                    return n.classPrivateMethod;
                }
            });
            Object.defineProperty(t, "ClassPrivateProperty", {
                enumerable: true,
                get: function() {
                    return n.classPrivateProperty;
                }
            });
            Object.defineProperty(t, "ClassProperty", {
                enumerable: true,
                get: function() {
                    return n.classProperty;
                }
            });
            Object.defineProperty(t, "ConditionalExpression", {
                enumerable: true,
                get: function() {
                    return n.conditionalExpression;
                }
            });
            Object.defineProperty(t, "ContinueStatement", {
                enumerable: true,
                get: function() {
                    return n.continueStatement;
                }
            });
            Object.defineProperty(t, "DebuggerStatement", {
                enumerable: true,
                get: function() {
                    return n.debuggerStatement;
                }
            });
            Object.defineProperty(t, "DecimalLiteral", {
                enumerable: true,
                get: function() {
                    return n.decimalLiteral;
                }
            });
            Object.defineProperty(t, "DeclareClass", {
                enumerable: true,
                get: function() {
                    return n.declareClass;
                }
            });
            Object.defineProperty(t, "DeclareExportAllDeclaration", {
                enumerable: true,
                get: function() {
                    return n.declareExportAllDeclaration;
                }
            });
            Object.defineProperty(t, "DeclareExportDeclaration", {
                enumerable: true,
                get: function() {
                    return n.declareExportDeclaration;
                }
            });
            Object.defineProperty(t, "DeclareFunction", {
                enumerable: true,
                get: function() {
                    return n.declareFunction;
                }
            });
            Object.defineProperty(t, "DeclareInterface", {
                enumerable: true,
                get: function() {
                    return n.declareInterface;
                }
            });
            Object.defineProperty(t, "DeclareModule", {
                enumerable: true,
                get: function() {
                    return n.declareModule;
                }
            });
            Object.defineProperty(t, "DeclareModuleExports", {
                enumerable: true,
                get: function() {
                    return n.declareModuleExports;
                }
            });
            Object.defineProperty(t, "DeclareOpaqueType", {
                enumerable: true,
                get: function() {
                    return n.declareOpaqueType;
                }
            });
            Object.defineProperty(t, "DeclareTypeAlias", {
                enumerable: true,
                get: function() {
                    return n.declareTypeAlias;
                }
            });
            Object.defineProperty(t, "DeclareVariable", {
                enumerable: true,
                get: function() {
                    return n.declareVariable;
                }
            });
            Object.defineProperty(t, "DeclaredPredicate", {
                enumerable: true,
                get: function() {
                    return n.declaredPredicate;
                }
            });
            Object.defineProperty(t, "Decorator", {
                enumerable: true,
                get: function() {
                    return n.decorator;
                }
            });
            Object.defineProperty(t, "Directive", {
                enumerable: true,
                get: function() {
                    return n.directive;
                }
            });
            Object.defineProperty(t, "DirectiveLiteral", {
                enumerable: true,
                get: function() {
                    return n.directiveLiteral;
                }
            });
            Object.defineProperty(t, "DoExpression", {
                enumerable: true,
                get: function() {
                    return n.doExpression;
                }
            });
            Object.defineProperty(t, "DoWhileStatement", {
                enumerable: true,
                get: function() {
                    return n.doWhileStatement;
                }
            });
            Object.defineProperty(t, "EmptyStatement", {
                enumerable: true,
                get: function() {
                    return n.emptyStatement;
                }
            });
            Object.defineProperty(t, "EmptyTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.emptyTypeAnnotation;
                }
            });
            Object.defineProperty(t, "EnumBooleanBody", {
                enumerable: true,
                get: function() {
                    return n.enumBooleanBody;
                }
            });
            Object.defineProperty(t, "EnumBooleanMember", {
                enumerable: true,
                get: function() {
                    return n.enumBooleanMember;
                }
            });
            Object.defineProperty(t, "EnumDeclaration", {
                enumerable: true,
                get: function() {
                    return n.enumDeclaration;
                }
            });
            Object.defineProperty(t, "EnumDefaultedMember", {
                enumerable: true,
                get: function() {
                    return n.enumDefaultedMember;
                }
            });
            Object.defineProperty(t, "EnumNumberBody", {
                enumerable: true,
                get: function() {
                    return n.enumNumberBody;
                }
            });
            Object.defineProperty(t, "EnumNumberMember", {
                enumerable: true,
                get: function() {
                    return n.enumNumberMember;
                }
            });
            Object.defineProperty(t, "EnumStringBody", {
                enumerable: true,
                get: function() {
                    return n.enumStringBody;
                }
            });
            Object.defineProperty(t, "EnumStringMember", {
                enumerable: true,
                get: function() {
                    return n.enumStringMember;
                }
            });
            Object.defineProperty(t, "EnumSymbolBody", {
                enumerable: true,
                get: function() {
                    return n.enumSymbolBody;
                }
            });
            Object.defineProperty(t, "ExistsTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.existsTypeAnnotation;
                }
            });
            Object.defineProperty(t, "ExportAllDeclaration", {
                enumerable: true,
                get: function() {
                    return n.exportAllDeclaration;
                }
            });
            Object.defineProperty(t, "ExportDefaultDeclaration", {
                enumerable: true,
                get: function() {
                    return n.exportDefaultDeclaration;
                }
            });
            Object.defineProperty(t, "ExportDefaultSpecifier", {
                enumerable: true,
                get: function() {
                    return n.exportDefaultSpecifier;
                }
            });
            Object.defineProperty(t, "ExportNamedDeclaration", {
                enumerable: true,
                get: function() {
                    return n.exportNamedDeclaration;
                }
            });
            Object.defineProperty(t, "ExportNamespaceSpecifier", {
                enumerable: true,
                get: function() {
                    return n.exportNamespaceSpecifier;
                }
            });
            Object.defineProperty(t, "ExportSpecifier", {
                enumerable: true,
                get: function() {
                    return n.exportSpecifier;
                }
            });
            Object.defineProperty(t, "ExpressionStatement", {
                enumerable: true,
                get: function() {
                    return n.expressionStatement;
                }
            });
            Object.defineProperty(t, "File", {
                enumerable: true,
                get: function() {
                    return n.file;
                }
            });
            Object.defineProperty(t, "ForInStatement", {
                enumerable: true,
                get: function() {
                    return n.forInStatement;
                }
            });
            Object.defineProperty(t, "ForOfStatement", {
                enumerable: true,
                get: function() {
                    return n.forOfStatement;
                }
            });
            Object.defineProperty(t, "ForStatement", {
                enumerable: true,
                get: function() {
                    return n.forStatement;
                }
            });
            Object.defineProperty(t, "FunctionDeclaration", {
                enumerable: true,
                get: function() {
                    return n.functionDeclaration;
                }
            });
            Object.defineProperty(t, "FunctionExpression", {
                enumerable: true,
                get: function() {
                    return n.functionExpression;
                }
            });
            Object.defineProperty(t, "FunctionTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.functionTypeAnnotation;
                }
            });
            Object.defineProperty(t, "FunctionTypeParam", {
                enumerable: true,
                get: function() {
                    return n.functionTypeParam;
                }
            });
            Object.defineProperty(t, "GenericTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.genericTypeAnnotation;
                }
            });
            Object.defineProperty(t, "Identifier", {
                enumerable: true,
                get: function() {
                    return n.identifier;
                }
            });
            Object.defineProperty(t, "IfStatement", {
                enumerable: true,
                get: function() {
                    return n.ifStatement;
                }
            });
            Object.defineProperty(t, "Import", {
                enumerable: true,
                get: function() {
                    return n.import;
                }
            });
            Object.defineProperty(t, "ImportAttribute", {
                enumerable: true,
                get: function() {
                    return n.importAttribute;
                }
            });
            Object.defineProperty(t, "ImportDeclaration", {
                enumerable: true,
                get: function() {
                    return n.importDeclaration;
                }
            });
            Object.defineProperty(t, "ImportDefaultSpecifier", {
                enumerable: true,
                get: function() {
                    return n.importDefaultSpecifier;
                }
            });
            Object.defineProperty(t, "ImportNamespaceSpecifier", {
                enumerable: true,
                get: function() {
                    return n.importNamespaceSpecifier;
                }
            });
            Object.defineProperty(t, "ImportSpecifier", {
                enumerable: true,
                get: function() {
                    return n.importSpecifier;
                }
            });
            Object.defineProperty(t, "IndexedAccessType", {
                enumerable: true,
                get: function() {
                    return n.indexedAccessType;
                }
            });
            Object.defineProperty(t, "InferredPredicate", {
                enumerable: true,
                get: function() {
                    return n.inferredPredicate;
                }
            });
            Object.defineProperty(t, "InterfaceDeclaration", {
                enumerable: true,
                get: function() {
                    return n.interfaceDeclaration;
                }
            });
            Object.defineProperty(t, "InterfaceExtends", {
                enumerable: true,
                get: function() {
                    return n.interfaceExtends;
                }
            });
            Object.defineProperty(t, "InterfaceTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.interfaceTypeAnnotation;
                }
            });
            Object.defineProperty(t, "InterpreterDirective", {
                enumerable: true,
                get: function() {
                    return n.interpreterDirective;
                }
            });
            Object.defineProperty(t, "IntersectionTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.intersectionTypeAnnotation;
                }
            });
            Object.defineProperty(t, "JSXAttribute", {
                enumerable: true,
                get: function() {
                    return n.jsxAttribute;
                }
            });
            Object.defineProperty(t, "JSXClosingElement", {
                enumerable: true,
                get: function() {
                    return n.jsxClosingElement;
                }
            });
            Object.defineProperty(t, "JSXClosingFragment", {
                enumerable: true,
                get: function() {
                    return n.jsxClosingFragment;
                }
            });
            Object.defineProperty(t, "JSXElement", {
                enumerable: true,
                get: function() {
                    return n.jsxElement;
                }
            });
            Object.defineProperty(t, "JSXEmptyExpression", {
                enumerable: true,
                get: function() {
                    return n.jsxEmptyExpression;
                }
            });
            Object.defineProperty(t, "JSXExpressionContainer", {
                enumerable: true,
                get: function() {
                    return n.jsxExpressionContainer;
                }
            });
            Object.defineProperty(t, "JSXFragment", {
                enumerable: true,
                get: function() {
                    return n.jsxFragment;
                }
            });
            Object.defineProperty(t, "JSXIdentifier", {
                enumerable: true,
                get: function() {
                    return n.jsxIdentifier;
                }
            });
            Object.defineProperty(t, "JSXMemberExpression", {
                enumerable: true,
                get: function() {
                    return n.jsxMemberExpression;
                }
            });
            Object.defineProperty(t, "JSXNamespacedName", {
                enumerable: true,
                get: function() {
                    return n.jsxNamespacedName;
                }
            });
            Object.defineProperty(t, "JSXOpeningElement", {
                enumerable: true,
                get: function() {
                    return n.jsxOpeningElement;
                }
            });
            Object.defineProperty(t, "JSXOpeningFragment", {
                enumerable: true,
                get: function() {
                    return n.jsxOpeningFragment;
                }
            });
            Object.defineProperty(t, "JSXSpreadAttribute", {
                enumerable: true,
                get: function() {
                    return n.jsxSpreadAttribute;
                }
            });
            Object.defineProperty(t, "JSXSpreadChild", {
                enumerable: true,
                get: function() {
                    return n.jsxSpreadChild;
                }
            });
            Object.defineProperty(t, "JSXText", {
                enumerable: true,
                get: function() {
                    return n.jsxText;
                }
            });
            Object.defineProperty(t, "LabeledStatement", {
                enumerable: true,
                get: function() {
                    return n.labeledStatement;
                }
            });
            Object.defineProperty(t, "LogicalExpression", {
                enumerable: true,
                get: function() {
                    return n.logicalExpression;
                }
            });
            Object.defineProperty(t, "MemberExpression", {
                enumerable: true,
                get: function() {
                    return n.memberExpression;
                }
            });
            Object.defineProperty(t, "MetaProperty", {
                enumerable: true,
                get: function() {
                    return n.metaProperty;
                }
            });
            Object.defineProperty(t, "MixedTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.mixedTypeAnnotation;
                }
            });
            Object.defineProperty(t, "ModuleExpression", {
                enumerable: true,
                get: function() {
                    return n.moduleExpression;
                }
            });
            Object.defineProperty(t, "NewExpression", {
                enumerable: true,
                get: function() {
                    return n.newExpression;
                }
            });
            Object.defineProperty(t, "Noop", {
                enumerable: true,
                get: function() {
                    return n.noop;
                }
            });
            Object.defineProperty(t, "NullLiteral", {
                enumerable: true,
                get: function() {
                    return n.nullLiteral;
                }
            });
            Object.defineProperty(t, "NullLiteralTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.nullLiteralTypeAnnotation;
                }
            });
            Object.defineProperty(t, "NullableTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.nullableTypeAnnotation;
                }
            });
            Object.defineProperty(t, "NumberLiteral", {
                enumerable: true,
                get: function() {
                    return n.numberLiteral;
                }
            });
            Object.defineProperty(t, "NumberLiteralTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.numberLiteralTypeAnnotation;
                }
            });
            Object.defineProperty(t, "NumberTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.numberTypeAnnotation;
                }
            });
            Object.defineProperty(t, "NumericLiteral", {
                enumerable: true,
                get: function() {
                    return n.numericLiteral;
                }
            });
            Object.defineProperty(t, "ObjectExpression", {
                enumerable: true,
                get: function() {
                    return n.objectExpression;
                }
            });
            Object.defineProperty(t, "ObjectMethod", {
                enumerable: true,
                get: function() {
                    return n.objectMethod;
                }
            });
            Object.defineProperty(t, "ObjectPattern", {
                enumerable: true,
                get: function() {
                    return n.objectPattern;
                }
            });
            Object.defineProperty(t, "ObjectProperty", {
                enumerable: true,
                get: function() {
                    return n.objectProperty;
                }
            });
            Object.defineProperty(t, "ObjectTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.objectTypeAnnotation;
                }
            });
            Object.defineProperty(t, "ObjectTypeCallProperty", {
                enumerable: true,
                get: function() {
                    return n.objectTypeCallProperty;
                }
            });
            Object.defineProperty(t, "ObjectTypeIndexer", {
                enumerable: true,
                get: function() {
                    return n.objectTypeIndexer;
                }
            });
            Object.defineProperty(t, "ObjectTypeInternalSlot", {
                enumerable: true,
                get: function() {
                    return n.objectTypeInternalSlot;
                }
            });
            Object.defineProperty(t, "ObjectTypeProperty", {
                enumerable: true,
                get: function() {
                    return n.objectTypeProperty;
                }
            });
            Object.defineProperty(t, "ObjectTypeSpreadProperty", {
                enumerable: true,
                get: function() {
                    return n.objectTypeSpreadProperty;
                }
            });
            Object.defineProperty(t, "OpaqueType", {
                enumerable: true,
                get: function() {
                    return n.opaqueType;
                }
            });
            Object.defineProperty(t, "OptionalCallExpression", {
                enumerable: true,
                get: function() {
                    return n.optionalCallExpression;
                }
            });
            Object.defineProperty(t, "OptionalIndexedAccessType", {
                enumerable: true,
                get: function() {
                    return n.optionalIndexedAccessType;
                }
            });
            Object.defineProperty(t, "OptionalMemberExpression", {
                enumerable: true,
                get: function() {
                    return n.optionalMemberExpression;
                }
            });
            Object.defineProperty(t, "ParenthesizedExpression", {
                enumerable: true,
                get: function() {
                    return n.parenthesizedExpression;
                }
            });
            Object.defineProperty(t, "PipelineBareFunction", {
                enumerable: true,
                get: function() {
                    return n.pipelineBareFunction;
                }
            });
            Object.defineProperty(t, "PipelinePrimaryTopicReference", {
                enumerable: true,
                get: function() {
                    return n.pipelinePrimaryTopicReference;
                }
            });
            Object.defineProperty(t, "PipelineTopicExpression", {
                enumerable: true,
                get: function() {
                    return n.pipelineTopicExpression;
                }
            });
            Object.defineProperty(t, "Placeholder", {
                enumerable: true,
                get: function() {
                    return n.placeholder;
                }
            });
            Object.defineProperty(t, "PrivateName", {
                enumerable: true,
                get: function() {
                    return n.privateName;
                }
            });
            Object.defineProperty(t, "Program", {
                enumerable: true,
                get: function() {
                    return n.program;
                }
            });
            Object.defineProperty(t, "QualifiedTypeIdentifier", {
                enumerable: true,
                get: function() {
                    return n.qualifiedTypeIdentifier;
                }
            });
            Object.defineProperty(t, "RecordExpression", {
                enumerable: true,
                get: function() {
                    return n.recordExpression;
                }
            });
            Object.defineProperty(t, "RegExpLiteral", {
                enumerable: true,
                get: function() {
                    return n.regExpLiteral;
                }
            });
            Object.defineProperty(t, "RegexLiteral", {
                enumerable: true,
                get: function() {
                    return n.regexLiteral;
                }
            });
            Object.defineProperty(t, "RestElement", {
                enumerable: true,
                get: function() {
                    return n.restElement;
                }
            });
            Object.defineProperty(t, "RestProperty", {
                enumerable: true,
                get: function() {
                    return n.restProperty;
                }
            });
            Object.defineProperty(t, "ReturnStatement", {
                enumerable: true,
                get: function() {
                    return n.returnStatement;
                }
            });
            Object.defineProperty(t, "SequenceExpression", {
                enumerable: true,
                get: function() {
                    return n.sequenceExpression;
                }
            });
            Object.defineProperty(t, "SpreadElement", {
                enumerable: true,
                get: function() {
                    return n.spreadElement;
                }
            });
            Object.defineProperty(t, "SpreadProperty", {
                enumerable: true,
                get: function() {
                    return n.spreadProperty;
                }
            });
            Object.defineProperty(t, "StaticBlock", {
                enumerable: true,
                get: function() {
                    return n.staticBlock;
                }
            });
            Object.defineProperty(t, "StringLiteral", {
                enumerable: true,
                get: function() {
                    return n.stringLiteral;
                }
            });
            Object.defineProperty(t, "StringLiteralTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.stringLiteralTypeAnnotation;
                }
            });
            Object.defineProperty(t, "StringTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.stringTypeAnnotation;
                }
            });
            Object.defineProperty(t, "Super", {
                enumerable: true,
                get: function() {
                    return n.super;
                }
            });
            Object.defineProperty(t, "SwitchCase", {
                enumerable: true,
                get: function() {
                    return n.switchCase;
                }
            });
            Object.defineProperty(t, "SwitchStatement", {
                enumerable: true,
                get: function() {
                    return n.switchStatement;
                }
            });
            Object.defineProperty(t, "SymbolTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.symbolTypeAnnotation;
                }
            });
            Object.defineProperty(t, "TSAnyKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsAnyKeyword;
                }
            });
            Object.defineProperty(t, "TSArrayType", {
                enumerable: true,
                get: function() {
                    return n.tsArrayType;
                }
            });
            Object.defineProperty(t, "TSAsExpression", {
                enumerable: true,
                get: function() {
                    return n.tsAsExpression;
                }
            });
            Object.defineProperty(t, "TSBigIntKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsBigIntKeyword;
                }
            });
            Object.defineProperty(t, "TSBooleanKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsBooleanKeyword;
                }
            });
            Object.defineProperty(t, "TSCallSignatureDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsCallSignatureDeclaration;
                }
            });
            Object.defineProperty(t, "TSConditionalType", {
                enumerable: true,
                get: function() {
                    return n.tsConditionalType;
                }
            });
            Object.defineProperty(t, "TSConstructSignatureDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsConstructSignatureDeclaration;
                }
            });
            Object.defineProperty(t, "TSConstructorType", {
                enumerable: true,
                get: function() {
                    return n.tsConstructorType;
                }
            });
            Object.defineProperty(t, "TSDeclareFunction", {
                enumerable: true,
                get: function() {
                    return n.tsDeclareFunction;
                }
            });
            Object.defineProperty(t, "TSDeclareMethod", {
                enumerable: true,
                get: function() {
                    return n.tsDeclareMethod;
                }
            });
            Object.defineProperty(t, "TSEnumDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsEnumDeclaration;
                }
            });
            Object.defineProperty(t, "TSEnumMember", {
                enumerable: true,
                get: function() {
                    return n.tsEnumMember;
                }
            });
            Object.defineProperty(t, "TSExportAssignment", {
                enumerable: true,
                get: function() {
                    return n.tsExportAssignment;
                }
            });
            Object.defineProperty(t, "TSExpressionWithTypeArguments", {
                enumerable: true,
                get: function() {
                    return n.tsExpressionWithTypeArguments;
                }
            });
            Object.defineProperty(t, "TSExternalModuleReference", {
                enumerable: true,
                get: function() {
                    return n.tsExternalModuleReference;
                }
            });
            Object.defineProperty(t, "TSFunctionType", {
                enumerable: true,
                get: function() {
                    return n.tsFunctionType;
                }
            });
            Object.defineProperty(t, "TSImportEqualsDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsImportEqualsDeclaration;
                }
            });
            Object.defineProperty(t, "TSImportType", {
                enumerable: true,
                get: function() {
                    return n.tsImportType;
                }
            });
            Object.defineProperty(t, "TSIndexSignature", {
                enumerable: true,
                get: function() {
                    return n.tsIndexSignature;
                }
            });
            Object.defineProperty(t, "TSIndexedAccessType", {
                enumerable: true,
                get: function() {
                    return n.tsIndexedAccessType;
                }
            });
            Object.defineProperty(t, "TSInferType", {
                enumerable: true,
                get: function() {
                    return n.tsInferType;
                }
            });
            Object.defineProperty(t, "TSInstantiationExpression", {
                enumerable: true,
                get: function() {
                    return n.tsInstantiationExpression;
                }
            });
            Object.defineProperty(t, "TSInterfaceBody", {
                enumerable: true,
                get: function() {
                    return n.tsInterfaceBody;
                }
            });
            Object.defineProperty(t, "TSInterfaceDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsInterfaceDeclaration;
                }
            });
            Object.defineProperty(t, "TSIntersectionType", {
                enumerable: true,
                get: function() {
                    return n.tsIntersectionType;
                }
            });
            Object.defineProperty(t, "TSIntrinsicKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsIntrinsicKeyword;
                }
            });
            Object.defineProperty(t, "TSLiteralType", {
                enumerable: true,
                get: function() {
                    return n.tsLiteralType;
                }
            });
            Object.defineProperty(t, "TSMappedType", {
                enumerable: true,
                get: function() {
                    return n.tsMappedType;
                }
            });
            Object.defineProperty(t, "TSMethodSignature", {
                enumerable: true,
                get: function() {
                    return n.tsMethodSignature;
                }
            });
            Object.defineProperty(t, "TSModuleBlock", {
                enumerable: true,
                get: function() {
                    return n.tsModuleBlock;
                }
            });
            Object.defineProperty(t, "TSModuleDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsModuleDeclaration;
                }
            });
            Object.defineProperty(t, "TSNamedTupleMember", {
                enumerable: true,
                get: function() {
                    return n.tsNamedTupleMember;
                }
            });
            Object.defineProperty(t, "TSNamespaceExportDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsNamespaceExportDeclaration;
                }
            });
            Object.defineProperty(t, "TSNeverKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsNeverKeyword;
                }
            });
            Object.defineProperty(t, "TSNonNullExpression", {
                enumerable: true,
                get: function() {
                    return n.tsNonNullExpression;
                }
            });
            Object.defineProperty(t, "TSNullKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsNullKeyword;
                }
            });
            Object.defineProperty(t, "TSNumberKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsNumberKeyword;
                }
            });
            Object.defineProperty(t, "TSObjectKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsObjectKeyword;
                }
            });
            Object.defineProperty(t, "TSOptionalType", {
                enumerable: true,
                get: function() {
                    return n.tsOptionalType;
                }
            });
            Object.defineProperty(t, "TSParameterProperty", {
                enumerable: true,
                get: function() {
                    return n.tsParameterProperty;
                }
            });
            Object.defineProperty(t, "TSParenthesizedType", {
                enumerable: true,
                get: function() {
                    return n.tsParenthesizedType;
                }
            });
            Object.defineProperty(t, "TSPropertySignature", {
                enumerable: true,
                get: function() {
                    return n.tsPropertySignature;
                }
            });
            Object.defineProperty(t, "TSQualifiedName", {
                enumerable: true,
                get: function() {
                    return n.tsQualifiedName;
                }
            });
            Object.defineProperty(t, "TSRestType", {
                enumerable: true,
                get: function() {
                    return n.tsRestType;
                }
            });
            Object.defineProperty(t, "TSSatisfiesExpression", {
                enumerable: true,
                get: function() {
                    return n.tsSatisfiesExpression;
                }
            });
            Object.defineProperty(t, "TSStringKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsStringKeyword;
                }
            });
            Object.defineProperty(t, "TSSymbolKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsSymbolKeyword;
                }
            });
            Object.defineProperty(t, "TSThisType", {
                enumerable: true,
                get: function() {
                    return n.tsThisType;
                }
            });
            Object.defineProperty(t, "TSTupleType", {
                enumerable: true,
                get: function() {
                    return n.tsTupleType;
                }
            });
            Object.defineProperty(t, "TSTypeAliasDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsTypeAliasDeclaration;
                }
            });
            Object.defineProperty(t, "TSTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.tsTypeAnnotation;
                }
            });
            Object.defineProperty(t, "TSTypeAssertion", {
                enumerable: true,
                get: function() {
                    return n.tsTypeAssertion;
                }
            });
            Object.defineProperty(t, "TSTypeLiteral", {
                enumerable: true,
                get: function() {
                    return n.tsTypeLiteral;
                }
            });
            Object.defineProperty(t, "TSTypeOperator", {
                enumerable: true,
                get: function() {
                    return n.tsTypeOperator;
                }
            });
            Object.defineProperty(t, "TSTypeParameter", {
                enumerable: true,
                get: function() {
                    return n.tsTypeParameter;
                }
            });
            Object.defineProperty(t, "TSTypeParameterDeclaration", {
                enumerable: true,
                get: function() {
                    return n.tsTypeParameterDeclaration;
                }
            });
            Object.defineProperty(t, "TSTypeParameterInstantiation", {
                enumerable: true,
                get: function() {
                    return n.tsTypeParameterInstantiation;
                }
            });
            Object.defineProperty(t, "TSTypePredicate", {
                enumerable: true,
                get: function() {
                    return n.tsTypePredicate;
                }
            });
            Object.defineProperty(t, "TSTypeQuery", {
                enumerable: true,
                get: function() {
                    return n.tsTypeQuery;
                }
            });
            Object.defineProperty(t, "TSTypeReference", {
                enumerable: true,
                get: function() {
                    return n.tsTypeReference;
                }
            });
            Object.defineProperty(t, "TSUndefinedKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsUndefinedKeyword;
                }
            });
            Object.defineProperty(t, "TSUnionType", {
                enumerable: true,
                get: function() {
                    return n.tsUnionType;
                }
            });
            Object.defineProperty(t, "TSUnknownKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsUnknownKeyword;
                }
            });
            Object.defineProperty(t, "TSVoidKeyword", {
                enumerable: true,
                get: function() {
                    return n.tsVoidKeyword;
                }
            });
            Object.defineProperty(t, "TaggedTemplateExpression", {
                enumerable: true,
                get: function() {
                    return n.taggedTemplateExpression;
                }
            });
            Object.defineProperty(t, "TemplateElement", {
                enumerable: true,
                get: function() {
                    return n.templateElement;
                }
            });
            Object.defineProperty(t, "TemplateLiteral", {
                enumerable: true,
                get: function() {
                    return n.templateLiteral;
                }
            });
            Object.defineProperty(t, "ThisExpression", {
                enumerable: true,
                get: function() {
                    return n.thisExpression;
                }
            });
            Object.defineProperty(t, "ThisTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.thisTypeAnnotation;
                }
            });
            Object.defineProperty(t, "ThrowStatement", {
                enumerable: true,
                get: function() {
                    return n.throwStatement;
                }
            });
            Object.defineProperty(t, "TopicReference", {
                enumerable: true,
                get: function() {
                    return n.topicReference;
                }
            });
            Object.defineProperty(t, "TryStatement", {
                enumerable: true,
                get: function() {
                    return n.tryStatement;
                }
            });
            Object.defineProperty(t, "TupleExpression", {
                enumerable: true,
                get: function() {
                    return n.tupleExpression;
                }
            });
            Object.defineProperty(t, "TupleTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.tupleTypeAnnotation;
                }
            });
            Object.defineProperty(t, "TypeAlias", {
                enumerable: true,
                get: function() {
                    return n.typeAlias;
                }
            });
            Object.defineProperty(t, "TypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.typeAnnotation;
                }
            });
            Object.defineProperty(t, "TypeCastExpression", {
                enumerable: true,
                get: function() {
                    return n.typeCastExpression;
                }
            });
            Object.defineProperty(t, "TypeParameter", {
                enumerable: true,
                get: function() {
                    return n.typeParameter;
                }
            });
            Object.defineProperty(t, "TypeParameterDeclaration", {
                enumerable: true,
                get: function() {
                    return n.typeParameterDeclaration;
                }
            });
            Object.defineProperty(t, "TypeParameterInstantiation", {
                enumerable: true,
                get: function() {
                    return n.typeParameterInstantiation;
                }
            });
            Object.defineProperty(t, "TypeofTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.typeofTypeAnnotation;
                }
            });
            Object.defineProperty(t, "UnaryExpression", {
                enumerable: true,
                get: function() {
                    return n.unaryExpression;
                }
            });
            Object.defineProperty(t, "UnionTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.unionTypeAnnotation;
                }
            });
            Object.defineProperty(t, "UpdateExpression", {
                enumerable: true,
                get: function() {
                    return n.updateExpression;
                }
            });
            Object.defineProperty(t, "V8IntrinsicIdentifier", {
                enumerable: true,
                get: function() {
                    return n.v8IntrinsicIdentifier;
                }
            });
            Object.defineProperty(t, "VariableDeclaration", {
                enumerable: true,
                get: function() {
                    return n.variableDeclaration;
                }
            });
            Object.defineProperty(t, "VariableDeclarator", {
                enumerable: true,
                get: function() {
                    return n.variableDeclarator;
                }
            });
            Object.defineProperty(t, "Variance", {
                enumerable: true,
                get: function() {
                    return n.variance;
                }
            });
            Object.defineProperty(t, "VoidTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return n.voidTypeAnnotation;
                }
            });
            Object.defineProperty(t, "WhileStatement", {
                enumerable: true,
                get: function() {
                    return n.whileStatement;
                }
            });
            Object.defineProperty(t, "WithStatement", {
                enumerable: true,
                get: function() {
                    return n.withStatement;
                }
            });
            Object.defineProperty(t, "YieldExpression", {
                enumerable: true,
                get: function() {
                    return n.yieldExpression;
                }
            });
            var n = r(7453);
        },
        4371: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = buildChildren;
            var n = r(601);
            var s = r(9187);
            function buildChildren(e1) {
                const t = [];
                for(let r = 0; r < e1.children.length; r++){
                    let i = e1.children[r];
                    if ((0, n.isJSXText)(i)) {
                        (0, s.default)(i, t);
                        continue;
                    }
                    if ((0, n.isJSXExpressionContainer)(i)) i = i.expression;
                    if ((0, n.isJSXEmptyExpression)(i)) continue;
                    t.push(i);
                }
                return t;
            }
        },
        8130: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = createTSUnionType;
            var n = r(7453);
            var s = r(1093);
            var i = r(601);
            function createTSUnionType(e1) {
                const t = e1.map((e1)=>(0, i.isTSTypeAnnotation)(e1) ? e1.typeAnnotation : e1);
                const r = (0, s.default)(t);
                if (r.length === 1) {
                    return r[0];
                } else {
                    return (0, n.tsUnionType)(r);
                }
            }
        },
        7170: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = validateNode;
            var n = r(4439);
            var s = r(776);
            function validateNode(e1) {
                const t = s.BUILDER_KEYS[e1.type];
                for (const r of t){
                    (0, n.default)(e1, r, e1[r]);
                }
                return e1;
            }
        },
        7653: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = clone;
            var n = r(7290);
            function clone(e1) {
                return (0, n.default)(e1, false);
            }
        },
        8853: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = cloneDeep;
            var n = r(7290);
            function cloneDeep(e1) {
                return (0, n.default)(e1);
            }
        },
        3198: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = cloneDeepWithoutLoc;
            var n = r(7290);
            function cloneDeepWithoutLoc(e1) {
                return (0, n.default)(e1, true, true);
            }
        },
        7290: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = cloneNode;
            var n = r(7940);
            var s = r(601);
            const i = Function.call.bind(Object.prototype.hasOwnProperty);
            function cloneIfNode(e1, t, r, n) {
                if (e1 && typeof e1.type === "string") {
                    return cloneNodeInternal(e1, t, r, n);
                }
                return e1;
            }
            function cloneIfNodeOrArray(e1, t, r, n) {
                if (Array.isArray(e1)) {
                    return e1.map((e1)=>cloneIfNode(e1, t, r, n));
                }
                return cloneIfNode(e1, t, r, n);
            }
            function cloneNode(e1, t = true, r = false) {
                return cloneNodeInternal(e1, t, r, new Map);
            }
            function cloneNodeInternal(e1, t = true, r = false, a) {
                if (!e1) return e1;
                const { type: o } = e1;
                const l = {
                    type: e1.type
                };
                if ((0, s.isIdentifier)(e1)) {
                    l.name = e1.name;
                    if (i(e1, "optional") && typeof e1.optional === "boolean") {
                        l.optional = e1.optional;
                    }
                    if (i(e1, "typeAnnotation")) {
                        l.typeAnnotation = t ? cloneIfNodeOrArray(e1.typeAnnotation, true, r, a) : e1.typeAnnotation;
                    }
                } else if (!i(n.NODE_FIELDS, o)) {
                    throw new Error(`Unknown node type: "${o}"`);
                } else {
                    for (const c of Object.keys(n.NODE_FIELDS[o])){
                        if (i(e1, c)) {
                            if (t) {
                                l[c] = (0, s.isFile)(e1) && c === "comments" ? maybeCloneComments(e1.comments, t, r, a) : cloneIfNodeOrArray(e1[c], true, r, a);
                            } else {
                                l[c] = e1[c];
                            }
                        }
                    }
                }
                if (i(e1, "loc")) {
                    if (r) {
                        l.loc = null;
                    } else {
                        l.loc = e1.loc;
                    }
                }
                if (i(e1, "leadingComments")) {
                    l.leadingComments = maybeCloneComments(e1.leadingComments, t, r, a);
                }
                if (i(e1, "innerComments")) {
                    l.innerComments = maybeCloneComments(e1.innerComments, t, r, a);
                }
                if (i(e1, "trailingComments")) {
                    l.trailingComments = maybeCloneComments(e1.trailingComments, t, r, a);
                }
                if (i(e1, "extra")) {
                    l.extra = Object.assign({}, e1.extra);
                }
                return l;
            }
            function maybeCloneComments(e1, t, r, n) {
                if (!e1 || !t) {
                    return e1;
                }
                return e1.map((e1)=>{
                    const t = n.get(e1);
                    if (t) return t;
                    const { type: s, value: i, loc: a } = e1;
                    const o = {
                        type: s,
                        value: i,
                        loc: a
                    };
                    if (r) {
                        o.loc = null;
                    }
                    n.set(e1, o);
                    return o;
                });
            }
        },
        764: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = cloneWithoutLoc;
            var n = r(7290);
            function cloneWithoutLoc(e1) {
                return (0, n.default)(e1, false, true);
            }
        },
        2217: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = addComment;
            var n = r(7777);
            function addComment(e1, t, r, s) {
                return (0, n.default)(e1, t, [
                    {
                        type: s ? "CommentLine" : "CommentBlock",
                        value: r
                    }
                ]);
            }
        },
        7777: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = addComments;
            function addComments(e1, t, r) {
                if (!r || !e1) return e1;
                const n = `${t}Comments`;
                if (e1[n]) {
                    if (t === "leading") {
                        e1[n] = r.concat(e1[n]);
                    } else {
                        e1[n].push(...r);
                    }
                } else {
                    e1[n] = r;
                }
                return e1;
            }
        },
        2324: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = inheritInnerComments;
            var n = r(1066);
            function inheritInnerComments(e1, t) {
                (0, n.default)("innerComments", e1, t);
            }
        },
        4570: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = inheritLeadingComments;
            var n = r(1066);
            function inheritLeadingComments(e1, t) {
                (0, n.default)("leadingComments", e1, t);
            }
        },
        7720: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = inheritTrailingComments;
            var n = r(1066);
            function inheritTrailingComments(e1, t) {
                (0, n.default)("trailingComments", e1, t);
            }
        },
        8727: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = inheritsComments;
            var n = r(7720);
            var s = r(4570);
            var i = r(2324);
            function inheritsComments(e1, t) {
                (0, n.default)(e1, t);
                (0, s.default)(e1, t);
                (0, i.default)(e1, t);
                return e1;
            }
        },
        2320: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = removeComments;
            var n = r(4152);
            function removeComments(e1) {
                n.COMMENT_KEYS.forEach((t)=>{
                    e1[t] = null;
                });
                return e1;
            }
        },
        4300: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.WHILE_TYPES = t.USERWHITESPACABLE_TYPES = t.UNARYLIKE_TYPES = t.TYPESCRIPT_TYPES = t.TSTYPE_TYPES = t.TSTYPEELEMENT_TYPES = t.TSENTITYNAME_TYPES = t.TSBASETYPE_TYPES = t.TERMINATORLESS_TYPES = t.STATEMENT_TYPES = t.STANDARDIZED_TYPES = t.SCOPABLE_TYPES = t.PUREISH_TYPES = t.PROPERTY_TYPES = t.PRIVATE_TYPES = t.PATTERN_TYPES = t.PATTERNLIKE_TYPES = t.OBJECTMEMBER_TYPES = t.MODULESPECIFIER_TYPES = t.MODULEDECLARATION_TYPES = t.MISCELLANEOUS_TYPES = t.METHOD_TYPES = t.LVAL_TYPES = t.LOOP_TYPES = t.LITERAL_TYPES = t.JSX_TYPES = t.IMPORTOREXPORTDECLARATION_TYPES = t.IMMUTABLE_TYPES = t.FUNCTION_TYPES = t.FUNCTIONPARENT_TYPES = t.FOR_TYPES = t.FORXSTATEMENT_TYPES = t.FLOW_TYPES = t.FLOWTYPE_TYPES = t.FLOWPREDICATE_TYPES = t.FLOWDECLARATION_TYPES = t.FLOWBASEANNOTATION_TYPES = t.EXPRESSION_TYPES = t.EXPRESSIONWRAPPER_TYPES = t.EXPORTDECLARATION_TYPES = t.ENUMMEMBER_TYPES = t.ENUMBODY_TYPES = t.DECLARATION_TYPES = t.CONDITIONAL_TYPES = t.COMPLETIONSTATEMENT_TYPES = t.CLASS_TYPES = t.BLOCK_TYPES = t.BLOCKPARENT_TYPES = t.BINARY_TYPES = t.ACCESSOR_TYPES = void 0;
            var n = r(7940);
            const s = n.FLIPPED_ALIAS_KEYS["Standardized"];
            t.STANDARDIZED_TYPES = s;
            const i = n.FLIPPED_ALIAS_KEYS["Expression"];
            t.EXPRESSION_TYPES = i;
            const a = n.FLIPPED_ALIAS_KEYS["Binary"];
            t.BINARY_TYPES = a;
            const o = n.FLIPPED_ALIAS_KEYS["Scopable"];
            t.SCOPABLE_TYPES = o;
            const l = n.FLIPPED_ALIAS_KEYS["BlockParent"];
            t.BLOCKPARENT_TYPES = l;
            const c = n.FLIPPED_ALIAS_KEYS["Block"];
            t.BLOCK_TYPES = c;
            const u = n.FLIPPED_ALIAS_KEYS["Statement"];
            t.STATEMENT_TYPES = u;
            const p = n.FLIPPED_ALIAS_KEYS["Terminatorless"];
            t.TERMINATORLESS_TYPES = p;
            const f = n.FLIPPED_ALIAS_KEYS["CompletionStatement"];
            t.COMPLETIONSTATEMENT_TYPES = f;
            const d = n.FLIPPED_ALIAS_KEYS["Conditional"];
            t.CONDITIONAL_TYPES = d;
            const h = n.FLIPPED_ALIAS_KEYS["Loop"];
            t.LOOP_TYPES = h;
            const m = n.FLIPPED_ALIAS_KEYS["While"];
            t.WHILE_TYPES = m;
            const y = n.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
            t.EXPRESSIONWRAPPER_TYPES = y;
            const g = n.FLIPPED_ALIAS_KEYS["For"];
            t.FOR_TYPES = g;
            const b = n.FLIPPED_ALIAS_KEYS["ForXStatement"];
            t.FORXSTATEMENT_TYPES = b;
            const T = n.FLIPPED_ALIAS_KEYS["Function"];
            t.FUNCTION_TYPES = T;
            const S = n.FLIPPED_ALIAS_KEYS["FunctionParent"];
            t.FUNCTIONPARENT_TYPES = S;
            const E = n.FLIPPED_ALIAS_KEYS["Pureish"];
            t.PUREISH_TYPES = E;
            const v = n.FLIPPED_ALIAS_KEYS["Declaration"];
            t.DECLARATION_TYPES = v;
            const x = n.FLIPPED_ALIAS_KEYS["PatternLike"];
            t.PATTERNLIKE_TYPES = x;
            const P = n.FLIPPED_ALIAS_KEYS["LVal"];
            t.LVAL_TYPES = P;
            const w = n.FLIPPED_ALIAS_KEYS["TSEntityName"];
            t.TSENTITYNAME_TYPES = w;
            const A = n.FLIPPED_ALIAS_KEYS["Literal"];
            t.LITERAL_TYPES = A;
            const C = n.FLIPPED_ALIAS_KEYS["Immutable"];
            t.IMMUTABLE_TYPES = C;
            const I = n.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
            t.USERWHITESPACABLE_TYPES = I;
            const O = n.FLIPPED_ALIAS_KEYS["Method"];
            t.METHOD_TYPES = O;
            const k = n.FLIPPED_ALIAS_KEYS["ObjectMember"];
            t.OBJECTMEMBER_TYPES = k;
            const N = n.FLIPPED_ALIAS_KEYS["Property"];
            t.PROPERTY_TYPES = N;
            const _ = n.FLIPPED_ALIAS_KEYS["UnaryLike"];
            t.UNARYLIKE_TYPES = _;
            const D = n.FLIPPED_ALIAS_KEYS["Pattern"];
            t.PATTERN_TYPES = D;
            const M = n.FLIPPED_ALIAS_KEYS["Class"];
            t.CLASS_TYPES = M;
            const L = n.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
            t.IMPORTOREXPORTDECLARATION_TYPES = L;
            const j = n.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
            t.EXPORTDECLARATION_TYPES = j;
            const F = n.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
            t.MODULESPECIFIER_TYPES = F;
            const R = n.FLIPPED_ALIAS_KEYS["Accessor"];
            t.ACCESSOR_TYPES = R;
            const B = n.FLIPPED_ALIAS_KEYS["Private"];
            t.PRIVATE_TYPES = B;
            const U = n.FLIPPED_ALIAS_KEYS["Flow"];
            t.FLOW_TYPES = U;
            const K = n.FLIPPED_ALIAS_KEYS["FlowType"];
            t.FLOWTYPE_TYPES = K;
            const V = n.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
            t.FLOWBASEANNOTATION_TYPES = V;
            const W = n.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
            t.FLOWDECLARATION_TYPES = W;
            const $ = n.FLIPPED_ALIAS_KEYS["FlowPredicate"];
            t.FLOWPREDICATE_TYPES = $;
            const q = n.FLIPPED_ALIAS_KEYS["EnumBody"];
            t.ENUMBODY_TYPES = q;
            const H = n.FLIPPED_ALIAS_KEYS["EnumMember"];
            t.ENUMMEMBER_TYPES = H;
            const G = n.FLIPPED_ALIAS_KEYS["JSX"];
            t.JSX_TYPES = G;
            const J = n.FLIPPED_ALIAS_KEYS["Miscellaneous"];
            t.MISCELLANEOUS_TYPES = J;
            const X = n.FLIPPED_ALIAS_KEYS["TypeScript"];
            t.TYPESCRIPT_TYPES = X;
            const z = n.FLIPPED_ALIAS_KEYS["TSTypeElement"];
            t.TSTYPEELEMENT_TYPES = z;
            const Y = n.FLIPPED_ALIAS_KEYS["TSType"];
            t.TSTYPE_TYPES = Y;
            const Q = n.FLIPPED_ALIAS_KEYS["TSBaseType"];
            t.TSBASETYPE_TYPES = Q;
            const Z = L;
            t.MODULEDECLARATION_TYPES = Z;
        },
        4152: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.UPDATE_OPERATORS = t.UNARY_OPERATORS = t.STRING_UNARY_OPERATORS = t.STATEMENT_OR_BLOCK_KEYS = t.NUMBER_UNARY_OPERATORS = t.NUMBER_BINARY_OPERATORS = t.NOT_LOCAL_BINDING = t.LOGICAL_OPERATORS = t.INHERIT_KEYS = t.FOR_INIT_KEYS = t.FLATTENABLE_KEYS = t.EQUALITY_BINARY_OPERATORS = t.COMPARISON_BINARY_OPERATORS = t.COMMENT_KEYS = t.BOOLEAN_UNARY_OPERATORS = t.BOOLEAN_NUMBER_BINARY_OPERATORS = t.BOOLEAN_BINARY_OPERATORS = t.BLOCK_SCOPED_SYMBOL = t.BINARY_OPERATORS = t.ASSIGNMENT_OPERATORS = void 0;
            const r = [
                "consequent",
                "body",
                "alternate"
            ];
            t.STATEMENT_OR_BLOCK_KEYS = r;
            const n = [
                "body",
                "expressions"
            ];
            t.FLATTENABLE_KEYS = n;
            const s = [
                "left",
                "init"
            ];
            t.FOR_INIT_KEYS = s;
            const i = [
                "leadingComments",
                "trailingComments",
                "innerComments"
            ];
            t.COMMENT_KEYS = i;
            const a = [
                "||",
                "&&",
                "??"
            ];
            t.LOGICAL_OPERATORS = a;
            const o = [
                "++",
                "--"
            ];
            t.UPDATE_OPERATORS = o;
            const l = [
                ">",
                "<",
                ">=",
                "<="
            ];
            t.BOOLEAN_NUMBER_BINARY_OPERATORS = l;
            const c = [
                "==",
                "===",
                "!=",
                "!=="
            ];
            t.EQUALITY_BINARY_OPERATORS = c;
            const u = [
                ...c,
                "in",
                "instanceof"
            ];
            t.COMPARISON_BINARY_OPERATORS = u;
            const p = [
                ...u,
                ...l
            ];
            t.BOOLEAN_BINARY_OPERATORS = p;
            const f = [
                "-",
                "/",
                "%",
                "*",
                "**",
                "&",
                "|",
                ">>",
                ">>>",
                "<<",
                "^"
            ];
            t.NUMBER_BINARY_OPERATORS = f;
            const d = [
                "+",
                ...f,
                ...p,
                "|>"
            ];
            t.BINARY_OPERATORS = d;
            const h = [
                "=",
                "+=",
                ...f.map((e1)=>e1 + "="),
                ...a.map((e1)=>e1 + "=")
            ];
            t.ASSIGNMENT_OPERATORS = h;
            const m = [
                "delete",
                "!"
            ];
            t.BOOLEAN_UNARY_OPERATORS = m;
            const y = [
                "+",
                "-",
                "~"
            ];
            t.NUMBER_UNARY_OPERATORS = y;
            const g = [
                "typeof"
            ];
            t.STRING_UNARY_OPERATORS = g;
            const b = [
                "void",
                "throw",
                ...m,
                ...y,
                ...g
            ];
            t.UNARY_OPERATORS = b;
            const T = {
                optional: [
                    "typeAnnotation",
                    "typeParameters",
                    "returnType"
                ],
                force: [
                    "start",
                    "loc",
                    "end"
                ]
            };
            t.INHERIT_KEYS = T;
            const S = Symbol.for("var used to be block scoped");
            t.BLOCK_SCOPED_SYMBOL = S;
            const E = Symbol.for("should not be considered a local binding");
            t.NOT_LOCAL_BINDING = E;
        },
        1846: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = ensureBlock;
            var n = r(3763);
            function ensureBlock(e1, t = "body") {
                const r = (0, n.default)(e1[t], e1);
                e1[t] = r;
                return r;
            }
        },
        2855: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = gatherSequenceExpressions;
            var n = r(6332);
            var s = r(601);
            var i = r(7453);
            var a = r(7290);
            function gatherSequenceExpressions(e1, t, r) {
                const o = [];
                let l = true;
                for (const c of e1){
                    if (!(0, s.isEmptyStatement)(c)) {
                        l = false;
                    }
                    if ((0, s.isExpression)(c)) {
                        o.push(c);
                    } else if ((0, s.isExpressionStatement)(c)) {
                        o.push(c.expression);
                    } else if ((0, s.isVariableDeclaration)(c)) {
                        if (c.kind !== "var") return;
                        for (const e1 of c.declarations){
                            const t = (0, n.default)(e1);
                            for (const e1 of Object.keys(t)){
                                r.push({
                                    kind: c.kind,
                                    id: (0, a.default)(t[e1])
                                });
                            }
                            if (e1.init) {
                                o.push((0, i.assignmentExpression)("=", e1.id, e1.init));
                            }
                        }
                        l = true;
                    } else if ((0, s.isIfStatement)(c)) {
                        const e1 = c.consequent ? gatherSequenceExpressions([
                            c.consequent
                        ], t, r) : t.buildUndefinedNode();
                        const n = c.alternate ? gatherSequenceExpressions([
                            c.alternate
                        ], t, r) : t.buildUndefinedNode();
                        if (!e1 || !n) return;
                        o.push((0, i.conditionalExpression)(c.test, e1, n));
                    } else if ((0, s.isBlockStatement)(c)) {
                        const e1 = gatherSequenceExpressions(c.body, t, r);
                        if (!e1) return;
                        o.push(e1);
                    } else if ((0, s.isEmptyStatement)(c)) {
                        if (e1.indexOf(c) === 0) {
                            l = true;
                        }
                    } else {
                        return;
                    }
                }
                if (l) {
                    o.push(t.buildUndefinedNode());
                }
                if (o.length === 1) {
                    return o[0];
                } else {
                    return (0, i.sequenceExpression)(o);
                }
            }
        },
        1642: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = toBindingIdentifierName;
            var n = r(5842);
            function toBindingIdentifierName(e1) {
                e1 = (0, n.default)(e1);
                if (e1 === "eval" || e1 === "arguments") e1 = "_" + e1;
                return e1;
            }
        },
        3763: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = toBlock;
            var n = r(601);
            var s = r(7453);
            function toBlock(e1, t) {
                if ((0, n.isBlockStatement)(e1)) {
                    return e1;
                }
                let r = [];
                if ((0, n.isEmptyStatement)(e1)) {
                    r = [];
                } else {
                    if (!(0, n.isStatement)(e1)) {
                        if ((0, n.isFunction)(t)) {
                            e1 = (0, s.returnStatement)(e1);
                        } else {
                            e1 = (0, s.expressionStatement)(e1);
                        }
                    }
                    r = [
                        e1
                    ];
                }
                return (0, s.blockStatement)(r);
            }
        },
        8564: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = toComputedKey;
            var n = r(601);
            var s = r(7453);
            function toComputedKey(e1, t = e1.key || e1.property) {
                if (!e1.computed && (0, n.isIdentifier)(t)) t = (0, s.stringLiteral)(t.name);
                return t;
            }
        },
        4409: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(601);
            var s = toExpression;
            t["default"] = s;
            function toExpression(e1) {
                if ((0, n.isExpressionStatement)(e1)) {
                    e1 = e1.expression;
                }
                if ((0, n.isExpression)(e1)) {
                    return e1;
                }
                if ((0, n.isClass)(e1)) {
                    e1.type = "ClassExpression";
                } else if ((0, n.isFunction)(e1)) {
                    e1.type = "FunctionExpression";
                }
                if (!(0, n.isExpression)(e1)) {
                    throw new Error(`cannot turn ${e1.type} to an expression`);
                }
                return e1;
            }
        },
        5842: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = toIdentifier;
            var n = r(6488);
            var s = r(4975);
            function toIdentifier(e1) {
                e1 = e1 + "";
                let t = "";
                for (const r of e1){
                    t += (0, s.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
                }
                t = t.replace(/^[-0-9]+/, "");
                t = t.replace(/[-\s]+(.)?/g, function(e1, t) {
                    return t ? t.toUpperCase() : "";
                });
                if (!(0, n.default)(t)) {
                    t = `_${t}`;
                }
                return t || "_";
            }
        },
        8136: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = toKeyAlias;
            var n = r(601);
            var s = r(7290);
            var i = r(2510);
            function toKeyAlias(e1, t = e1.key) {
                let r;
                if (e1.kind === "method") {
                    return toKeyAlias.increment() + "";
                } else if ((0, n.isIdentifier)(t)) {
                    r = t.name;
                } else if ((0, n.isStringLiteral)(t)) {
                    r = JSON.stringify(t.value);
                } else {
                    r = JSON.stringify((0, i.default)((0, s.default)(t)));
                }
                if (e1.computed) {
                    r = `[${r}]`;
                }
                if (e1.static) {
                    r = `static:${r}`;
                }
                return r;
            }
            toKeyAlias.uid = 0;
            toKeyAlias.increment = function() {
                if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
                    return toKeyAlias.uid = 0;
                } else {
                    return toKeyAlias.uid++;
                }
            };
        },
        3541: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = toSequenceExpression;
            var n = r(2855);
            function toSequenceExpression(e1, t) {
                if (!(e1 != null && e1.length)) return;
                const r = [];
                const s = (0, n.default)(e1, t, r);
                if (!s) return;
                for (const e1 of r){
                    t.push(e1);
                }
                return s;
            }
        },
        5678: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(601);
            var s = r(7453);
            var i = toStatement;
            t["default"] = i;
            function toStatement(e1, t) {
                if ((0, n.isStatement)(e1)) {
                    return e1;
                }
                let r = false;
                let i;
                if ((0, n.isClass)(e1)) {
                    r = true;
                    i = "ClassDeclaration";
                } else if ((0, n.isFunction)(e1)) {
                    r = true;
                    i = "FunctionDeclaration";
                } else if ((0, n.isAssignmentExpression)(e1)) {
                    return (0, s.expressionStatement)(e1);
                }
                if (r && !e1.id) {
                    i = false;
                }
                if (!i) {
                    if (t) {
                        return false;
                    } else {
                        throw new Error(`cannot turn ${e1.type} to a statement`);
                    }
                }
                e1.type = i;
                return e1;
            }
        },
        2576: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(6488);
            var s = r(7453);
            var i = valueToNode;
            t["default"] = i;
            const a = Function.call.bind(Object.prototype.toString);
            function isRegExp(e1) {
                return a(e1) === "[object RegExp]";
            }
            function isPlainObject(e1) {
                if (typeof e1 !== "object" || e1 === null || Object.prototype.toString.call(e1) !== "[object Object]") {
                    return false;
                }
                const t = Object.getPrototypeOf(e1);
                return t === null || Object.getPrototypeOf(t) === null;
            }
            function valueToNode(e1) {
                if (e1 === undefined) {
                    return (0, s.identifier)("undefined");
                }
                if (e1 === true || e1 === false) {
                    return (0, s.booleanLiteral)(e1);
                }
                if (e1 === null) {
                    return (0, s.nullLiteral)();
                }
                if (typeof e1 === "string") {
                    return (0, s.stringLiteral)(e1);
                }
                if (typeof e1 === "number") {
                    let t;
                    if (Number.isFinite(e1)) {
                        t = (0, s.numericLiteral)(Math.abs(e1));
                    } else {
                        let r;
                        if (Number.isNaN(e1)) {
                            r = (0, s.numericLiteral)(0);
                        } else {
                            r = (0, s.numericLiteral)(1);
                        }
                        t = (0, s.binaryExpression)("/", r, (0, s.numericLiteral)(0));
                    }
                    if (e1 < 0 || Object.is(e1, -0)) {
                        t = (0, s.unaryExpression)("-", t);
                    }
                    return t;
                }
                if (isRegExp(e1)) {
                    const t = e1.source;
                    const r = e1.toString().match(/\/([a-z]+|)$/)[1];
                    return (0, s.regExpLiteral)(t, r);
                }
                if (Array.isArray(e1)) {
                    return (0, s.arrayExpression)(e1.map(valueToNode));
                }
                if (isPlainObject(e1)) {
                    const t = [];
                    for (const r of Object.keys(e1)){
                        let i;
                        if ((0, n.default)(r)) {
                            i = (0, s.identifier)(r);
                        } else {
                            i = (0, s.stringLiteral)(r);
                        }
                        t.push((0, s.objectProperty)(i, valueToNode(e1[r])));
                    }
                    return (0, s.objectExpression)(t);
                }
                throw new Error("don't know how to turn this value into a node");
            }
        },
        8013: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.patternLikeCommon = t.functionTypeAnnotationCommon = t.functionDeclarationCommon = t.functionCommon = t.classMethodOrPropertyCommon = t.classMethodOrDeclareMethodCommon = void 0;
            var n = r(9247);
            var s = r(6488);
            var i = r(4975);
            var a = r(6476);
            var o = r(4152);
            var l = r(3706);
            const c = (0, l.defineAliasedType)("Standardized");
            c("ArrayExpression", {
                fields: {
                    elements: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
                        default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
                    }
                },
                visitor: [
                    "elements"
                ],
                aliases: [
                    "Expression"
                ]
            });
            c("AssignmentExpression", {
                fields: {
                    operator: {
                        validate: function() {
                            if (!process.env.BABEL_TYPES_8_BREAKING) {
                                return (0, l.assertValueType)("string");
                            }
                            const e1 = (0, l.assertOneOf)(...o.ASSIGNMENT_OPERATORS);
                            const t = (0, l.assertOneOf)("=");
                            return function(r, s, i) {
                                const a = (0, n.default)("Pattern", r.left) ? t : e1;
                                a(r, s, i);
                            };
                        }()
                    },
                    left: {
                        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("LVal") : (0, l.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
                    },
                    right: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                },
                builder: [
                    "operator",
                    "left",
                    "right"
                ],
                visitor: [
                    "left",
                    "right"
                ],
                aliases: [
                    "Expression"
                ]
            });
            c("BinaryExpression", {
                builder: [
                    "operator",
                    "left",
                    "right"
                ],
                fields: {
                    operator: {
                        validate: (0, l.assertOneOf)(...o.BINARY_OPERATORS)
                    },
                    left: {
                        validate: function() {
                            const e1 = (0, l.assertNodeType)("Expression");
                            const t = (0, l.assertNodeType)("Expression", "PrivateName");
                            const r = Object.assign(function(r, n, s) {
                                const i = r.operator === "in" ? t : e1;
                                i(r, n, s);
                            }, {
                                oneOfNodeTypes: [
                                    "Expression",
                                    "PrivateName"
                                ]
                            });
                            return r;
                        }()
                    },
                    right: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                },
                visitor: [
                    "left",
                    "right"
                ],
                aliases: [
                    "Binary",
                    "Expression"
                ]
            });
            c("InterpreterDirective", {
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, l.assertValueType)("string")
                    }
                }
            });
            c("Directive", {
                visitor: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, l.assertNodeType)("DirectiveLiteral")
                    }
                }
            });
            c("DirectiveLiteral", {
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, l.assertValueType)("string")
                    }
                }
            });
            c("BlockStatement", {
                builder: [
                    "body",
                    "directives"
                ],
                visitor: [
                    "directives",
                    "body"
                ],
                fields: {
                    directives: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Directive"))),
                        default: []
                    },
                    body: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Statement")))
                    }
                },
                aliases: [
                    "Scopable",
                    "BlockParent",
                    "Block",
                    "Statement"
                ]
            });
            c("BreakStatement", {
                visitor: [
                    "label"
                ],
                fields: {
                    label: {
                        validate: (0, l.assertNodeType)("Identifier"),
                        optional: true
                    }
                },
                aliases: [
                    "Statement",
                    "Terminatorless",
                    "CompletionStatement"
                ]
            });
            c("CallExpression", {
                visitor: [
                    "callee",
                    "arguments",
                    "typeParameters",
                    "typeArguments"
                ],
                builder: [
                    "callee",
                    "arguments"
                ],
                aliases: [
                    "Expression"
                ],
                fields: Object.assign({
                    callee: {
                        validate: (0, l.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
                    },
                    arguments: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
                    }
                }, !process.env.BABEL_TYPES_8_BREAKING ? {
                    optional: {
                        validate: (0, l.assertOneOf)(true, false),
                        optional: true
                    }
                } : {}, {
                    typeArguments: {
                        validate: (0, l.assertNodeType)("TypeParameterInstantiation"),
                        optional: true
                    },
                    typeParameters: {
                        validate: (0, l.assertNodeType)("TSTypeParameterInstantiation"),
                        optional: true
                    }
                })
            });
            c("CatchClause", {
                visitor: [
                    "param",
                    "body"
                ],
                fields: {
                    param: {
                        validate: (0, l.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
                        optional: true
                    },
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement")
                    }
                },
                aliases: [
                    "Scopable",
                    "BlockParent"
                ]
            });
            c("ConditionalExpression", {
                visitor: [
                    "test",
                    "consequent",
                    "alternate"
                ],
                fields: {
                    test: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    consequent: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    alternate: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                },
                aliases: [
                    "Expression",
                    "Conditional"
                ]
            });
            c("ContinueStatement", {
                visitor: [
                    "label"
                ],
                fields: {
                    label: {
                        validate: (0, l.assertNodeType)("Identifier"),
                        optional: true
                    }
                },
                aliases: [
                    "Statement",
                    "Terminatorless",
                    "CompletionStatement"
                ]
            });
            c("DebuggerStatement", {
                aliases: [
                    "Statement"
                ]
            });
            c("DoWhileStatement", {
                visitor: [
                    "test",
                    "body"
                ],
                fields: {
                    test: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    }
                },
                aliases: [
                    "Statement",
                    "BlockParent",
                    "Loop",
                    "While",
                    "Scopable"
                ]
            });
            c("EmptyStatement", {
                aliases: [
                    "Statement"
                ]
            });
            c("ExpressionStatement", {
                visitor: [
                    "expression"
                ],
                fields: {
                    expression: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                },
                aliases: [
                    "Statement",
                    "ExpressionWrapper"
                ]
            });
            c("File", {
                builder: [
                    "program",
                    "comments",
                    "tokens"
                ],
                visitor: [
                    "program"
                ],
                fields: {
                    program: {
                        validate: (0, l.assertNodeType)("Program")
                    },
                    comments: {
                        validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(()=>{}, {
                            each: {
                                oneOfNodeTypes: [
                                    "CommentBlock",
                                    "CommentLine"
                                ]
                            }
                        }) : (0, l.assertEach)((0, l.assertNodeType)("CommentBlock", "CommentLine")),
                        optional: true
                    },
                    tokens: {
                        validate: (0, l.assertEach)(Object.assign(()=>{}, {
                            type: "any"
                        })),
                        optional: true
                    }
                }
            });
            c("ForInStatement", {
                visitor: [
                    "left",
                    "right",
                    "body"
                ],
                aliases: [
                    "Scopable",
                    "Statement",
                    "For",
                    "BlockParent",
                    "Loop",
                    "ForXStatement"
                ],
                fields: {
                    left: {
                        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("VariableDeclaration", "LVal") : (0, l.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
                    },
                    right: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    }
                }
            });
            c("ForStatement", {
                visitor: [
                    "init",
                    "test",
                    "update",
                    "body"
                ],
                aliases: [
                    "Scopable",
                    "Statement",
                    "For",
                    "BlockParent",
                    "Loop"
                ],
                fields: {
                    init: {
                        validate: (0, l.assertNodeType)("VariableDeclaration", "Expression"),
                        optional: true
                    },
                    test: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    },
                    update: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    }
                }
            });
            const functionCommon = ()=>({
                    params: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Identifier", "Pattern", "RestElement")))
                    },
                    generator: {
                        default: false
                    },
                    async: {
                        default: false
                    }
                });
            t.functionCommon = functionCommon;
            const functionTypeAnnotationCommon = ()=>({
                    returnType: {
                        validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: true
                    },
                    typeParameters: {
                        validate: (0, l.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                        optional: true
                    }
                });
            t.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
            const functionDeclarationCommon = ()=>Object.assign({}, functionCommon(), {
                    declare: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    id: {
                        validate: (0, l.assertNodeType)("Identifier"),
                        optional: true
                    }
                });
            t.functionDeclarationCommon = functionDeclarationCommon;
            c("FunctionDeclaration", {
                builder: [
                    "id",
                    "params",
                    "body",
                    "generator",
                    "async"
                ],
                visitor: [
                    "id",
                    "params",
                    "body",
                    "returnType",
                    "typeParameters"
                ],
                fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement")
                    },
                    predicate: {
                        validate: (0, l.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
                        optional: true
                    }
                }),
                aliases: [
                    "Scopable",
                    "Function",
                    "BlockParent",
                    "FunctionParent",
                    "Statement",
                    "Pureish",
                    "Declaration"
                ],
                validate: function() {
                    if (!process.env.BABEL_TYPES_8_BREAKING) return ()=>{};
                    const e1 = (0, l.assertNodeType)("Identifier");
                    return function(t, r, s) {
                        if (!(0, n.default)("ExportDefaultDeclaration", t)) {
                            e1(s, "id", s.id);
                        }
                    };
                }()
            });
            c("FunctionExpression", {
                inherits: "FunctionDeclaration",
                aliases: [
                    "Scopable",
                    "Function",
                    "BlockParent",
                    "FunctionParent",
                    "Expression",
                    "Pureish"
                ],
                fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
                    id: {
                        validate: (0, l.assertNodeType)("Identifier"),
                        optional: true
                    },
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement")
                    },
                    predicate: {
                        validate: (0, l.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
                        optional: true
                    }
                })
            });
            const patternLikeCommon = ()=>({
                    typeAnnotation: {
                        validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: true
                    },
                    optional: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Decorator"))),
                        optional: true
                    }
                });
            t.patternLikeCommon = patternLikeCommon;
            c("Identifier", {
                builder: [
                    "name"
                ],
                visitor: [
                    "typeAnnotation",
                    "decorators"
                ],
                aliases: [
                    "Expression",
                    "PatternLike",
                    "LVal",
                    "TSEntityName"
                ],
                fields: Object.assign({}, patternLikeCommon(), {
                    name: {
                        validate: (0, l.chain)((0, l.assertValueType)("string"), Object.assign(function(e1, t, r) {
                            if (!process.env.BABEL_TYPES_8_BREAKING) return;
                            if (!(0, s.default)(r, false)) {
                                throw new TypeError(`"${r}" is not a valid identifier name`);
                            }
                        }, {
                            type: "string"
                        }))
                    }
                }),
                validate (e1, t, r) {
                    if (!process.env.BABEL_TYPES_8_BREAKING) return;
                    const s = /\.(\w+)$/.exec(t);
                    if (!s) return;
                    const [, a] = s;
                    const o = {
                        computed: false
                    };
                    if (a === "property") {
                        if ((0, n.default)("MemberExpression", e1, o)) return;
                        if ((0, n.default)("OptionalMemberExpression", e1, o)) return;
                    } else if (a === "key") {
                        if ((0, n.default)("Property", e1, o)) return;
                        if ((0, n.default)("Method", e1, o)) return;
                    } else if (a === "exported") {
                        if ((0, n.default)("ExportSpecifier", e1)) return;
                    } else if (a === "imported") {
                        if ((0, n.default)("ImportSpecifier", e1, {
                            imported: r
                        })) return;
                    } else if (a === "meta") {
                        if ((0, n.default)("MetaProperty", e1, {
                            meta: r
                        })) return;
                    }
                    if (((0, i.isKeyword)(r.name) || (0, i.isReservedWord)(r.name, false)) && r.name !== "this") {
                        throw new TypeError(`"${r.name}" is not a valid identifier`);
                    }
                }
            });
            c("IfStatement", {
                visitor: [
                    "test",
                    "consequent",
                    "alternate"
                ],
                aliases: [
                    "Statement",
                    "Conditional"
                ],
                fields: {
                    test: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    consequent: {
                        validate: (0, l.assertNodeType)("Statement")
                    },
                    alternate: {
                        optional: true,
                        validate: (0, l.assertNodeType)("Statement")
                    }
                }
            });
            c("LabeledStatement", {
                visitor: [
                    "label",
                    "body"
                ],
                aliases: [
                    "Statement"
                ],
                fields: {
                    label: {
                        validate: (0, l.assertNodeType)("Identifier")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    }
                }
            });
            c("StringLiteral", {
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, l.assertValueType)("string")
                    }
                },
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal",
                    "Immutable"
                ]
            });
            c("NumericLiteral", {
                builder: [
                    "value"
                ],
                deprecatedAlias: "NumberLiteral",
                fields: {
                    value: {
                        validate: (0, l.assertValueType)("number")
                    }
                },
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal",
                    "Immutable"
                ]
            });
            c("NullLiteral", {
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal",
                    "Immutable"
                ]
            });
            c("BooleanLiteral", {
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, l.assertValueType)("boolean")
                    }
                },
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal",
                    "Immutable"
                ]
            });
            c("RegExpLiteral", {
                builder: [
                    "pattern",
                    "flags"
                ],
                deprecatedAlias: "RegexLiteral",
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal"
                ],
                fields: {
                    pattern: {
                        validate: (0, l.assertValueType)("string")
                    },
                    flags: {
                        validate: (0, l.chain)((0, l.assertValueType)("string"), Object.assign(function(e1, t, r) {
                            if (!process.env.BABEL_TYPES_8_BREAKING) return;
                            const n = /[^gimsuy]/.exec(r);
                            if (n) {
                                throw new TypeError(`"${n[0]}" is not a valid RegExp flag`);
                            }
                        }, {
                            type: "string"
                        })),
                        default: ""
                    }
                }
            });
            c("LogicalExpression", {
                builder: [
                    "operator",
                    "left",
                    "right"
                ],
                visitor: [
                    "left",
                    "right"
                ],
                aliases: [
                    "Binary",
                    "Expression"
                ],
                fields: {
                    operator: {
                        validate: (0, l.assertOneOf)(...o.LOGICAL_OPERATORS)
                    },
                    left: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    right: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("MemberExpression", {
                builder: [
                    "object",
                    "property",
                    "computed",
                    ...!process.env.BABEL_TYPES_8_BREAKING ? [
                        "optional"
                    ] : []
                ],
                visitor: [
                    "object",
                    "property"
                ],
                aliases: [
                    "Expression",
                    "LVal"
                ],
                fields: Object.assign({
                    object: {
                        validate: (0, l.assertNodeType)("Expression", "Super")
                    },
                    property: {
                        validate: function() {
                            const e1 = (0, l.assertNodeType)("Identifier", "PrivateName");
                            const t = (0, l.assertNodeType)("Expression");
                            const validator = function(r, n, s) {
                                const i = r.computed ? t : e1;
                                i(r, n, s);
                            };
                            validator.oneOfNodeTypes = [
                                "Expression",
                                "Identifier",
                                "PrivateName"
                            ];
                            return validator;
                        }()
                    },
                    computed: {
                        default: false
                    }
                }, !process.env.BABEL_TYPES_8_BREAKING ? {
                    optional: {
                        validate: (0, l.assertOneOf)(true, false),
                        optional: true
                    }
                } : {})
            });
            c("NewExpression", {
                inherits: "CallExpression"
            });
            c("Program", {
                visitor: [
                    "directives",
                    "body"
                ],
                builder: [
                    "body",
                    "directives",
                    "sourceType",
                    "interpreter"
                ],
                fields: {
                    sourceFile: {
                        validate: (0, l.assertValueType)("string")
                    },
                    sourceType: {
                        validate: (0, l.assertOneOf)("script", "module"),
                        default: "script"
                    },
                    interpreter: {
                        validate: (0, l.assertNodeType)("InterpreterDirective"),
                        default: null,
                        optional: true
                    },
                    directives: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Directive"))),
                        default: []
                    },
                    body: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Statement")))
                    }
                },
                aliases: [
                    "Scopable",
                    "BlockParent",
                    "Block"
                ]
            });
            c("ObjectExpression", {
                visitor: [
                    "properties"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    properties: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
                    }
                }
            });
            c("ObjectMethod", {
                builder: [
                    "kind",
                    "key",
                    "params",
                    "body",
                    "computed",
                    "generator",
                    "async"
                ],
                fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
                    kind: Object.assign({
                        validate: (0, l.assertOneOf)("method", "get", "set")
                    }, !process.env.BABEL_TYPES_8_BREAKING ? {
                        default: "method"
                    } : {}),
                    computed: {
                        default: false
                    },
                    key: {
                        validate: function() {
                            const e1 = (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
                            const t = (0, l.assertNodeType)("Expression");
                            const validator = function(r, n, s) {
                                const i = r.computed ? t : e1;
                                i(r, n, s);
                            };
                            validator.oneOfNodeTypes = [
                                "Expression",
                                "Identifier",
                                "StringLiteral",
                                "NumericLiteral",
                                "BigIntLiteral"
                            ];
                            return validator;
                        }()
                    },
                    decorators: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Decorator"))),
                        optional: true
                    },
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement")
                    }
                }),
                visitor: [
                    "key",
                    "params",
                    "body",
                    "decorators",
                    "returnType",
                    "typeParameters"
                ],
                aliases: [
                    "UserWhitespacable",
                    "Function",
                    "Scopable",
                    "BlockParent",
                    "FunctionParent",
                    "Method",
                    "ObjectMember"
                ]
            });
            c("ObjectProperty", {
                builder: [
                    "key",
                    "value",
                    "computed",
                    "shorthand",
                    ...!process.env.BABEL_TYPES_8_BREAKING ? [
                        "decorators"
                    ] : []
                ],
                fields: {
                    computed: {
                        default: false
                    },
                    key: {
                        validate: function() {
                            const e1 = (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
                            const t = (0, l.assertNodeType)("Expression");
                            const r = Object.assign(function(r, n, s) {
                                const i = r.computed ? t : e1;
                                i(r, n, s);
                            }, {
                                oneOfNodeTypes: [
                                    "Expression",
                                    "Identifier",
                                    "StringLiteral",
                                    "NumericLiteral",
                                    "BigIntLiteral",
                                    "DecimalLiteral",
                                    "PrivateName"
                                ]
                            });
                            return r;
                        }()
                    },
                    value: {
                        validate: (0, l.assertNodeType)("Expression", "PatternLike")
                    },
                    shorthand: {
                        validate: (0, l.chain)((0, l.assertValueType)("boolean"), Object.assign(function(e1, t, r) {
                            if (!process.env.BABEL_TYPES_8_BREAKING) return;
                            if (r && e1.computed) {
                                throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
                            }
                        }, {
                            type: "boolean"
                        }), function(e1, t, r) {
                            if (!process.env.BABEL_TYPES_8_BREAKING) return;
                            if (r && !(0, n.default)("Identifier", e1.key)) {
                                throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
                            }
                        }),
                        default: false
                    },
                    decorators: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Decorator"))),
                        optional: true
                    }
                },
                visitor: [
                    "key",
                    "value",
                    "decorators"
                ],
                aliases: [
                    "UserWhitespacable",
                    "Property",
                    "ObjectMember"
                ],
                validate: function() {
                    const e1 = (0, l.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
                    const t = (0, l.assertNodeType)("Expression");
                    return function(r, s, i) {
                        if (!process.env.BABEL_TYPES_8_BREAKING) return;
                        const a = (0, n.default)("ObjectPattern", r) ? e1 : t;
                        a(i, "value", i.value);
                    };
                }()
            });
            c("RestElement", {
                visitor: [
                    "argument",
                    "typeAnnotation"
                ],
                builder: [
                    "argument"
                ],
                aliases: [
                    "LVal",
                    "PatternLike"
                ],
                deprecatedAlias: "RestProperty",
                fields: Object.assign({}, patternLikeCommon(), {
                    argument: {
                        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("LVal") : (0, l.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
                    }
                }),
                validate (e1, t) {
                    if (!process.env.BABEL_TYPES_8_BREAKING) return;
                    const r = /(\w+)\[(\d+)\]/.exec(t);
                    if (!r) throw new Error("Internal Babel error: malformed key.");
                    const [, n, s] = r;
                    if (e1[n].length > +s + 1) {
                        throw new TypeError(`RestElement must be last element of ${n}`);
                    }
                }
            });
            c("ReturnStatement", {
                visitor: [
                    "argument"
                ],
                aliases: [
                    "Statement",
                    "Terminatorless",
                    "CompletionStatement"
                ],
                fields: {
                    argument: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    }
                }
            });
            c("SequenceExpression", {
                visitor: [
                    "expressions"
                ],
                fields: {
                    expressions: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Expression")))
                    }
                },
                aliases: [
                    "Expression"
                ]
            });
            c("ParenthesizedExpression", {
                visitor: [
                    "expression"
                ],
                aliases: [
                    "Expression",
                    "ExpressionWrapper"
                ],
                fields: {
                    expression: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("SwitchCase", {
                visitor: [
                    "test",
                    "consequent"
                ],
                fields: {
                    test: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    },
                    consequent: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Statement")))
                    }
                }
            });
            c("SwitchStatement", {
                visitor: [
                    "discriminant",
                    "cases"
                ],
                aliases: [
                    "Statement",
                    "BlockParent",
                    "Scopable"
                ],
                fields: {
                    discriminant: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    cases: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("SwitchCase")))
                    }
                }
            });
            c("ThisExpression", {
                aliases: [
                    "Expression"
                ]
            });
            c("ThrowStatement", {
                visitor: [
                    "argument"
                ],
                aliases: [
                    "Statement",
                    "Terminatorless",
                    "CompletionStatement"
                ],
                fields: {
                    argument: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("TryStatement", {
                visitor: [
                    "block",
                    "handler",
                    "finalizer"
                ],
                aliases: [
                    "Statement"
                ],
                fields: {
                    block: {
                        validate: (0, l.chain)((0, l.assertNodeType)("BlockStatement"), Object.assign(function(e1) {
                            if (!process.env.BABEL_TYPES_8_BREAKING) return;
                            if (!e1.handler && !e1.finalizer) {
                                throw new TypeError("TryStatement expects either a handler or finalizer, or both");
                            }
                        }, {
                            oneOfNodeTypes: [
                                "BlockStatement"
                            ]
                        }))
                    },
                    handler: {
                        optional: true,
                        validate: (0, l.assertNodeType)("CatchClause")
                    },
                    finalizer: {
                        optional: true,
                        validate: (0, l.assertNodeType)("BlockStatement")
                    }
                }
            });
            c("UnaryExpression", {
                builder: [
                    "operator",
                    "argument",
                    "prefix"
                ],
                fields: {
                    prefix: {
                        default: true
                    },
                    argument: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    operator: {
                        validate: (0, l.assertOneOf)(...o.UNARY_OPERATORS)
                    }
                },
                visitor: [
                    "argument"
                ],
                aliases: [
                    "UnaryLike",
                    "Expression"
                ]
            });
            c("UpdateExpression", {
                builder: [
                    "operator",
                    "argument",
                    "prefix"
                ],
                fields: {
                    prefix: {
                        default: false
                    },
                    argument: {
                        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("Expression") : (0, l.assertNodeType)("Identifier", "MemberExpression")
                    },
                    operator: {
                        validate: (0, l.assertOneOf)(...o.UPDATE_OPERATORS)
                    }
                },
                visitor: [
                    "argument"
                ],
                aliases: [
                    "Expression"
                ]
            });
            c("VariableDeclaration", {
                builder: [
                    "kind",
                    "declarations"
                ],
                visitor: [
                    "declarations"
                ],
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    declare: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    kind: {
                        validate: (0, l.assertOneOf)("var", "let", "const", "using", "await using")
                    },
                    declarations: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("VariableDeclarator")))
                    }
                },
                validate (e1, t, r) {
                    if (!process.env.BABEL_TYPES_8_BREAKING) return;
                    if (!(0, n.default)("ForXStatement", e1, {
                        left: r
                    })) return;
                    if (r.declarations.length !== 1) {
                        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${e1.type}`);
                    }
                }
            });
            c("VariableDeclarator", {
                visitor: [
                    "id",
                    "init"
                ],
                fields: {
                    id: {
                        validate: function() {
                            if (!process.env.BABEL_TYPES_8_BREAKING) {
                                return (0, l.assertNodeType)("LVal");
                            }
                            const e1 = (0, l.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
                            const t = (0, l.assertNodeType)("Identifier");
                            return function(r, n, s) {
                                const i = r.init ? e1 : t;
                                i(r, n, s);
                            };
                        }()
                    },
                    definite: {
                        optional: true,
                        validate: (0, l.assertValueType)("boolean")
                    },
                    init: {
                        optional: true,
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("WhileStatement", {
                visitor: [
                    "test",
                    "body"
                ],
                aliases: [
                    "Statement",
                    "BlockParent",
                    "Loop",
                    "While",
                    "Scopable"
                ],
                fields: {
                    test: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    }
                }
            });
            c("WithStatement", {
                visitor: [
                    "object",
                    "body"
                ],
                aliases: [
                    "Statement"
                ],
                fields: {
                    object: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    }
                }
            });
            c("AssignmentPattern", {
                visitor: [
                    "left",
                    "right",
                    "decorators"
                ],
                builder: [
                    "left",
                    "right"
                ],
                aliases: [
                    "Pattern",
                    "PatternLike",
                    "LVal"
                ],
                fields: Object.assign({}, patternLikeCommon(), {
                    left: {
                        validate: (0, l.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
                    },
                    right: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    decorators: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Decorator"))),
                        optional: true
                    }
                })
            });
            c("ArrayPattern", {
                visitor: [
                    "elements",
                    "typeAnnotation"
                ],
                builder: [
                    "elements"
                ],
                aliases: [
                    "Pattern",
                    "PatternLike",
                    "LVal"
                ],
                fields: Object.assign({}, patternLikeCommon(), {
                    elements: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeOrValueType)("null", "PatternLike", "LVal")))
                    }
                })
            });
            c("ArrowFunctionExpression", {
                builder: [
                    "params",
                    "body",
                    "async"
                ],
                visitor: [
                    "params",
                    "body",
                    "returnType",
                    "typeParameters"
                ],
                aliases: [
                    "Scopable",
                    "Function",
                    "BlockParent",
                    "FunctionParent",
                    "Expression",
                    "Pureish"
                ],
                fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
                    expression: {
                        validate: (0, l.assertValueType)("boolean")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement", "Expression")
                    },
                    predicate: {
                        validate: (0, l.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
                        optional: true
                    }
                })
            });
            c("ClassBody", {
                visitor: [
                    "body"
                ],
                fields: {
                    body: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
                    }
                }
            });
            c("ClassExpression", {
                builder: [
                    "id",
                    "superClass",
                    "body",
                    "decorators"
                ],
                visitor: [
                    "id",
                    "body",
                    "superClass",
                    "mixins",
                    "typeParameters",
                    "superTypeParameters",
                    "implements",
                    "decorators"
                ],
                aliases: [
                    "Scopable",
                    "Class",
                    "Expression"
                ],
                fields: {
                    id: {
                        validate: (0, l.assertNodeType)("Identifier"),
                        optional: true
                    },
                    typeParameters: {
                        validate: (0, l.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                        optional: true
                    },
                    body: {
                        validate: (0, l.assertNodeType)("ClassBody")
                    },
                    superClass: {
                        optional: true,
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    superTypeParameters: {
                        validate: (0, l.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: true
                    },
                    implements: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Decorator"))),
                        optional: true
                    },
                    mixins: {
                        validate: (0, l.assertNodeType)("InterfaceExtends"),
                        optional: true
                    }
                }
            });
            c("ClassDeclaration", {
                inherits: "ClassExpression",
                aliases: [
                    "Scopable",
                    "Class",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: {
                        validate: (0, l.assertNodeType)("Identifier")
                    },
                    typeParameters: {
                        validate: (0, l.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                        optional: true
                    },
                    body: {
                        validate: (0, l.assertNodeType)("ClassBody")
                    },
                    superClass: {
                        optional: true,
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    superTypeParameters: {
                        validate: (0, l.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: true
                    },
                    implements: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Decorator"))),
                        optional: true
                    },
                    mixins: {
                        validate: (0, l.assertNodeType)("InterfaceExtends"),
                        optional: true
                    },
                    declare: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    abstract: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    }
                },
                validate: function() {
                    const e1 = (0, l.assertNodeType)("Identifier");
                    return function(t, r, s) {
                        if (!process.env.BABEL_TYPES_8_BREAKING) return;
                        if (!(0, n.default)("ExportDefaultDeclaration", t)) {
                            e1(s, "id", s.id);
                        }
                    };
                }()
            });
            c("ExportAllDeclaration", {
                builder: [
                    "source"
                ],
                visitor: [
                    "source",
                    "attributes",
                    "assertions"
                ],
                aliases: [
                    "Statement",
                    "Declaration",
                    "ImportOrExportDeclaration",
                    "ExportDeclaration"
                ],
                fields: {
                    source: {
                        validate: (0, l.assertNodeType)("StringLiteral")
                    },
                    exportKind: (0, l.validateOptional)((0, l.assertOneOf)("type", "value")),
                    attributes: {
                        optional: true,
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("ImportAttribute")))
                    },
                    assertions: {
                        optional: true,
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("ImportAttribute")))
                    }
                }
            });
            c("ExportDefaultDeclaration", {
                visitor: [
                    "declaration"
                ],
                aliases: [
                    "Statement",
                    "Declaration",
                    "ImportOrExportDeclaration",
                    "ExportDeclaration"
                ],
                fields: {
                    declaration: {
                        validate: (0, l.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
                    },
                    exportKind: (0, l.validateOptional)((0, l.assertOneOf)("value"))
                }
            });
            c("ExportNamedDeclaration", {
                builder: [
                    "declaration",
                    "specifiers",
                    "source"
                ],
                visitor: [
                    "declaration",
                    "specifiers",
                    "source",
                    "attributes",
                    "assertions"
                ],
                aliases: [
                    "Statement",
                    "Declaration",
                    "ImportOrExportDeclaration",
                    "ExportDeclaration"
                ],
                fields: {
                    declaration: {
                        optional: true,
                        validate: (0, l.chain)((0, l.assertNodeType)("Declaration"), Object.assign(function(e1, t, r) {
                            if (!process.env.BABEL_TYPES_8_BREAKING) return;
                            if (r && e1.specifiers.length) {
                                throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
                            }
                        }, {
                            oneOfNodeTypes: [
                                "Declaration"
                            ]
                        }), function(e1, t, r) {
                            if (!process.env.BABEL_TYPES_8_BREAKING) return;
                            if (r && e1.source) {
                                throw new TypeError("Cannot export a declaration from a source");
                            }
                        })
                    },
                    attributes: {
                        optional: true,
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("ImportAttribute")))
                    },
                    assertions: {
                        optional: true,
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("ImportAttribute")))
                    },
                    specifiers: {
                        default: [],
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)(function() {
                            const e1 = (0, l.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
                            const t = (0, l.assertNodeType)("ExportSpecifier");
                            if (!process.env.BABEL_TYPES_8_BREAKING) return e1;
                            return function(r, n, s) {
                                const i = r.source ? e1 : t;
                                i(r, n, s);
                            };
                        }()))
                    },
                    source: {
                        validate: (0, l.assertNodeType)("StringLiteral"),
                        optional: true
                    },
                    exportKind: (0, l.validateOptional)((0, l.assertOneOf)("type", "value"))
                }
            });
            c("ExportSpecifier", {
                visitor: [
                    "local",
                    "exported"
                ],
                aliases: [
                    "ModuleSpecifier"
                ],
                fields: {
                    local: {
                        validate: (0, l.assertNodeType)("Identifier")
                    },
                    exported: {
                        validate: (0, l.assertNodeType)("Identifier", "StringLiteral")
                    },
                    exportKind: {
                        validate: (0, l.assertOneOf)("type", "value"),
                        optional: true
                    }
                }
            });
            c("ForOfStatement", {
                visitor: [
                    "left",
                    "right",
                    "body"
                ],
                builder: [
                    "left",
                    "right",
                    "body",
                    "await"
                ],
                aliases: [
                    "Scopable",
                    "Statement",
                    "For",
                    "BlockParent",
                    "Loop",
                    "ForXStatement"
                ],
                fields: {
                    left: {
                        validate: function() {
                            if (!process.env.BABEL_TYPES_8_BREAKING) {
                                return (0, l.assertNodeType)("VariableDeclaration", "LVal");
                            }
                            const e1 = (0, l.assertNodeType)("VariableDeclaration");
                            const t = (0, l.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
                            return function(r, s, i) {
                                if ((0, n.default)("VariableDeclaration", i)) {
                                    e1(r, s, i);
                                } else {
                                    t(r, s, i);
                                }
                            };
                        }()
                    },
                    right: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("Statement")
                    },
                    await: {
                        default: false
                    }
                }
            });
            c("ImportDeclaration", {
                builder: [
                    "specifiers",
                    "source"
                ],
                visitor: [
                    "specifiers",
                    "source",
                    "attributes",
                    "assertions"
                ],
                aliases: [
                    "Statement",
                    "Declaration",
                    "ImportOrExportDeclaration"
                ],
                fields: {
                    attributes: {
                        optional: true,
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("ImportAttribute")))
                    },
                    assertions: {
                        optional: true,
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("ImportAttribute")))
                    },
                    module: {
                        optional: true,
                        validate: (0, l.assertValueType)("boolean")
                    },
                    specifiers: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
                    },
                    source: {
                        validate: (0, l.assertNodeType)("StringLiteral")
                    },
                    importKind: {
                        validate: (0, l.assertOneOf)("type", "typeof", "value"),
                        optional: true
                    }
                }
            });
            c("ImportDefaultSpecifier", {
                visitor: [
                    "local"
                ],
                aliases: [
                    "ModuleSpecifier"
                ],
                fields: {
                    local: {
                        validate: (0, l.assertNodeType)("Identifier")
                    }
                }
            });
            c("ImportNamespaceSpecifier", {
                visitor: [
                    "local"
                ],
                aliases: [
                    "ModuleSpecifier"
                ],
                fields: {
                    local: {
                        validate: (0, l.assertNodeType)("Identifier")
                    }
                }
            });
            c("ImportSpecifier", {
                visitor: [
                    "local",
                    "imported"
                ],
                aliases: [
                    "ModuleSpecifier"
                ],
                fields: {
                    local: {
                        validate: (0, l.assertNodeType)("Identifier")
                    },
                    imported: {
                        validate: (0, l.assertNodeType)("Identifier", "StringLiteral")
                    },
                    importKind: {
                        validate: (0, l.assertOneOf)("type", "typeof", "value"),
                        optional: true
                    }
                }
            });
            c("MetaProperty", {
                visitor: [
                    "meta",
                    "property"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    meta: {
                        validate: (0, l.chain)((0, l.assertNodeType)("Identifier"), Object.assign(function(e1, t, r) {
                            if (!process.env.BABEL_TYPES_8_BREAKING) return;
                            let s;
                            switch(r.name){
                                case "function":
                                    s = "sent";
                                    break;
                                case "new":
                                    s = "target";
                                    break;
                                case "import":
                                    s = "meta";
                                    break;
                            }
                            if (!(0, n.default)("Identifier", e1.property, {
                                name: s
                            })) {
                                throw new TypeError("Unrecognised MetaProperty");
                            }
                        }, {
                            oneOfNodeTypes: [
                                "Identifier"
                            ]
                        }))
                    },
                    property: {
                        validate: (0, l.assertNodeType)("Identifier")
                    }
                }
            });
            const classMethodOrPropertyCommon = ()=>({
                    abstract: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    accessibility: {
                        validate: (0, l.assertOneOf)("public", "private", "protected"),
                        optional: true
                    },
                    static: {
                        default: false
                    },
                    override: {
                        default: false
                    },
                    computed: {
                        default: false
                    },
                    optional: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    key: {
                        validate: (0, l.chain)(function() {
                            const e1 = (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
                            const t = (0, l.assertNodeType)("Expression");
                            return function(r, n, s) {
                                const i = r.computed ? t : e1;
                                i(r, n, s);
                            };
                        }(), (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
                    }
                });
            t.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
            const classMethodOrDeclareMethodCommon = ()=>Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
                    params: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
                    },
                    kind: {
                        validate: (0, l.assertOneOf)("get", "set", "method", "constructor"),
                        default: "method"
                    },
                    access: {
                        validate: (0, l.chain)((0, l.assertValueType)("string"), (0, l.assertOneOf)("public", "private", "protected")),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Decorator"))),
                        optional: true
                    }
                });
            t.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
            c("ClassMethod", {
                aliases: [
                    "Function",
                    "Scopable",
                    "BlockParent",
                    "FunctionParent",
                    "Method"
                ],
                builder: [
                    "kind",
                    "key",
                    "params",
                    "body",
                    "computed",
                    "static",
                    "generator",
                    "async"
                ],
                visitor: [
                    "key",
                    "params",
                    "body",
                    "decorators",
                    "returnType",
                    "typeParameters"
                ],
                fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement")
                    }
                })
            });
            c("ObjectPattern", {
                visitor: [
                    "properties",
                    "typeAnnotation",
                    "decorators"
                ],
                builder: [
                    "properties"
                ],
                aliases: [
                    "Pattern",
                    "PatternLike",
                    "LVal"
                ],
                fields: Object.assign({}, patternLikeCommon(), {
                    properties: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("RestElement", "ObjectProperty")))
                    }
                })
            });
            c("SpreadElement", {
                visitor: [
                    "argument"
                ],
                aliases: [
                    "UnaryLike"
                ],
                deprecatedAlias: "SpreadProperty",
                fields: {
                    argument: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("Super", {
                aliases: [
                    "Expression"
                ]
            });
            c("TaggedTemplateExpression", {
                visitor: [
                    "tag",
                    "quasi",
                    "typeParameters"
                ],
                builder: [
                    "tag",
                    "quasi"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    tag: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    quasi: {
                        validate: (0, l.assertNodeType)("TemplateLiteral")
                    },
                    typeParameters: {
                        validate: (0, l.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: true
                    }
                }
            });
            c("TemplateElement", {
                builder: [
                    "value",
                    "tail"
                ],
                fields: {
                    value: {
                        validate: (0, l.chain)((0, l.assertShape)({
                            raw: {
                                validate: (0, l.assertValueType)("string")
                            },
                            cooked: {
                                validate: (0, l.assertValueType)("string"),
                                optional: true
                            }
                        }), function templateElementCookedValidator(e1) {
                            const t = e1.value.raw;
                            let r = false;
                            const error = ()=>{
                                throw new Error("Internal @babel/types error.");
                            };
                            const { str: n, firstInvalidLoc: s } = (0, a.readStringContents)("template", t, 0, 0, 0, {
                                unterminated () {
                                    r = true;
                                },
                                strictNumericEscape: error,
                                invalidEscapeSequence: error,
                                numericSeparatorInEscapeSequence: error,
                                unexpectedNumericSeparator: error,
                                invalidDigit: error,
                                invalidCodePoint: error
                            });
                            if (!r) throw new Error("Invalid raw");
                            e1.value.cooked = s ? null : n;
                        })
                    },
                    tail: {
                        default: false
                    }
                }
            });
            c("TemplateLiteral", {
                visitor: [
                    "quasis",
                    "expressions"
                ],
                aliases: [
                    "Expression",
                    "Literal"
                ],
                fields: {
                    quasis: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("TemplateElement")))
                    },
                    expressions: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Expression", "TSType")), function(e1, t, r) {
                            if (e1.quasis.length !== r.length + 1) {
                                throw new TypeError(`Number of ${e1.type} quasis should be exactly one more than the number of expressions.\nExpected ${r.length + 1} quasis but got ${e1.quasis.length}`);
                            }
                        })
                    }
                }
            });
            c("YieldExpression", {
                builder: [
                    "argument",
                    "delegate"
                ],
                visitor: [
                    "argument"
                ],
                aliases: [
                    "Expression",
                    "Terminatorless"
                ],
                fields: {
                    delegate: {
                        validate: (0, l.chain)((0, l.assertValueType)("boolean"), Object.assign(function(e1, t, r) {
                            if (!process.env.BABEL_TYPES_8_BREAKING) return;
                            if (r && !e1.argument) {
                                throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
                            }
                        }, {
                            type: "boolean"
                        })),
                        default: false
                    },
                    argument: {
                        optional: true,
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("AwaitExpression", {
                builder: [
                    "argument"
                ],
                visitor: [
                    "argument"
                ],
                aliases: [
                    "Expression",
                    "Terminatorless"
                ],
                fields: {
                    argument: {
                        validate: (0, l.assertNodeType)("Expression")
                    }
                }
            });
            c("Import", {
                aliases: [
                    "Expression"
                ]
            });
            c("BigIntLiteral", {
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, l.assertValueType)("string")
                    }
                },
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal",
                    "Immutable"
                ]
            });
            c("ExportNamespaceSpecifier", {
                visitor: [
                    "exported"
                ],
                aliases: [
                    "ModuleSpecifier"
                ],
                fields: {
                    exported: {
                        validate: (0, l.assertNodeType)("Identifier")
                    }
                }
            });
            c("OptionalMemberExpression", {
                builder: [
                    "object",
                    "property",
                    "computed",
                    "optional"
                ],
                visitor: [
                    "object",
                    "property"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    object: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    property: {
                        validate: function() {
                            const e1 = (0, l.assertNodeType)("Identifier");
                            const t = (0, l.assertNodeType)("Expression");
                            const r = Object.assign(function(r, n, s) {
                                const i = r.computed ? t : e1;
                                i(r, n, s);
                            }, {
                                oneOfNodeTypes: [
                                    "Expression",
                                    "Identifier"
                                ]
                            });
                            return r;
                        }()
                    },
                    computed: {
                        default: false
                    },
                    optional: {
                        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, l.assertValueType)("boolean") : (0, l.chain)((0, l.assertValueType)("boolean"), (0, l.assertOptionalChainStart)())
                    }
                }
            });
            c("OptionalCallExpression", {
                visitor: [
                    "callee",
                    "arguments",
                    "typeParameters",
                    "typeArguments"
                ],
                builder: [
                    "callee",
                    "arguments",
                    "optional"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    callee: {
                        validate: (0, l.assertNodeType)("Expression")
                    },
                    arguments: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
                    },
                    optional: {
                        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, l.assertValueType)("boolean") : (0, l.chain)((0, l.assertValueType)("boolean"), (0, l.assertOptionalChainStart)())
                    },
                    typeArguments: {
                        validate: (0, l.assertNodeType)("TypeParameterInstantiation"),
                        optional: true
                    },
                    typeParameters: {
                        validate: (0, l.assertNodeType)("TSTypeParameterInstantiation"),
                        optional: true
                    }
                }
            });
            c("ClassProperty", {
                visitor: [
                    "key",
                    "value",
                    "typeAnnotation",
                    "decorators"
                ],
                builder: [
                    "key",
                    "value",
                    "typeAnnotation",
                    "decorators",
                    "computed",
                    "static"
                ],
                aliases: [
                    "Property"
                ],
                fields: Object.assign({}, classMethodOrPropertyCommon(), {
                    value: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    },
                    definite: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    typeAnnotation: {
                        validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Decorator"))),
                        optional: true
                    },
                    readonly: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    declare: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    variance: {
                        validate: (0, l.assertNodeType)("Variance"),
                        optional: true
                    }
                })
            });
            c("ClassAccessorProperty", {
                visitor: [
                    "key",
                    "value",
                    "typeAnnotation",
                    "decorators"
                ],
                builder: [
                    "key",
                    "value",
                    "typeAnnotation",
                    "decorators",
                    "computed",
                    "static"
                ],
                aliases: [
                    "Property",
                    "Accessor"
                ],
                fields: Object.assign({}, classMethodOrPropertyCommon(), {
                    key: {
                        validate: (0, l.chain)(function() {
                            const e1 = (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
                            const t = (0, l.assertNodeType)("Expression");
                            return function(r, n, s) {
                                const i = r.computed ? t : e1;
                                i(r, n, s);
                            };
                        }(), (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
                    },
                    value: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    },
                    definite: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    typeAnnotation: {
                        validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Decorator"))),
                        optional: true
                    },
                    readonly: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    declare: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    variance: {
                        validate: (0, l.assertNodeType)("Variance"),
                        optional: true
                    }
                })
            });
            c("ClassPrivateProperty", {
                visitor: [
                    "key",
                    "value",
                    "decorators",
                    "typeAnnotation"
                ],
                builder: [
                    "key",
                    "value",
                    "decorators",
                    "static"
                ],
                aliases: [
                    "Property",
                    "Private"
                ],
                fields: {
                    key: {
                        validate: (0, l.assertNodeType)("PrivateName")
                    },
                    value: {
                        validate: (0, l.assertNodeType)("Expression"),
                        optional: true
                    },
                    typeAnnotation: {
                        validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                        optional: true
                    },
                    decorators: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Decorator"))),
                        optional: true
                    },
                    static: {
                        validate: (0, l.assertValueType)("boolean"),
                        default: false
                    },
                    readonly: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    definite: {
                        validate: (0, l.assertValueType)("boolean"),
                        optional: true
                    },
                    variance: {
                        validate: (0, l.assertNodeType)("Variance"),
                        optional: true
                    }
                }
            });
            c("ClassPrivateMethod", {
                builder: [
                    "kind",
                    "key",
                    "params",
                    "body",
                    "static"
                ],
                visitor: [
                    "key",
                    "params",
                    "body",
                    "decorators",
                    "returnType",
                    "typeParameters"
                ],
                aliases: [
                    "Function",
                    "Scopable",
                    "BlockParent",
                    "FunctionParent",
                    "Method",
                    "Private"
                ],
                fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
                    kind: {
                        validate: (0, l.assertOneOf)("get", "set", "method"),
                        default: "method"
                    },
                    key: {
                        validate: (0, l.assertNodeType)("PrivateName")
                    },
                    body: {
                        validate: (0, l.assertNodeType)("BlockStatement")
                    }
                })
            });
            c("PrivateName", {
                visitor: [
                    "id"
                ],
                aliases: [
                    "Private"
                ],
                fields: {
                    id: {
                        validate: (0, l.assertNodeType)("Identifier")
                    }
                }
            });
            c("StaticBlock", {
                visitor: [
                    "body"
                ],
                fields: {
                    body: {
                        validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Statement")))
                    }
                },
                aliases: [
                    "Scopable",
                    "BlockParent",
                    "FunctionParent"
                ]
            });
        },
        4482: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DEPRECATED_ALIASES = void 0;
            const r = {
                ModuleDeclaration: "ImportOrExportDeclaration"
            };
            t.DEPRECATED_ALIASES = r;
        },
        6851: (e1, t, r)=>{
            "use strict";
            var n = r(3706);
            (0, n.default)("ArgumentPlaceholder", {});
            (0, n.default)("BindExpression", {
                visitor: [
                    "object",
                    "callee"
                ],
                aliases: [
                    "Expression"
                ],
                fields: !process.env.BABEL_TYPES_8_BREAKING ? {
                    object: {
                        validate: Object.assign(()=>{}, {
                            oneOfNodeTypes: [
                                "Expression"
                            ]
                        })
                    },
                    callee: {
                        validate: Object.assign(()=>{}, {
                            oneOfNodeTypes: [
                                "Expression"
                            ]
                        })
                    }
                } : {
                    object: {
                        validate: (0, n.assertNodeType)("Expression")
                    },
                    callee: {
                        validate: (0, n.assertNodeType)("Expression")
                    }
                }
            });
            (0, n.default)("ImportAttribute", {
                visitor: [
                    "key",
                    "value"
                ],
                fields: {
                    key: {
                        validate: (0, n.assertNodeType)("Identifier", "StringLiteral")
                    },
                    value: {
                        validate: (0, n.assertNodeType)("StringLiteral")
                    }
                }
            });
            (0, n.default)("Decorator", {
                visitor: [
                    "expression"
                ],
                fields: {
                    expression: {
                        validate: (0, n.assertNodeType)("Expression")
                    }
                }
            });
            (0, n.default)("DoExpression", {
                visitor: [
                    "body"
                ],
                builder: [
                    "body",
                    "async"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    body: {
                        validate: (0, n.assertNodeType)("BlockStatement")
                    },
                    async: {
                        validate: (0, n.assertValueType)("boolean"),
                        default: false
                    }
                }
            });
            (0, n.default)("ExportDefaultSpecifier", {
                visitor: [
                    "exported"
                ],
                aliases: [
                    "ModuleSpecifier"
                ],
                fields: {
                    exported: {
                        validate: (0, n.assertNodeType)("Identifier")
                    }
                }
            });
            (0, n.default)("RecordExpression", {
                visitor: [
                    "properties"
                ],
                aliases: [
                    "Expression"
                ],
                fields: {
                    properties: {
                        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ObjectProperty", "SpreadElement")))
                    }
                }
            });
            (0, n.default)("TupleExpression", {
                fields: {
                    elements: {
                        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression", "SpreadElement"))),
                        default: []
                    }
                },
                visitor: [
                    "elements"
                ],
                aliases: [
                    "Expression"
                ]
            });
            (0, n.default)("DecimalLiteral", {
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, n.assertValueType)("string")
                    }
                },
                aliases: [
                    "Expression",
                    "Pureish",
                    "Literal",
                    "Immutable"
                ]
            });
            (0, n.default)("ModuleExpression", {
                visitor: [
                    "body"
                ],
                fields: {
                    body: {
                        validate: (0, n.assertNodeType)("Program")
                    }
                },
                aliases: [
                    "Expression"
                ]
            });
            (0, n.default)("TopicReference", {
                aliases: [
                    "Expression"
                ]
            });
            (0, n.default)("PipelineTopicExpression", {
                builder: [
                    "expression"
                ],
                visitor: [
                    "expression"
                ],
                fields: {
                    expression: {
                        validate: (0, n.assertNodeType)("Expression")
                    }
                },
                aliases: [
                    "Expression"
                ]
            });
            (0, n.default)("PipelineBareFunction", {
                builder: [
                    "callee"
                ],
                visitor: [
                    "callee"
                ],
                fields: {
                    callee: {
                        validate: (0, n.assertNodeType)("Expression")
                    }
                },
                aliases: [
                    "Expression"
                ]
            });
            (0, n.default)("PipelinePrimaryTopicReference", {
                aliases: [
                    "Expression"
                ]
            });
        },
        9563: (e1, t, r)=>{
            "use strict";
            var n = r(3706);
            const s = (0, n.defineAliasedType)("Flow");
            const defineInterfaceishType = (e1)=>{
                const t = e1 === "DeclareClass";
                s(e1, {
                    builder: [
                        "id",
                        "typeParameters",
                        "extends",
                        "body"
                    ],
                    visitor: [
                        "id",
                        "typeParameters",
                        "extends",
                        ...t ? [
                            "mixins",
                            "implements"
                        ] : [],
                        "body"
                    ],
                    aliases: [
                        "FlowDeclaration",
                        "Statement",
                        "Declaration"
                    ],
                    fields: Object.assign({
                        id: (0, n.validateType)("Identifier"),
                        typeParameters: (0, n.validateOptionalType)("TypeParameterDeclaration"),
                        extends: (0, n.validateOptional)((0, n.arrayOfType)("InterfaceExtends"))
                    }, t ? {
                        mixins: (0, n.validateOptional)((0, n.arrayOfType)("InterfaceExtends")),
                        implements: (0, n.validateOptional)((0, n.arrayOfType)("ClassImplements"))
                    } : {}, {
                        body: (0, n.validateType)("ObjectTypeAnnotation")
                    })
                });
            };
            s("AnyTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            s("ArrayTypeAnnotation", {
                visitor: [
                    "elementType"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    elementType: (0, n.validateType)("FlowType")
                }
            });
            s("BooleanTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            s("BooleanLiteralTypeAnnotation", {
                builder: [
                    "value"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    value: (0, n.validate)((0, n.assertValueType)("boolean"))
                }
            });
            s("NullLiteralTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            s("ClassImplements", {
                visitor: [
                    "id",
                    "typeParameters"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier"),
                    typeParameters: (0, n.validateOptionalType)("TypeParameterInstantiation")
                }
            });
            defineInterfaceishType("DeclareClass");
            s("DeclareFunction", {
                visitor: [
                    "id"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier"),
                    predicate: (0, n.validateOptionalType)("DeclaredPredicate")
                }
            });
            defineInterfaceishType("DeclareInterface");
            s("DeclareModule", {
                builder: [
                    "id",
                    "body",
                    "kind"
                ],
                visitor: [
                    "id",
                    "body"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, n.validateType)([
                        "Identifier",
                        "StringLiteral"
                    ]),
                    body: (0, n.validateType)("BlockStatement"),
                    kind: (0, n.validateOptional)((0, n.assertOneOf)("CommonJS", "ES"))
                }
            });
            s("DeclareModuleExports", {
                visitor: [
                    "typeAnnotation"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    typeAnnotation: (0, n.validateType)("TypeAnnotation")
                }
            });
            s("DeclareTypeAlias", {
                visitor: [
                    "id",
                    "typeParameters",
                    "right"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier"),
                    typeParameters: (0, n.validateOptionalType)("TypeParameterDeclaration"),
                    right: (0, n.validateType)("FlowType")
                }
            });
            s("DeclareOpaqueType", {
                visitor: [
                    "id",
                    "typeParameters",
                    "supertype"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier"),
                    typeParameters: (0, n.validateOptionalType)("TypeParameterDeclaration"),
                    supertype: (0, n.validateOptionalType)("FlowType"),
                    impltype: (0, n.validateOptionalType)("FlowType")
                }
            });
            s("DeclareVariable", {
                visitor: [
                    "id"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier")
                }
            });
            s("DeclareExportDeclaration", {
                visitor: [
                    "declaration",
                    "specifiers",
                    "source"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    declaration: (0, n.validateOptionalType)("Flow"),
                    specifiers: (0, n.validateOptional)((0, n.arrayOfType)([
                        "ExportSpecifier",
                        "ExportNamespaceSpecifier"
                    ])),
                    source: (0, n.validateOptionalType)("StringLiteral"),
                    default: (0, n.validateOptional)((0, n.assertValueType)("boolean"))
                }
            });
            s("DeclareExportAllDeclaration", {
                visitor: [
                    "source"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    source: (0, n.validateType)("StringLiteral"),
                    exportKind: (0, n.validateOptional)((0, n.assertOneOf)("type", "value"))
                }
            });
            s("DeclaredPredicate", {
                visitor: [
                    "value"
                ],
                aliases: [
                    "FlowPredicate"
                ],
                fields: {
                    value: (0, n.validateType)("Flow")
                }
            });
            s("ExistsTypeAnnotation", {
                aliases: [
                    "FlowType"
                ]
            });
            s("FunctionTypeAnnotation", {
                visitor: [
                    "typeParameters",
                    "params",
                    "rest",
                    "returnType"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    typeParameters: (0, n.validateOptionalType)("TypeParameterDeclaration"),
                    params: (0, n.validate)((0, n.arrayOfType)("FunctionTypeParam")),
                    rest: (0, n.validateOptionalType)("FunctionTypeParam"),
                    this: (0, n.validateOptionalType)("FunctionTypeParam"),
                    returnType: (0, n.validateType)("FlowType")
                }
            });
            s("FunctionTypeParam", {
                visitor: [
                    "name",
                    "typeAnnotation"
                ],
                fields: {
                    name: (0, n.validateOptionalType)("Identifier"),
                    typeAnnotation: (0, n.validateType)("FlowType"),
                    optional: (0, n.validateOptional)((0, n.assertValueType)("boolean"))
                }
            });
            s("GenericTypeAnnotation", {
                visitor: [
                    "id",
                    "typeParameters"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    id: (0, n.validateType)([
                        "Identifier",
                        "QualifiedTypeIdentifier"
                    ]),
                    typeParameters: (0, n.validateOptionalType)("TypeParameterInstantiation")
                }
            });
            s("InferredPredicate", {
                aliases: [
                    "FlowPredicate"
                ]
            });
            s("InterfaceExtends", {
                visitor: [
                    "id",
                    "typeParameters"
                ],
                fields: {
                    id: (0, n.validateType)([
                        "Identifier",
                        "QualifiedTypeIdentifier"
                    ]),
                    typeParameters: (0, n.validateOptionalType)("TypeParameterInstantiation")
                }
            });
            defineInterfaceishType("InterfaceDeclaration");
            s("InterfaceTypeAnnotation", {
                visitor: [
                    "extends",
                    "body"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    extends: (0, n.validateOptional)((0, n.arrayOfType)("InterfaceExtends")),
                    body: (0, n.validateType)("ObjectTypeAnnotation")
                }
            });
            s("IntersectionTypeAnnotation", {
                visitor: [
                    "types"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    types: (0, n.validate)((0, n.arrayOfType)("FlowType"))
                }
            });
            s("MixedTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            s("EmptyTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            s("NullableTypeAnnotation", {
                visitor: [
                    "typeAnnotation"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    typeAnnotation: (0, n.validateType)("FlowType")
                }
            });
            s("NumberLiteralTypeAnnotation", {
                builder: [
                    "value"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    value: (0, n.validate)((0, n.assertValueType)("number"))
                }
            });
            s("NumberTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            s("ObjectTypeAnnotation", {
                visitor: [
                    "properties",
                    "indexers",
                    "callProperties",
                    "internalSlots"
                ],
                aliases: [
                    "FlowType"
                ],
                builder: [
                    "properties",
                    "indexers",
                    "callProperties",
                    "internalSlots",
                    "exact"
                ],
                fields: {
                    properties: (0, n.validate)((0, n.arrayOfType)([
                        "ObjectTypeProperty",
                        "ObjectTypeSpreadProperty"
                    ])),
                    indexers: {
                        validate: (0, n.arrayOfType)("ObjectTypeIndexer"),
                        optional: true,
                        default: []
                    },
                    callProperties: {
                        validate: (0, n.arrayOfType)("ObjectTypeCallProperty"),
                        optional: true,
                        default: []
                    },
                    internalSlots: {
                        validate: (0, n.arrayOfType)("ObjectTypeInternalSlot"),
                        optional: true,
                        default: []
                    },
                    exact: {
                        validate: (0, n.assertValueType)("boolean"),
                        default: false
                    },
                    inexact: (0, n.validateOptional)((0, n.assertValueType)("boolean"))
                }
            });
            s("ObjectTypeInternalSlot", {
                visitor: [
                    "id",
                    "value",
                    "optional",
                    "static",
                    "method"
                ],
                aliases: [
                    "UserWhitespacable"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier"),
                    value: (0, n.validateType)("FlowType"),
                    optional: (0, n.validate)((0, n.assertValueType)("boolean")),
                    static: (0, n.validate)((0, n.assertValueType)("boolean")),
                    method: (0, n.validate)((0, n.assertValueType)("boolean"))
                }
            });
            s("ObjectTypeCallProperty", {
                visitor: [
                    "value"
                ],
                aliases: [
                    "UserWhitespacable"
                ],
                fields: {
                    value: (0, n.validateType)("FlowType"),
                    static: (0, n.validate)((0, n.assertValueType)("boolean"))
                }
            });
            s("ObjectTypeIndexer", {
                visitor: [
                    "id",
                    "key",
                    "value",
                    "variance"
                ],
                aliases: [
                    "UserWhitespacable"
                ],
                fields: {
                    id: (0, n.validateOptionalType)("Identifier"),
                    key: (0, n.validateType)("FlowType"),
                    value: (0, n.validateType)("FlowType"),
                    static: (0, n.validate)((0, n.assertValueType)("boolean")),
                    variance: (0, n.validateOptionalType)("Variance")
                }
            });
            s("ObjectTypeProperty", {
                visitor: [
                    "key",
                    "value",
                    "variance"
                ],
                aliases: [
                    "UserWhitespacable"
                ],
                fields: {
                    key: (0, n.validateType)([
                        "Identifier",
                        "StringLiteral"
                    ]),
                    value: (0, n.validateType)("FlowType"),
                    kind: (0, n.validate)((0, n.assertOneOf)("init", "get", "set")),
                    static: (0, n.validate)((0, n.assertValueType)("boolean")),
                    proto: (0, n.validate)((0, n.assertValueType)("boolean")),
                    optional: (0, n.validate)((0, n.assertValueType)("boolean")),
                    variance: (0, n.validateOptionalType)("Variance"),
                    method: (0, n.validate)((0, n.assertValueType)("boolean"))
                }
            });
            s("ObjectTypeSpreadProperty", {
                visitor: [
                    "argument"
                ],
                aliases: [
                    "UserWhitespacable"
                ],
                fields: {
                    argument: (0, n.validateType)("FlowType")
                }
            });
            s("OpaqueType", {
                visitor: [
                    "id",
                    "typeParameters",
                    "supertype",
                    "impltype"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier"),
                    typeParameters: (0, n.validateOptionalType)("TypeParameterDeclaration"),
                    supertype: (0, n.validateOptionalType)("FlowType"),
                    impltype: (0, n.validateType)("FlowType")
                }
            });
            s("QualifiedTypeIdentifier", {
                visitor: [
                    "id",
                    "qualification"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier"),
                    qualification: (0, n.validateType)([
                        "Identifier",
                        "QualifiedTypeIdentifier"
                    ])
                }
            });
            s("StringLiteralTypeAnnotation", {
                builder: [
                    "value"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    value: (0, n.validate)((0, n.assertValueType)("string"))
                }
            });
            s("StringTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            s("SymbolTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            s("ThisTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            s("TupleTypeAnnotation", {
                visitor: [
                    "types"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    types: (0, n.validate)((0, n.arrayOfType)("FlowType"))
                }
            });
            s("TypeofTypeAnnotation", {
                visitor: [
                    "argument"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    argument: (0, n.validateType)("FlowType")
                }
            });
            s("TypeAlias", {
                visitor: [
                    "id",
                    "typeParameters",
                    "right"
                ],
                aliases: [
                    "FlowDeclaration",
                    "Statement",
                    "Declaration"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier"),
                    typeParameters: (0, n.validateOptionalType)("TypeParameterDeclaration"),
                    right: (0, n.validateType)("FlowType")
                }
            });
            s("TypeAnnotation", {
                visitor: [
                    "typeAnnotation"
                ],
                fields: {
                    typeAnnotation: (0, n.validateType)("FlowType")
                }
            });
            s("TypeCastExpression", {
                visitor: [
                    "expression",
                    "typeAnnotation"
                ],
                aliases: [
                    "ExpressionWrapper",
                    "Expression"
                ],
                fields: {
                    expression: (0, n.validateType)("Expression"),
                    typeAnnotation: (0, n.validateType)("TypeAnnotation")
                }
            });
            s("TypeParameter", {
                visitor: [
                    "bound",
                    "default",
                    "variance"
                ],
                fields: {
                    name: (0, n.validate)((0, n.assertValueType)("string")),
                    bound: (0, n.validateOptionalType)("TypeAnnotation"),
                    default: (0, n.validateOptionalType)("FlowType"),
                    variance: (0, n.validateOptionalType)("Variance")
                }
            });
            s("TypeParameterDeclaration", {
                visitor: [
                    "params"
                ],
                fields: {
                    params: (0, n.validate)((0, n.arrayOfType)("TypeParameter"))
                }
            });
            s("TypeParameterInstantiation", {
                visitor: [
                    "params"
                ],
                fields: {
                    params: (0, n.validate)((0, n.arrayOfType)("FlowType"))
                }
            });
            s("UnionTypeAnnotation", {
                visitor: [
                    "types"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    types: (0, n.validate)((0, n.arrayOfType)("FlowType"))
                }
            });
            s("Variance", {
                builder: [
                    "kind"
                ],
                fields: {
                    kind: (0, n.validate)((0, n.assertOneOf)("minus", "plus"))
                }
            });
            s("VoidTypeAnnotation", {
                aliases: [
                    "FlowType",
                    "FlowBaseAnnotation"
                ]
            });
            s("EnumDeclaration", {
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                visitor: [
                    "id",
                    "body"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier"),
                    body: (0, n.validateType)([
                        "EnumBooleanBody",
                        "EnumNumberBody",
                        "EnumStringBody",
                        "EnumSymbolBody"
                    ])
                }
            });
            s("EnumBooleanBody", {
                aliases: [
                    "EnumBody"
                ],
                visitor: [
                    "members"
                ],
                fields: {
                    explicitType: (0, n.validate)((0, n.assertValueType)("boolean")),
                    members: (0, n.validateArrayOfType)("EnumBooleanMember"),
                    hasUnknownMembers: (0, n.validate)((0, n.assertValueType)("boolean"))
                }
            });
            s("EnumNumberBody", {
                aliases: [
                    "EnumBody"
                ],
                visitor: [
                    "members"
                ],
                fields: {
                    explicitType: (0, n.validate)((0, n.assertValueType)("boolean")),
                    members: (0, n.validateArrayOfType)("EnumNumberMember"),
                    hasUnknownMembers: (0, n.validate)((0, n.assertValueType)("boolean"))
                }
            });
            s("EnumStringBody", {
                aliases: [
                    "EnumBody"
                ],
                visitor: [
                    "members"
                ],
                fields: {
                    explicitType: (0, n.validate)((0, n.assertValueType)("boolean")),
                    members: (0, n.validateArrayOfType)([
                        "EnumStringMember",
                        "EnumDefaultedMember"
                    ]),
                    hasUnknownMembers: (0, n.validate)((0, n.assertValueType)("boolean"))
                }
            });
            s("EnumSymbolBody", {
                aliases: [
                    "EnumBody"
                ],
                visitor: [
                    "members"
                ],
                fields: {
                    members: (0, n.validateArrayOfType)("EnumDefaultedMember"),
                    hasUnknownMembers: (0, n.validate)((0, n.assertValueType)("boolean"))
                }
            });
            s("EnumBooleanMember", {
                aliases: [
                    "EnumMember"
                ],
                visitor: [
                    "id"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier"),
                    init: (0, n.validateType)("BooleanLiteral")
                }
            });
            s("EnumNumberMember", {
                aliases: [
                    "EnumMember"
                ],
                visitor: [
                    "id",
                    "init"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier"),
                    init: (0, n.validateType)("NumericLiteral")
                }
            });
            s("EnumStringMember", {
                aliases: [
                    "EnumMember"
                ],
                visitor: [
                    "id",
                    "init"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier"),
                    init: (0, n.validateType)("StringLiteral")
                }
            });
            s("EnumDefaultedMember", {
                aliases: [
                    "EnumMember"
                ],
                visitor: [
                    "id"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier")
                }
            });
            s("IndexedAccessType", {
                visitor: [
                    "objectType",
                    "indexType"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    objectType: (0, n.validateType)("FlowType"),
                    indexType: (0, n.validateType)("FlowType")
                }
            });
            s("OptionalIndexedAccessType", {
                visitor: [
                    "objectType",
                    "indexType"
                ],
                aliases: [
                    "FlowType"
                ],
                fields: {
                    objectType: (0, n.validateType)("FlowType"),
                    indexType: (0, n.validateType)("FlowType"),
                    optional: (0, n.validate)((0, n.assertValueType)("boolean"))
                }
            });
        },
        7940: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "ALIAS_KEYS", {
                enumerable: true,
                get: function() {
                    return s.ALIAS_KEYS;
                }
            });
            Object.defineProperty(t, "BUILDER_KEYS", {
                enumerable: true,
                get: function() {
                    return s.BUILDER_KEYS;
                }
            });
            Object.defineProperty(t, "DEPRECATED_ALIASES", {
                enumerable: true,
                get: function() {
                    return a.DEPRECATED_ALIASES;
                }
            });
            Object.defineProperty(t, "DEPRECATED_KEYS", {
                enumerable: true,
                get: function() {
                    return s.DEPRECATED_KEYS;
                }
            });
            Object.defineProperty(t, "FLIPPED_ALIAS_KEYS", {
                enumerable: true,
                get: function() {
                    return s.FLIPPED_ALIAS_KEYS;
                }
            });
            Object.defineProperty(t, "NODE_FIELDS", {
                enumerable: true,
                get: function() {
                    return s.NODE_FIELDS;
                }
            });
            Object.defineProperty(t, "NODE_PARENT_VALIDATIONS", {
                enumerable: true,
                get: function() {
                    return s.NODE_PARENT_VALIDATIONS;
                }
            });
            Object.defineProperty(t, "PLACEHOLDERS", {
                enumerable: true,
                get: function() {
                    return i.PLACEHOLDERS;
                }
            });
            Object.defineProperty(t, "PLACEHOLDERS_ALIAS", {
                enumerable: true,
                get: function() {
                    return i.PLACEHOLDERS_ALIAS;
                }
            });
            Object.defineProperty(t, "PLACEHOLDERS_FLIPPED_ALIAS", {
                enumerable: true,
                get: function() {
                    return i.PLACEHOLDERS_FLIPPED_ALIAS;
                }
            });
            t.TYPES = void 0;
            Object.defineProperty(t, "VISITOR_KEYS", {
                enumerable: true,
                get: function() {
                    return s.VISITOR_KEYS;
                }
            });
            var n = r(3797);
            r(8013);
            r(9563);
            r(8899);
            r(8195);
            r(6851);
            r(3980);
            var s = r(3706);
            var i = r(7762);
            var a = r(4482);
            Object.keys(a.DEPRECATED_ALIASES).forEach((e1)=>{
                s.FLIPPED_ALIAS_KEYS[e1] = s.FLIPPED_ALIAS_KEYS[a.DEPRECATED_ALIASES[e1]];
            });
            n(s.VISITOR_KEYS);
            n(s.ALIAS_KEYS);
            n(s.FLIPPED_ALIAS_KEYS);
            n(s.NODE_FIELDS);
            n(s.BUILDER_KEYS);
            n(s.DEPRECATED_KEYS);
            n(i.PLACEHOLDERS_ALIAS);
            n(i.PLACEHOLDERS_FLIPPED_ALIAS);
            const o = [].concat(Object.keys(s.VISITOR_KEYS), Object.keys(s.FLIPPED_ALIAS_KEYS), Object.keys(s.DEPRECATED_KEYS));
            t.TYPES = o;
        },
        8899: (e1, t, r)=>{
            "use strict";
            var n = r(3706);
            const s = (0, n.defineAliasedType)("JSX");
            s("JSXAttribute", {
                visitor: [
                    "name",
                    "value"
                ],
                aliases: [
                    "Immutable"
                ],
                fields: {
                    name: {
                        validate: (0, n.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
                    },
                    value: {
                        optional: true,
                        validate: (0, n.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
                    }
                }
            });
            s("JSXClosingElement", {
                visitor: [
                    "name"
                ],
                aliases: [
                    "Immutable"
                ],
                fields: {
                    name: {
                        validate: (0, n.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                    }
                }
            });
            s("JSXElement", {
                builder: [
                    "openingElement",
                    "closingElement",
                    "children",
                    "selfClosing"
                ],
                visitor: [
                    "openingElement",
                    "children",
                    "closingElement"
                ],
                aliases: [
                    "Immutable",
                    "Expression"
                ],
                fields: Object.assign({
                    openingElement: {
                        validate: (0, n.assertNodeType)("JSXOpeningElement")
                    },
                    closingElement: {
                        optional: true,
                        validate: (0, n.assertNodeType)("JSXClosingElement")
                    },
                    children: {
                        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
                    }
                }, {
                    selfClosing: {
                        validate: (0, n.assertValueType)("boolean"),
                        optional: true
                    }
                })
            });
            s("JSXEmptyExpression", {});
            s("JSXExpressionContainer", {
                visitor: [
                    "expression"
                ],
                aliases: [
                    "Immutable"
                ],
                fields: {
                    expression: {
                        validate: (0, n.assertNodeType)("Expression", "JSXEmptyExpression")
                    }
                }
            });
            s("JSXSpreadChild", {
                visitor: [
                    "expression"
                ],
                aliases: [
                    "Immutable"
                ],
                fields: {
                    expression: {
                        validate: (0, n.assertNodeType)("Expression")
                    }
                }
            });
            s("JSXIdentifier", {
                builder: [
                    "name"
                ],
                fields: {
                    name: {
                        validate: (0, n.assertValueType)("string")
                    }
                }
            });
            s("JSXMemberExpression", {
                visitor: [
                    "object",
                    "property"
                ],
                fields: {
                    object: {
                        validate: (0, n.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
                    },
                    property: {
                        validate: (0, n.assertNodeType)("JSXIdentifier")
                    }
                }
            });
            s("JSXNamespacedName", {
                visitor: [
                    "namespace",
                    "name"
                ],
                fields: {
                    namespace: {
                        validate: (0, n.assertNodeType)("JSXIdentifier")
                    },
                    name: {
                        validate: (0, n.assertNodeType)("JSXIdentifier")
                    }
                }
            });
            s("JSXOpeningElement", {
                builder: [
                    "name",
                    "attributes",
                    "selfClosing"
                ],
                visitor: [
                    "name",
                    "attributes"
                ],
                aliases: [
                    "Immutable"
                ],
                fields: {
                    name: {
                        validate: (0, n.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
                    },
                    selfClosing: {
                        default: false
                    },
                    attributes: {
                        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
                    },
                    typeParameters: {
                        validate: (0, n.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                        optional: true
                    }
                }
            });
            s("JSXSpreadAttribute", {
                visitor: [
                    "argument"
                ],
                fields: {
                    argument: {
                        validate: (0, n.assertNodeType)("Expression")
                    }
                }
            });
            s("JSXText", {
                aliases: [
                    "Immutable"
                ],
                builder: [
                    "value"
                ],
                fields: {
                    value: {
                        validate: (0, n.assertValueType)("string")
                    }
                }
            });
            s("JSXFragment", {
                builder: [
                    "openingFragment",
                    "closingFragment",
                    "children"
                ],
                visitor: [
                    "openingFragment",
                    "children",
                    "closingFragment"
                ],
                aliases: [
                    "Immutable",
                    "Expression"
                ],
                fields: {
                    openingFragment: {
                        validate: (0, n.assertNodeType)("JSXOpeningFragment")
                    },
                    closingFragment: {
                        validate: (0, n.assertNodeType)("JSXClosingFragment")
                    },
                    children: {
                        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
                    }
                }
            });
            s("JSXOpeningFragment", {
                aliases: [
                    "Immutable"
                ]
            });
            s("JSXClosingFragment", {
                aliases: [
                    "Immutable"
                ]
            });
        },
        8195: (e1, t, r)=>{
            "use strict";
            var n = r(3706);
            var s = r(7762);
            const i = (0, n.defineAliasedType)("Miscellaneous");
            {
                i("Noop", {
                    visitor: []
                });
            }
            i("Placeholder", {
                visitor: [],
                builder: [
                    "expectedNode",
                    "name"
                ],
                fields: {
                    name: {
                        validate: (0, n.assertNodeType)("Identifier")
                    },
                    expectedNode: {
                        validate: (0, n.assertOneOf)(...s.PLACEHOLDERS)
                    }
                }
            });
            i("V8IntrinsicIdentifier", {
                builder: [
                    "name"
                ],
                fields: {
                    name: {
                        validate: (0, n.assertValueType)("string")
                    }
                }
            });
        },
        7762: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.PLACEHOLDERS_FLIPPED_ALIAS = t.PLACEHOLDERS_ALIAS = t.PLACEHOLDERS = void 0;
            var n = r(3706);
            const s = [
                "Identifier",
                "StringLiteral",
                "Expression",
                "Statement",
                "Declaration",
                "BlockStatement",
                "ClassBody",
                "Pattern"
            ];
            t.PLACEHOLDERS = s;
            const i = {
                Declaration: [
                    "Statement"
                ],
                Pattern: [
                    "PatternLike",
                    "LVal"
                ]
            };
            t.PLACEHOLDERS_ALIAS = i;
            for (const e1 of s){
                const t = n.ALIAS_KEYS[e1];
                if (t != null && t.length) i[e1] = t;
            }
            const a = {};
            t.PLACEHOLDERS_FLIPPED_ALIAS = a;
            Object.keys(i).forEach((e1)=>{
                i[e1].forEach((t)=>{
                    if (!Object.hasOwnProperty.call(a, t)) {
                        a[t] = [];
                    }
                    a[t].push(e1);
                });
            });
        },
        3980: (e1, t, r)=>{
            "use strict";
            var n = r(3706);
            var s = r(8013);
            var i = r(9247);
            const a = (0, n.defineAliasedType)("TypeScript");
            const o = (0, n.assertValueType)("boolean");
            const tSFunctionTypeAnnotationCommon = ()=>({
                    returnType: {
                        validate: (0, n.assertNodeType)("TSTypeAnnotation", "Noop"),
                        optional: true
                    },
                    typeParameters: {
                        validate: (0, n.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
                        optional: true
                    }
                });
            a("TSParameterProperty", {
                aliases: [
                    "LVal"
                ],
                visitor: [
                    "parameter"
                ],
                fields: {
                    accessibility: {
                        validate: (0, n.assertOneOf)("public", "private", "protected"),
                        optional: true
                    },
                    readonly: {
                        validate: (0, n.assertValueType)("boolean"),
                        optional: true
                    },
                    parameter: {
                        validate: (0, n.assertNodeType)("Identifier", "AssignmentPattern")
                    },
                    override: {
                        validate: (0, n.assertValueType)("boolean"),
                        optional: true
                    },
                    decorators: {
                        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
                        optional: true
                    }
                }
            });
            a("TSDeclareFunction", {
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                visitor: [
                    "id",
                    "typeParameters",
                    "params",
                    "returnType"
                ],
                fields: Object.assign({}, (0, s.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
            });
            a("TSDeclareMethod", {
                visitor: [
                    "decorators",
                    "key",
                    "typeParameters",
                    "params",
                    "returnType"
                ],
                fields: Object.assign({}, (0, s.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
            });
            a("TSQualifiedName", {
                aliases: [
                    "TSEntityName"
                ],
                visitor: [
                    "left",
                    "right"
                ],
                fields: {
                    left: (0, n.validateType)("TSEntityName"),
                    right: (0, n.validateType)("Identifier")
                }
            });
            const signatureDeclarationCommon = ()=>({
                    typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"),
                    ["parameters"]: (0, n.validateArrayOfType)([
                        "Identifier",
                        "RestElement"
                    ]),
                    ["typeAnnotation"]: (0, n.validateOptionalType)("TSTypeAnnotation")
                });
            const l = {
                aliases: [
                    "TSTypeElement"
                ],
                visitor: [
                    "typeParameters",
                    "parameters",
                    "typeAnnotation"
                ],
                fields: signatureDeclarationCommon()
            };
            a("TSCallSignatureDeclaration", l);
            a("TSConstructSignatureDeclaration", l);
            const namedTypeElementCommon = ()=>({
                    key: (0, n.validateType)("Expression"),
                    computed: {
                        default: false
                    },
                    optional: (0, n.validateOptional)(o)
                });
            a("TSPropertySignature", {
                aliases: [
                    "TSTypeElement"
                ],
                visitor: [
                    "key",
                    "typeAnnotation",
                    "initializer"
                ],
                fields: Object.assign({}, namedTypeElementCommon(), {
                    readonly: (0, n.validateOptional)(o),
                    typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation"),
                    initializer: (0, n.validateOptionalType)("Expression"),
                    kind: {
                        validate: (0, n.assertOneOf)("get", "set")
                    }
                })
            });
            a("TSMethodSignature", {
                aliases: [
                    "TSTypeElement"
                ],
                visitor: [
                    "key",
                    "typeParameters",
                    "parameters",
                    "typeAnnotation"
                ],
                fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
                    kind: {
                        validate: (0, n.assertOneOf)("method", "get", "set")
                    }
                })
            });
            a("TSIndexSignature", {
                aliases: [
                    "TSTypeElement"
                ],
                visitor: [
                    "parameters",
                    "typeAnnotation"
                ],
                fields: {
                    readonly: (0, n.validateOptional)(o),
                    static: (0, n.validateOptional)(o),
                    parameters: (0, n.validateArrayOfType)("Identifier"),
                    typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation")
                }
            });
            const c = [
                "TSAnyKeyword",
                "TSBooleanKeyword",
                "TSBigIntKeyword",
                "TSIntrinsicKeyword",
                "TSNeverKeyword",
                "TSNullKeyword",
                "TSNumberKeyword",
                "TSObjectKeyword",
                "TSStringKeyword",
                "TSSymbolKeyword",
                "TSUndefinedKeyword",
                "TSUnknownKeyword",
                "TSVoidKeyword"
            ];
            for (const e1 of c){
                a(e1, {
                    aliases: [
                        "TSType",
                        "TSBaseType"
                    ],
                    visitor: [],
                    fields: {}
                });
            }
            a("TSThisType", {
                aliases: [
                    "TSType",
                    "TSBaseType"
                ],
                visitor: [],
                fields: {}
            });
            const u = {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeParameters",
                    "parameters",
                    "typeAnnotation"
                ]
            };
            a("TSFunctionType", Object.assign({}, u, {
                fields: signatureDeclarationCommon()
            }));
            a("TSConstructorType", Object.assign({}, u, {
                fields: Object.assign({}, signatureDeclarationCommon(), {
                    abstract: (0, n.validateOptional)(o)
                })
            }));
            a("TSTypeReference", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeName",
                    "typeParameters"
                ],
                fields: {
                    typeName: (0, n.validateType)("TSEntityName"),
                    typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation")
                }
            });
            a("TSTypePredicate", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "parameterName",
                    "typeAnnotation"
                ],
                builder: [
                    "parameterName",
                    "typeAnnotation",
                    "asserts"
                ],
                fields: {
                    parameterName: (0, n.validateType)([
                        "Identifier",
                        "TSThisType"
                    ]),
                    typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation"),
                    asserts: (0, n.validateOptional)(o)
                }
            });
            a("TSTypeQuery", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "exprName",
                    "typeParameters"
                ],
                fields: {
                    exprName: (0, n.validateType)([
                        "TSEntityName",
                        "TSImportType"
                    ]),
                    typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation")
                }
            });
            a("TSTypeLiteral", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "members"
                ],
                fields: {
                    members: (0, n.validateArrayOfType)("TSTypeElement")
                }
            });
            a("TSArrayType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "elementType"
                ],
                fields: {
                    elementType: (0, n.validateType)("TSType")
                }
            });
            a("TSTupleType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "elementTypes"
                ],
                fields: {
                    elementTypes: (0, n.validateArrayOfType)([
                        "TSType",
                        "TSNamedTupleMember"
                    ])
                }
            });
            a("TSOptionalType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeAnnotation"
                ],
                fields: {
                    typeAnnotation: (0, n.validateType)("TSType")
                }
            });
            a("TSRestType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeAnnotation"
                ],
                fields: {
                    typeAnnotation: (0, n.validateType)("TSType")
                }
            });
            a("TSNamedTupleMember", {
                visitor: [
                    "label",
                    "elementType"
                ],
                builder: [
                    "label",
                    "elementType",
                    "optional"
                ],
                fields: {
                    label: (0, n.validateType)("Identifier"),
                    optional: {
                        validate: o,
                        default: false
                    },
                    elementType: (0, n.validateType)("TSType")
                }
            });
            const p = {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "types"
                ],
                fields: {
                    types: (0, n.validateArrayOfType)("TSType")
                }
            };
            a("TSUnionType", p);
            a("TSIntersectionType", p);
            a("TSConditionalType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "checkType",
                    "extendsType",
                    "trueType",
                    "falseType"
                ],
                fields: {
                    checkType: (0, n.validateType)("TSType"),
                    extendsType: (0, n.validateType)("TSType"),
                    trueType: (0, n.validateType)("TSType"),
                    falseType: (0, n.validateType)("TSType")
                }
            });
            a("TSInferType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeParameter"
                ],
                fields: {
                    typeParameter: (0, n.validateType)("TSTypeParameter")
                }
            });
            a("TSParenthesizedType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeAnnotation"
                ],
                fields: {
                    typeAnnotation: (0, n.validateType)("TSType")
                }
            });
            a("TSTypeOperator", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeAnnotation"
                ],
                fields: {
                    operator: (0, n.validate)((0, n.assertValueType)("string")),
                    typeAnnotation: (0, n.validateType)("TSType")
                }
            });
            a("TSIndexedAccessType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "objectType",
                    "indexType"
                ],
                fields: {
                    objectType: (0, n.validateType)("TSType"),
                    indexType: (0, n.validateType)("TSType")
                }
            });
            a("TSMappedType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "typeParameter",
                    "typeAnnotation",
                    "nameType"
                ],
                fields: {
                    readonly: (0, n.validateOptional)((0, n.assertOneOf)(true, false, "+", "-")),
                    typeParameter: (0, n.validateType)("TSTypeParameter"),
                    optional: (0, n.validateOptional)((0, n.assertOneOf)(true, false, "+", "-")),
                    typeAnnotation: (0, n.validateOptionalType)("TSType"),
                    nameType: (0, n.validateOptionalType)("TSType")
                }
            });
            a("TSLiteralType", {
                aliases: [
                    "TSType",
                    "TSBaseType"
                ],
                visitor: [
                    "literal"
                ],
                fields: {
                    literal: {
                        validate: function() {
                            const e1 = (0, n.assertNodeType)("NumericLiteral", "BigIntLiteral");
                            const t = (0, n.assertOneOf)("-");
                            const r = (0, n.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
                            function validator(n, s, a) {
                                if ((0, i.default)("UnaryExpression", a)) {
                                    t(a, "operator", a.operator);
                                    e1(a, "argument", a.argument);
                                } else {
                                    r(n, s, a);
                                }
                            }
                            validator.oneOfNodeTypes = [
                                "NumericLiteral",
                                "StringLiteral",
                                "BooleanLiteral",
                                "BigIntLiteral",
                                "TemplateLiteral",
                                "UnaryExpression"
                            ];
                            return validator;
                        }()
                    }
                }
            });
            a("TSExpressionWithTypeArguments", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "expression",
                    "typeParameters"
                ],
                fields: {
                    expression: (0, n.validateType)("TSEntityName"),
                    typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation")
                }
            });
            a("TSInterfaceDeclaration", {
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                visitor: [
                    "id",
                    "typeParameters",
                    "extends",
                    "body"
                ],
                fields: {
                    declare: (0, n.validateOptional)(o),
                    id: (0, n.validateType)("Identifier"),
                    typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"),
                    extends: (0, n.validateOptional)((0, n.arrayOfType)("TSExpressionWithTypeArguments")),
                    body: (0, n.validateType)("TSInterfaceBody")
                }
            });
            a("TSInterfaceBody", {
                visitor: [
                    "body"
                ],
                fields: {
                    body: (0, n.validateArrayOfType)("TSTypeElement")
                }
            });
            a("TSTypeAliasDeclaration", {
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                visitor: [
                    "id",
                    "typeParameters",
                    "typeAnnotation"
                ],
                fields: {
                    declare: (0, n.validateOptional)(o),
                    id: (0, n.validateType)("Identifier"),
                    typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"),
                    typeAnnotation: (0, n.validateType)("TSType")
                }
            });
            a("TSInstantiationExpression", {
                aliases: [
                    "Expression"
                ],
                visitor: [
                    "expression",
                    "typeParameters"
                ],
                fields: {
                    expression: (0, n.validateType)("Expression"),
                    typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation")
                }
            });
            const f = {
                aliases: [
                    "Expression",
                    "LVal",
                    "PatternLike"
                ],
                visitor: [
                    "expression",
                    "typeAnnotation"
                ],
                fields: {
                    expression: (0, n.validateType)("Expression"),
                    typeAnnotation: (0, n.validateType)("TSType")
                }
            };
            a("TSAsExpression", f);
            a("TSSatisfiesExpression", f);
            a("TSTypeAssertion", {
                aliases: [
                    "Expression",
                    "LVal",
                    "PatternLike"
                ],
                visitor: [
                    "typeAnnotation",
                    "expression"
                ],
                fields: {
                    typeAnnotation: (0, n.validateType)("TSType"),
                    expression: (0, n.validateType)("Expression")
                }
            });
            a("TSEnumDeclaration", {
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                visitor: [
                    "id",
                    "members"
                ],
                fields: {
                    declare: (0, n.validateOptional)(o),
                    const: (0, n.validateOptional)(o),
                    id: (0, n.validateType)("Identifier"),
                    members: (0, n.validateArrayOfType)("TSEnumMember"),
                    initializer: (0, n.validateOptionalType)("Expression")
                }
            });
            a("TSEnumMember", {
                visitor: [
                    "id",
                    "initializer"
                ],
                fields: {
                    id: (0, n.validateType)([
                        "Identifier",
                        "StringLiteral"
                    ]),
                    initializer: (0, n.validateOptionalType)("Expression")
                }
            });
            a("TSModuleDeclaration", {
                aliases: [
                    "Statement",
                    "Declaration"
                ],
                visitor: [
                    "id",
                    "body"
                ],
                fields: {
                    declare: (0, n.validateOptional)(o),
                    global: (0, n.validateOptional)(o),
                    id: (0, n.validateType)([
                        "Identifier",
                        "StringLiteral"
                    ]),
                    body: (0, n.validateType)([
                        "TSModuleBlock",
                        "TSModuleDeclaration"
                    ])
                }
            });
            a("TSModuleBlock", {
                aliases: [
                    "Scopable",
                    "Block",
                    "BlockParent",
                    "FunctionParent"
                ],
                visitor: [
                    "body"
                ],
                fields: {
                    body: (0, n.validateArrayOfType)("Statement")
                }
            });
            a("TSImportType", {
                aliases: [
                    "TSType"
                ],
                visitor: [
                    "argument",
                    "qualifier",
                    "typeParameters"
                ],
                fields: {
                    argument: (0, n.validateType)("StringLiteral"),
                    qualifier: (0, n.validateOptionalType)("TSEntityName"),
                    typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation")
                }
            });
            a("TSImportEqualsDeclaration", {
                aliases: [
                    "Statement"
                ],
                visitor: [
                    "id",
                    "moduleReference"
                ],
                fields: {
                    isExport: (0, n.validate)(o),
                    id: (0, n.validateType)("Identifier"),
                    moduleReference: (0, n.validateType)([
                        "TSEntityName",
                        "TSExternalModuleReference"
                    ]),
                    importKind: {
                        validate: (0, n.assertOneOf)("type", "value"),
                        optional: true
                    }
                }
            });
            a("TSExternalModuleReference", {
                visitor: [
                    "expression"
                ],
                fields: {
                    expression: (0, n.validateType)("StringLiteral")
                }
            });
            a("TSNonNullExpression", {
                aliases: [
                    "Expression",
                    "LVal",
                    "PatternLike"
                ],
                visitor: [
                    "expression"
                ],
                fields: {
                    expression: (0, n.validateType)("Expression")
                }
            });
            a("TSExportAssignment", {
                aliases: [
                    "Statement"
                ],
                visitor: [
                    "expression"
                ],
                fields: {
                    expression: (0, n.validateType)("Expression")
                }
            });
            a("TSNamespaceExportDeclaration", {
                aliases: [
                    "Statement"
                ],
                visitor: [
                    "id"
                ],
                fields: {
                    id: (0, n.validateType)("Identifier")
                }
            });
            a("TSTypeAnnotation", {
                visitor: [
                    "typeAnnotation"
                ],
                fields: {
                    typeAnnotation: {
                        validate: (0, n.assertNodeType)("TSType")
                    }
                }
            });
            a("TSTypeParameterInstantiation", {
                visitor: [
                    "params"
                ],
                fields: {
                    params: {
                        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TSType")))
                    }
                }
            });
            a("TSTypeParameterDeclaration", {
                visitor: [
                    "params"
                ],
                fields: {
                    params: {
                        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TSTypeParameter")))
                    }
                }
            });
            a("TSTypeParameter", {
                builder: [
                    "constraint",
                    "default",
                    "name"
                ],
                visitor: [
                    "constraint",
                    "default"
                ],
                fields: {
                    name: {
                        validate: (0, n.assertValueType)("string")
                    },
                    in: {
                        validate: (0, n.assertValueType)("boolean"),
                        optional: true
                    },
                    out: {
                        validate: (0, n.assertValueType)("boolean"),
                        optional: true
                    },
                    const: {
                        validate: (0, n.assertValueType)("boolean"),
                        optional: true
                    },
                    constraint: {
                        validate: (0, n.assertNodeType)("TSType"),
                        optional: true
                    },
                    default: {
                        validate: (0, n.assertNodeType)("TSType"),
                        optional: true
                    }
                }
            });
        },
        3706: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.VISITOR_KEYS = t.NODE_PARENT_VALIDATIONS = t.NODE_FIELDS = t.FLIPPED_ALIAS_KEYS = t.DEPRECATED_KEYS = t.BUILDER_KEYS = t.ALIAS_KEYS = void 0;
            t.arrayOf = arrayOf;
            t.arrayOfType = arrayOfType;
            t.assertEach = assertEach;
            t.assertNodeOrValueType = assertNodeOrValueType;
            t.assertNodeType = assertNodeType;
            t.assertOneOf = assertOneOf;
            t.assertOptionalChainStart = assertOptionalChainStart;
            t.assertShape = assertShape;
            t.assertValueType = assertValueType;
            t.chain = chain;
            t["default"] = defineType;
            t.defineAliasedType = defineAliasedType;
            t.typeIs = typeIs;
            t.validate = validate;
            t.validateArrayOfType = validateArrayOfType;
            t.validateOptional = validateOptional;
            t.validateOptionalType = validateOptionalType;
            t.validateType = validateType;
            var n = r(9247);
            var s = r(4439);
            const i = {};
            t.VISITOR_KEYS = i;
            const a = {};
            t.ALIAS_KEYS = a;
            const o = {};
            t.FLIPPED_ALIAS_KEYS = o;
            const l = {};
            t.NODE_FIELDS = l;
            const c = {};
            t.BUILDER_KEYS = c;
            const u = {};
            t.DEPRECATED_KEYS = u;
            const p = {};
            t.NODE_PARENT_VALIDATIONS = p;
            function getType(e1) {
                if (Array.isArray(e1)) {
                    return "array";
                } else if (e1 === null) {
                    return "null";
                } else {
                    return typeof e1;
                }
            }
            function validate(e1) {
                return {
                    validate: e1
                };
            }
            function typeIs(e1) {
                return typeof e1 === "string" ? assertNodeType(e1) : assertNodeType(...e1);
            }
            function validateType(e1) {
                return validate(typeIs(e1));
            }
            function validateOptional(e1) {
                return {
                    validate: e1,
                    optional: true
                };
            }
            function validateOptionalType(e1) {
                return {
                    validate: typeIs(e1),
                    optional: true
                };
            }
            function arrayOf(e1) {
                return chain(assertValueType("array"), assertEach(e1));
            }
            function arrayOfType(e1) {
                return arrayOf(typeIs(e1));
            }
            function validateArrayOfType(e1) {
                return validate(arrayOfType(e1));
            }
            function assertEach(e1) {
                function validator(t, r, n) {
                    if (!Array.isArray(n)) return;
                    for(let i = 0; i < n.length; i++){
                        const a = `${r}[${i}]`;
                        const o = n[i];
                        e1(t, a, o);
                        if (process.env.BABEL_TYPES_8_BREAKING) (0, s.validateChild)(t, a, o);
                    }
                }
                validator.each = e1;
                return validator;
            }
            function assertOneOf(...e1) {
                function validate(t, r, n) {
                    if (e1.indexOf(n) < 0) {
                        throw new TypeError(`Property ${r} expected value to be one of ${JSON.stringify(e1)} but got ${JSON.stringify(n)}`);
                    }
                }
                validate.oneOf = e1;
                return validate;
            }
            function assertNodeType(...e1) {
                function validate(t, r, i) {
                    for (const a of e1){
                        if ((0, n.default)(a, i)) {
                            (0, s.validateChild)(t, r, i);
                            return;
                        }
                    }
                    throw new TypeError(`Property ${r} of ${t.type} expected node to be of a type ${JSON.stringify(e1)} but instead got ${JSON.stringify(i == null ? void 0 : i.type)}`);
                }
                validate.oneOfNodeTypes = e1;
                return validate;
            }
            function assertNodeOrValueType(...e1) {
                function validate(t, r, i) {
                    for (const a of e1){
                        if (getType(i) === a || (0, n.default)(a, i)) {
                            (0, s.validateChild)(t, r, i);
                            return;
                        }
                    }
                    throw new TypeError(`Property ${r} of ${t.type} expected node to be of a type ${JSON.stringify(e1)} but instead got ${JSON.stringify(i == null ? void 0 : i.type)}`);
                }
                validate.oneOfNodeOrValueTypes = e1;
                return validate;
            }
            function assertValueType(e1) {
                function validate(t, r, n) {
                    const s = getType(n) === e1;
                    if (!s) {
                        throw new TypeError(`Property ${r} expected type of ${e1} but got ${getType(n)}`);
                    }
                }
                validate.type = e1;
                return validate;
            }
            function assertShape(e1) {
                function validate(t, r, n) {
                    const i = [];
                    for (const r of Object.keys(e1)){
                        try {
                            (0, s.validateField)(t, r, n[r], e1[r]);
                        } catch (e1) {
                            if (e1 instanceof TypeError) {
                                i.push(e1.message);
                                continue;
                            }
                            throw e1;
                        }
                    }
                    if (i.length) {
                        throw new TypeError(`Property ${r} of ${t.type} expected to have the following:\n${i.join("\n")}`);
                    }
                }
                validate.shapeOf = e1;
                return validate;
            }
            function assertOptionalChainStart() {
                function validate(e1) {
                    var t;
                    let r = e1;
                    while(e1){
                        const { type: e1 } = r;
                        if (e1 === "OptionalCallExpression") {
                            if (r.optional) return;
                            r = r.callee;
                            continue;
                        }
                        if (e1 === "OptionalMemberExpression") {
                            if (r.optional) return;
                            r = r.object;
                            continue;
                        }
                        break;
                    }
                    throw new TypeError(`Non-optional ${e1.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(t = r) == null ? void 0 : t.type}`);
                }
                return validate;
            }
            function chain(...e1) {
                function validate(...t) {
                    for (const r of e1){
                        r(...t);
                    }
                }
                validate.chainOf = e1;
                if (e1.length >= 2 && "type" in e1[0] && e1[0].type === "array" && !("each" in e1[1])) {
                    throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
                }
                return validate;
            }
            const f = [
                "aliases",
                "builder",
                "deprecatedAlias",
                "fields",
                "inherits",
                "visitor",
                "validate"
            ];
            const d = [
                "default",
                "optional",
                "deprecated",
                "validate"
            ];
            const h = {};
            function defineAliasedType(...e1) {
                return (t, r = {})=>{
                    let n = r.aliases;
                    if (!n) {
                        var s, i;
                        if (r.inherits) n = (s = h[r.inherits].aliases) == null ? void 0 : s.slice();
                        (i = n) != null ? i : n = [];
                        r.aliases = n;
                    }
                    const a = e1.filter((e1)=>!n.includes(e1));
                    n.unshift(...a);
                    defineType(t, r);
                };
            }
            function defineType(e1, t = {}) {
                const r = t.inherits && h[t.inherits] || {};
                let n = t.fields;
                if (!n) {
                    n = {};
                    if (r.fields) {
                        const e1 = Object.getOwnPropertyNames(r.fields);
                        for (const t of e1){
                            const e1 = r.fields[t];
                            const s = e1.default;
                            if (Array.isArray(s) ? s.length > 0 : s && typeof s === "object") {
                                throw new Error("field defaults can only be primitives or empty arrays currently");
                            }
                            n[t] = {
                                default: Array.isArray(s) ? [] : s,
                                optional: e1.optional,
                                deprecated: e1.deprecated,
                                validate: e1.validate
                            };
                        }
                    }
                }
                const s = t.visitor || r.visitor || [];
                const m = t.aliases || r.aliases || [];
                const y = t.builder || r.builder || t.visitor || [];
                for (const r of Object.keys(t)){
                    if (f.indexOf(r) === -1) {
                        throw new Error(`Unknown type option "${r}" on ${e1}`);
                    }
                }
                if (t.deprecatedAlias) {
                    u[t.deprecatedAlias] = e1;
                }
                for (const e1 of s.concat(y)){
                    n[e1] = n[e1] || {};
                }
                for (const t of Object.keys(n)){
                    const r = n[t];
                    if (r.default !== undefined && y.indexOf(t) === -1) {
                        r.optional = true;
                    }
                    if (r.default === undefined) {
                        r.default = null;
                    } else if (!r.validate && r.default != null) {
                        r.validate = assertValueType(getType(r.default));
                    }
                    for (const n of Object.keys(r)){
                        if (d.indexOf(n) === -1) {
                            throw new Error(`Unknown field key "${n}" on ${e1}.${t}`);
                        }
                    }
                }
                i[e1] = t.visitor = s;
                c[e1] = t.builder = y;
                l[e1] = t.fields = n;
                a[e1] = t.aliases = m;
                m.forEach((t)=>{
                    o[t] = o[t] || [];
                    o[t].push(e1);
                });
                if (t.validate) {
                    p[e1] = t.validate;
                }
                h[e1] = t;
            }
        },
        776: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            var n = {
                react: true,
                assertNode: true,
                createTypeAnnotationBasedOnTypeof: true,
                createUnionTypeAnnotation: true,
                createFlowUnionType: true,
                createTSUnionType: true,
                cloneNode: true,
                clone: true,
                cloneDeep: true,
                cloneDeepWithoutLoc: true,
                cloneWithoutLoc: true,
                addComment: true,
                addComments: true,
                inheritInnerComments: true,
                inheritLeadingComments: true,
                inheritsComments: true,
                inheritTrailingComments: true,
                removeComments: true,
                ensureBlock: true,
                toBindingIdentifierName: true,
                toBlock: true,
                toComputedKey: true,
                toExpression: true,
                toIdentifier: true,
                toKeyAlias: true,
                toSequenceExpression: true,
                toStatement: true,
                valueToNode: true,
                appendToMemberExpression: true,
                inherits: true,
                prependToMemberExpression: true,
                removeProperties: true,
                removePropertiesDeep: true,
                removeTypeDuplicates: true,
                getBindingIdentifiers: true,
                getOuterBindingIdentifiers: true,
                traverse: true,
                traverseFast: true,
                shallowEqual: true,
                is: true,
                isBinding: true,
                isBlockScoped: true,
                isImmutable: true,
                isLet: true,
                isNode: true,
                isNodesEquivalent: true,
                isPlaceholderType: true,
                isReferenced: true,
                isScope: true,
                isSpecifierDefault: true,
                isType: true,
                isValidES3Identifier: true,
                isValidIdentifier: true,
                isVar: true,
                matchesPattern: true,
                validate: true,
                buildMatchMemberExpression: true,
                __internal__deprecationWarning: true
            };
            Object.defineProperty(t, "__internal__deprecationWarning", {
                enumerable: true,
                get: function() {
                    return me.default;
                }
            });
            Object.defineProperty(t, "addComment", {
                enumerable: true,
                get: function() {
                    return T.default;
                }
            });
            Object.defineProperty(t, "addComments", {
                enumerable: true,
                get: function() {
                    return S.default;
                }
            });
            Object.defineProperty(t, "appendToMemberExpression", {
                enumerable: true,
                get: function() {
                    return B.default;
                }
            });
            Object.defineProperty(t, "assertNode", {
                enumerable: true,
                get: function() {
                    return o.default;
                }
            });
            Object.defineProperty(t, "buildMatchMemberExpression", {
                enumerable: true,
                get: function() {
                    return de.default;
                }
            });
            Object.defineProperty(t, "clone", {
                enumerable: true,
                get: function() {
                    return m.default;
                }
            });
            Object.defineProperty(t, "cloneDeep", {
                enumerable: true,
                get: function() {
                    return y.default;
                }
            });
            Object.defineProperty(t, "cloneDeepWithoutLoc", {
                enumerable: true,
                get: function() {
                    return g.default;
                }
            });
            Object.defineProperty(t, "cloneNode", {
                enumerable: true,
                get: function() {
                    return h.default;
                }
            });
            Object.defineProperty(t, "cloneWithoutLoc", {
                enumerable: true,
                get: function() {
                    return b.default;
                }
            });
            Object.defineProperty(t, "createFlowUnionType", {
                enumerable: true,
                get: function() {
                    return u.default;
                }
            });
            Object.defineProperty(t, "createTSUnionType", {
                enumerable: true,
                get: function() {
                    return p.default;
                }
            });
            Object.defineProperty(t, "createTypeAnnotationBasedOnTypeof", {
                enumerable: true,
                get: function() {
                    return c.default;
                }
            });
            Object.defineProperty(t, "createUnionTypeAnnotation", {
                enumerable: true,
                get: function() {
                    return u.default;
                }
            });
            Object.defineProperty(t, "ensureBlock", {
                enumerable: true,
                get: function() {
                    return I.default;
                }
            });
            Object.defineProperty(t, "getBindingIdentifiers", {
                enumerable: true,
                get: function() {
                    return q.default;
                }
            });
            Object.defineProperty(t, "getOuterBindingIdentifiers", {
                enumerable: true,
                get: function() {
                    return H.default;
                }
            });
            Object.defineProperty(t, "inheritInnerComments", {
                enumerable: true,
                get: function() {
                    return E.default;
                }
            });
            Object.defineProperty(t, "inheritLeadingComments", {
                enumerable: true,
                get: function() {
                    return v.default;
                }
            });
            Object.defineProperty(t, "inheritTrailingComments", {
                enumerable: true,
                get: function() {
                    return P.default;
                }
            });
            Object.defineProperty(t, "inherits", {
                enumerable: true,
                get: function() {
                    return U.default;
                }
            });
            Object.defineProperty(t, "inheritsComments", {
                enumerable: true,
                get: function() {
                    return x.default;
                }
            });
            Object.defineProperty(t, "is", {
                enumerable: true,
                get: function() {
                    return z.default;
                }
            });
            Object.defineProperty(t, "isBinding", {
                enumerable: true,
                get: function() {
                    return Y.default;
                }
            });
            Object.defineProperty(t, "isBlockScoped", {
                enumerable: true,
                get: function() {
                    return Q.default;
                }
            });
            Object.defineProperty(t, "isImmutable", {
                enumerable: true,
                get: function() {
                    return Z.default;
                }
            });
            Object.defineProperty(t, "isLet", {
                enumerable: true,
                get: function() {
                    return ee.default;
                }
            });
            Object.defineProperty(t, "isNode", {
                enumerable: true,
                get: function() {
                    return te.default;
                }
            });
            Object.defineProperty(t, "isNodesEquivalent", {
                enumerable: true,
                get: function() {
                    return re.default;
                }
            });
            Object.defineProperty(t, "isPlaceholderType", {
                enumerable: true,
                get: function() {
                    return ne.default;
                }
            });
            Object.defineProperty(t, "isReferenced", {
                enumerable: true,
                get: function() {
                    return se.default;
                }
            });
            Object.defineProperty(t, "isScope", {
                enumerable: true,
                get: function() {
                    return ie.default;
                }
            });
            Object.defineProperty(t, "isSpecifierDefault", {
                enumerable: true,
                get: function() {
                    return ae.default;
                }
            });
            Object.defineProperty(t, "isType", {
                enumerable: true,
                get: function() {
                    return oe.default;
                }
            });
            Object.defineProperty(t, "isValidES3Identifier", {
                enumerable: true,
                get: function() {
                    return le.default;
                }
            });
            Object.defineProperty(t, "isValidIdentifier", {
                enumerable: true,
                get: function() {
                    return ce.default;
                }
            });
            Object.defineProperty(t, "isVar", {
                enumerable: true,
                get: function() {
                    return ue.default;
                }
            });
            Object.defineProperty(t, "matchesPattern", {
                enumerable: true,
                get: function() {
                    return pe.default;
                }
            });
            Object.defineProperty(t, "prependToMemberExpression", {
                enumerable: true,
                get: function() {
                    return K.default;
                }
            });
            t.react = void 0;
            Object.defineProperty(t, "removeComments", {
                enumerable: true,
                get: function() {
                    return w.default;
                }
            });
            Object.defineProperty(t, "removeProperties", {
                enumerable: true,
                get: function() {
                    return V.default;
                }
            });
            Object.defineProperty(t, "removePropertiesDeep", {
                enumerable: true,
                get: function() {
                    return W.default;
                }
            });
            Object.defineProperty(t, "removeTypeDuplicates", {
                enumerable: true,
                get: function() {
                    return $.default;
                }
            });
            Object.defineProperty(t, "shallowEqual", {
                enumerable: true,
                get: function() {
                    return X.default;
                }
            });
            Object.defineProperty(t, "toBindingIdentifierName", {
                enumerable: true,
                get: function() {
                    return O.default;
                }
            });
            Object.defineProperty(t, "toBlock", {
                enumerable: true,
                get: function() {
                    return k.default;
                }
            });
            Object.defineProperty(t, "toComputedKey", {
                enumerable: true,
                get: function() {
                    return N.default;
                }
            });
            Object.defineProperty(t, "toExpression", {
                enumerable: true,
                get: function() {
                    return _.default;
                }
            });
            Object.defineProperty(t, "toIdentifier", {
                enumerable: true,
                get: function() {
                    return D.default;
                }
            });
            Object.defineProperty(t, "toKeyAlias", {
                enumerable: true,
                get: function() {
                    return M.default;
                }
            });
            Object.defineProperty(t, "toSequenceExpression", {
                enumerable: true,
                get: function() {
                    return L.default;
                }
            });
            Object.defineProperty(t, "toStatement", {
                enumerable: true,
                get: function() {
                    return j.default;
                }
            });
            Object.defineProperty(t, "traverse", {
                enumerable: true,
                get: function() {
                    return G.default;
                }
            });
            Object.defineProperty(t, "traverseFast", {
                enumerable: true,
                get: function() {
                    return J.default;
                }
            });
            Object.defineProperty(t, "validate", {
                enumerable: true,
                get: function() {
                    return fe.default;
                }
            });
            Object.defineProperty(t, "valueToNode", {
                enumerable: true,
                get: function() {
                    return F.default;
                }
            });
            var s = r(7922);
            var i = r(5454);
            var a = r(4371);
            var o = r(6958);
            var l = r(9174);
            Object.keys(l).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === l[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return l[e1];
                    }
                });
            });
            var c = r(785);
            var u = r(3103);
            var p = r(8130);
            var f = r(7453);
            Object.keys(f).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === f[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return f[e1];
                    }
                });
            });
            var d = r(8611);
            Object.keys(d).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === d[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return d[e1];
                    }
                });
            });
            var h = r(7290);
            var m = r(7653);
            var y = r(8853);
            var g = r(3198);
            var b = r(764);
            var T = r(2217);
            var S = r(7777);
            var E = r(2324);
            var v = r(4570);
            var x = r(8727);
            var P = r(7720);
            var w = r(2320);
            var A = r(4300);
            Object.keys(A).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === A[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return A[e1];
                    }
                });
            });
            var C = r(4152);
            Object.keys(C).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === C[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return C[e1];
                    }
                });
            });
            var I = r(1846);
            var O = r(1642);
            var k = r(3763);
            var N = r(8564);
            var _ = r(4409);
            var D = r(5842);
            var M = r(8136);
            var L = r(3541);
            var j = r(5678);
            var F = r(2576);
            var R = r(7940);
            Object.keys(R).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === R[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return R[e1];
                    }
                });
            });
            var B = r(3307);
            var U = r(8194);
            var K = r(3687);
            var V = r(2664);
            var W = r(2510);
            var $ = r(6627);
            var q = r(6332);
            var H = r(8644);
            var G = r(275);
            Object.keys(G).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === G[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return G[e1];
                    }
                });
            });
            var J = r(2871);
            var X = r(3631);
            var z = r(9247);
            var Y = r(7527);
            var Q = r(5127);
            var Z = r(9803);
            var ee = r(775);
            var te = r(4955);
            var re = r(598);
            var ne = r(4576);
            var se = r(8103);
            var ie = r(8498);
            var ae = r(2424);
            var oe = r(9810);
            var le = r(2042);
            var ce = r(6488);
            var ue = r(6205);
            var pe = r(8877);
            var fe = r(4439);
            var de = r(2049);
            var he = r(601);
            Object.keys(he).forEach(function(e1) {
                if (e1 === "default" || e1 === "__esModule") return;
                if (Object.prototype.hasOwnProperty.call(n, e1)) return;
                if (e1 in t && t[e1] === he[e1]) return;
                Object.defineProperty(t, e1, {
                    enumerable: true,
                    get: function() {
                        return he[e1];
                    }
                });
            });
            var me = r(4585);
            const ye = {
                isReactComponent: s.default,
                isCompatTag: i.default,
                buildChildren: a.default
            };
            t.react = ye;
        },
        3307: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = appendToMemberExpression;
            var n = r(7453);
            function appendToMemberExpression(e1, t, r = false) {
                e1.object = (0, n.memberExpression)(e1.object, e1.property, e1.computed);
                e1.property = t;
                e1.computed = !!r;
                return e1;
            }
        },
        6627: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = removeTypeDuplicates;
            var n = r(601);
            function getQualifiedName(e1) {
                return (0, n.isIdentifier)(e1) ? e1.name : `${e1.id.name}.${getQualifiedName(e1.qualification)}`;
            }
            function removeTypeDuplicates(e1) {
                const t = Array.from(e1);
                const r = new Map;
                const s = new Map;
                const i = new Set;
                const a = [];
                for(let e1 = 0; e1 < t.length; e1++){
                    const o = t[e1];
                    if (!o) continue;
                    if (a.indexOf(o) >= 0) {
                        continue;
                    }
                    if ((0, n.isAnyTypeAnnotation)(o)) {
                        return [
                            o
                        ];
                    }
                    if ((0, n.isFlowBaseAnnotation)(o)) {
                        s.set(o.type, o);
                        continue;
                    }
                    if ((0, n.isUnionTypeAnnotation)(o)) {
                        if (!i.has(o.types)) {
                            t.push(...o.types);
                            i.add(o.types);
                        }
                        continue;
                    }
                    if ((0, n.isGenericTypeAnnotation)(o)) {
                        const e1 = getQualifiedName(o.id);
                        if (r.has(e1)) {
                            let t = r.get(e1);
                            if (t.typeParameters) {
                                if (o.typeParameters) {
                                    t.typeParameters.params.push(...o.typeParameters.params);
                                    t.typeParameters.params = removeTypeDuplicates(t.typeParameters.params);
                                }
                            } else {
                                t = o.typeParameters;
                            }
                        } else {
                            r.set(e1, o);
                        }
                        continue;
                    }
                    a.push(o);
                }
                for (const [, e1] of s){
                    a.push(e1);
                }
                for (const [, e1] of r){
                    a.push(e1);
                }
                return a;
            }
        },
        8194: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = inherits;
            var n = r(4152);
            var s = r(8727);
            function inherits(e1, t) {
                if (!e1 || !t) return e1;
                for (const r of n.INHERIT_KEYS.optional){
                    if (e1[r] == null) {
                        e1[r] = t[r];
                    }
                }
                for (const r of Object.keys(t)){
                    if (r[0] === "_" && r !== "__clone") {
                        e1[r] = t[r];
                    }
                }
                for (const r of n.INHERIT_KEYS.force){
                    e1[r] = t[r];
                }
                (0, s.default)(e1, t);
                return e1;
            }
        },
        3687: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = prependToMemberExpression;
            var n = r(7453);
            var s = r(776);
            function prependToMemberExpression(e1, t) {
                if ((0, s.isSuper)(e1.object)) {
                    throw new Error("Cannot prepend node to super property access (`super.foo`).");
                }
                e1.object = (0, n.memberExpression)(t, e1.object);
                return e1;
            }
        },
        2664: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = removeProperties;
            var n = r(4152);
            const s = [
                "tokens",
                "start",
                "end",
                "loc",
                "raw",
                "rawValue"
            ];
            const i = [
                ...n.COMMENT_KEYS,
                "comments",
                ...s
            ];
            function removeProperties(e1, t = {}) {
                const r = t.preserveComments ? s : i;
                for (const t of r){
                    if (e1[t] != null) e1[t] = undefined;
                }
                for (const t of Object.keys(e1)){
                    if (t[0] === "_" && e1[t] != null) e1[t] = undefined;
                }
                const n = Object.getOwnPropertySymbols(e1);
                for (const t of n){
                    e1[t] = null;
                }
            }
        },
        2510: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = removePropertiesDeep;
            var n = r(2871);
            var s = r(2664);
            function removePropertiesDeep(e1, t) {
                (0, n.default)(e1, s.default, t);
                return e1;
            }
        },
        1093: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = removeTypeDuplicates;
            var n = r(601);
            function getQualifiedName(e1) {
                return (0, n.isIdentifier)(e1) ? e1.name : `${e1.right.name}.${getQualifiedName(e1.left)}`;
            }
            function removeTypeDuplicates(e1) {
                const t = Array.from(e1);
                const r = new Map;
                const s = new Map;
                const i = new Set;
                const a = [];
                for(let e1 = 0; e1 < t.length; e1++){
                    const o = t[e1];
                    if (!o) continue;
                    if (a.indexOf(o) >= 0) {
                        continue;
                    }
                    if ((0, n.isTSAnyKeyword)(o)) {
                        return [
                            o
                        ];
                    }
                    if ((0, n.isTSBaseType)(o)) {
                        s.set(o.type, o);
                        continue;
                    }
                    if ((0, n.isTSUnionType)(o)) {
                        if (!i.has(o.types)) {
                            t.push(...o.types);
                            i.add(o.types);
                        }
                        continue;
                    }
                    if ((0, n.isTSTypeReference)(o) && o.typeParameters) {
                        const e1 = getQualifiedName(o.typeName);
                        if (r.has(e1)) {
                            let t = r.get(e1);
                            if (t.typeParameters) {
                                if (o.typeParameters) {
                                    t.typeParameters.params.push(...o.typeParameters.params);
                                    t.typeParameters.params = removeTypeDuplicates(t.typeParameters.params);
                                }
                            } else {
                                t = o.typeParameters;
                            }
                        } else {
                            r.set(e1, o);
                        }
                        continue;
                    }
                    a.push(o);
                }
                for (const [, e1] of s){
                    a.push(e1);
                }
                for (const [, e1] of r){
                    a.push(e1);
                }
                return a;
            }
        },
        6332: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = getBindingIdentifiers;
            var n = r(601);
            function getBindingIdentifiers(e1, t, r) {
                const s = [].concat(e1);
                const i = Object.create(null);
                while(s.length){
                    const e1 = s.shift();
                    if (!e1) continue;
                    const a = getBindingIdentifiers.keys[e1.type];
                    if ((0, n.isIdentifier)(e1)) {
                        if (t) {
                            const t = i[e1.name] = i[e1.name] || [];
                            t.push(e1);
                        } else {
                            i[e1.name] = e1;
                        }
                        continue;
                    }
                    if ((0, n.isExportDeclaration)(e1) && !(0, n.isExportAllDeclaration)(e1)) {
                        if ((0, n.isDeclaration)(e1.declaration)) {
                            s.push(e1.declaration);
                        }
                        continue;
                    }
                    if (r) {
                        if ((0, n.isFunctionDeclaration)(e1)) {
                            s.push(e1.id);
                            continue;
                        }
                        if ((0, n.isFunctionExpression)(e1)) {
                            continue;
                        }
                    }
                    if (a) {
                        for(let t = 0; t < a.length; t++){
                            const r = a[t];
                            const n = e1[r];
                            if (n) {
                                Array.isArray(n) ? s.push(...n) : s.push(n);
                            }
                        }
                    }
                }
                return i;
            }
            getBindingIdentifiers.keys = {
                DeclareClass: [
                    "id"
                ],
                DeclareFunction: [
                    "id"
                ],
                DeclareModule: [
                    "id"
                ],
                DeclareVariable: [
                    "id"
                ],
                DeclareInterface: [
                    "id"
                ],
                DeclareTypeAlias: [
                    "id"
                ],
                DeclareOpaqueType: [
                    "id"
                ],
                InterfaceDeclaration: [
                    "id"
                ],
                TypeAlias: [
                    "id"
                ],
                OpaqueType: [
                    "id"
                ],
                CatchClause: [
                    "param"
                ],
                LabeledStatement: [
                    "label"
                ],
                UnaryExpression: [
                    "argument"
                ],
                AssignmentExpression: [
                    "left"
                ],
                ImportSpecifier: [
                    "local"
                ],
                ImportNamespaceSpecifier: [
                    "local"
                ],
                ImportDefaultSpecifier: [
                    "local"
                ],
                ImportDeclaration: [
                    "specifiers"
                ],
                ExportSpecifier: [
                    "exported"
                ],
                ExportNamespaceSpecifier: [
                    "exported"
                ],
                ExportDefaultSpecifier: [
                    "exported"
                ],
                FunctionDeclaration: [
                    "id",
                    "params"
                ],
                FunctionExpression: [
                    "id",
                    "params"
                ],
                ArrowFunctionExpression: [
                    "params"
                ],
                ObjectMethod: [
                    "params"
                ],
                ClassMethod: [
                    "params"
                ],
                ClassPrivateMethod: [
                    "params"
                ],
                ForInStatement: [
                    "left"
                ],
                ForOfStatement: [
                    "left"
                ],
                ClassDeclaration: [
                    "id"
                ],
                ClassExpression: [
                    "id"
                ],
                RestElement: [
                    "argument"
                ],
                UpdateExpression: [
                    "argument"
                ],
                ObjectProperty: [
                    "value"
                ],
                AssignmentPattern: [
                    "left"
                ],
                ArrayPattern: [
                    "elements"
                ],
                ObjectPattern: [
                    "properties"
                ],
                VariableDeclaration: [
                    "declarations"
                ],
                VariableDeclarator: [
                    "id"
                ]
            };
        },
        8644: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(6332);
            var s = getOuterBindingIdentifiers;
            t["default"] = s;
            function getOuterBindingIdentifiers(e1, t) {
                return (0, n.default)(e1, t, true);
            }
        },
        275: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = traverse;
            var n = r(7940);
            function traverse(e1, t, r) {
                if (typeof t === "function") {
                    t = {
                        enter: t
                    };
                }
                const { enter: n, exit: s } = t;
                traverseSimpleImpl(e1, n, s, r, []);
            }
            function traverseSimpleImpl(e1, t, r, s, i) {
                const a = n.VISITOR_KEYS[e1.type];
                if (!a) return;
                if (t) t(e1, i, s);
                for (const n of a){
                    const a = e1[n];
                    if (Array.isArray(a)) {
                        for(let o = 0; o < a.length; o++){
                            const l = a[o];
                            if (!l) continue;
                            i.push({
                                node: e1,
                                key: n,
                                index: o
                            });
                            traverseSimpleImpl(l, t, r, s, i);
                            i.pop();
                        }
                    } else if (a) {
                        i.push({
                            node: e1,
                            key: n
                        });
                        traverseSimpleImpl(a, t, r, s, i);
                        i.pop();
                    }
                }
                if (r) r(e1, i, s);
            }
        },
        2871: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = traverseFast;
            var n = r(7940);
            function traverseFast(e1, t, r) {
                if (!e1) return;
                const s = n.VISITOR_KEYS[e1.type];
                if (!s) return;
                r = r || {};
                t(e1, r);
                for (const n of s){
                    const s = e1[n];
                    if (Array.isArray(s)) {
                        for (const e1 of s){
                            traverseFast(e1, t, r);
                        }
                    } else {
                        traverseFast(s, t, r);
                    }
                }
            }
        },
        4585: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = deprecationWarning;
            const r = new Set;
            function deprecationWarning(e1, t, n = "") {
                if (r.has(e1)) return;
                r.add(e1);
                const { internal: s, trace: i } = captureShortStackTrace(1, 2);
                if (s) {
                    return;
                }
                console.warn(`${n}\`${e1}\` has been deprecated, please migrate to \`${t}\`\n${i}`);
            }
            function captureShortStackTrace(e1, t) {
                const { stackTraceLimit: r, prepareStackTrace: n } = Error;
                let s;
                Error.stackTraceLimit = 1 + e1 + t;
                Error.prepareStackTrace = function(e1, t) {
                    s = t;
                };
                (new Error).stack;
                Error.stackTraceLimit = r;
                Error.prepareStackTrace = n;
                if (!s) return {
                    internal: false,
                    trace: ""
                };
                const i = s.slice(1 + e1, 1 + e1 + t);
                return {
                    internal: /[\\/]@babel[\\/]/.test(i[1].getFileName()),
                    trace: i.map((e1)=>`    at ${e1}`).join("\n")
                };
            }
        },
        1066: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = inherit;
            function inherit(e1, t, r) {
                if (t && r) {
                    t[e1] = Array.from(new Set([].concat(t[e1], r[e1]).filter(Boolean)));
                }
            }
        },
        9187: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = cleanJSXElementLiteralChild;
            var n = r(7453);
            var s = r(776);
            function cleanJSXElementLiteralChild(e1, t) {
                const r = e1.value.split(/\r\n|\n|\r/);
                let i = 0;
                for(let e1 = 0; e1 < r.length; e1++){
                    if (r[e1].match(/[^ \t]/)) {
                        i = e1;
                    }
                }
                let a = "";
                for(let e1 = 0; e1 < r.length; e1++){
                    const t = r[e1];
                    const n = e1 === 0;
                    const s = e1 === r.length - 1;
                    const o = e1 === i;
                    let l = t.replace(/\t/g, " ");
                    if (!n) {
                        l = l.replace(/^[ ]+/, "");
                    }
                    if (!s) {
                        l = l.replace(/[ ]+$/, "");
                    }
                    if (l) {
                        if (!o) {
                            l += " ";
                        }
                        a += l;
                    }
                }
                if (a) t.push((0, s.inherits)((0, n.stringLiteral)(a), e1));
            }
        },
        3631: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = shallowEqual;
            function shallowEqual(e1, t) {
                const r = Object.keys(t);
                for (const n of r){
                    if (e1[n] !== t[n]) {
                        return false;
                    }
                }
                return true;
            }
        },
        2049: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = buildMatchMemberExpression;
            var n = r(8877);
            function buildMatchMemberExpression(e1, t) {
                const r = e1.split(".");
                return (e1)=>(0, n.default)(e1, r, t);
            }
        },
        601: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isAccessor = isAccessor;
            t.isAnyTypeAnnotation = isAnyTypeAnnotation;
            t.isArgumentPlaceholder = isArgumentPlaceholder;
            t.isArrayExpression = isArrayExpression;
            t.isArrayPattern = isArrayPattern;
            t.isArrayTypeAnnotation = isArrayTypeAnnotation;
            t.isArrowFunctionExpression = isArrowFunctionExpression;
            t.isAssignmentExpression = isAssignmentExpression;
            t.isAssignmentPattern = isAssignmentPattern;
            t.isAwaitExpression = isAwaitExpression;
            t.isBigIntLiteral = isBigIntLiteral;
            t.isBinary = isBinary;
            t.isBinaryExpression = isBinaryExpression;
            t.isBindExpression = isBindExpression;
            t.isBlock = isBlock;
            t.isBlockParent = isBlockParent;
            t.isBlockStatement = isBlockStatement;
            t.isBooleanLiteral = isBooleanLiteral;
            t.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
            t.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
            t.isBreakStatement = isBreakStatement;
            t.isCallExpression = isCallExpression;
            t.isCatchClause = isCatchClause;
            t.isClass = isClass;
            t.isClassAccessorProperty = isClassAccessorProperty;
            t.isClassBody = isClassBody;
            t.isClassDeclaration = isClassDeclaration;
            t.isClassExpression = isClassExpression;
            t.isClassImplements = isClassImplements;
            t.isClassMethod = isClassMethod;
            t.isClassPrivateMethod = isClassPrivateMethod;
            t.isClassPrivateProperty = isClassPrivateProperty;
            t.isClassProperty = isClassProperty;
            t.isCompletionStatement = isCompletionStatement;
            t.isConditional = isConditional;
            t.isConditionalExpression = isConditionalExpression;
            t.isContinueStatement = isContinueStatement;
            t.isDebuggerStatement = isDebuggerStatement;
            t.isDecimalLiteral = isDecimalLiteral;
            t.isDeclaration = isDeclaration;
            t.isDeclareClass = isDeclareClass;
            t.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
            t.isDeclareExportDeclaration = isDeclareExportDeclaration;
            t.isDeclareFunction = isDeclareFunction;
            t.isDeclareInterface = isDeclareInterface;
            t.isDeclareModule = isDeclareModule;
            t.isDeclareModuleExports = isDeclareModuleExports;
            t.isDeclareOpaqueType = isDeclareOpaqueType;
            t.isDeclareTypeAlias = isDeclareTypeAlias;
            t.isDeclareVariable = isDeclareVariable;
            t.isDeclaredPredicate = isDeclaredPredicate;
            t.isDecorator = isDecorator;
            t.isDirective = isDirective;
            t.isDirectiveLiteral = isDirectiveLiteral;
            t.isDoExpression = isDoExpression;
            t.isDoWhileStatement = isDoWhileStatement;
            t.isEmptyStatement = isEmptyStatement;
            t.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
            t.isEnumBody = isEnumBody;
            t.isEnumBooleanBody = isEnumBooleanBody;
            t.isEnumBooleanMember = isEnumBooleanMember;
            t.isEnumDeclaration = isEnumDeclaration;
            t.isEnumDefaultedMember = isEnumDefaultedMember;
            t.isEnumMember = isEnumMember;
            t.isEnumNumberBody = isEnumNumberBody;
            t.isEnumNumberMember = isEnumNumberMember;
            t.isEnumStringBody = isEnumStringBody;
            t.isEnumStringMember = isEnumStringMember;
            t.isEnumSymbolBody = isEnumSymbolBody;
            t.isExistsTypeAnnotation = isExistsTypeAnnotation;
            t.isExportAllDeclaration = isExportAllDeclaration;
            t.isExportDeclaration = isExportDeclaration;
            t.isExportDefaultDeclaration = isExportDefaultDeclaration;
            t.isExportDefaultSpecifier = isExportDefaultSpecifier;
            t.isExportNamedDeclaration = isExportNamedDeclaration;
            t.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
            t.isExportSpecifier = isExportSpecifier;
            t.isExpression = isExpression;
            t.isExpressionStatement = isExpressionStatement;
            t.isExpressionWrapper = isExpressionWrapper;
            t.isFile = isFile;
            t.isFlow = isFlow;
            t.isFlowBaseAnnotation = isFlowBaseAnnotation;
            t.isFlowDeclaration = isFlowDeclaration;
            t.isFlowPredicate = isFlowPredicate;
            t.isFlowType = isFlowType;
            t.isFor = isFor;
            t.isForInStatement = isForInStatement;
            t.isForOfStatement = isForOfStatement;
            t.isForStatement = isForStatement;
            t.isForXStatement = isForXStatement;
            t.isFunction = isFunction;
            t.isFunctionDeclaration = isFunctionDeclaration;
            t.isFunctionExpression = isFunctionExpression;
            t.isFunctionParent = isFunctionParent;
            t.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
            t.isFunctionTypeParam = isFunctionTypeParam;
            t.isGenericTypeAnnotation = isGenericTypeAnnotation;
            t.isIdentifier = isIdentifier;
            t.isIfStatement = isIfStatement;
            t.isImmutable = isImmutable;
            t.isImport = isImport;
            t.isImportAttribute = isImportAttribute;
            t.isImportDeclaration = isImportDeclaration;
            t.isImportDefaultSpecifier = isImportDefaultSpecifier;
            t.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
            t.isImportOrExportDeclaration = isImportOrExportDeclaration;
            t.isImportSpecifier = isImportSpecifier;
            t.isIndexedAccessType = isIndexedAccessType;
            t.isInferredPredicate = isInferredPredicate;
            t.isInterfaceDeclaration = isInterfaceDeclaration;
            t.isInterfaceExtends = isInterfaceExtends;
            t.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
            t.isInterpreterDirective = isInterpreterDirective;
            t.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
            t.isJSX = isJSX;
            t.isJSXAttribute = isJSXAttribute;
            t.isJSXClosingElement = isJSXClosingElement;
            t.isJSXClosingFragment = isJSXClosingFragment;
            t.isJSXElement = isJSXElement;
            t.isJSXEmptyExpression = isJSXEmptyExpression;
            t.isJSXExpressionContainer = isJSXExpressionContainer;
            t.isJSXFragment = isJSXFragment;
            t.isJSXIdentifier = isJSXIdentifier;
            t.isJSXMemberExpression = isJSXMemberExpression;
            t.isJSXNamespacedName = isJSXNamespacedName;
            t.isJSXOpeningElement = isJSXOpeningElement;
            t.isJSXOpeningFragment = isJSXOpeningFragment;
            t.isJSXSpreadAttribute = isJSXSpreadAttribute;
            t.isJSXSpreadChild = isJSXSpreadChild;
            t.isJSXText = isJSXText;
            t.isLVal = isLVal;
            t.isLabeledStatement = isLabeledStatement;
            t.isLiteral = isLiteral;
            t.isLogicalExpression = isLogicalExpression;
            t.isLoop = isLoop;
            t.isMemberExpression = isMemberExpression;
            t.isMetaProperty = isMetaProperty;
            t.isMethod = isMethod;
            t.isMiscellaneous = isMiscellaneous;
            t.isMixedTypeAnnotation = isMixedTypeAnnotation;
            t.isModuleDeclaration = isModuleDeclaration;
            t.isModuleExpression = isModuleExpression;
            t.isModuleSpecifier = isModuleSpecifier;
            t.isNewExpression = isNewExpression;
            t.isNoop = isNoop;
            t.isNullLiteral = isNullLiteral;
            t.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
            t.isNullableTypeAnnotation = isNullableTypeAnnotation;
            t.isNumberLiteral = isNumberLiteral;
            t.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
            t.isNumberTypeAnnotation = isNumberTypeAnnotation;
            t.isNumericLiteral = isNumericLiteral;
            t.isObjectExpression = isObjectExpression;
            t.isObjectMember = isObjectMember;
            t.isObjectMethod = isObjectMethod;
            t.isObjectPattern = isObjectPattern;
            t.isObjectProperty = isObjectProperty;
            t.isObjectTypeAnnotation = isObjectTypeAnnotation;
            t.isObjectTypeCallProperty = isObjectTypeCallProperty;
            t.isObjectTypeIndexer = isObjectTypeIndexer;
            t.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
            t.isObjectTypeProperty = isObjectTypeProperty;
            t.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
            t.isOpaqueType = isOpaqueType;
            t.isOptionalCallExpression = isOptionalCallExpression;
            t.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
            t.isOptionalMemberExpression = isOptionalMemberExpression;
            t.isParenthesizedExpression = isParenthesizedExpression;
            t.isPattern = isPattern;
            t.isPatternLike = isPatternLike;
            t.isPipelineBareFunction = isPipelineBareFunction;
            t.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
            t.isPipelineTopicExpression = isPipelineTopicExpression;
            t.isPlaceholder = isPlaceholder;
            t.isPrivate = isPrivate;
            t.isPrivateName = isPrivateName;
            t.isProgram = isProgram;
            t.isProperty = isProperty;
            t.isPureish = isPureish;
            t.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
            t.isRecordExpression = isRecordExpression;
            t.isRegExpLiteral = isRegExpLiteral;
            t.isRegexLiteral = isRegexLiteral;
            t.isRestElement = isRestElement;
            t.isRestProperty = isRestProperty;
            t.isReturnStatement = isReturnStatement;
            t.isScopable = isScopable;
            t.isSequenceExpression = isSequenceExpression;
            t.isSpreadElement = isSpreadElement;
            t.isSpreadProperty = isSpreadProperty;
            t.isStandardized = isStandardized;
            t.isStatement = isStatement;
            t.isStaticBlock = isStaticBlock;
            t.isStringLiteral = isStringLiteral;
            t.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
            t.isStringTypeAnnotation = isStringTypeAnnotation;
            t.isSuper = isSuper;
            t.isSwitchCase = isSwitchCase;
            t.isSwitchStatement = isSwitchStatement;
            t.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
            t.isTSAnyKeyword = isTSAnyKeyword;
            t.isTSArrayType = isTSArrayType;
            t.isTSAsExpression = isTSAsExpression;
            t.isTSBaseType = isTSBaseType;
            t.isTSBigIntKeyword = isTSBigIntKeyword;
            t.isTSBooleanKeyword = isTSBooleanKeyword;
            t.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
            t.isTSConditionalType = isTSConditionalType;
            t.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
            t.isTSConstructorType = isTSConstructorType;
            t.isTSDeclareFunction = isTSDeclareFunction;
            t.isTSDeclareMethod = isTSDeclareMethod;
            t.isTSEntityName = isTSEntityName;
            t.isTSEnumDeclaration = isTSEnumDeclaration;
            t.isTSEnumMember = isTSEnumMember;
            t.isTSExportAssignment = isTSExportAssignment;
            t.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
            t.isTSExternalModuleReference = isTSExternalModuleReference;
            t.isTSFunctionType = isTSFunctionType;
            t.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
            t.isTSImportType = isTSImportType;
            t.isTSIndexSignature = isTSIndexSignature;
            t.isTSIndexedAccessType = isTSIndexedAccessType;
            t.isTSInferType = isTSInferType;
            t.isTSInstantiationExpression = isTSInstantiationExpression;
            t.isTSInterfaceBody = isTSInterfaceBody;
            t.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
            t.isTSIntersectionType = isTSIntersectionType;
            t.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
            t.isTSLiteralType = isTSLiteralType;
            t.isTSMappedType = isTSMappedType;
            t.isTSMethodSignature = isTSMethodSignature;
            t.isTSModuleBlock = isTSModuleBlock;
            t.isTSModuleDeclaration = isTSModuleDeclaration;
            t.isTSNamedTupleMember = isTSNamedTupleMember;
            t.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
            t.isTSNeverKeyword = isTSNeverKeyword;
            t.isTSNonNullExpression = isTSNonNullExpression;
            t.isTSNullKeyword = isTSNullKeyword;
            t.isTSNumberKeyword = isTSNumberKeyword;
            t.isTSObjectKeyword = isTSObjectKeyword;
            t.isTSOptionalType = isTSOptionalType;
            t.isTSParameterProperty = isTSParameterProperty;
            t.isTSParenthesizedType = isTSParenthesizedType;
            t.isTSPropertySignature = isTSPropertySignature;
            t.isTSQualifiedName = isTSQualifiedName;
            t.isTSRestType = isTSRestType;
            t.isTSSatisfiesExpression = isTSSatisfiesExpression;
            t.isTSStringKeyword = isTSStringKeyword;
            t.isTSSymbolKeyword = isTSSymbolKeyword;
            t.isTSThisType = isTSThisType;
            t.isTSTupleType = isTSTupleType;
            t.isTSType = isTSType;
            t.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
            t.isTSTypeAnnotation = isTSTypeAnnotation;
            t.isTSTypeAssertion = isTSTypeAssertion;
            t.isTSTypeElement = isTSTypeElement;
            t.isTSTypeLiteral = isTSTypeLiteral;
            t.isTSTypeOperator = isTSTypeOperator;
            t.isTSTypeParameter = isTSTypeParameter;
            t.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
            t.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
            t.isTSTypePredicate = isTSTypePredicate;
            t.isTSTypeQuery = isTSTypeQuery;
            t.isTSTypeReference = isTSTypeReference;
            t.isTSUndefinedKeyword = isTSUndefinedKeyword;
            t.isTSUnionType = isTSUnionType;
            t.isTSUnknownKeyword = isTSUnknownKeyword;
            t.isTSVoidKeyword = isTSVoidKeyword;
            t.isTaggedTemplateExpression = isTaggedTemplateExpression;
            t.isTemplateElement = isTemplateElement;
            t.isTemplateLiteral = isTemplateLiteral;
            t.isTerminatorless = isTerminatorless;
            t.isThisExpression = isThisExpression;
            t.isThisTypeAnnotation = isThisTypeAnnotation;
            t.isThrowStatement = isThrowStatement;
            t.isTopicReference = isTopicReference;
            t.isTryStatement = isTryStatement;
            t.isTupleExpression = isTupleExpression;
            t.isTupleTypeAnnotation = isTupleTypeAnnotation;
            t.isTypeAlias = isTypeAlias;
            t.isTypeAnnotation = isTypeAnnotation;
            t.isTypeCastExpression = isTypeCastExpression;
            t.isTypeParameter = isTypeParameter;
            t.isTypeParameterDeclaration = isTypeParameterDeclaration;
            t.isTypeParameterInstantiation = isTypeParameterInstantiation;
            t.isTypeScript = isTypeScript;
            t.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
            t.isUnaryExpression = isUnaryExpression;
            t.isUnaryLike = isUnaryLike;
            t.isUnionTypeAnnotation = isUnionTypeAnnotation;
            t.isUpdateExpression = isUpdateExpression;
            t.isUserWhitespacable = isUserWhitespacable;
            t.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
            t.isVariableDeclaration = isVariableDeclaration;
            t.isVariableDeclarator = isVariableDeclarator;
            t.isVariance = isVariance;
            t.isVoidTypeAnnotation = isVoidTypeAnnotation;
            t.isWhile = isWhile;
            t.isWhileStatement = isWhileStatement;
            t.isWithStatement = isWithStatement;
            t.isYieldExpression = isYieldExpression;
            var n = r(3631);
            var s = r(4585);
            function isArrayExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ArrayExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isAssignmentExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "AssignmentExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBinaryExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BinaryExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isInterpreterDirective(e1, t) {
                if (!e1) return false;
                if (e1.type !== "InterpreterDirective") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDirective(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Directive") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDirectiveLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DirectiveLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBlockStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BlockStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBreakStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BreakStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isCallExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "CallExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isCatchClause(e1, t) {
                if (!e1) return false;
                if (e1.type !== "CatchClause") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isConditionalExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ConditionalExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isContinueStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ContinueStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDebuggerStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DebuggerStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDoWhileStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DoWhileStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEmptyStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EmptyStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExpressionStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExpressionStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isFile(e1, t) {
                if (!e1) return false;
                if (e1.type !== "File") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isForInStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ForInStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isForStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ForStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isFunctionDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "FunctionDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isFunctionExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "FunctionExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isIdentifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Identifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isIfStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "IfStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isLabeledStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "LabeledStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isStringLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "StringLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNumericLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NumericLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNullLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NullLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBooleanLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BooleanLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isRegExpLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "RegExpLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isLogicalExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "LogicalExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isMemberExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "MemberExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNewExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NewExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isProgram(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Program") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectMethod(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectMethod") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isRestElement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "RestElement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isReturnStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ReturnStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSequenceExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "SequenceExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isParenthesizedExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ParenthesizedExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSwitchCase(e1, t) {
                if (!e1) return false;
                if (e1.type !== "SwitchCase") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSwitchStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "SwitchStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isThisExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ThisExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isThrowStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ThrowStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTryStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TryStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isUnaryExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "UnaryExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isUpdateExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "UpdateExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isVariableDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "VariableDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isVariableDeclarator(e1, t) {
                if (!e1) return false;
                if (e1.type !== "VariableDeclarator") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isWhileStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "WhileStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isWithStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "WithStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isAssignmentPattern(e1, t) {
                if (!e1) return false;
                if (e1.type !== "AssignmentPattern") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isArrayPattern(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ArrayPattern") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isArrowFunctionExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ArrowFunctionExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassBody(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassBody") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExportAllDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExportAllDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExportDefaultDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExportDefaultDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExportNamedDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExportNamedDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExportSpecifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExportSpecifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isForOfStatement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ForOfStatement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isImportDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ImportDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isImportDefaultSpecifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ImportDefaultSpecifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isImportNamespaceSpecifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ImportNamespaceSpecifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isImportSpecifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ImportSpecifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isMetaProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "MetaProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassMethod(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassMethod") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectPattern(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectPattern") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSpreadElement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "SpreadElement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSuper(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Super") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTaggedTemplateExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TaggedTemplateExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTemplateElement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TemplateElement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTemplateLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TemplateLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isYieldExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "YieldExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isAwaitExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "AwaitExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isImport(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Import") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBigIntLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BigIntLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExportNamespaceSpecifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExportNamespaceSpecifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isOptionalMemberExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "OptionalMemberExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isOptionalCallExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "OptionalCallExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassAccessorProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassAccessorProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassPrivateProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassPrivateProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassPrivateMethod(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassPrivateMethod") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isPrivateName(e1, t) {
                if (!e1) return false;
                if (e1.type !== "PrivateName") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isStaticBlock(e1, t) {
                if (!e1) return false;
                if (e1.type !== "StaticBlock") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isAnyTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "AnyTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isArrayTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ArrayTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBooleanTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BooleanTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBooleanLiteralTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BooleanLiteralTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNullLiteralTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NullLiteralTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isClassImplements(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ClassImplements") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareClass(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareClass") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareFunction(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareFunction") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareInterface(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareInterface") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareModule(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareModule") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareModuleExports(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareModuleExports") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareTypeAlias(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareTypeAlias") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareOpaqueType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareOpaqueType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareVariable(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareVariable") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareExportDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareExportDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclareExportAllDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclareExportAllDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclaredPredicate(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DeclaredPredicate") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExistsTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExistsTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isFunctionTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "FunctionTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isFunctionTypeParam(e1, t) {
                if (!e1) return false;
                if (e1.type !== "FunctionTypeParam") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isGenericTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "GenericTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isInferredPredicate(e1, t) {
                if (!e1) return false;
                if (e1.type !== "InferredPredicate") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isInterfaceExtends(e1, t) {
                if (!e1) return false;
                if (e1.type !== "InterfaceExtends") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isInterfaceDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "InterfaceDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isInterfaceTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "InterfaceTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isIntersectionTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "IntersectionTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isMixedTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "MixedTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEmptyTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EmptyTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNullableTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NullableTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNumberLiteralTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NumberLiteralTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNumberTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "NumberTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectTypeInternalSlot(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectTypeInternalSlot") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectTypeCallProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectTypeCallProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectTypeIndexer(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectTypeIndexer") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectTypeProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectTypeProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectTypeSpreadProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ObjectTypeSpreadProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isOpaqueType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "OpaqueType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isQualifiedTypeIdentifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "QualifiedTypeIdentifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isStringLiteralTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "StringLiteralTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isStringTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "StringTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSymbolTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "SymbolTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isThisTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ThisTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTupleTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TupleTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeofTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeofTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeAlias(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeAlias") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeCastExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeCastExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeParameter(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeParameter") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeParameterDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeParameterDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeParameterInstantiation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TypeParameterInstantiation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isUnionTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "UnionTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isVariance(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Variance") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isVoidTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "VoidTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumBooleanBody(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumBooleanBody") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumNumberBody(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumNumberBody") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumStringBody(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumStringBody") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumSymbolBody(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumSymbolBody") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumBooleanMember(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumBooleanMember") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumNumberMember(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumNumberMember") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumStringMember(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumStringMember") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumDefaultedMember(e1, t) {
                if (!e1) return false;
                if (e1.type !== "EnumDefaultedMember") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isIndexedAccessType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "IndexedAccessType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isOptionalIndexedAccessType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "OptionalIndexedAccessType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXAttribute(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXAttribute") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXClosingElement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXClosingElement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXElement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXElement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXEmptyExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXEmptyExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXExpressionContainer(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXExpressionContainer") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXSpreadChild(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXSpreadChild") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXIdentifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXIdentifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXMemberExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXMemberExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXNamespacedName(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXNamespacedName") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXOpeningElement(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXOpeningElement") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXSpreadAttribute(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXSpreadAttribute") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXText(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXText") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXFragment(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXFragment") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXOpeningFragment(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXOpeningFragment") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isJSXClosingFragment(e1, t) {
                if (!e1) return false;
                if (e1.type !== "JSXClosingFragment") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isNoop(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Noop") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isPlaceholder(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Placeholder") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isV8IntrinsicIdentifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "V8IntrinsicIdentifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isArgumentPlaceholder(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ArgumentPlaceholder") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isBindExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "BindExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isImportAttribute(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ImportAttribute") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDecorator(e1, t) {
                if (!e1) return false;
                if (e1.type !== "Decorator") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDoExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DoExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isExportDefaultSpecifier(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ExportDefaultSpecifier") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isRecordExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "RecordExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTupleExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TupleExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isDecimalLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "DecimalLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isModuleExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "ModuleExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTopicReference(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TopicReference") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isPipelineTopicExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "PipelineTopicExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isPipelineBareFunction(e1, t) {
                if (!e1) return false;
                if (e1.type !== "PipelineBareFunction") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isPipelinePrimaryTopicReference(e1, t) {
                if (!e1) return false;
                if (e1.type !== "PipelinePrimaryTopicReference") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSParameterProperty(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSParameterProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSDeclareFunction(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSDeclareFunction") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSDeclareMethod(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSDeclareMethod") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSQualifiedName(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSQualifiedName") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSCallSignatureDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSCallSignatureDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSConstructSignatureDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSConstructSignatureDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSPropertySignature(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSPropertySignature") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSMethodSignature(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSMethodSignature") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSIndexSignature(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSIndexSignature") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSAnyKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSAnyKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSBooleanKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSBooleanKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSBigIntKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSBigIntKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSIntrinsicKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSIntrinsicKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSNeverKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSNeverKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSNullKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSNullKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSNumberKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSNumberKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSObjectKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSObjectKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSStringKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSStringKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSSymbolKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSSymbolKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSUndefinedKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSUndefinedKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSUnknownKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSUnknownKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSVoidKeyword(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSVoidKeyword") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSThisType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSThisType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSFunctionType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSFunctionType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSConstructorType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSConstructorType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeReference(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeReference") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypePredicate(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypePredicate") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeQuery(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeQuery") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeLiteral(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSArrayType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSArrayType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTupleType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTupleType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSOptionalType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSOptionalType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSRestType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSRestType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSNamedTupleMember(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSNamedTupleMember") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSUnionType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSUnionType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSIntersectionType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSIntersectionType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSConditionalType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSConditionalType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSInferType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSInferType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSParenthesizedType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSParenthesizedType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeOperator(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeOperator") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSIndexedAccessType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSIndexedAccessType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSMappedType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSMappedType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSLiteralType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSLiteralType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSExpressionWithTypeArguments(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSExpressionWithTypeArguments") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSInterfaceDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSInterfaceDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSInterfaceBody(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSInterfaceBody") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeAliasDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeAliasDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSInstantiationExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSInstantiationExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSAsExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSAsExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSSatisfiesExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSSatisfiesExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeAssertion(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeAssertion") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSEnumDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSEnumDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSEnumMember(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSEnumMember") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSModuleDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSModuleDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSModuleBlock(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSModuleBlock") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSImportType(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSImportType") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSImportEqualsDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSImportEqualsDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSExternalModuleReference(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSExternalModuleReference") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSNonNullExpression(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSNonNullExpression") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSExportAssignment(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSExportAssignment") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSNamespaceExportDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSNamespaceExportDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeAnnotation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeAnnotation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeParameterInstantiation(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeParameterInstantiation") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeParameterDeclaration(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeParameterDeclaration") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeParameter(e1, t) {
                if (!e1) return false;
                if (e1.type !== "TSTypeParameter") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isStandardized(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ArrayExpression":
                    case "AssignmentExpression":
                    case "BinaryExpression":
                    case "InterpreterDirective":
                    case "Directive":
                    case "DirectiveLiteral":
                    case "BlockStatement":
                    case "BreakStatement":
                    case "CallExpression":
                    case "CatchClause":
                    case "ConditionalExpression":
                    case "ContinueStatement":
                    case "DebuggerStatement":
                    case "DoWhileStatement":
                    case "EmptyStatement":
                    case "ExpressionStatement":
                    case "File":
                    case "ForInStatement":
                    case "ForStatement":
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "Identifier":
                    case "IfStatement":
                    case "LabeledStatement":
                    case "StringLiteral":
                    case "NumericLiteral":
                    case "NullLiteral":
                    case "BooleanLiteral":
                    case "RegExpLiteral":
                    case "LogicalExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "Program":
                    case "ObjectExpression":
                    case "ObjectMethod":
                    case "ObjectProperty":
                    case "RestElement":
                    case "ReturnStatement":
                    case "SequenceExpression":
                    case "ParenthesizedExpression":
                    case "SwitchCase":
                    case "SwitchStatement":
                    case "ThisExpression":
                    case "ThrowStatement":
                    case "TryStatement":
                    case "UnaryExpression":
                    case "UpdateExpression":
                    case "VariableDeclaration":
                    case "VariableDeclarator":
                    case "WhileStatement":
                    case "WithStatement":
                    case "AssignmentPattern":
                    case "ArrayPattern":
                    case "ArrowFunctionExpression":
                    case "ClassBody":
                    case "ClassExpression":
                    case "ClassDeclaration":
                    case "ExportAllDeclaration":
                    case "ExportDefaultDeclaration":
                    case "ExportNamedDeclaration":
                    case "ExportSpecifier":
                    case "ForOfStatement":
                    case "ImportDeclaration":
                    case "ImportDefaultSpecifier":
                    case "ImportNamespaceSpecifier":
                    case "ImportSpecifier":
                    case "MetaProperty":
                    case "ClassMethod":
                    case "ObjectPattern":
                    case "SpreadElement":
                    case "Super":
                    case "TaggedTemplateExpression":
                    case "TemplateElement":
                    case "TemplateLiteral":
                    case "YieldExpression":
                    case "AwaitExpression":
                    case "Import":
                    case "BigIntLiteral":
                    case "ExportNamespaceSpecifier":
                    case "OptionalMemberExpression":
                    case "OptionalCallExpression":
                    case "ClassProperty":
                    case "ClassAccessorProperty":
                    case "ClassPrivateProperty":
                    case "ClassPrivateMethod":
                    case "PrivateName":
                    case "StaticBlock":
                        break;
                    case "Placeholder":
                        switch(e1.expectedNode){
                            case "Identifier":
                            case "StringLiteral":
                            case "BlockStatement":
                            case "ClassBody":
                                break;
                            default:
                                return false;
                        }
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isExpression(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ArrayExpression":
                    case "AssignmentExpression":
                    case "BinaryExpression":
                    case "CallExpression":
                    case "ConditionalExpression":
                    case "FunctionExpression":
                    case "Identifier":
                    case "StringLiteral":
                    case "NumericLiteral":
                    case "NullLiteral":
                    case "BooleanLiteral":
                    case "RegExpLiteral":
                    case "LogicalExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "ObjectExpression":
                    case "SequenceExpression":
                    case "ParenthesizedExpression":
                    case "ThisExpression":
                    case "UnaryExpression":
                    case "UpdateExpression":
                    case "ArrowFunctionExpression":
                    case "ClassExpression":
                    case "MetaProperty":
                    case "Super":
                    case "TaggedTemplateExpression":
                    case "TemplateLiteral":
                    case "YieldExpression":
                    case "AwaitExpression":
                    case "Import":
                    case "BigIntLiteral":
                    case "OptionalMemberExpression":
                    case "OptionalCallExpression":
                    case "TypeCastExpression":
                    case "JSXElement":
                    case "JSXFragment":
                    case "BindExpression":
                    case "DoExpression":
                    case "RecordExpression":
                    case "TupleExpression":
                    case "DecimalLiteral":
                    case "ModuleExpression":
                    case "TopicReference":
                    case "PipelineTopicExpression":
                    case "PipelineBareFunction":
                    case "PipelinePrimaryTopicReference":
                    case "TSInstantiationExpression":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSTypeAssertion":
                    case "TSNonNullExpression":
                        break;
                    case "Placeholder":
                        switch(e1.expectedNode){
                            case "Expression":
                            case "Identifier":
                            case "StringLiteral":
                                break;
                            default:
                                return false;
                        }
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isBinary(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BinaryExpression":
                    case "LogicalExpression":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isScopable(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BlockStatement":
                    case "CatchClause":
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "Program":
                    case "ObjectMethod":
                    case "SwitchStatement":
                    case "WhileStatement":
                    case "ArrowFunctionExpression":
                    case "ClassExpression":
                    case "ClassDeclaration":
                    case "ForOfStatement":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                    case "StaticBlock":
                    case "TSModuleBlock":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "BlockStatement") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isBlockParent(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BlockStatement":
                    case "CatchClause":
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "Program":
                    case "ObjectMethod":
                    case "SwitchStatement":
                    case "WhileStatement":
                    case "ArrowFunctionExpression":
                    case "ForOfStatement":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                    case "StaticBlock":
                    case "TSModuleBlock":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "BlockStatement") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isBlock(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BlockStatement":
                    case "Program":
                    case "TSModuleBlock":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "BlockStatement") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isStatement(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BlockStatement":
                    case "BreakStatement":
                    case "ContinueStatement":
                    case "DebuggerStatement":
                    case "DoWhileStatement":
                    case "EmptyStatement":
                    case "ExpressionStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "FunctionDeclaration":
                    case "IfStatement":
                    case "LabeledStatement":
                    case "ReturnStatement":
                    case "SwitchStatement":
                    case "ThrowStatement":
                    case "TryStatement":
                    case "VariableDeclaration":
                    case "WhileStatement":
                    case "WithStatement":
                    case "ClassDeclaration":
                    case "ExportAllDeclaration":
                    case "ExportDefaultDeclaration":
                    case "ExportNamedDeclaration":
                    case "ForOfStatement":
                    case "ImportDeclaration":
                    case "DeclareClass":
                    case "DeclareFunction":
                    case "DeclareInterface":
                    case "DeclareModule":
                    case "DeclareModuleExports":
                    case "DeclareTypeAlias":
                    case "DeclareOpaqueType":
                    case "DeclareVariable":
                    case "DeclareExportDeclaration":
                    case "DeclareExportAllDeclaration":
                    case "InterfaceDeclaration":
                    case "OpaqueType":
                    case "TypeAlias":
                    case "EnumDeclaration":
                    case "TSDeclareFunction":
                    case "TSInterfaceDeclaration":
                    case "TSTypeAliasDeclaration":
                    case "TSEnumDeclaration":
                    case "TSModuleDeclaration":
                    case "TSImportEqualsDeclaration":
                    case "TSExportAssignment":
                    case "TSNamespaceExportDeclaration":
                        break;
                    case "Placeholder":
                        switch(e1.expectedNode){
                            case "Statement":
                            case "Declaration":
                            case "BlockStatement":
                                break;
                            default:
                                return false;
                        }
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isTerminatorless(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BreakStatement":
                    case "ContinueStatement":
                    case "ReturnStatement":
                    case "ThrowStatement":
                    case "YieldExpression":
                    case "AwaitExpression":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isCompletionStatement(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "BreakStatement":
                    case "ContinueStatement":
                    case "ReturnStatement":
                    case "ThrowStatement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isConditional(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ConditionalExpression":
                    case "IfStatement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isLoop(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "WhileStatement":
                    case "ForOfStatement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isWhile(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "DoWhileStatement":
                    case "WhileStatement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isExpressionWrapper(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ExpressionStatement":
                    case "ParenthesizedExpression":
                    case "TypeCastExpression":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFor(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ForInStatement":
                    case "ForStatement":
                    case "ForOfStatement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isForXStatement(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ForInStatement":
                    case "ForOfStatement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFunction(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "ObjectMethod":
                    case "ArrowFunctionExpression":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFunctionParent(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "ObjectMethod":
                    case "ArrowFunctionExpression":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                    case "StaticBlock":
                    case "TSModuleBlock":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isPureish(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "StringLiteral":
                    case "NumericLiteral":
                    case "NullLiteral":
                    case "BooleanLiteral":
                    case "RegExpLiteral":
                    case "ArrowFunctionExpression":
                    case "BigIntLiteral":
                    case "DecimalLiteral":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "StringLiteral") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isDeclaration(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "FunctionDeclaration":
                    case "VariableDeclaration":
                    case "ClassDeclaration":
                    case "ExportAllDeclaration":
                    case "ExportDefaultDeclaration":
                    case "ExportNamedDeclaration":
                    case "ImportDeclaration":
                    case "DeclareClass":
                    case "DeclareFunction":
                    case "DeclareInterface":
                    case "DeclareModule":
                    case "DeclareModuleExports":
                    case "DeclareTypeAlias":
                    case "DeclareOpaqueType":
                    case "DeclareVariable":
                    case "DeclareExportDeclaration":
                    case "DeclareExportAllDeclaration":
                    case "InterfaceDeclaration":
                    case "OpaqueType":
                    case "TypeAlias":
                    case "EnumDeclaration":
                    case "TSDeclareFunction":
                    case "TSInterfaceDeclaration":
                    case "TSTypeAliasDeclaration":
                    case "TSEnumDeclaration":
                    case "TSModuleDeclaration":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "Declaration") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isPatternLike(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "Identifier":
                    case "RestElement":
                    case "AssignmentPattern":
                    case "ArrayPattern":
                    case "ObjectPattern":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSTypeAssertion":
                    case "TSNonNullExpression":
                        break;
                    case "Placeholder":
                        switch(e1.expectedNode){
                            case "Pattern":
                            case "Identifier":
                                break;
                            default:
                                return false;
                        }
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isLVal(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "Identifier":
                    case "MemberExpression":
                    case "RestElement":
                    case "AssignmentPattern":
                    case "ArrayPattern":
                    case "ObjectPattern":
                    case "TSParameterProperty":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSTypeAssertion":
                    case "TSNonNullExpression":
                        break;
                    case "Placeholder":
                        switch(e1.expectedNode){
                            case "Pattern":
                            case "Identifier":
                                break;
                            default:
                                return false;
                        }
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isTSEntityName(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "Identifier":
                    case "TSQualifiedName":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "Identifier") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isLiteral(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "StringLiteral":
                    case "NumericLiteral":
                    case "NullLiteral":
                    case "BooleanLiteral":
                    case "RegExpLiteral":
                    case "TemplateLiteral":
                    case "BigIntLiteral":
                    case "DecimalLiteral":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "StringLiteral") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isImmutable(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "StringLiteral":
                    case "NumericLiteral":
                    case "NullLiteral":
                    case "BooleanLiteral":
                    case "BigIntLiteral":
                    case "JSXAttribute":
                    case "JSXClosingElement":
                    case "JSXElement":
                    case "JSXExpressionContainer":
                    case "JSXSpreadChild":
                    case "JSXOpeningElement":
                    case "JSXText":
                    case "JSXFragment":
                    case "JSXOpeningFragment":
                    case "JSXClosingFragment":
                    case "DecimalLiteral":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "StringLiteral") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isUserWhitespacable(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ObjectMethod":
                    case "ObjectProperty":
                    case "ObjectTypeInternalSlot":
                    case "ObjectTypeCallProperty":
                    case "ObjectTypeIndexer":
                    case "ObjectTypeProperty":
                    case "ObjectTypeSpreadProperty":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isMethod(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ObjectMethod":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isObjectMember(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ObjectMethod":
                    case "ObjectProperty":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isProperty(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ObjectProperty":
                    case "ClassProperty":
                    case "ClassAccessorProperty":
                    case "ClassPrivateProperty":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isUnaryLike(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "UnaryExpression":
                    case "SpreadElement":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isPattern(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "AssignmentPattern":
                    case "ArrayPattern":
                    case "ObjectPattern":
                        break;
                    case "Placeholder":
                        if (e1.expectedNode === "Pattern") break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isClass(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ClassExpression":
                    case "ClassDeclaration":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isImportOrExportDeclaration(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ExportAllDeclaration":
                    case "ExportDefaultDeclaration":
                    case "ExportNamedDeclaration":
                    case "ImportDeclaration":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isExportDeclaration(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ExportAllDeclaration":
                    case "ExportDefaultDeclaration":
                    case "ExportNamedDeclaration":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isModuleSpecifier(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ExportSpecifier":
                    case "ImportDefaultSpecifier":
                    case "ImportNamespaceSpecifier":
                    case "ImportSpecifier":
                    case "ExportNamespaceSpecifier":
                    case "ExportDefaultSpecifier":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isAccessor(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ClassAccessorProperty":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isPrivate(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "ClassPrivateProperty":
                    case "ClassPrivateMethod":
                    case "PrivateName":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFlow(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "AnyTypeAnnotation":
                    case "ArrayTypeAnnotation":
                    case "BooleanTypeAnnotation":
                    case "BooleanLiteralTypeAnnotation":
                    case "NullLiteralTypeAnnotation":
                    case "ClassImplements":
                    case "DeclareClass":
                    case "DeclareFunction":
                    case "DeclareInterface":
                    case "DeclareModule":
                    case "DeclareModuleExports":
                    case "DeclareTypeAlias":
                    case "DeclareOpaqueType":
                    case "DeclareVariable":
                    case "DeclareExportDeclaration":
                    case "DeclareExportAllDeclaration":
                    case "DeclaredPredicate":
                    case "ExistsTypeAnnotation":
                    case "FunctionTypeAnnotation":
                    case "FunctionTypeParam":
                    case "GenericTypeAnnotation":
                    case "InferredPredicate":
                    case "InterfaceExtends":
                    case "InterfaceDeclaration":
                    case "InterfaceTypeAnnotation":
                    case "IntersectionTypeAnnotation":
                    case "MixedTypeAnnotation":
                    case "EmptyTypeAnnotation":
                    case "NullableTypeAnnotation":
                    case "NumberLiteralTypeAnnotation":
                    case "NumberTypeAnnotation":
                    case "ObjectTypeAnnotation":
                    case "ObjectTypeInternalSlot":
                    case "ObjectTypeCallProperty":
                    case "ObjectTypeIndexer":
                    case "ObjectTypeProperty":
                    case "ObjectTypeSpreadProperty":
                    case "OpaqueType":
                    case "QualifiedTypeIdentifier":
                    case "StringLiteralTypeAnnotation":
                    case "StringTypeAnnotation":
                    case "SymbolTypeAnnotation":
                    case "ThisTypeAnnotation":
                    case "TupleTypeAnnotation":
                    case "TypeofTypeAnnotation":
                    case "TypeAlias":
                    case "TypeAnnotation":
                    case "TypeCastExpression":
                    case "TypeParameter":
                    case "TypeParameterDeclaration":
                    case "TypeParameterInstantiation":
                    case "UnionTypeAnnotation":
                    case "Variance":
                    case "VoidTypeAnnotation":
                    case "EnumDeclaration":
                    case "EnumBooleanBody":
                    case "EnumNumberBody":
                    case "EnumStringBody":
                    case "EnumSymbolBody":
                    case "EnumBooleanMember":
                    case "EnumNumberMember":
                    case "EnumStringMember":
                    case "EnumDefaultedMember":
                    case "IndexedAccessType":
                    case "OptionalIndexedAccessType":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFlowType(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "AnyTypeAnnotation":
                    case "ArrayTypeAnnotation":
                    case "BooleanTypeAnnotation":
                    case "BooleanLiteralTypeAnnotation":
                    case "NullLiteralTypeAnnotation":
                    case "ExistsTypeAnnotation":
                    case "FunctionTypeAnnotation":
                    case "GenericTypeAnnotation":
                    case "InterfaceTypeAnnotation":
                    case "IntersectionTypeAnnotation":
                    case "MixedTypeAnnotation":
                    case "EmptyTypeAnnotation":
                    case "NullableTypeAnnotation":
                    case "NumberLiteralTypeAnnotation":
                    case "NumberTypeAnnotation":
                    case "ObjectTypeAnnotation":
                    case "StringLiteralTypeAnnotation":
                    case "StringTypeAnnotation":
                    case "SymbolTypeAnnotation":
                    case "ThisTypeAnnotation":
                    case "TupleTypeAnnotation":
                    case "TypeofTypeAnnotation":
                    case "UnionTypeAnnotation":
                    case "VoidTypeAnnotation":
                    case "IndexedAccessType":
                    case "OptionalIndexedAccessType":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFlowBaseAnnotation(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "AnyTypeAnnotation":
                    case "BooleanTypeAnnotation":
                    case "NullLiteralTypeAnnotation":
                    case "MixedTypeAnnotation":
                    case "EmptyTypeAnnotation":
                    case "NumberTypeAnnotation":
                    case "StringTypeAnnotation":
                    case "SymbolTypeAnnotation":
                    case "ThisTypeAnnotation":
                    case "VoidTypeAnnotation":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFlowDeclaration(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "DeclareClass":
                    case "DeclareFunction":
                    case "DeclareInterface":
                    case "DeclareModule":
                    case "DeclareModuleExports":
                    case "DeclareTypeAlias":
                    case "DeclareOpaqueType":
                    case "DeclareVariable":
                    case "DeclareExportDeclaration":
                    case "DeclareExportAllDeclaration":
                    case "InterfaceDeclaration":
                    case "OpaqueType":
                    case "TypeAlias":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isFlowPredicate(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "DeclaredPredicate":
                    case "InferredPredicate":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumBody(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "EnumBooleanBody":
                    case "EnumNumberBody":
                    case "EnumStringBody":
                    case "EnumSymbolBody":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isEnumMember(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "EnumBooleanMember":
                    case "EnumNumberMember":
                    case "EnumStringMember":
                    case "EnumDefaultedMember":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isJSX(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "JSXAttribute":
                    case "JSXClosingElement":
                    case "JSXElement":
                    case "JSXEmptyExpression":
                    case "JSXExpressionContainer":
                    case "JSXSpreadChild":
                    case "JSXIdentifier":
                    case "JSXMemberExpression":
                    case "JSXNamespacedName":
                    case "JSXOpeningElement":
                    case "JSXSpreadAttribute":
                    case "JSXText":
                    case "JSXFragment":
                    case "JSXOpeningFragment":
                    case "JSXClosingFragment":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isMiscellaneous(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "Noop":
                    case "Placeholder":
                    case "V8IntrinsicIdentifier":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isTypeScript(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "TSParameterProperty":
                    case "TSDeclareFunction":
                    case "TSDeclareMethod":
                    case "TSQualifiedName":
                    case "TSCallSignatureDeclaration":
                    case "TSConstructSignatureDeclaration":
                    case "TSPropertySignature":
                    case "TSMethodSignature":
                    case "TSIndexSignature":
                    case "TSAnyKeyword":
                    case "TSBooleanKeyword":
                    case "TSBigIntKeyword":
                    case "TSIntrinsicKeyword":
                    case "TSNeverKeyword":
                    case "TSNullKeyword":
                    case "TSNumberKeyword":
                    case "TSObjectKeyword":
                    case "TSStringKeyword":
                    case "TSSymbolKeyword":
                    case "TSUndefinedKeyword":
                    case "TSUnknownKeyword":
                    case "TSVoidKeyword":
                    case "TSThisType":
                    case "TSFunctionType":
                    case "TSConstructorType":
                    case "TSTypeReference":
                    case "TSTypePredicate":
                    case "TSTypeQuery":
                    case "TSTypeLiteral":
                    case "TSArrayType":
                    case "TSTupleType":
                    case "TSOptionalType":
                    case "TSRestType":
                    case "TSNamedTupleMember":
                    case "TSUnionType":
                    case "TSIntersectionType":
                    case "TSConditionalType":
                    case "TSInferType":
                    case "TSParenthesizedType":
                    case "TSTypeOperator":
                    case "TSIndexedAccessType":
                    case "TSMappedType":
                    case "TSLiteralType":
                    case "TSExpressionWithTypeArguments":
                    case "TSInterfaceDeclaration":
                    case "TSInterfaceBody":
                    case "TSTypeAliasDeclaration":
                    case "TSInstantiationExpression":
                    case "TSAsExpression":
                    case "TSSatisfiesExpression":
                    case "TSTypeAssertion":
                    case "TSEnumDeclaration":
                    case "TSEnumMember":
                    case "TSModuleDeclaration":
                    case "TSModuleBlock":
                    case "TSImportType":
                    case "TSImportEqualsDeclaration":
                    case "TSExternalModuleReference":
                    case "TSNonNullExpression":
                    case "TSExportAssignment":
                    case "TSNamespaceExportDeclaration":
                    case "TSTypeAnnotation":
                    case "TSTypeParameterInstantiation":
                    case "TSTypeParameterDeclaration":
                    case "TSTypeParameter":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isTSTypeElement(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "TSCallSignatureDeclaration":
                    case "TSConstructSignatureDeclaration":
                    case "TSPropertySignature":
                    case "TSMethodSignature":
                    case "TSIndexSignature":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isTSType(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "TSAnyKeyword":
                    case "TSBooleanKeyword":
                    case "TSBigIntKeyword":
                    case "TSIntrinsicKeyword":
                    case "TSNeverKeyword":
                    case "TSNullKeyword":
                    case "TSNumberKeyword":
                    case "TSObjectKeyword":
                    case "TSStringKeyword":
                    case "TSSymbolKeyword":
                    case "TSUndefinedKeyword":
                    case "TSUnknownKeyword":
                    case "TSVoidKeyword":
                    case "TSThisType":
                    case "TSFunctionType":
                    case "TSConstructorType":
                    case "TSTypeReference":
                    case "TSTypePredicate":
                    case "TSTypeQuery":
                    case "TSTypeLiteral":
                    case "TSArrayType":
                    case "TSTupleType":
                    case "TSOptionalType":
                    case "TSRestType":
                    case "TSUnionType":
                    case "TSIntersectionType":
                    case "TSConditionalType":
                    case "TSInferType":
                    case "TSParenthesizedType":
                    case "TSTypeOperator":
                    case "TSIndexedAccessType":
                    case "TSMappedType":
                    case "TSLiteralType":
                    case "TSExpressionWithTypeArguments":
                    case "TSImportType":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isTSBaseType(e1, t) {
                if (!e1) return false;
                switch(e1.type){
                    case "TSAnyKeyword":
                    case "TSBooleanKeyword":
                    case "TSBigIntKeyword":
                    case "TSIntrinsicKeyword":
                    case "TSNeverKeyword":
                    case "TSNullKeyword":
                    case "TSNumberKeyword":
                    case "TSObjectKeyword":
                    case "TSStringKeyword":
                    case "TSSymbolKeyword":
                    case "TSUndefinedKeyword":
                    case "TSUnknownKeyword":
                    case "TSVoidKeyword":
                    case "TSThisType":
                    case "TSLiteralType":
                        break;
                    default:
                        return false;
                }
                return t == null || (0, n.default)(e1, t);
            }
            function isNumberLiteral(e1, t) {
                (0, s.default)("isNumberLiteral", "isNumericLiteral");
                if (!e1) return false;
                if (e1.type !== "NumberLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isRegexLiteral(e1, t) {
                (0, s.default)("isRegexLiteral", "isRegExpLiteral");
                if (!e1) return false;
                if (e1.type !== "RegexLiteral") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isRestProperty(e1, t) {
                (0, s.default)("isRestProperty", "isRestElement");
                if (!e1) return false;
                if (e1.type !== "RestProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isSpreadProperty(e1, t) {
                (0, s.default)("isSpreadProperty", "isSpreadElement");
                if (!e1) return false;
                if (e1.type !== "SpreadProperty") return false;
                return t == null || (0, n.default)(e1, t);
            }
            function isModuleDeclaration(e1, t) {
                (0, s.default)("isModuleDeclaration", "isImportOrExportDeclaration");
                return isImportOrExportDeclaration(e1, t);
            }
        },
        9247: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = is;
            var n = r(3631);
            var s = r(9810);
            var i = r(4576);
            var a = r(7940);
            function is(e1, t, r) {
                if (!t) return false;
                const o = (0, s.default)(t.type, e1);
                if (!o) {
                    if (!r && t.type === "Placeholder" && e1 in a.FLIPPED_ALIAS_KEYS) {
                        return (0, i.default)(t.expectedNode, e1);
                    }
                    return false;
                }
                if (typeof r === "undefined") {
                    return true;
                } else {
                    return (0, n.default)(t, r);
                }
            }
        },
        7527: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isBinding;
            var n = r(6332);
            function isBinding(e1, t, r) {
                if (r && e1.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression") {
                    return false;
                }
                const s = n.default.keys[t.type];
                if (s) {
                    for(let r = 0; r < s.length; r++){
                        const n = s[r];
                        const i = t[n];
                        if (Array.isArray(i)) {
                            if (i.indexOf(e1) >= 0) return true;
                        } else {
                            if (i === e1) return true;
                        }
                    }
                }
                return false;
            }
        },
        5127: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isBlockScoped;
            var n = r(601);
            var s = r(775);
            function isBlockScoped(e1) {
                return (0, n.isFunctionDeclaration)(e1) || (0, n.isClassDeclaration)(e1) || (0, s.default)(e1);
            }
        },
        9803: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isImmutable;
            var n = r(9810);
            var s = r(601);
            function isImmutable(e1) {
                if ((0, n.default)(e1.type, "Immutable")) return true;
                if ((0, s.isIdentifier)(e1)) {
                    if (e1.name === "undefined") {
                        return true;
                    } else {
                        return false;
                    }
                }
                return false;
            }
        },
        775: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isLet;
            var n = r(601);
            var s = r(4152);
            function isLet(e1) {
                return (0, n.isVariableDeclaration)(e1) && (e1.kind !== "var" || e1[s.BLOCK_SCOPED_SYMBOL]);
            }
        },
        4955: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isNode;
            var n = r(7940);
            function isNode(e1) {
                return !!(e1 && n.VISITOR_KEYS[e1.type]);
            }
        },
        598: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isNodesEquivalent;
            var n = r(7940);
            function isNodesEquivalent(e1, t) {
                if (typeof e1 !== "object" || typeof t !== "object" || e1 == null || t == null) {
                    return e1 === t;
                }
                if (e1.type !== t.type) {
                    return false;
                }
                const r = Object.keys(n.NODE_FIELDS[e1.type] || e1.type);
                const s = n.VISITOR_KEYS[e1.type];
                for (const n of r){
                    const r = e1[n];
                    const i = t[n];
                    if (typeof r !== typeof i) {
                        return false;
                    }
                    if (r == null && i == null) {
                        continue;
                    } else if (r == null || i == null) {
                        return false;
                    }
                    if (Array.isArray(r)) {
                        if (!Array.isArray(i)) {
                            return false;
                        }
                        if (r.length !== i.length) {
                            return false;
                        }
                        for(let e1 = 0; e1 < r.length; e1++){
                            if (!isNodesEquivalent(r[e1], i[e1])) {
                                return false;
                            }
                        }
                        continue;
                    }
                    if (typeof r === "object" && !(s != null && s.includes(n))) {
                        for (const e1 of Object.keys(r)){
                            if (r[e1] !== i[e1]) {
                                return false;
                            }
                        }
                        continue;
                    }
                    if (!isNodesEquivalent(r, i)) {
                        return false;
                    }
                }
                return true;
            }
        },
        4576: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isPlaceholderType;
            var n = r(7940);
            function isPlaceholderType(e1, t) {
                if (e1 === t) return true;
                const r = n.PLACEHOLDERS_ALIAS[e1];
                if (r) {
                    for (const e1 of r){
                        if (t === e1) return true;
                    }
                }
                return false;
            }
        },
        8103: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isReferenced;
            function isReferenced(e1, t, r) {
                switch(t.type){
                    case "MemberExpression":
                    case "OptionalMemberExpression":
                        if (t.property === e1) {
                            return !!t.computed;
                        }
                        return t.object === e1;
                    case "JSXMemberExpression":
                        return t.object === e1;
                    case "VariableDeclarator":
                        return t.init === e1;
                    case "ArrowFunctionExpression":
                        return t.body === e1;
                    case "PrivateName":
                        return false;
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                    case "ObjectMethod":
                        if (t.key === e1) {
                            return !!t.computed;
                        }
                        return false;
                    case "ObjectProperty":
                        if (t.key === e1) {
                            return !!t.computed;
                        }
                        return !r || r.type !== "ObjectPattern";
                    case "ClassProperty":
                    case "ClassAccessorProperty":
                        if (t.key === e1) {
                            return !!t.computed;
                        }
                        return true;
                    case "ClassPrivateProperty":
                        return t.key !== e1;
                    case "ClassDeclaration":
                    case "ClassExpression":
                        return t.superClass === e1;
                    case "AssignmentExpression":
                        return t.right === e1;
                    case "AssignmentPattern":
                        return t.right === e1;
                    case "LabeledStatement":
                        return false;
                    case "CatchClause":
                        return false;
                    case "RestElement":
                        return false;
                    case "BreakStatement":
                    case "ContinueStatement":
                        return false;
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                        return false;
                    case "ExportNamespaceSpecifier":
                    case "ExportDefaultSpecifier":
                        return false;
                    case "ExportSpecifier":
                        if (r != null && r.source) {
                            return false;
                        }
                        return t.local === e1;
                    case "ImportDefaultSpecifier":
                    case "ImportNamespaceSpecifier":
                    case "ImportSpecifier":
                        return false;
                    case "ImportAttribute":
                        return false;
                    case "JSXAttribute":
                        return false;
                    case "ObjectPattern":
                    case "ArrayPattern":
                        return false;
                    case "MetaProperty":
                        return false;
                    case "ObjectTypeProperty":
                        return t.key !== e1;
                    case "TSEnumMember":
                        return t.id !== e1;
                    case "TSPropertySignature":
                        if (t.key === e1) {
                            return !!t.computed;
                        }
                        return true;
                }
                return true;
            }
        },
        8498: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isScope;
            var n = r(601);
            function isScope(e1, t) {
                if ((0, n.isBlockStatement)(e1) && ((0, n.isFunction)(t) || (0, n.isCatchClause)(t))) {
                    return false;
                }
                if ((0, n.isPattern)(e1) && ((0, n.isFunction)(t) || (0, n.isCatchClause)(t))) {
                    return true;
                }
                return (0, n.isScopable)(e1);
            }
        },
        2424: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isSpecifierDefault;
            var n = r(601);
            function isSpecifierDefault(e1) {
                return (0, n.isImportDefaultSpecifier)(e1) || (0, n.isIdentifier)(e1.imported || e1.exported, {
                    name: "default"
                });
            }
        },
        9810: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isType;
            var n = r(7940);
            function isType(e1, t) {
                if (e1 === t) return true;
                if (n.ALIAS_KEYS[t]) return false;
                const r = n.FLIPPED_ALIAS_KEYS[t];
                if (r) {
                    if (r[0] === e1) return true;
                    for (const t of r){
                        if (e1 === t) return true;
                    }
                }
                return false;
            }
        },
        2042: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isValidES3Identifier;
            var n = r(6488);
            const s = new Set([
                "abstract",
                "boolean",
                "byte",
                "char",
                "double",
                "enum",
                "final",
                "float",
                "goto",
                "implements",
                "int",
                "interface",
                "long",
                "native",
                "package",
                "private",
                "protected",
                "public",
                "short",
                "static",
                "synchronized",
                "throws",
                "transient",
                "volatile"
            ]);
            function isValidES3Identifier(e1) {
                return (0, n.default)(e1) && !s.has(e1);
            }
        },
        6488: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isValidIdentifier;
            var n = r(4975);
            function isValidIdentifier(e1, t = true) {
                if (typeof e1 !== "string") return false;
                if (t) {
                    if ((0, n.isKeyword)(e1) || (0, n.isStrictReservedWord)(e1, true)) {
                        return false;
                    }
                }
                return (0, n.isIdentifierName)(e1);
            }
        },
        6205: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isVar;
            var n = r(601);
            var s = r(4152);
            function isVar(e1) {
                return (0, n.isVariableDeclaration)(e1, {
                    kind: "var"
                }) && !e1[s.BLOCK_SCOPED_SYMBOL];
            }
        },
        8877: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = matchesPattern;
            var n = r(601);
            function matchesPattern(e1, t, r) {
                if (!(0, n.isMemberExpression)(e1)) return false;
                const s = Array.isArray(t) ? t : t.split(".");
                const i = [];
                let a;
                for(a = e1; (0, n.isMemberExpression)(a); a = a.object){
                    i.push(a.property);
                }
                i.push(a);
                if (i.length < s.length) return false;
                if (!r && i.length > s.length) return false;
                for(let e1 = 0, t = i.length - 1; e1 < s.length; e1++, t--){
                    const r = i[t];
                    let a;
                    if ((0, n.isIdentifier)(r)) {
                        a = r.name;
                    } else if ((0, n.isStringLiteral)(r)) {
                        a = r.value;
                    } else if ((0, n.isThisExpression)(r)) {
                        a = "this";
                    } else {
                        return false;
                    }
                    if (s[e1] !== a) return false;
                }
                return true;
            }
        },
        5454: (e1, t)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = isCompatTag;
            function isCompatTag(e1) {
                return !!e1 && /^[a-z]/.test(e1);
            }
        },
        7922: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = void 0;
            var n = r(2049);
            const s = (0, n.default)("React.Component");
            var i = s;
            t["default"] = i;
        },
        4439: (e1, t, r)=>{
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = validate;
            t.validateChild = validateChild;
            t.validateField = validateField;
            var n = r(7940);
            function validate(e1, t, r) {
                if (!e1) return;
                const s = n.NODE_FIELDS[e1.type];
                if (!s) return;
                const i = s[t];
                validateField(e1, t, r, i);
                validateChild(e1, t, r);
            }
            function validateField(e1, t, r, n) {
                if (!(n != null && n.validate)) return;
                if (n.optional && r == null) return;
                n.validate(e1, t, r);
            }
            function validateChild(e1, t, r) {
                if (r == null) return;
                const s = n.NODE_PARENT_VALIDATIONS[r.type];
                if (!s) return;
                s(e1, t, r);
            }
        },
        8204: (e1, t, r)=>{
            e1.exports = function import_(e1) {
                return r(5179)(e1);
            };
            0 && 0;
        },
        212: (e1)=>{
            "use strict";
            e1.exports = JSON.parse('{"es6.module":{"chrome":"61","and_chr":"61","edge":"16","firefox":"60","and_ff":"60","node":"13.2.0","opera":"48","op_mob":"45","safari":"10.1","ios":"10.3","samsung":"8.2","android":"61","electron":"2.0","ios_saf":"10.3"}}');
        },
        2735: (e1)=>{
            "use strict";
            e1.exports = JSON.parse('{"transform-unicode-sets-regex":{"chrome":"112","opera":"98","edge":"112","firefox":"116","safari":"tp","node":"20","deno":"1.32","opera_mobile":"75","electron":"24.0"},"transform-class-static-block":{"chrome":"94","opera":"80","edge":"94","firefox":"93","safari":"16.4","node":"16.11","deno":"1.14","ios":"16.4","samsung":"17","opera_mobile":"66","electron":"15.0"},"proposal-class-static-block":{"chrome":"94","opera":"80","edge":"94","firefox":"93","safari":"16.4","node":"16.11","deno":"1.14","ios":"16.4","samsung":"17","opera_mobile":"66","electron":"15.0"},"transform-private-property-in-object":{"chrome":"91","opera":"77","edge":"91","firefox":"90","safari":"15","node":"16.9","deno":"1.9","ios":"15","samsung":"16","opera_mobile":"64","electron":"13.0"},"proposal-private-property-in-object":{"chrome":"91","opera":"77","edge":"91","firefox":"90","safari":"15","node":"16.9","deno":"1.9","ios":"15","samsung":"16","opera_mobile":"64","electron":"13.0"},"transform-class-properties":{"chrome":"74","opera":"62","edge":"79","firefox":"90","safari":"14.1","node":"12","deno":"1","ios":"14.5","samsung":"11","opera_mobile":"53","electron":"6.0"},"proposal-class-properties":{"chrome":"74","opera":"62","edge":"79","firefox":"90","safari":"14.1","node":"12","deno":"1","ios":"14.5","samsung":"11","opera_mobile":"53","electron":"6.0"},"transform-private-methods":{"chrome":"84","opera":"70","edge":"84","firefox":"90","safari":"15","node":"14.6","deno":"1","ios":"15","samsung":"14","opera_mobile":"60","electron":"10.0"},"proposal-private-methods":{"chrome":"84","opera":"70","edge":"84","firefox":"90","safari":"15","node":"14.6","deno":"1","ios":"15","samsung":"14","opera_mobile":"60","electron":"10.0"},"transform-numeric-separator":{"chrome":"75","opera":"62","edge":"79","firefox":"70","safari":"13","node":"12.5","deno":"1","ios":"13","samsung":"11","rhino":"1.7.14","opera_mobile":"54","electron":"6.0"},"proposal-numeric-separator":{"chrome":"75","opera":"62","edge":"79","firefox":"70","safari":"13","node":"12.5","deno":"1","ios":"13","samsung":"11","rhino":"1.7.14","opera_mobile":"54","electron":"6.0"},"transform-logical-assignment-operators":{"chrome":"85","opera":"71","edge":"85","firefox":"79","safari":"14","node":"15","deno":"1.2","ios":"14","samsung":"14","opera_mobile":"60","electron":"10.0"},"proposal-logical-assignment-operators":{"chrome":"85","opera":"71","edge":"85","firefox":"79","safari":"14","node":"15","deno":"1.2","ios":"14","samsung":"14","opera_mobile":"60","electron":"10.0"},"transform-nullish-coalescing-operator":{"chrome":"80","opera":"67","edge":"80","firefox":"72","safari":"13.1","node":"14","deno":"1","ios":"13.4","samsung":"13","opera_mobile":"57","electron":"8.0"},"proposal-nullish-coalescing-operator":{"chrome":"80","opera":"67","edge":"80","firefox":"72","safari":"13.1","node":"14","deno":"1","ios":"13.4","samsung":"13","opera_mobile":"57","electron":"8.0"},"transform-optional-chaining":{"chrome":"91","opera":"77","edge":"91","firefox":"74","safari":"13.1","node":"16.9","deno":"1.9","ios":"13.4","samsung":"16","opera_mobile":"64","electron":"13.0"},"proposal-optional-chaining":{"chrome":"91","opera":"77","edge":"91","firefox":"74","safari":"13.1","node":"16.9","deno":"1.9","ios":"13.4","samsung":"16","opera_mobile":"64","electron":"13.0"},"transform-json-strings":{"chrome":"66","opera":"53","edge":"79","firefox":"62","safari":"12","node":"10","deno":"1","ios":"12","samsung":"9","rhino":"1.7.14","opera_mobile":"47","electron":"3.0"},"proposal-json-strings":{"chrome":"66","opera":"53","edge":"79","firefox":"62","safari":"12","node":"10","deno":"1","ios":"12","samsung":"9","rhino":"1.7.14","opera_mobile":"47","electron":"3.0"},"transform-optional-catch-binding":{"chrome":"66","opera":"53","edge":"79","firefox":"58","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"proposal-optional-catch-binding":{"chrome":"66","opera":"53","edge":"79","firefox":"58","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"transform-parameters":{"chrome":"49","opera":"36","edge":"18","firefox":"53","safari":"16.3","node":"6","deno":"1","ios":"16.3","samsung":"5","opera_mobile":"36","electron":"0.37"},"transform-async-generator-functions":{"chrome":"63","opera":"50","edge":"79","firefox":"57","safari":"12","node":"10","deno":"1","ios":"12","samsung":"8","opera_mobile":"46","electron":"3.0"},"proposal-async-generator-functions":{"chrome":"63","opera":"50","edge":"79","firefox":"57","safari":"12","node":"10","deno":"1","ios":"12","samsung":"8","opera_mobile":"46","electron":"3.0"},"transform-object-rest-spread":{"chrome":"60","opera":"47","edge":"79","firefox":"55","safari":"11.1","node":"8.3","deno":"1","ios":"11.3","samsung":"8","opera_mobile":"44","electron":"2.0"},"proposal-object-rest-spread":{"chrome":"60","opera":"47","edge":"79","firefox":"55","safari":"11.1","node":"8.3","deno":"1","ios":"11.3","samsung":"8","opera_mobile":"44","electron":"2.0"},"transform-dotall-regex":{"chrome":"62","opera":"49","edge":"79","firefox":"78","safari":"11.1","node":"8.10","deno":"1","ios":"11.3","samsung":"8","opera_mobile":"46","electron":"3.0"},"transform-unicode-property-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"proposal-unicode-property-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"transform-named-capturing-groups-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","deno":"1","ios":"11.3","samsung":"9","opera_mobile":"47","electron":"3.0"},"transform-async-to-generator":{"chrome":"55","opera":"42","edge":"15","firefox":"52","safari":"11","node":"7.6","deno":"1","ios":"11","samsung":"6","opera_mobile":"42","electron":"1.6"},"transform-exponentiation-operator":{"chrome":"52","opera":"39","edge":"14","firefox":"52","safari":"10.1","node":"7","deno":"1","ios":"10.3","samsung":"6","rhino":"1.7.14","opera_mobile":"41","electron":"1.3"},"transform-template-literals":{"chrome":"41","opera":"28","edge":"13","firefox":"34","safari":"13","node":"4","deno":"1","ios":"13","samsung":"3.4","opera_mobile":"28","electron":"0.21"},"transform-literals":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","deno":"1","ios":"9","samsung":"4","opera_mobile":"32","electron":"0.30"},"transform-function-name":{"chrome":"51","opera":"38","edge":"79","firefox":"53","safari":"10","node":"6.5","deno":"1","ios":"10","samsung":"5","opera_mobile":"41","electron":"1.2"},"transform-arrow-functions":{"chrome":"47","opera":"34","edge":"13","firefox":"43","safari":"10","node":"6","deno":"1","ios":"10","samsung":"5","rhino":"1.7.13","opera_mobile":"34","electron":"0.36"},"transform-block-scoped-functions":{"chrome":"41","opera":"28","edge":"12","firefox":"46","safari":"10","node":"4","deno":"1","ie":"11","ios":"10","samsung":"3.4","opera_mobile":"28","electron":"0.21"},"transform-classes":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-object-super":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-shorthand-properties":{"chrome":"43","opera":"30","edge":"12","firefox":"33","safari":"9","node":"4","deno":"1","ios":"9","samsung":"4","rhino":"1.7.14","opera_mobile":"30","electron":"0.27"},"transform-duplicate-keys":{"chrome":"42","opera":"29","edge":"12","firefox":"34","safari":"9","node":"4","deno":"1","ios":"9","samsung":"3.4","opera_mobile":"29","electron":"0.25"},"transform-computed-properties":{"chrome":"44","opera":"31","edge":"12","firefox":"34","safari":"7.1","node":"4","deno":"1","ios":"8","samsung":"4","opera_mobile":"32","electron":"0.30"},"transform-for-of":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","deno":"1","ios":"10","samsung":"5","opera_mobile":"41","electron":"1.2"},"transform-sticky-regex":{"chrome":"49","opera":"36","edge":"13","firefox":"3","safari":"10","node":"6","deno":"1","ios":"10","samsung":"5","opera_mobile":"36","electron":"0.37"},"transform-unicode-escapes":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","deno":"1","ios":"9","samsung":"4","opera_mobile":"32","electron":"0.30"},"transform-unicode-regex":{"chrome":"50","opera":"37","edge":"13","firefox":"46","safari":"12","node":"6","deno":"1","ios":"12","samsung":"5","opera_mobile":"37","electron":"1.1"},"transform-spread":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-destructuring":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","deno":"1","ios":"10","samsung":"5","opera_mobile":"41","electron":"1.2"},"transform-block-scoping":{"chrome":"50","opera":"37","edge":"14","firefox":"53","safari":"11","node":"6","deno":"1","ios":"11","samsung":"5","opera_mobile":"37","electron":"1.1"},"transform-typeof-symbol":{"chrome":"38","opera":"25","edge":"12","firefox":"36","safari":"9","node":"0.12","deno":"1","ios":"9","samsung":"3","rhino":"1.7.13","opera_mobile":"25","electron":"0.20"},"transform-new-target":{"chrome":"46","opera":"33","edge":"14","firefox":"41","safari":"10","node":"5","deno":"1","ios":"10","samsung":"5","opera_mobile":"33","electron":"0.36"},"transform-regenerator":{"chrome":"50","opera":"37","edge":"13","firefox":"53","safari":"10","node":"6","deno":"1","ios":"10","samsung":"5","opera_mobile":"37","electron":"1.1"},"transform-member-expression-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.4","deno":"1","ie":"9","android":"4","ios":"6","phantom":"1.9","samsung":"1","rhino":"1.7.13","opera_mobile":"12","electron":"0.20"},"transform-property-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.4","deno":"1","ie":"9","android":"4","ios":"6","phantom":"1.9","samsung":"1","rhino":"1.7.13","opera_mobile":"12","electron":"0.20"},"transform-reserved-words":{"chrome":"13","opera":"10.50","edge":"12","firefox":"2","safari":"3.1","node":"0.6","deno":"1","ie":"9","android":"4.4","ios":"6","phantom":"1.9","samsung":"1","rhino":"1.7.13","opera_mobile":"10.1","electron":"0.20"},"transform-export-namespace-from":{"chrome":"72","deno":"1.0","edge":"79","firefox":"80","node":"13.2","opera":"60","opera_mobile":"51","safari":"14.1","ios":"14.5","samsung":"11.0","android":"72","electron":"5.0"},"proposal-export-namespace-from":{"chrome":"72","deno":"1.0","edge":"79","firefox":"80","node":"13.2","opera":"60","opera_mobile":"51","safari":"14.1","ios":"14.5","samsung":"11.0","android":"72","electron":"5.0"}}');
        },
        8819: (e1)=>{
            "use strict";
            e1.exports = JSON.parse('{"name":"@babel/preset-typescript","version":"7.22.5","description":"Babel preset for TypeScript.","repository":{"type":"git","url":"https://github.com/babel/babel.git","directory":"packages/babel-preset-typescript"},"license":"MIT","publishConfig":{"access":"public"},"main":"./lib/index.js","keywords":["babel-preset","typescript"],"dependencies":{"@babel/helper-plugin-utils":"^7.22.5","@babel/helper-validator-option":"^7.22.5","@babel/plugin-syntax-jsx":"^7.22.5","@babel/plugin-transform-modules-commonjs":"^7.22.5","@babel/plugin-transform-typescript":"^7.22.5"},"peerDependencies":{"@babel/core":"^7.0.0-0"},"devDependencies":{"@babel/core":"^7.22.5","@babel/helper-plugin-test-runner":"^7.22.5"},"homepage":"https://babel.dev/docs/en/next/babel-preset-typescript","bugs":"https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen","engines":{"node":">=6.9.0"},"author":"The Babel Team (https://babel.dev/team)","type":"commonjs"}');
        },
        3676: (e1)=>{
            "use strict";
            e1.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
        }
    };
    var t = {};
    function __nccwpck_require__(r) {
        var n = t[r];
        if (n !== undefined) {
            return n.exports;
        }
        var s = t[r] = {
            id: r,
            loaded: false,
            exports: {}
        };
        var i = true;
        try {
            e1[r].call(s.exports, s, s.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete t[r];
        }
        s.loaded = true;
        return s.exports;
    }
    (()=>{
        __nccwpck_require__.o = (e1, t)=>Object.prototype.hasOwnProperty.call(e1, t);
    })();
    (()=>{
        __nccwpck_require__.nmd = (e1)=>{
            e1.paths = [];
            if (!e1.children) e1.children = [];
            return e1;
        };
    })();
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var r = __nccwpck_require__(3050);
    module.exports = r;
})();
}}),

};

//# sourceMappingURL=node_modules_next_dist_compiled_babel_bundle_11bdf1.js.map